//! In-memory caching layer for storing and retrieving procedural generation data (Chunks).
//!
//! This module defines the core thread-safe cache (`ChunkCache`) responsible for holding
//! `ChunkData` generated by the SSXL engine. It is optimized for high-speed concurrent
//! access across multiple worker threads using `ssxl_sync::AtomicResource`.

use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
use ssxl_shared::chunk_data::ChunkData;
use std::collections::HashMap;
use std::io; // Required for the Result type, ensuring robust initialization and I/O interface.
use tracing::{info, warn};

// --- 1. Type Definitions ---

/// Type alias for the thread-safe core map.
/// Maps a unique spatial identifier (`ChunkKey`) to the chunk's content (`ChunkData`).
type CacheMap = HashMap<ChunkKey, ChunkData>;

// --- 2. Cache Structure ---

/// The thread-safe, in-memory cache for generated Chunk data.
///
/// Wraps a standard HashMap in an **AtomicResource** to allow safe, concurrent
/// read/write access across game engine worker threads. This is the **tempo** optimization.
#[derive(Debug, Clone)]
pub struct ChunkCache {
    /// The underlying storage map protected by an `AtomicResource`.
    storage: AtomicResource<CacheMap>,
}

impl ChunkCache {
    /// Creates a new, empty, thread-safe cache instance.
    ///
    /// The return type is wrapped in `Result<Self, io::Error>` to align with the
    /// Conductor's initialization interface, promoting robust project **completion**.
    pub fn new() -> Result<Self, io::Error> {
        info!("SSXL ChunkCache initialized: Ready for thread-safe storage.");
        Ok(ChunkCache {
            // Initialize the AtomicResource with an empty HashMap.
            storage: AtomicResource::new(HashMap::new()),
        })
    }

    /// Attempts to retrieve a ChunkData by its ChunkKey (Cache Load implementation).
    ///
    /// # Arguments
    /// * `key`: The unique spatial key identifying the desired chunk.
    ///
    /// # Returns
    /// `Ok(Some(ChunkData))` if found, or `Ok(None)` if a cache miss occurs.
    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<ChunkData>, io::Error> {
        // Acquire a read lock on the internal map.
        let map = self.storage.read();

        // Retrieve the data, clone it (to give the caller ownership), and wrap in Ok.
        Ok(map.get(key).cloned())
    }

    /// Inserts a ChunkData into the cache (Cache Save implementation).
    ///
    /// # Arguments
    /// * `key`: The unique spatial key to store the chunk under.
    /// * `data`: A reference to the chunk data to be cloned and stored.
    ///
    /// # Returns
    /// `Ok(())` on successful insertion or update.
    pub fn save_chunk(&self, key: &ChunkKey, data: &ChunkData) -> Result<(), io::Error> {
        // Acquire a write lock on the internal map.
        let mut map = self.storage.write();

        // Insert the cloned data. If `insert` returns `None`, it was a new key.
        // We use `info` for new data and `warn` for overwrites for easy debug monitoring.
        if map.insert(*key, data.clone()).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
        } else {
            // Otherwise, an existing chunk was overwritten (this shouldn't happen often).
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }

    /// Reports the current number of chunks stored in the cache.
    ///
    /// This requires briefly acquiring a read lock to access the underlying map.
    pub fn len(&self) -> usize {
        self.storage.read().len()
    }

    /// Clears all entries from the cache.
    ///
    /// Acquires a write lock to empty the underlying HashMap (a **bulldozer** operation).
    pub fn clear(&self) {
        self.storage.write().clear();
        info!("SSXL ChunkCache cleared.");
    }

    /// Checks if the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}