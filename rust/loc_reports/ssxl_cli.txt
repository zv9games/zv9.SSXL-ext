>>> FILE START: ssxl_cli\build.rs (23 LOC) <<<
// rust/ssxl_cli/build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    // 1. Get the output directory for the current build step
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // 2. Calculate the path to the 'deps' directory where ssxl_ext.dll.lib lives.
    // We traverse up 3 levels from the build script output:
    // target/debug/build/ssxl_cli-XYZ/out -> target/debug/deps
    let deps_dir = out_dir
        .parent().unwrap() // ssxl_cli-XYZ
        .parent().unwrap() // build
        .parent().unwrap() // debug
        .join("deps");

    // 3. Add the search path for the linker
    println!("cargo:rustc-link-search=native={}", deps_dir.display());

    // 4. Link against the 'ssxl_ext' library dynamically.
    // CRITICAL FIX: Link against the DLL name ('ssxl_ext.dll') to correctly find the
    // MSVC-generated import library ('ssxl_ext.dll.lib').
    println!("cargo:rustc-link-lib=dylib=ssxl_ext.dll"); // <-- FIXED

    // 5. Ensure we rebuild if the library changes
    println!("cargo:rerun-if-changed=../ssxl_ext");
}
<<< FILE END: ssxl_cli\build.rs >>>

>>> FILE START: ssxl_cli\Cargo.toml (12 LOC) <<<
[package]
name = "ssxl_cli"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
ssxl_ext = { path = "../ssxl_ext" }
flume = "0.12"


tracing = "0.1" 
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

crossterm = "0.27"
walkdir = "2.5"
<<< FILE END: ssxl_cli\Cargo.toml >>>

>>> FILE START: ssxl_cli\src\main.rs (120 LOC) <<<
// ssxl_cli\src\main.rs
// ============================================================================
// 🧭 SSXL-ext CLI Developer Console (`ssxl_cli::main`)
// ----------------------------------------------------------------------------
// The main entry point, handling initialization, core stubs, and coordinating
// the interactive menu and source scanning modules.
// ============================================================================

// --- Module Declarations ---
pub mod ssxl_menu;
pub mod ssxl_source_scan;
pub mod ssxl_api_scan; 

use std::io; 
use std::fs; 
use std::path::PathBuf;
use tracing::{info, error, warn};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

// Re-export public function stubs required by ssxl_menu.rs
pub use ssxl_api_scan::print_godot_api_surface;

// --- FFI Declarations (Exported by ssxl_ext) ---
extern "C" {
    // New function to replace the ssxl_start_runtime MOCK
    fn ssxl_boot_core_to_idle() -> i32; 

    // FFI functions used by mocked menu actions (kept for linking)
    fn ssxl_set_cell(x: i32, y: i32, tile_id: i32);
    fn ssxl_notify_tilemap_update();
}


// --- RUNTIME BOOT AND UTILITIES ---

/// ✅ REAL: Calls the FFI function in ssxl_ext.dll to initialize the engine core.
fn ssxl_start_runtime() -> bool {
    info!("Engine FFI core: Attempting to boot to idle via DLL...");
    // Safety: Calls an FFI function defined in ssxl_ext.
    unsafe {
        match ssxl_boot_core_to_idle() {
            0 => {
                info!("✅ Engine FFI core initialized (REAL).");
                true
            },
            e => {
                error!("❌ Engine FFI core failed to boot. Exit code: {}", e);
                false
            }
        }
    }
}

/// ✅ REAL: Copies the built ssxl_ext.dll to the Godot tester project folder.
fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    let source = PathBuf::from("target/debug/ssxl_ext.dll");
    let destination = PathBuf::from("../SSXLtester2/ssxl_ext.dll");

    if !source.exists() {
        warn!("Source DLL not found: {}. Did you run 'cargo build'?", source.display());
        return Err(format!("Source DLL not found: {}", source.display()));
    }

    match fs::copy(&source, &destination) {
        Ok(_) => {
            info!("✅ DLL Copy: Successfully copied {} to {}.", 
                  source.display(), destination.display());
            Ok(())
        },
        Err(e) => {
            if !destination.parent().map_or(false, |p| p.exists()) {
                 return Err(format!("❌ DLL Copy Failed: Destination directory ({}) does not exist. Error: {}", 
                                     destination.parent().unwrap_or(&destination).display(), e));
            }
            Err(format!("❌ DLL Copy Failed: Could not copy from {} to {}. Error: {}", 
                        source.display(), destination.display(), e))
        }
    }
}

// ⚠️ MOCK: Stubs for functions called by the menu, now pub for ssxl_menu.rs
pub fn run_fast_test() { println!("MOCK ACTION: Running fast test..."); }
pub fn run_full_test() { println!("MOCK ACTION: Running full test..."); }
pub fn run_max_grid_benchmark() { println!("MOCK ACTION: Running max grid benchmark..."); }
pub fn run_bitmask_conversion() { println!("MOCK ACTION: Running bitmask conversion..."); }
pub fn print_module_tree() { println!("MOCK ACTION: Inspecting Rust module tree..."); }


fn init_logging_and_engine() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // This is now a real FFI call
    if !ssxl_start_runtime() {
        error!("Fatal: Engine FFI core failed to initialize. Aborting console boot.");
    }
    
    // This is a real copy operation
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // 1. Logging, FFI Initialization, and DLL Copy
    init_logging_and_engine();
    
    // 2. FFI Linker Guards: These references ensure the linker attempts to resolve the symbols.
    let _ = ssxl_boot_core_to_idle as *const ();
    let _ = ssxl_set_cell as *const ();
    let _ = ssxl_notify_tilemap_update as *const ();
    
    // 3. LOC Report and Banner - ***MODULE CALL***
    ssxl_source_scan::scan_and_report_loc();
    
    println!(
        r#"
                 (__)    
                 (oo)
           /------\/
          / |    ||
         * ||----||
           ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // 4. Interactive Loop - ***MODULE CALL***
    let menu = ssxl_menu::build_menu();
    ssxl_menu::run_interactive_loop(menu);
}
<<< FILE END: ssxl_cli\src\main.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_api_scan.rs (8 LOC) <<<
// ssxl_api_scan.rs
use tracing::info;

/// Action stub: Prints an inspection of the Godot API Surface exposed via the GDExtension.
pub fn print_godot_api_surface() { 
    info!("MOCK ACTION: Inspecting Godot API surface...");
    println!("API Scan: Currently using placeholder FFI stubs (`ssxl_set_cell`, `ssxl_notify_tilemap_update`).");
    println!("API Scan: Real implementation will reflect the final Godot<->Rust API defined by the 'finisher' component.");
}
<<< FILE END: ssxl_cli\src\ssxl_api_scan.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_menu.rs (108 LOC) <<<
// ssxl_menu.rs
use std::collections::HashSet;
use std::io::{self, Write};
use std::time::Duration;
use std::thread;
use crossterm::event::{self, Event, KeyCode};
use tracing::info;

// Note: We use extern crate self as ssxl_cli to resolve actions defined in main.rs
extern crate self as ssxl_cli;
use ssxl_cli::{
    run_fast_test, run_full_test, run_max_grid_benchmark, run_bitmask_conversion,
    print_module_tree, print_godot_api_surface
};

/// Structure representing a single menu item and its action.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn()>,
}

pub fn build_menu() -> Vec<CliAction> {
    vec![
        CliAction {
            key: 'A',
            label: "✅ press A: Inspect Rust Module Tree",
            id: "module_tree",
            action: Box::new(print_module_tree)
        },
        CliAction {
            key: 'B',
            label: "✅ press B: Run Fast Test",
            id: "fast_test",
            action: Box::new(run_fast_test)
        },
        CliAction {
            key: 'C',
            label: "✅ press C: Run Full Integration Test",
            id: "full_test",
            action: Box::new(run_full_test)
        },
        CliAction {
            key: 'D',
            label: "✅ press D: Run Max Grid Benchmark",
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)
        },
        CliAction {
            key: 'E',
            label: "✅ press E: Run Bitmask Conversion Test",
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)
        },
        CliAction {
            key: 'F',
            label: "✅ press F: Inspect Godot API Surface",
            id: "api_surface",
            action: Box::new(print_godot_api_surface)
        },
        
        // Corrected menu item for exit
        CliAction { key: 'U', label: "✅ press U: EXIT Console", id: "exit", action: Box::new(|| {}) },
    ]
}

fn print_menu(menu: &[CliAction]) {
    println!("\n--- SSXL-ext Main Menu ---");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
}

fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

pub fn run_interactive_loop(menu: Vec<CliAction>) {
    let mut last_keys = HashSet::new();

    loop {
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            // Debounced input poll
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                (item.action)(); // Execute the action closure

                                if c == 'U' {   
                                    return;
                                }

                                wait_for_enter();
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}
<<< FILE END: ssxl_cli\src\ssxl_menu.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_source_scan.rs (126 LOC) <<<
// ssxl_source_scan.rs
use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// --- CONSTANTS ---
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";
// Note: Relative paths are assumed to be run from the 'rust' directory.

// --- LOC COUNTING LOGIC ---

/// Counts non-empty, non-comment lines of code.
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        // Ignores lines starting with '//' (Rust) or '#' (GDScript).
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Writes the total Rust LOC count to the fixed-name file for Godot's boot parser.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level from 'rust' to the project root for the output file.
    let root_dir = PathBuf::from("../"); 
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("🔥 SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("❌ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                       output_path, e);
        }
    }
}

// --- MAIN SCAN FUNCTION ---

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // UPDATED DIRECTORIES for the consolidated ssxl-ext structure (as per manifest).
    // Scans the main GDExtension library and the CLI tool itself.
    let rust_dirs = [
        "ssxl_ext/src", // Contains all core logic (host, generate, shared).
        "ssxl_cli/src", // Contains CLI tool logic (like this file).
    ];

    // --- SCAN RUST FILES ---
    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- SCAN GDSCRIPT FILES ---
    // Assuming the GDScript test directory remains the same relative path.
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- WRITE REPORTS ---
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("❌ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n        {} LOC | *.rs (Rust Total)\n        {} LOC | *.gd (GDScript Total)\n        {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("✅ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("❌ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // --- CRITICAL STEP FOR GODOT ---
    write_final_loc_total(total_rs_loc);

    // Final sleep to ensure writes/logs are flushed
    thread::sleep(Duration::from_millis(100));
}
<<< FILE END: ssxl_cli\src\ssxl_source_scan.rs >>>

