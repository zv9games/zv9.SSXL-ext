>>> FILE START: Cargo.toml (10 LOC) <<<
[workspace]
members = [
    "ssxl_ext",
    "ssxl_cli",
]
# Add this line to explicitly select the newer dependency resolver
resolver = "2" 

[profile.release]
lto = "fat"
codegen-units = 1
<<< FILE END: Cargo.toml >>>

>>> FILE START: manifest.rs (75 LOC) <<<
SSXL-ext is a mythic core — a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ →).

🪶 Manifest v9.1.seed (direct write to tilemap)

PS C:\zv9\zv9.ssxl-ext\rust> Get-ChildItem -Path "C:\zv9\zv9.ssxl-ext\rust" -Recurse | Select-Object FullName

FullName
--------
C:\zv9\zv9.ssxl-ext\rust\loc_reports
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext
C:\zv9\zv9.ssxl-ext\rust\Cargo.lock
C:\zv9\zv9.ssxl-ext\rust\Cargo.toml
C:\zv9\zv9.ssxl-ext\rust\LOC_scan.ps1
C:\zv9\zv9.ssxl-ext\rust\manifest.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_config.toml
C:\zv9\zv9.ssxl-ext\rust\SSXL_forward.rs
C:\zv9\zv9.ssxl-ext\rust\SSXL_manual.rs
C:\zv9\zv9.ssxl-ext\rust\SSXL_noob_survival_guide.gd
C:\zv9\zv9.ssxl-ext\rust\verbose.rs
C:\zv9\zv9.ssxl-ext\rust\loc_reports\loc_summary_1507901416...
C:\zv9\zv9.ssxl-ext\rust\loc_reports\rust.txt
C:\zv9\zv9.ssxl-ext\rust\loc_reports\ssxl_cli.txt
C:\zv9\zv9.ssxl-ext\rust\loc_reports\ssxl_ext.txt
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\build.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\Cargo.toml
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\main.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\ssxl_api_scan.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\ssxl_menu.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\ssxl_source_scan.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\Cargo.toml
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\animate_conductor.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\animate_events.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\animate_worker.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\bridge_ffi.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\bridge_oracle.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\bridge_signals.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\cache.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\config.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_anim_conduct...
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_batch_proces...
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_ca.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_ca_simulatio...
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_conductor.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_conductor_st...
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_conductor_sy...
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_manager.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_perlin.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_runtime.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\generate_task_queue.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_anim.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_cleanup.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_commands.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_init.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_poller.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_render.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_state.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_tick.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_tilemap.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\host_tilemap_status.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\lib.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\math.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\rhythm_manager.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_chunk.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_config.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_error.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_job.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_math.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_message.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\shared_tile.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\sync_pool.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\sync_rhythm.rs
C:\zv9\zv9.ssxl-ext\rust\ssxl_ext\src\tools.rs


PS C:\zv9\zv9.SSXL-ext\rust>

<<< FILE END: manifest.rs >>>

>>> FILE START: ssxl_config.toml (23 LOC) <<<
[threading]
generation_worker_count = 4
animation_worker_count = 2
task_channel_capacity = 4096

[map_settings]
chunk_size = 32
map_extent_chunks = 8
tile_scale_factor = 1.0

[generation]
world_seed = 5011993

[generation.perlin]
scale = 250.0
octaves = 3
persistence = 0.5
lacunarity = 2.0
threshold = 0.0

[generation.ca]
death_limit = 4
birth_limit = 5
steps = 5

[animation]
simulation_fps = 30
fluid_damping_factor = 0.95

<<< FILE END: ssxl_config.toml >>>

>>> FILE START: SSXL_forward.rs (17 LOC) <<<
## 🚀 Foreword: The Mythic Core Expanded

The SSXL-ext engine is not merely a library; it is an architectural decision. It defines a **separation of concerns** so strict that it fundamentally alters the performance profile of procedural generation in the Godot ecosystem.

### **The Velocity Mandate**

The core directive of the SSXL-ext project is to achieve **real-time procedural generation**—a feat often prohibited by the intrinsic limitations of single-threaded game engines.

* **Decoupling the Complexity:** We aggressively sever the $\text{O}(N)$ complexity of map generation from the engine's main loop. Generation, which scales with the total number of tiles ($\text{N}$), is executed entirely off-thread in the Rust core.
* **Minimal Main Thread Impact:** Godot's primary responsibility, the **render loop**, is only burdened with **$\text{O}(1)$ calls** per tile update. This is achieved by passing *only* the final, ready-to-place tile data across the FFI boundary, minimizing the critical path latency and preventing frame stuttering.
* **The Result:** Your GDScript runs fast, your frame rate remains stable, and your world scales to mythic proportions.

### **Rust: The Parallel Backbone**

Rust was selected as the engine's core language specifically because of its safety guarantees surrounding concurrent operations, forming the engine's robust **Parallel Backbone**.

* **Fearless Concurrency:** Rust's strict ownership and lifetime rules eliminate the possibility of data races and deadlocks that plague concurrent systems written in other languages. This allows the engine to safely utilize every available CPU core for generation tasks.
    * *The Conductor:* The central `Conductor` uses **Tokio's multithreaded runtime** to distribute $\text{Chunk}$ generation work across a large worker pool without risk of corruption.
* **Zero-Cost Abstractions:** Rust compiles down to machine code with performance equivalent to C/C++, ensuring that the raw compute time for algorithms (e.g., noise functions, cellular automata) is the absolute fastest possible.

### **The FFI Gateway**

The **Foreign Function Interface (FFI)** is the disciplined gateway between the two languages. It is the only point of contact, ensuring the strict separation of state.



* **Defining the Contract:** The FFI layer (`ssxl_engine_ffi`) explicitly defines the minimal, non-blocking function calls required to manage the engine's lifecycle and exchange data.
* **Zero-Entropy Principle:** FFI calls are designed to be idempotent and to avoid mutable access to global state where possible, particularly favoring **atomic operations** and shared $\text{Mutex}$ locks to maintain state integrity across threads and across the language barrier.
* **Data Serialization:** Data transfer is managed using the fast, small-footprint **Bincode** serialization format. This keeps the binary messages exchanged between Rust and Godot minimal, ensuring that the deserialization time on the Godot side is negligible.
<<< FILE END: SSXL_forward.rs >>>

>>> FILE START: SSXL_manual.rs (377 LOC) <<<
# 📖 SSXL-ext Developer Manual: The Zero-Latency Engine

## Foreword: The Mythic Core

* **The Velocity Mandate:** Achieving real-time procedural generation
by decoupling O(N) compute from the Godot O(1) render loop.

* **Rust: The Parallel Backbone:** Why Rust's fearless concurrency 
powers the TileMap generation.

* **The FFI Gateway:** Defining the contract between the compiled 
engine and Godot's scripting layer.

---

## Part I: Architectural Blueprint (The Why)

## Chapter 1: The Conductor Pattern

The $\text{Conductor}$ is the heart of the SSXL-ext engine—the 
single point of control that translates synchronous requests from 
Godot into asynchronous, parallel computation in Rust. This pattern 
ensures the heavy lifting of world generation never blocks the game thread.

### **The SSXL Module Tree: Roles and Responsibilities**

The SSXL-ext core is structured into highly specialized, zero-dependency 
modules to enforce the decoupling principle:

| Module | Primary Responsibility | Key Function |
| :--- | :--- | :--- |
| **ssxl\_shared** | **Universal Contracts.** Defines all fundamental 
data structures (e.g., $\text{ChunkKey}$, $\text{TileData}$) and the 
**Generation Message** structure. Ensures data integrity across module 
boundaries. 

| `initialize_shared_data()` | 
| **ssxl\_cache** | **State Management.** 
Manages the $\text{Chunk}$ memory cache using an $\text{LRU}$ (Least Recently Used) 
eviction policy. Minimizes re-computation and provides fast $\text{O}(1)$ lookup 
for existing $\text{ChunkData}$. 

| `LruCache<ChunkKey, ChunkData>` |
| **ssxl\_generate** | **Compute & Orchestration.** Contains the generator 
algorithms (Noise, $\text{CA}$, etc.) and the $\text{Conductor}$ structure 
which manages the **Tokio Runtime**. | `Conductor::new()` |

### **The Conductor: Orchestrating Parallelism**

The $\text{Conductor}$ itself is a $\text{struct}$ wrapped in a 
$\text{static OnceCell<Mutex<Conductor>>}$. This critical boundary allows a 
single instance to be safely accessed (locked) from the synchronous 
FFI calls while managing an entirely asynchronous internal state.

* **The Tokio Runtime:** The $\text{Conductor}$ owns and manages the 
**Tokio Multithreaded Runtime**. This is the **Worker Pool**, dedicating 
a fixed number of threads (often matching $\text{num\_cpus}$ or 
$\text{num\_cpus} \times 2$) exclusively to executing long-running 
procedural generation tasks. Godot never touches these threads.

* **The Task Queue:** Requests (e.g., "Generate Chunk at [X, Y]") are converted 
into $\text{Tokio}$ tasks and pushed onto an asynchronous $\text{mpsc}$ 
(multi-producer, single-consumer) channel. This channel is the **communication 
buffer** between the FFI request and the worker threads.

### **Decoupling Principle: Asynchronous Generation**

The interaction is strictly one-way: requests enter, and results are polled.

1.  **Request Ingestion (Sync):** Godot calls an FFI function, which locks the 
$\text{Conductor}$ and sends a generation request message over the $\text{mpsc}$ 
channel. The $\text{Conductor}$ quickly unlocks and the FFI function returns 
$\text{O}(1)$.

2.  **Asynchronous Execution (Worker Threads):** A $\text{Tokio}$ worker thread 
picks up the task from the channel, runs the entire $\text{O}(N)$ generation algorithm, 
and computes the $\text{ChunkData}$.
3.  **Result Delivery (Channel):** Once complete, the worker thread serializes the 
final $\text{ChunkData}$ into a compressed **Generation Message** and pushes it onto 
a separate **Progress Channel** (also $\text{mpsc}$).

### **Data Structure: The Generation Message**

This structure is the immutable contract that crosses the FFI boundary, designed for 
absolute efficiency.

* **Bincode Payload:** The message is serialized using $\text{Bincode}$, chosen 
for its fast, zero-schema binary format, resulting in the smallest possible byte array.

* **Minimalism is Key:** The message only contains the data required for Godot to 
perform $\text{set\_cell}()$ calls.

| Component | Purpose | Data Type | Notes |
| :--- | :--- | :--- | :--- |
| **$\text{ChunkKey}$** | World position of the $\text{Chunk}$. | $\text{Vector2i}$ (x, y) | Used by Godot to calculate the $\text{TileMap}$ offset. |
| **$\text{TileData}$ array** | List of tiles to be placed. | $\text{Vec<TileData>}$ | The core payload. |
| **$\text{TileData}$ members** | $\text{id}$, $\text{coords\_x}$, $\text{coords\_y}$ | $\text{u32, i32, i32}$ | The absolute minimum required for $\text{set\_cell()}$. |

This strict message contract ensures the $\text{Bincode}$ deserialization in GDScript is as fast as possible, preserving the $\text{O}(1)$ target on the main thread.

## Chapter 2: The FFI Boundary (ssxl\_engine\_ffi)

The $\text{ssxl\_engine\_ffi}$ module is the most sensitive component of the system. It is where the distinct memory models and threading environments of Rust and Godot meet. This boundary must be built with maximum care to ensure **safety, stability, and speed**.

### **Static Statics: The Global Access Gates**

The engine relies on a single, shared instance of the $\text{Conductor}$ and the $\text{ProgressReceiver}$—critical resources that must live for the entire duration of the program.

* **OnceCell:** The core mechanism is $\text{once\_cell::sync::OnceCell}$. This guarantees that the $\text{CONDUCTOR}$ and $\text{PROGRESS\_RECEIVER}$ are initialized **exactly once** at runtime. Once initialized, they are immutable in their reference, preventing double-initialization races.
* **Mutex for Interior Mutability:** The contents of the $\text{OnceCell}$ are wrapped in a $\text{std::sync::Mutex}$ (e.g., $\text{OnceCell<Mutex<Conductor>>}$).
    * **Synchronization:** The $\text{Mutex}$ provides the necessary synchronization layer. Any FFI call that needs to interact with the $\text{Conductor}$ (like signaling shutdown or pushing a request) must first acquire the lock. This ensures thread-safe access and state consistency from multiple external threads (or internal Rust threads).
    * **Lock Discipline:** FFI functions are designed to hold the $\text{Mutex}$ lock for the absolute minimum time required ($\text{O}(1)$ operations like signaling or pushing to an $\text{mpsc}$ channel), thus minimizing lock contention and maximizing throughput.

### **Safety Critical: Avoiding Undefined Behavior (UB)**

The primary threat at the FFI boundary is the accidental introduction of **Undefined Behavior (UB)**, which can lead to unpredictable crashes, silent data corruption, or security vulnerabilities.

* **The Lifetime Contract:** Static items in Rust have a fixed memory address for the program's lifetime ($\text{'static}$). Attempting to gain **mutable exclusive access** ($\text{\&mut}$) to a $\text{static}$ item, especially one accessed through shared references ($\text{OnceCell::get()}$), is a direct violation of Rust's core memory model.
    * *Case Study: The OnceCell::take() Anti-Pattern:* The misguided attempt to call $\text{take()}$ on a $\text{static OnceCell}$ via raw pointers ($\text{(*ptr).take()}$) violates the Rust $\text{aliasing}$ rules. It fools the compiler into allowing mutable access to a piece of data the compiler knows might have active, immutable references ($\text{\&'static T}$) outstanding. **This is instant UB.**
* **The Graceful Shutdown Fix:** The safe design eliminates all mutable FFI-driven de-initialization of statics. Teardown is managed by:
    1.  Calling the **$\text{Conductor}$'s graceful shutdown signal** (an $\text{O}(1)$ operation protected by the $\text{Mutex}$).
    2.  Trusting the operating system to clean up the $\text{static}$ memory upon process termination, which is the only truly safe $\text{'static}$ cleanup. 

### **The Error Atlas: Deterministic Handling**

FFI functions cannot return rich $\text{Result<T, E>}$ types; they must rely on primitive types. The SSXL-ext engine adopts a standard convention for the $\text{ssxl\_poll\_progress\_message()}$ function:

| Return Value ($\text{isize}$) | Interpretation | Godot Action |
| :--- | :--- | :--- |
| **Positive $N$** | Success. $N$ is the number of bytes written to the buffer. | Deserialize $\text{N}$ bytes from the buffer. |
| **0** | Empty. No message was available this poll cycle ($\text{TryRecvError::Empty}$). | Continue polling in the next frame. |
| **Negative $E$** | Error. $E$ is a permanent failure code. | Stop polling, log error, and trigger $\text{ssxl\_shutdown\_runtime()}$. |

This strict, integer-based contract allows GDScript to perform rapid, deterministic error handling via a $\text{match}$ statement, crucial for robust engine integration.

---

## Part II: Integration and Execution (The How)

## Chapter 3: Godot Setup (The FFI Bridge)

The $\text{FFI}$ Bridge in Godot is primarily a configuration task. This chapter details the minimum required steps to securely load the compiled Rust library and establish the function contract within $\text{GDScript}$.

### **Project Manifest and Deployment**

The first step is ensuring the compiled Rust artifact—the Dynamic Link Library ($\text{DLL}$), Shared Object ($\text{SO}$), or DyLib—is correctly placed and accessible by the Godot engine at runtime.

* **Location Strategy:** Place the compiled library (e.g., $\text{ssxl\_engine.dll}$) into a controlled project path, typically $\text{res://bin/}$ or similar. This path must be included in your deployment scripts to ensure it is bundled with the final game export.
* **The $\text{Library}$ Path:** The path provided to the $\text{Godot.FFI.Library.open()}$ call must be **absolute** or a valid **$\text{res://}$** path.

### **The Autoload Singleton: Lifecycle Control**

We use a $\text{Godot Autoload}$ (or $\text{Singleton}$) named $\text{SSXL.gd}$ to manage the engine's lifecycle and global state. This guarantees initialization occurs once and provides a reliable global access point for all other scripts.

* **Global Access:** The singleton ensures that the engine's state ($\text{is\_ready}$, $\text{message\_buffer}$, $\text{ssxl\_engine}$ object) is consistent and available from anywhere in the game logic.
* **Encapsulation:** All FFI calls are encapsulated within this script, protecting the rest of your $\text{GDScript}$ from dealing with raw pointers and complex FFI error codes.

### **Library Loading: Opening the Gateway**

The $\text{Godot.FFI.Library}$ class is the $\text{GDScript}$ object responsible for interacting with the raw system library.

* **Instantiate and Open:**
    ```gdscript
    var ssxl_engine = Library.new()
    var error = ssxl_engine.open("res://bin/ssxl_engine.dll") 
    assert(error == OK)
    ```
* **Error Check:** A critical $\text{assert}$ immediately after $\text{open()}$ confirms the system was able to load the binary file. Failure here is a fatal deployment or architecture mismatch ($\text{x64}$ vs $\text{x86}$, missing dependencies).

### **Function Binding: Establishing the Contract**

Every function exposed by the Rust $\text{#[no\_mangle]}$ attribute must be meticulously declared to $\text{Godot.FFI.Library}$ using $\text{add\_symbol}$. If the signature is incorrect, the engine will likely crash with a segmentation fault ($\text{SIGSEGV}$), as the $\text{GDScript}$ stack frame will not align with Rust's expectation.

* **Signature Mapping:** Define the arguments (input types) and the return type.
    * **Pointers:** Rust's $\text{*mut u8}$ (for the data buffer) and $\text{size\_t}$ (for buffer length) map directly to $\text{TYPE\_INT}$ in $\text{GDScript}$, as pointers are treated as opaque integer addresses.
    * **Booleans:** Rust's $\text{bool}$ maps to $\text{TYPE\_BOOL}$.
    * **Integers:** Rust's $\text{u32}$ maps to $\text{TYPE\_INT}$.

| Rust Signature | GDScript Type | Example Use |
| :--- | :--- | :--- |
| $\text{ssxl\_start\_runtime() -> bool}$ | $\text{[ ], TYPE\_BOOL}$ | Initialization Status |
| $\text{ssxl\_poll\_progress\_message(*mut u8, usize) -> isize}$ | $\text{[TYPE\_INT, TYPE\_INT], TYPE\_INT}$ | The Polling Loop |
| $\text{ssxl\_get\_chunks\_completed() -> u32}$ | $\text{[ ], TYPE\_INT}$ | Metric Fetch |

* ***The $\text{isize}$ Contract: Mapping Length and Error***
    The Rust return type $\text{isize}$ (signed integer) is mapped to $\text{TYPE\_INT}$ in $\text{GDScript}$. This single return value is overloaded to serve three distinct outcomes, which $\text{GDScript}$ must interpret immediately:
    1.  **If Result > 0:** Success. The positive integer is the number of bytes received.
    2.  **If Result = 0:** No message. $\text{TryRecvError::Empty}$.
    3.  **If Result < 0:** Failure. The negative integer is the $\text{FFI\_ERR}$ code (e.g., $\text{-3}$ for Disconnected).

## Chapter 4: The Core Loop: Poll & Place

This chapter details the most performance-critical aspect of the engine: the **tight polling loop** in $\text{GDScript}$ that receives the processed data from Rust and executes the $\text{TileMap}$ rendering commands. This loop is the ultimate realization of the **Velocity Mandate**, ensuring zero frame stutter.

### **Initialization Sequence and State Checks**

Before entering the core loop, the system must confirm the Rust runtime is alive and ready.

* **The $\text{O}(1)$ Kickoff:** The initialization is a single, non-blocking $\text{O}(1)$ call to the FFI boundary:
    ```gdscript
    is_ready = ssxl_engine.call("ssxl_start_runtime") 
    ```
* **Safety Guards:** Once the runtime is active, two helper functions are available for robust state checks, though the negative $\text{isize}$ return codes from $\text{ssxl\_poll\_progress\_message}$ often provide sufficient failure detection:
    * $\text{ssxl\_is\_runtime\_ready()}$ (checks $\text{INIT\_SUCCESSFUL}$)
    * $\text{ssxl\_is\_receiver\_ready()}$ (checks $\text{PROGRESS\_RECEIVER.get().is\_some()}$)

### **The Hyper-Efficient Polling Loop**

The polling function should be placed in $\text{\_process(delta)}$ or $\text{\_physics\_process(delta)}$ in your $\text{SSXL.gd}$ Singleton. It is designed to be a $\text{fire-and-forget}$ operation on the FFI side, maximizing main thread availability.

* ***Buffer Management: The Allocation Zero***
    The single most important optimization is **pre-allocating and re-using** a single $\text{PackedByteArray}$ buffer. This eliminates continuous heap allocation/deallocation on the Godot side for every message, turning a potentially $\text{O}(A)$ cost (where $\text{A}$ is allocation time) into a guaranteed $\text{O}(1)$ operation.
    ```gdscript
    # Only done once during setup
    var message_buffer = PackedByteArray()
    message_buffer.resize(BUFFER_SIZE) 
    ```
    The FFI call uses the pointer to this existing buffer, writing the serialized data directly into the pre-allocated memory space.
    ```gdscript
    var result_len = ssxl_engine.call("ssxl_poll_progress_message", message_buffer.ptr(), message_buffer.size())
    ```
* **Atomic State Check:** The polling function itself is $\text{O}(1)$ in the Rust core because it uses $\text{tokio::sync::mpsc::Receiver::try\_recv()}$, which is non-blocking and involves simple atomic state checks, allowing the Rust thread to yield immediately if no message is ready ($\text{result\_len} = 0$).

### **Critical Path: Bincode Deserialization**

If the FFI call returns a $\text{result\_len} > 0$, the byte array contains the serialized $\text{Generation Message}$. The next step is the deserialization, which is the only $\text{O}(N)$ operation performed on the main thread, where $\text{N}$ is the message size.

* **Minimizing $\text{N}$:** Because the $\text{Generation Message}$ only contains essential $\text{TileData}$ and $\text{Bincode}$ is efficient, this $\text{O}(N)$ cost is negligible, maintaining the illusion of zero latency.
* **Data Slicing:** Use the returned $\text{result\_len}$ to safely slice the buffer for the exact message size, preventing deserialization of garbage data:
    ```gdscript
    var message_bytes = message_buffer.slice(0, result_len)
    var message_data = Bincode.decode(message_bytes) # The deserialization step
    ```

### **TileMap Placement (The O(1) Render Hook)**

The deserialized $\text{message\_data}$ is immediately passed to the placement logic, where the bulk of the process is an iterative loop of $\text{O}(1)$ Godot API calls.

1.  **Coordinate Translation:** The raw $\text{TileData}$ coordinates are relative to the $\text{ChunkKey}$. This step translates local chunk coordinates into global $\text{TileMap}$ grid coordinates:
    $$\text{WorldCoords}_{\text{x}} = \text{LocalCoords}_{\text{x}} + (\text{ChunkKey}_{\text{x}} \times \text{CHUNK\_SIZE})$$
2.  **The Final $\text{O}(1)$ Draw Call:** For every tile in the payload, one single, fast call is made to the $\text{TileMap}$ node. This is the ultimate goal: the expensive calculation is done, and Godot is only asked to update a specific memory location on the grid.
    ```gdscript
    # Assuming layer 0
    tile_map_node.set_cell(0, world_coords, tile_id, Vector2i.ZERO)
    ```
This architecture ensures that the **Frame Time** remains consistently low, allowing the **Throughput** (chunks generated per second) to be dictated entirely by the multi-threaded Rust backend.

## Chapter 5: Engine Lifecycle and Diagnostics

The final piece of the SSXL-ext integration puzzle involves ensuring a clean, stable engine lifetime. This chapter covers the non-functional, yet critical, aspects of **Graceful Teardown** and **Runtime Telemetry**.

### **Graceful Teardown: Zero-Entropy Exit**

A hard exit (process termination before thread cleanup) can lead to resource leaks, corrupted files, or instability in the host system. **Graceful Teardown** ensures the $\text{Conductor}$'s background $\text{Tokio}$ runtime and its associated worker threads are properly signaled to shut down.

* **The Mandatory Hook:** $\text{ssxl\_shutdown\_runtime()}$ must be called when the Godot application requests to close. This is done via the $\text{\_notification}$ method on your $\text{SSXL.gd}$ singleton.
    ```gdscript
    func _notification(what):
        if what == NOTIFICATION_WM_CLOSE_REQUEST or what == NOTIFICATION_EXIT:
            _teardown_runtime()

    func _teardown_runtime():
        if ssxl_engine.is_open():
            # This O(1) FFI call locks the Conductor and sets the shutdown flag.
            ssxl_engine.call("ssxl_shutdown_runtime")
            print("SSXL: Runtime signaled for graceful shutdown.")
    ```
* **Thread Cleanup:** When $\text{ssxl\_shutdown\_runtime}$ is called, the Rust $\text{Conductor}$ receives the signal, stops accepting new tasks, and allows all in-flight worker tasks to finish before the $\text{Tokio}$ runtime is dropped. This safe process prevents orphaned threads and state corruption.

### **Runtime Status Checks: Flow Control**

The engine provides simple $\text{O}(1)$ atomic flag checks to gate your $\text{GDScript}$ logic, preventing calls to the $\text{poll}$ or $\text{request}$ functions when the engine is not fully initialized.

* **$\text{ssxl\_is\_runtime\_ready() -> bool}$:** Checks the $\text{INIT\_SUCCESSFUL}$ atomic flag. Use this before attempting any action (like requesting a $\text{Chunk}$) to ensure the $\text{Conductor}$ is alive and running.
* **$\text{ssxl\_is\_receiver\_ready() -> bool}$:** Checks if the $\text{PROGRESS\_RECEIVER}$ static is set. This is a secondary stability check, ensuring the communication channel is established. If this check fails *after* $\text{ssxl\_is\_runtime\_ready()}$ passes, it indicates a critical, internal communication failure.

### **Metrics Telemetry: Live Performance Tracking**

The engine exposes core performance metrics via $\text{O}(1)$ atomic reads, allowing you to monitor the backend's throughput in real-time without locking the main thread.

* **$\text{ssxl\_get\_chunks\_completed() -> u32}$:** This function reads the $\text{CHUNKS\_COMPLETED\_COUNT}$ atomic counter.
    * **Application:** Use this metric to display a loading progress bar, track generation rate (Chunks per Second), or confirm that worker threads are actively completing tasks.
    * **Implementation:** Since the Rust counter ($\text{AtomicU32}$) is updated by the worker threads, this FFI call is a quick, lock-free **atomic load**, ensuring it never contributes to frame hitching.

### **Configuration: Injecting Runtime Parameters**

The $\text{ssxl\_shared}$ module is designed to load configuration data early in the initialization sequence, typically from a file readable by both Godot and the Rust core.

* **Source of Truth:** Configuration is managed through a JSON file, typically $\text{res://ssxl\_config.json}$. This file defines parameters like **Chunk Size, Worker Thread Count, Cache Capacity,** and **Default Generator ID**.
* **One-Time Load:** During the $\text{ssxl\_start\_runtime()}$ call, the $\text{initialize\_shared\_data()}$ function attempts to read and parse this configuration.
    * **Impact:** Parameters like $\text{Worker Thread Count}$ are immediately used to configure the $\text{Tokio}$ runtime thread pool, while $\text{Chunk Size}$ is baked into the coordinate translation logic.
* **Flexibility:** Since the configuration is loaded before the $\text{Conductor}$ starts, you can easily switch generation algorithms (e.g., from $\text{Perlin}$ to $\text{Cellular Automata}$) or tune performance parameters without recompiling the Rust core logic.

---

## Part III: Reference & Appendices

## A. FFI Function Signature Reference (GDScript ↔ Rust)

This reference defines the complete, stable contract between the Godot engine ($\text{GDScript}$) and the SSXL-ext Rust core. It is the definitive guide for binding the FFI functions using $\text{Godot.FFI.Library.add\_symbol()}$.

### 1. Engine Lifecycle and Initialization

These functions manage the creation and destruction of the $\text{Tokio}$ runtime and the $\text{Conductor}$ instance.

| Rust Function Name | GDScript Arguments | GDScript Return | Description |
| :--- | :--- | :--- | :--- |
| **$\text{ssxl\_start\_runtime}$** | $\text{[]}$ | $\text{TYPE\_BOOL}$ | Initializes $\text{Tokio}$ runtime and $\text{Conductor}$. Returns $\text{true}$ on success. |
| **$\text{ssxl\_initialize\_engine}$** | $\text{[]}$ | $\text{TYPE\_BOOL}$ | Alias for $\text{ssxl\_start\_runtime}$. Recommended entry point. |
| **$\text{ssxl\_shutdown\_runtime}$** | $\text{[]}$ | $\text{TYPE\_VOID}$ | Signals graceful shutdown to the $\text{Conductor}$ and worker threads. |
| **$\text{ssxl\_is\_runtime\_ready}$** | $\text{[]}$ | $\text{TYPE\_BOOL}$ | Checks if $\text{INIT\_SUCCESSFUL}$ is $\text{true}$ ($\text{O}(1)$ atomic load). |
| **$\text{ssxl\_is\_receiver\_ready}$** | $\text{[]}$ | $\text{TYPE\_BOOL}$ | Checks if the $\text{PROGRESS\_RECEIVER}$ static is initialized. |

### 2. The Core Communication Loop

This is the primary function used to retrieve data. The return value ($\text{isize}$) is an overloaded contract for length or error.

| Rust Function Name | Rust Signature | GDScript Arguments | GDScript Return |
| :--- | :--- | :--- | :--- |
| **$\text{ssxl\_poll\_progress\_message}$** | $\text{(*mut u8, usize) -> isize}$ | $\text{[TYPE\_INT, TYPE\_INT]}$ | $\text{TYPE\_INT}$ ($\text{isize}$) |
| **Argument 1 ($\text{*mut u8}$):** The raw $\text{pointer}$ address of the $\text{PackedByteArray}$ buffer. Mapped as $\text{TYPE\_INT}$. |
| **Argument 2 ($\text{usize}$):** The $\text{length/capacity}$ of the buffer. Mapped as $\text{TYPE\_INT}$. |
| **Return Value ($\text{isize}$):** The **length** of the message if positive, or an **error code** if negative. |

### 3. Diagnostics and Metrics

These functions provide lock-free metrics and simple debugging utility.

| Rust Function Name | GDScript Arguments | GDScript Return | Description |
| :--- | :--- | :--- | :--- |
| **$\text{ssxl\_get\_chunks\_completed}$** | $\text{[]}$ | $\text{TYPE\_INT}$ ($\text{u32}$) | Returns the total number of $\text{Chunks}$ successfully generated ($\text{O}(1)$ atomic read). |
| **$\text{ssxl\_trigger\_runtime\_test}$** | $\text{[]}$ | $\text{TYPE\_VOID}$ | Triggers an internal, structural $\text{Conductor}$ test sequence for debugging. |
| **$\text{ssxl\_write\_status}$** | $\text{(*mut c\_char, usize, u32)}$ | $\text{TYPE\_INT}$ ($\text{isize}$) | Writes a basic status string (e.g., "Runtime Running: true") to a user-provided $\text{c\_char}$ buffer. Returns length or $\text{-1}$ error. |

### 4. The Error Atlas (Negative $\text{isize}$ Return Codes)

When $\text{ssxl\_poll\_progress\_message}$ returns a value less than zero, $\text{GDScript}$ should immediately match it against these defined error codes to determine the next action.

| Error Code | Rust Constant | Description and Action |
| :--- | :--- | :--- |
| **$\text{-1}$** | $\text{FFI\_ERR\_RUNTIME\_NOT\_INIT}$ | The $\text{Conductor}$ has not been successfully initialized. Call $\text{ssxl\_initialize\_engine()}$. |
| **$\text{-2}$** | $\text{FFI\_ERR\_LOCK\_FAILED}$ | Failed to acquire the $\text{Mutex}$ lock (e.g., poisoned lock). Indicates a severe internal panic. **Trigger Teardown.** |
| **$\text{-3}$** | $\text{FFI\_ERR\_CHANNEL\_DISCONNECTED}$ | The internal communication channel ($\text{mpsc}$) has closed. **Trigger Teardown** (channel is broken). |
| **$\text{-4}$** | $\text{FFI\_ERR\_SERIALIZATION\_FAILED}$ | $\text{Bincode}$ failed to serialize the message. Indicates a data mismatch in Rust. |
| **$\text{-5}$** | $\text{FFI\_ERR\_BUFFER\_TOO\_SMALL}$ | The $\text{PackedByteArray}$ size is insufficient for the message. **Increase $\text{BUFFER\_SIZE}$**. |
| **$\text{-6}$** | $\text{FFI\_ERR\_EMPTY\_MESSAGE}$ | A zero-byte message was serialized. Usually an internal logic error. |* 

## B. Bincode Data Schema (The Message Contract)

The **Bincode Data Schema** defines the exact byte layout of the $\text{Generation Message}$ as it travels across the $\text{FFI}$ boundary. This contract is sacred: any misalignment in data types or structure between the Rust serialization and the $\text{GDScript}$ deserialization will result in corrupted data or a runtime error.

### 1. The Chunk Message Structure ($\text{GenerationMessage}$)

The root object received by $\text{GDScript}$ is the $\text{GenerationMessage}$ (or similar structure within the $\text{ssxl\_shared}$ module), which encapsulates all necessary data to update a $\text{TileMap}$ section.

| Rust Struct Field | Rust Type | GDScript Equivalent | Purpose |
| :--- | :--- | :--- | :--- |
| **$\text{key\_x}$** | $\text{i32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | The X coordinate of the Chunk in the world grid. |
| **$\text{key\_y}$** | $\text{i32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | The Y coordinate of the Chunk in the world grid. |
| **$\text{tiles}$** | $\text{Vec<TileData>}$ | $\text{TYPE\_ARRAY}$ ($\text{Array}$) | The list of individual tile updates within this chunk. |
| **$\text{tile\_count}$** | $\text{u32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | Confirms the size of the $\text{tiles}$ array for integrity checking. |

### 2. The Tile Data Structure ($\text{TileData}$)

The $\text{tiles}$ array contains structs representing individual tile placement commands. $\text{GDScript}$ must iterate over this array and extract the specific parameters for the $\text{TileMap.set\_cell()}$ call.

| Rust Struct Field | Rust Type | GDScript Equivalent | Placement Role |
| :--- | :--- | :--- | :--- |
| **$\text{coords\_x}$** | $\text{i32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | Local X coordinate within the Chunk. |
| **$\text{coords\_y}$** | $\text{i32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | Local Y coordinate within the Chunk. |
| **$\text{id}$** | $\text{u32}$ | $\text{TYPE\_INT}$ ($\text{int}$) | The $\text{TileSet}$ $\text{source\_id}$ for the tile to be placed. |
| **$\text{level}$** | $\text{f32}$ | $\text{TYPE\_FLOAT}$ ($\text{float}$) | Optional: Metadata for visualization or logic (e.g., noise height). |

### 3. GDScript Deserialization Logic

The $\text{GDScript}$ side relies on a helper binding (e.g., a $\text{Bincode}$ module or extension) to take the $\text{PackedByteArray}$ slice and reconstruct the $\text{GDScript}$ $\text{Dictionary}$ that matches the Rust structure.

The verification process is critical, as shown in the provided LOC report:

```gdscript
# LOC Report Verification Snippet (Essential Integrity Check)
# Check for TYPE_INT (id) and TYPE_FLOAT (level)
var first_tile = tiles[0]
if typeof(first_tile.id) != TYPE_INT:
    printerr("FAIL: Tile ID type mismatch.")
    return false

if typeof(first_tile.level) != TYPE_FLOAT:
    printerr("FAIL: Tile Level type mismatch.")
    return false
	
## C. Atomic Primitives Reference (Rust $\text{AtomicBool}$, $\text{AtomicU32}$)

Atomic primitives are fundamental to the SSXL-ext engine's promise of **zero-latency metrics and status updates**. They represent a single memory location that can be safely read and written by multiple threads concurrently without needing to acquire a traditional $\text{Mutex}$ lock, making the operation incredibly fast ($\text{O}(1)$).

### 1. The Need for Lock-Free State

In a high-performance multi-threaded system, any $\text{Mutex}$ ($\text{std::sync::Mutex}$) used for simple read/write operations becomes a bottleneck.

* **$\text{Mutex}$ Cost:** Acquiring and releasing a lock is a relatively expensive operation that forces threads to wait (contention).
* **Atomic Benefit:** Atomic operations bypass the operating system's locking mechanisms entirely. The hardware guarantees that the read or write completes in a single, indivisible step, making it **thread-safe by design** and **non-blocking**.

### 2. Key Atomic Types in SSXL-ext

The engine uses two primary atomic types to manage its simple global state:

| Rust Atomic Type | Purpose | FFI Exposure | Notes |
| :--- | :--- | :--- | :--- |
| **$\text{AtomicBool}$** | Manages binary engine state. | Used for $\text{ssxl\_is\_runtime\_ready()}$ check on the $\text{INIT\_SUCCESSFUL}$ flag. | Guarantees $\text{true}$ or $\text{false}$ is written completely, without corruption. |
| **$\text{AtomicU32/Usize}$** | Counters and metrics. | Used for $\text{ssxl\_get\_chunks\_completed()}$ to track $\text{Chunk}$ throughput. | $\text{AtomicUsize}$ is generally preferred for counters on the current architecture. |

### 3. Memory Ordering: The Velocity Setting

Atomic operations require a **memory ordering** parameter, which dictates how strictly the compiler and CPU must enforce the sequence of operations relative to other threads.

* **$\text{Ordering::Relaxed}$ (The Default):** For simple metric collection, SSXL-ext typically uses $\text{Ordering::Relaxed}$.
    * **Benefit:** This is the *fastest* ordering. It guarantees atomicity (the read/write is complete) but provides no guarantees about the order in which the write becomes visible to other threads relative to other memory operations.
    * **Usage:** Perfect for non-critical telemetry like the $\text{CHUNKS\_COMPLETED\_COUNT}$. If the counter is slightly behind reality, it's acceptable.

* **$\text{Ordering::Acquire}$ / $\text{Ordering::Release}$ (For Synchronization):** Stronger orderings are used internally by the $\text{Conductor}$'s state flags (e.g., signaling shutdown) to ensure that code executed *after* the flag is set sees all memory writes that occurred *before* the flag was set.

### 4. Implementation Examples

All $\text{O}(1)$ FFI calls exposed for status and metrics are simple atomic loads:

* **Reading the Status ($\text{O}(1)$):**
    ```rust
    // In ssxl_engine_ffi/src/lib.rs
    static INIT_SUCCESSFUL: AtomicBool = AtomicBool::new(false);

    #[no_mangle]
    pub extern "C" fn ssxl_is_runtime_ready() -> bool {
        // Atomic load with Relaxed ordering is extremely fast.
        INIT_SUCCESSFUL.load(Ordering::Relaxed)
    }
    ```

* **Reading the Metric ($\text{O}(1)$):**
    ```rust
    // In ssxl_shared/src/lib.rs
    pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);

    #[no_mangle]
    pub extern "C" fn ssxl_get_chunks_completed() -> u32 {
        // Atomic load returns the latest value written by worker threads.
        CHUNKS_COMPLETED_COUNT.load(Ordering::Relaxed) as u32
    }
    ```
This atomic design is what allows $\text{GDScript}$ to poll status and metrics thousands of times per second with negligible performance overhead.

## D. Logging and Tracing Setup

In a complex, multi-threaded architecture with a foreign function interface ($\text{FFI}$), standard debugging becomes impossible. The **Logging and Tracing Setup** is the developer's eyes and ears into the concurrent Rust backend, providing necessary context and sequencing for debugging race conditions and thread communication failures.

### 1. The Tracing Philosophy

The SSXL-ext engine uses the **$\text{tracing}$** crate ecosystem in Rust, which is significantly more powerful than traditional logging. $\text{tracing}$ records structured events and allows developers to associate those events with a **Span**—a segment of time or an execution context (like a single $\text{Chunk}$ generation job).

* **Context over Console:** Logs (or "events") are tagged with rich metadata (level, module path, thread ID, timestamp) and, crucially, the active $\text{Span}$ ID. This allows you to track an event, such as a $\text{TileData}$ being generated, back to the specific $\text{Tokio}$ worker thread and the specific $\text{Chunk}$ task that created it.
* **Structured Output:** The output is designed to be easily machine-parsable, which is why the console output includes structured information like the $\text{Timestamp}$, $\text{Level}$, $\text{Module Path}$, and the $\text{Message}$.
    ```text
    2025-12-04T03:58:29.286837Z INFO ssxl_generate::task::task_queue: Generation Task Queue started
    ```

### 2. Standard Logging Levels

Logs are categorized by severity, allowing the developer to filter output based on what they are investigating.

| Level | Purpose in SSXL-ext | Example Use Case |
| :--- | :--- | :--- |
| **$\text{ERROR}$** | Critical failure or panic. | $\text{Mutex}$ poisoned, $\text{Conductor}$ initialization failure. |
| **$\text{WARN}$** | Non-critical, but unexpected state. | $\text{Config}$ default generator not found, cache misses, potential resource contention. |
| **$\text{INFO}$** | Major state changes or milestones. | $\text{Runtime}$ initialized, $\text{DLL}$ copied, $\text{Chunk}$ generation completed. |
| **$\text{DEBUG}$** | Detailed flow control information. | $\text{Conductor}$ acquired lock, $\text{ChunkKey}$ requested, specific generator parameters. |
| **$\text{TRACE}$** | Extremely verbose, fine-grained details. | Individual $\text{TileData}$ calculations, low-level network or file operations. |

### 3. Contextual Tracing with Spans

Spans are essential for tracking the flow of an asynchronous task. They define the lifetime of a specific unit of work.

* **Task Identification:** Every time a new $\text{Chunk}$ generation task is spawned onto the $\text{Tokio}$ runtime, a new $\text{Span}$ is created, often tagged with the $\text{ChunkKey}$ coordinates.
* **Span Guards:** Functions like $\text{ssxl\_start\_runtime}$ wrap their entire execution in a $\text{span!().enter()}$ guard. This ensures that any log event generated during that synchronous $\text{FFI}$ call is correctly attributed to the specific start-up phase.

```rust
// Example of a Panic Guard Span in the FFI layer
use tracing::{info, error, Level, span};

#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    let result = panic::catch_unwind(|| {
        // All events inside this block are tagged with the 'ssxl_start_runtime_panic_guard' span.
        let _guard = span!(Level::INFO, "ssxl_start_runtime_panic_guard").enter();
        // ... initialization code ...
        info!("FFI Bridge: Runtime started."); 
    });
    // ...
}


## E. Troubleshooting FFI/UB Issues

Integrating systems across a $\text{Foreign Function Interface (FFI)}$ is inherently complex. When things fail, the symptoms can range from silent data corruption to immediate program termination ($\text{SegFault}$ or $\text{Panic}$). This section outlines the most common issues specific to the SSXL-ext architecture and provides systematic debugging steps.

### 1. Hard Crashes: Segmentation Faults and Panics

A hard crash means the fundamental memory contract between Godot and Rust has been violated, often pointing directly to **Undefined Behavior (UB)**.

| Symptom | Root Cause | Debugging Strategy |
| :--- | :--- | :--- |
| **Immediate $\text{SegFault}$ on $\text{Library.open()}$** | **Linker Mismatch.** Incorrect compilation target, or missing dependencies ($\text{Visual C++ Redistributable}$). | Confirm $\text{x64}$ vs $\text{x86}$ architecture match between Godot and the compiled $\text{.dll}$. Ensure the $\text{GDScript}$ path to the $\text{.dll}$ is correct. |
| **Crash on $\text{add\_symbol}$ or first call** | **Signature Mismatch.** The $\text{GDScript}$ function binding does not match the Rust signature ($\text{Calling Convention}$ or wrong argument types). | **Cross-Reference Section A.** If Rust expects $\text{usize}$ (4-byte $\text{int}$) but $\text{GDScript}$ sends an incorrect type, the stack is corrupted. Carefully check the $\text{TYPE\_INT}$ mapping for pointers and sizes. |
| **Rust Panic on startup/shutdown** | **$\text{Mutex}$ Poisoning or UB.** An internal thread panicked while holding a $\text{Mutex}$, or an attempt was made to $\text{take()}$ a $\text{static}$ item. | **Check Chapter 2 and Tracing Logs.** Use the $\text{tracing}$ logs to find the exact line where the $\text{panic}$ occurred. If $\text{ssxl\_shutdown\_runtime}$ panics, it's often due to a lingering UB artifact or a task that was not signaled correctly. |
| **Unpredictable $\text{TileMap}$ corruption** | **Data Race.** Two threads are simultaneously writing to shared, un-atomized memory. | This should be prevented by the $\text{Conductor}$ pattern. If seen, check any shared $\text{static}$ state in the Rust core that is not guarded by a $\text{Mutex}$ or $\text{Atomic}$ primitive. |

### 2. Communication Errors (Negative $\text{isize}$ Returns)

These errors are graceful failures returned by $\text{ssxl\_poll\_progress\_message()}$ and require specific $\text{GDScript}$ action, as detailed in the **Error Atlas (Section A.4)**.

| Error Code | Symptom in $\text{GDScript}$ | Debugging Strategy |
| :--- | :--- | :--- |
| **$\text{FFI\_ERR\_CHANNEL\_DISCONNECTED}$ ($\text{-3}$)** | Polling stops working after a long period of inactivity or a large load. | Check the Rust worker threads. This means the $\text{mpsc}$ sender half has been dropped—usually because the $\text{Conductor}$ or a worker thread panicked or prematurely terminated without logging. |
| **$\text{FFI\_ERR\_BUFFER\_TOO\_SMALL}$ ($\text{-5}$)** | Polling fails, but the engine is running. | **Increase $\text{BUFFER\_SIZE}$** in $\text{SSXL.gd}$. The size of the serialized $\text{GenerationMessage}$ exceeded the $\text{PackedByteArray}$ capacity. If this persists, review the $\text{GenerationMessage}$ structure for unusually large arrays. |
| **$\text{FFI\_ERR\_SERIALIZATION\_FAILED}$ ($\text{-4}$)** | Rust generated data but cannot serialize it. | This points to a Rust-side $\text{Bincode}$ error (e.g., trying to serialize a type that isn't $\text{Derive(Serialize)}$). **Check Rust core logs ($\text{tracing}$).** |

### 3. Latency and Throughput Issues

If the engine runs but the $\text{TileMap}$ updates slowly or stutters, the performance contract is being violated.

* **Stuttering on $\text{poll}$ Success:**
    * **Cause:** The $\text{O}(N)$ $\text{Bincode}$ deserialization or the subsequent $\text{TileMap}$ $\text{O}(1)$ calls are taking too long.
    * **Action:** **Profile the $\text{GDScript}$ Deserialization.** If $\text{Bincode.decode()}$ is the bottleneck, you must further reduce the complexity or size of the $\text{GenerationMessage}$ payload (reduce $\text{N}$). If $\text{set\_cell()}$ is slow, consider batching updates if Godot's API allows.
* **Low Chunks/Second Rate:**
    * **Cause:** The Rust backend is not utilizing all available cores.
    * **Action:** **Check $\text{ssxl\_config.json}$** to ensure $\text{Worker Thread Count}$ is correctly configured. Check $\text{Tracing}$ logs for **lock contention warnings** ($\text{Mutex}$ wait times). If the generation task itself is $\text{CPU}$-bound, the only solution is optimizing the Rust algorithm.
<<< FILE END: SSXL_manual.rs >>>

>>> FILE START: verbose.rs (12 LOC) <<<
PS C:\zv9\zv9.SSXL-ext\rust> cargo metadata
warning: please specify `--format-version` flag explicitly to avoid compatibility problems
  Downloaded wasm-bindgen-shared v0.2.106
  Downloaded redox_syscall v0.5.18
  Downloaded wasm-bindgen-macro v0.2.106
  Downloaded wasm-bindgen-macro-support v0.2.106
  Downloaded js-sys v0.3.83
  Downloaded wasi v0.11.1+wasi-snapshot-preview1
  Downloaded wasm-bindgen v0.2.106
  Downloaded 7 crates (227.7KiB) in 0.69s
{"packages":[{"name":"aho-corasick","version":"1.1.4","id":"registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","license":"Unlicense OR MIT","license_file":null,"description":"Fast multiple substring searching.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"log","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.17","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"memchr","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.4.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"doc-comment","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"aho_corasick","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\aho-corasick-1.1.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"default":["std","perf-literal"],"logging":["dep:log"],"perf-literal":["dep:memchr"],"std":["memchr?/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\aho-corasick-1.1.4\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs","--generate-link-to-definition"]}}},"publish":null,"authors":["Andrew Gallant <jamslam@gmail.com>"],"categories":["text-processing"],"keywords":["string","search","text","pattern","multi"],"readme":"README.md","repository":"https://github.com/BurntSushi/aho-corasick","homepage":"https://github.com/BurntSushi/aho-corasick","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.60.0"},{"name":"autocfg","version":"1.5.0","id":"registry+https://github.com/rust-lang/crates.io-index#autocfg@1.5.0","license":"Apache-2.0 OR MIT","license_file":null,"description":"Automatic cfg for Rust compiler features","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"autocfg","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"integers","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\examples\\integers.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"nightly","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\examples\\nightly.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"paths","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\examples\\paths.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"traits","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\examples\\traits.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"versions","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\examples\\versions.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["test"],"crate_types":["bin"],"name":"no_std","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\tests\\no_std.rs","edition":"2015","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rustflags","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\tests\\rustflags.rs","edition":"2015","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tests","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\tests\\tests.rs","edition":"2015","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"wrappers","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\tests\\wrappers.rs","edition":"2015","doc":false,"doctest":false,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.5.0\\Cargo.toml","metadata":null,"publish":null,"authors":["Josh Stone <cuviper@gmail.com>"],"categories":["development-tools::build-utils"],"keywords":["rustc","build","autoconf"],"readme":"README.md","repository":"https://github.com/cuviper/autocfg","homepage":null,"documentation":"https://docs.rs/autocfg/","edition":"2015","links":null,"default_run":null,"rust_version":"1.0"},{"name":"bitflags","version":"2.10.0","id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0","license":"MIT OR Apache-2.0","license_file":null,"description":"A macro to generate structures which behave like bitflags.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"bytemuck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.12","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.228","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"bytemuck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.12.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.103","kind":"dev","rename":"serde_lib","optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"serde_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.19","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"trybuild","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.18","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"zerocopy","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"bitflags","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"custom_bits_type","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\examples\\custom_bits_type.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"custom_derive","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\examples\\custom_derive.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"fmt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\examples\\fmt.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"macro_free","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\examples\\macro_free.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"serde","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\examples\\serde.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"parse","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\benches\\parse.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"arbitrary":["dep:arbitrary"],"bytemuck":["dep:bytemuck"],"example_generated":[],"serde":["serde_core"],"serde_core":["dep:serde_core"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\Cargo.toml","metadata":{"docs":{"rs":{"features":["example_generated"]}}},"publish":null,"authors":["The Rust Project Developers"],"categories":["no-std"],"keywords":["bit","bitmask","bitflags","flags"],"readme":"README.md","repository":"https://github.com/bitflags/bitflags","homepage":"https://github.com/bitflags/bitflags","documentation":"https://docs.rs/bitflags","edition":"2021","links":null,"default_run":null,"rust_version":"1.56.0"},{"name":"bumpalo","version":"3.19.0","id":"registry+https://github.com/rust-lang/crates.io-index#bumpalo@3.19.0","license":"MIT OR Apache-2.0","license_file":null,"description":"A fast bump allocation arena for Rust.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"allocator-api2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.171","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"blink-alloc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.3.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.6","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.5","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.197","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.115","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"bumpalo","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bumpalo-3.19.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"allocator-api2":["dep:allocator-api2"],"allocator_api":[],"bench_allocator_api":["allocator_api","blink-alloc/nightly"],"boxed":[],"collections":[],"default":[],"serde":["dep:serde"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bumpalo-3.19.0\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true}}},"publish":null,"authors":["Nick Fitzgerald <fitzgen@gmail.com>"],"categories":["memory-management","rust-patterns","no-std"],"keywords":[],"readme":"README.md","repository":"https://github.com/fitzgen/bumpalo","homepage":null,"documentation":"https://docs.rs/bumpalo","edition":"2021","links":null,"default_run":null,"rust_version":"1.71.1"},{"name":"cfg-if","version":"1.0.4","id":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","license":"MIT OR Apache-2.0","license_file":null,"description":"A macro to ergonomically define an item depending on a large number of #[cfg]\nparameters. Structured like an if-else chain, the first matching branch is the\nitem that gets emitted.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"cfg_if","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.4\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"xcrate","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.4\\tests\\xcrate.rs","edition":"2018","doc":false,"doctest":false,"test":true}],"features":{"core":["dep:core"],"rustc-dep-of-std":["core"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.4\\Cargo.toml","metadata":null,"publish":null,"authors":["Alex Crichton <alex@alexcrichton.com>"],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-lang/cfg-if","homepage":null,"documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":"1.32"},{"name":"crossbeam-deque","version":"0.8.6","id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-deque@0.8.6","license":"MIT OR Apache-2.0","license_file":null,"description":"Concurrent work-stealing deque","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"crossbeam-epoch","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.17","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"crossbeam-utils","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.18","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_deque","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fifo","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\tests\\fifo.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"injector","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\tests\\injector.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"lifo","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\tests\\lifo.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"steal","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\tests\\steal.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"default":["std"],"std":["crossbeam-epoch/std","crossbeam-utils/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-deque-0.8.6\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["algorithms","concurrency","data-structures"],"keywords":["chase-lev","lock-free","scheduler","scheduling"],"readme":"README.md","repository":"https://github.com/crossbeam-rs/crossbeam","homepage":"https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-deque","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"crossbeam-epoch","version":"0.9.18","id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-epoch@0.9.18","license":"MIT OR Apache-2.0","license_file":null,"description":"Epoch-based garbage collection","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"crossbeam-utils","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.18","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.1","kind":null,"rename":"loom-crate","optional":true,"uses_default_features":true,"features":[],"target":"cfg(crossbeam_loom)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_epoch","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"sanitize","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\examples\\sanitize.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["test"],"crate_types":["bin"],"name":"loom","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\tests\\loom.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"defer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\benches\\defer.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"flush","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\benches\\flush.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"pin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\benches\\pin.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"alloc":[],"default":["std"],"loom":["loom-crate","crossbeam-utils/loom"],"loom-crate":["dep:loom-crate"],"nightly":["crossbeam-utils/nightly"],"std":["alloc","crossbeam-utils/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-epoch-0.9.18\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["concurrency","memory-management","no-std"],"keywords":["lock-free","rcu","atomic","garbage"],"readme":"README.md","repository":"https://github.com/crossbeam-rs/crossbeam","homepage":"https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-epoch","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"crossbeam-utils","version":"0.8.21","id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","license":"MIT OR Apache-2.0","license_file":null,"description":"Utilities for concurrent programming","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(crossbeam_loom)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"crossbeam_utils","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"atomic_cell","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\atomic_cell.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"cache_padded","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\cache_padded.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"parker","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\parker.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sharded_lock","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\sharded_lock.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"thread","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\thread.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"wait_group","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\tests\\wait_group.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"atomic_cell","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\benches\\atomic_cell.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"loom":["dep:loom"],"nightly":[],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["algorithms","concurrency","data-structures","no-std"],"keywords":["scoped","thread","atomic","cache"],"readme":"README.md","repository":"https://github.com/crossbeam-rs/crossbeam","homepage":"https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-utils","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.60"},{"name":"dashmap","version":"6.1.0","id":"registry+https://github.com/rust-lang/crates.io-index#dashmap@6.1.0","license":"MIT","license_file":null,"description":"Blazing fast concurrent HashMap for Rust.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.3.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"cfg-if","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"crossbeam-utils","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"hashbrown","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.14.0","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["raw"],"target":null,"registry":null},{"name":"lock_api","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.10","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"once_cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.18.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"parking_lot_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.8","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.7.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.188","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"typesize","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"dashmap","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\dashmap-6.1.0\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"arbitrary":["dep:arbitrary"],"inline":["hashbrown/inline-more"],"raw-api":[],"rayon":["dep:rayon"],"serde":["dep:serde"],"typesize":["dep:typesize"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\dashmap-6.1.0\\Cargo.toml","metadata":{"docs":{"rs":{"features":["rayon","raw-api","serde"]}}},"publish":null,"authors":["Acrimon <joel.wejdenstal@gmail.com>"],"categories":["concurrency","algorithms","data-structures"],"keywords":["atomic","concurrent","hashmap"],"readme":"README.md","repository":"https://github.com/xacrimon/dashmap","homepage":"https://github.com/xacrimon/dashmap","documentation":"https://docs.rs/dashmap","edition":"2018","links":null,"default_run":null,"rust_version":"1.65"},{"name":"either","version":"1.15.0","id":"registry+https://github.com/rust-lang/crates.io-index#either@1.15.0","license":"MIT OR Apache-2.0","license_file":null,"description":"The enum `Either` with variants `Left` and `Right` is a general purpose sum type with two cases.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.95","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc","derive"],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"either","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.15.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"default":["std"],"serde":["dep:serde"],"std":[],"use_std":["std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.15.0\\Cargo.toml","metadata":{"docs":{"rs":{"features":["serde"]}},"playground":{"features":["serde"]},"release":{"allow-branch":["main"],"sign-tag":true,"tag-name":"{{version}}"}},"publish":null,"authors":["bluss"],"categories":["data-structures","no-std"],"keywords":["data-structure","no_std"],"readme":"README-crates.io.md","repository":"https://github.com/rayon-rs/either","homepage":null,"documentation":"https://docs.rs/either/1/","edition":"2021","links":null,"default_run":null,"rust_version":"1.63.0"},{"name":"equivalent","version":"1.0.2","id":"registry+https://github.com/rust-lang/crates.io-index#equivalent@1.0.2","license":"Apache-2.0 OR MIT","license_file":null,"description":"Traits for key comparison in maps.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"equivalent","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\equivalent-1.0.2\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\equivalent-1.0.2\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["data-structures","no-std"],"keywords":["hashmap","no_std"],"readme":"README.md","repository":"https://github.com/indexmap-rs/equivalent","homepage":null,"documentation":null,"edition":"2015","links":null,"default_run":null,"rust_version":"1.6"},{"name":"fastrand","version":"2.3.0","id":"registry+https://github.com/rust-lang/crates.io-index#fastrand@2.3.0","license":"Apache-2.0 OR MIT","license_file":null,"description":"A simple and fast random number generator","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"getrandom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wyhash","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"getrandom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["js"],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null},{"name":"getrandom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["js"],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null},{"name":"wasm-bindgen-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"fastrand","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fastrand-2.3.0\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"char","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fastrand-2.3.0\\tests\\char.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"smoke","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fastrand-2.3.0\\tests\\smoke.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fastrand-2.3.0\\benches\\bench.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"alloc":[],"default":["std"],"getrandom":["dep:getrandom"],"js":["std","getrandom"],"std":["alloc"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fastrand-2.3.0\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":["Stjepan Glavina <stjepang@gmail.com>"],"categories":["algorithms"],"keywords":["simple","fast","rand","random","wyrand"],"readme":"README.md","repository":"https://github.com/smol-rs/fastrand","homepage":null,"documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":"1.36"},{"name":"flume","version":"0.12.0","id":"registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","license":"Apache-2.0/MIT","license_file":null,"description":"A blazingly fast multi-producer channel","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"fastrand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.3","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["std","js"],"target":null,"registry":null},{"name":"futures-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"futures-sink","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"spin","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.8","kind":null,"rename":"spin1","optional":false,"uses_default_features":true,"features":["mutex"],"target":null,"registry":null},{"name":"async-std","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.13.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["attributes","unstable"],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.1","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"crossbeam-channel","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.5","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"crossbeam-utils","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.10","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"futures","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["std"],"target":null,"registry":null},{"name":"getrandom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.15","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["js"],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.16.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["rt","macros"],"target":null,"registry":null},{"name":"waker-fn","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"flume","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"async","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\examples\\async.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"perf","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\examples\\perf.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"select","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\examples\\select.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"simple","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\examples\\simple.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["test"],"crate_types":["bin"],"name":"after","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\after.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"array","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\array.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"async","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\async.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"basic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\basic.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"check_same_channel","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\check_same_channel.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"golang","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\golang.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"iter","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\iter.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"list","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\list.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"method_sharing","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\method_sharing.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mpsc","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\mpsc.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"never","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\never.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"ready","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\ready.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"same_channel","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\same_channel.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"select","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\select.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"select_macro","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\select_macro.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\stream.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"thread_locals","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\thread_locals.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tick","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\tick.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"zero","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\tests\\zero.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"basic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\benches\\basic.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"async":["futures-sink","futures-core"],"default":["async","select","eventual-fairness"],"eventual-fairness":["select","fastrand"],"fastrand":["dep:fastrand"],"futures-core":["dep:futures-core"],"futures-sink":["dep:futures-sink"],"select":[],"spin":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\flume-0.12.0\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":["Joshua Barretto <joshua.s.barretto@gmail.com>"],"categories":["concurrency","data-structures"],"keywords":["mpsc","fifo","channel","thread","mpmc"],"readme":"README.md","repository":"https://github.com/zesterer/flume","homepage":null,"documentation":"https://docs.rs/flume","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"futures-core","version":"0.3.31","id":"registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31","license":"MIT OR Apache-2.0","license_file":null,"description":"The core traits and types in for the `futures` library.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"portable-atomic","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.3","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["require-cas"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"futures_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"cfg-target-has-atomic":[],"default":["std"],"portable-atomic":["dep:portable-atomic"],"std":["alloc"],"unstable":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":[],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-lang/futures-rs","homepage":"https://rust-lang.github.io/futures-rs","documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":"1.36"},{"name":"futures-sink","version":"0.3.31","id":"registry+https://github.com/rust-lang/crates.io-index#futures-sink@0.3.31","license":"MIT OR Apache-2.0","license_file":null,"description":"The asynchronous `Sink` trait for the futures-rs library.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"futures_sink","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-sink-0.3.31\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"default":["std"],"std":["alloc"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-sink-0.3.31\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true}}},"publish":null,"authors":[],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-lang/futures-rs","homepage":"https://rust-lang.github.io/futures-rs","documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":"1.36"},{"name":"gdextension-api","version":"0.3.0","id":"registry+https://github.com/rust-lang/crates.io-index#gdextension-api@0.3.0","license":"MPL-2.0","license_file":null,"description":"Godot GDExtension API; used by godot-rust.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"gdextension_api","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\gdextension-api-0.3.0\\src\\lib.rs","edition":"2024","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\gdextension-api-0.3.0\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","ffi"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2024","links":null,"default_run":null,"rust_version":null},{"name":"getrandom","version":"0.2.16","id":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.2.16","license":"MIT OR Apache-2.0","license_file":null,"description":"A small cross-platform library for retrieving random data from system source","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"cfg-if","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"compiler_builtins","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"js-sys","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null},{"name":"wasm-bindgen","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.62","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null},{"name":"wasm-bindgen-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.18","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))","registry":null},{"name":"wasi","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.11","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":"cfg(target_os = \"wasi\")","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.154","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":"cfg(unix)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"getrandom","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"custom","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\tests\\custom.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"normal","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\tests\\normal.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rdrand","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\tests\\rdrand.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"buffer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\benches\\buffer.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"compiler_builtins":["dep:compiler_builtins"],"core":["dep:core"],"custom":[],"js":["wasm-bindgen","js-sys"],"js-sys":["dep:js-sys"],"linux_disable_fallback":[],"rdrand":[],"rustc-dep-of-std":["compiler_builtins","core","libc/rustc-dep-of-std","wasi/rustc-dep-of-std"],"std":[],"test-in-browser":[],"wasm-bindgen":["dep:wasm-bindgen"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\getrandom-0.2.16\\Cargo.toml","metadata":{"cross":{"target":{"x86_64-unknown-netbsd":{"pre-build":["mkdir -p /tmp/netbsd","curl https://cdn.netbsd.org/pub/NetBSD/NetBSD-9.2/amd64/binary/sets/base.tar.xz -O","tar -C /tmp/netbsd -xJf base.tar.xz","cp /tmp/netbsd/usr/lib/libexecinfo.so /usr/local/x86_64-unknown-netbsd/lib","rm base.tar.xz","rm -rf /tmp/netbsd"]}}},"docs":{"rs":{"features":["std","custom"],"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":["The Rand Project Developers"],"categories":["os","no-std"],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-random/getrandom","homepage":null,"documentation":"https://docs.rs/getrandom","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"glam","version":"0.30.9","id":"registry+https://github.com/rust-lang/crates.io-index#glam@0.30.9","license":"MIT OR Apache-2.0","license_file":null,"description":"A simple and fast 3D math library for games and graphics","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"approx","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.4.2","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"bytemuck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.9","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["derive","aarch64_simd","wasm_simd"],"target":null,"registry":null},{"name":"encase","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.12","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"libm","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"mint","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rkyv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"speedy","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"zerocopy","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["simd"],"target":null,"registry":null},{"name":"zerocopy-derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand_xoshiro","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rkyv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["html_reports"],"target":"cfg(not(target_arch = \"wasm32\"))","registry":null},{"name":"iai-callgrind","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.14","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(target_arch = \"wasm32\"))","registry":null},{"name":"wasm-bindgen-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(target_arch = \"wasm32\")","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"glam","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"affine2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\affine2.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"affine3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\affine3.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"euler","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\euler.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"float","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\float.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mat2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\mat2.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mat3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\mat3.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mat4","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\mat4.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"quat","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\quat.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"support","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\support.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_f32","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_f32.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_f64","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_f64.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_i16","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_i16.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_i32","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_i32.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_i64","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_i64.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_i8","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_i8.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_u16","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_u16.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_u32","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_u32.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_u64","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_u64.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_u8","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_u8.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"swizzles_usize","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\swizzles_usize.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"vec2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\vec2.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"vec3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\vec3.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"vec4","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\tests\\vec4.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"affine2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\affine2.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"affine3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\affine3.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"iai","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\iai.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"mat2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\mat2.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"mat3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\mat3.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"mat3a","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\mat3a.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"mat4","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\mat4.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"quat","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\quat.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"support","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\support.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"vec2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\vec2.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"vec3","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\vec3.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"vec3a","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\vec3a.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"vec4","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\benches\\vec4.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"approx":["dep:approx"],"arbitrary":["dep:arbitrary"],"bytecheck":["rkyv/bytecheck"],"bytemuck":["dep:bytemuck"],"core-simd":["bytemuck?/nightly_portable_simd"],"cuda":[],"debug-glam-assert":[],"default":["std"],"encase":["dep:encase"],"fast-math":[],"glam-assert":[],"libm":["dep:libm"],"mint":["dep:mint"],"nostd-libm":["dep:libm"],"rand":["dep:rand"],"rkyv":["dep:rkyv"],"scalar-math":[],"serde":["dep:serde_core"],"speedy":["dep:speedy"],"std":[],"zerocopy":["dep:zerocopy","dep:zerocopy-derive"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\glam-0.30.9\\Cargo.toml","metadata":null,"publish":null,"authors":["Cameron Hart <cameron.hart@gmail.com>"],"categories":["game-engines","no-std"],"keywords":["gamedev","math","matrix","vector","quaternion"],"readme":"README.md","repository":"https://github.com/bitshifter/glam-rs","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.68.2"},{"name":"godot","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot@0.4.4","license":"MPL-2.0","license_file":null,"description":"Rust bindings for Godot 4","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"godot-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-macros","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"__codegen-full":["godot-core/codegen-full","godot-macros/codegen-full"],"__debug-log":["godot-core/debug-log"],"__trace":["godot-core/trace"],"api-4-2":["godot-core/api-4-2"],"api-4-2-1":["godot-core/api-4-2-1"],"api-4-2-2":["godot-core/api-4-2-2"],"api-4-3":["godot-core/api-4-3"],"api-4-4":["godot-core/api-4-4"],"api-4-5":["godot-core/api-4-5"],"api-custom":["godot-core/api-custom"],"api-custom-json":["godot-core/api-custom-json"],"codegen-rustfmt":["godot-core/codegen-rustfmt"],"custom-godot":["api-custom"],"custom-json":["api-custom-json"],"default":["__codegen-full"],"double-precision":["godot-core/double-precision"],"experimental-godot-api":["godot-core/experimental-godot-api"],"experimental-threads":["godot-core/experimental-threads"],"experimental-wasm":[],"experimental-wasm-nothreads":["godot-core/experimental-wasm-nothreads"],"lazy-function-tables":["godot-core/codegen-lazy-fptrs"],"register-docs":["godot-macros/register-docs","godot-core/register-docs"],"safeguards-dev-balanced":["godot-core/safeguards-dev-balanced"],"safeguards-release-disengaged":["godot-core/safeguards-release-disengaged"],"serde":["godot-core/serde"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":["Bromeon","godot-rust contributors"],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","2d","3d"],"readme":"crate-readme.md","repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":"https://docs.rs/godot/0.4.4","edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-bindings","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"bindgen","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.72.1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["runtime"],"target":null,"registry":null},{"name":"gdextension-api","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"nanoserde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"regex","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.11","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["std","unicode-bool","unicode-gencat"],"target":null,"registry":null},{"name":"which","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^7","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"regex","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.11","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["std","unicode-bool","unicode-gencat"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot_bindings","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-bindings-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-bindings-0.4.4\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"api-4-2":[],"api-4-2-1":[],"api-4-2-2":[],"api-4-3":[],"api-4-4":[],"api-4-5":[],"api-custom":["dep:bindgen","dep:regex","dep:which"],"api-custom-extheader":[],"api-custom-json":["dep:nanoserde","dep:bindgen","dep:regex","dep:which"],"default":[],"experimental-wasm-nothreads":[],"safeguards-dev-balanced":[],"safeguards-release-disengaged":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-bindings-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","ffi","sys"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-cell","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-cell@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proptest","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot_cell","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-cell-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mock","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-cell-0.4.4\\tests\\mock\\main.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"proptest":["dep:proptest"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-cell-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api","experimental-threads"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","ffi"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-codegen","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"godot-bindings","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"heck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"nanoserde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.80","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.37","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"regex","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.11","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["std","unicode-bool","unicode-gencat"],"target":null,"registry":null},{"name":"godot-bindings","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot_codegen","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-codegen-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-codegen-0.4.4\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"api-custom":["godot-bindings/api-custom"],"api-custom-json":["godot-bindings/api-custom-json"],"codegen-full":[],"codegen-lazy-fptrs":[],"codegen-rustfmt":[],"default":[],"double-precision":[],"experimental-godot-api":[],"experimental-threads":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-codegen-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","codegen"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-core","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-core@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"glam","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.30","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["debug-glam-assert"],"target":null,"registry":null},{"name":"godot-cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-ffi","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-bindings","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-codegen","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-core-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-core-0.4.4\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"api-4-2":["godot-ffi/api-4-2"],"api-4-2-1":["godot-ffi/api-4-2-1"],"api-4-2-2":["godot-ffi/api-4-2-2"],"api-4-3":["godot-ffi/api-4-3"],"api-4-4":["godot-ffi/api-4-4"],"api-4-5":["godot-ffi/api-4-5"],"api-custom":["godot-ffi/api-custom","godot-codegen/api-custom"],"api-custom-json":["godot-codegen/api-custom-json"],"codegen-full":["godot-codegen/codegen-full"],"codegen-lazy-fptrs":["godot-ffi/codegen-lazy-fptrs","godot-codegen/codegen-lazy-fptrs"],"codegen-rustfmt":["godot-ffi/codegen-rustfmt","godot-codegen/codegen-rustfmt"],"debug-log":["godot-ffi/debug-log"],"default":[],"double-precision":["godot-codegen/double-precision"],"experimental-godot-api":["godot-codegen/experimental-godot-api"],"experimental-threads":["godot-ffi/experimental-threads","godot-codegen/experimental-threads"],"experimental-wasm-nothreads":["godot-ffi/experimental-wasm-nothreads"],"register-docs":[],"safeguards-dev-balanced":["godot-ffi/safeguards-dev-balanced"],"safeguards-release-disengaged":["godot-ffi/safeguards-release-disengaged"],"serde":["dep:serde"],"trace":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-core-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","2d","3d"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-ffi","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-ffi@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"godot-bindings","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-codegen","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-macros","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["experimental-wasm"],"target":"cfg(target_family = \"wasm\")","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.172","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(target_os = \"linux\")","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"godot_ffi","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-ffi-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-ffi-0.4.4\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"api-4-2":["godot-bindings/api-4-2"],"api-4-2-1":["godot-bindings/api-4-2-1"],"api-4-2-2":["godot-bindings/api-4-2-2"],"api-4-3":["godot-bindings/api-4-3"],"api-4-4":["godot-bindings/api-4-4"],"api-4-5":["godot-bindings/api-4-5"],"api-custom":["godot-bindings/api-custom"],"api-custom-json":["godot-bindings/api-custom-json"],"codegen-lazy-fptrs":["godot-codegen/codegen-lazy-fptrs"],"codegen-rustfmt":["godot-codegen/codegen-rustfmt"],"debug-log":[],"experimental-godot-api":["godot-codegen/experimental-godot-api"],"experimental-threads":["godot-codegen/experimental-threads"],"experimental-wasm-nothreads":["godot-bindings/experimental-wasm-nothreads"],"safeguards-dev-balanced":["godot-bindings/safeguards-dev-balanced"],"safeguards-release-disengaged":["godot-bindings/safeguards-release-disengaged"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-ffi-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","ffi"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"godot-macros","version":"0.4.4","id":"registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4","license":"MPL-2.0","license_file":null,"description":"Internal crate used by godot-rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"litrs","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["proc-macro2"],"target":null,"registry":null},{"name":"markdown","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=1.0.0-alpha.23","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.80","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.37","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"venial","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot-bindings","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.4.4","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"godot_macros","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-macros-0.4.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-macros-0.4.4\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"api-custom":["godot-bindings/api-custom"],"api-custom-json":["godot-bindings/api-custom-json"],"codegen-full":[],"experimental-wasm":[],"register-docs":["dep:markdown","dep:litrs"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\godot-macros-0.4.4\\Cargo.toml","metadata":{"docs":{"rs":{"features":["experimental-godot-api"],"rustdoc-args":["--cfg","published_docs"],"rustc-args":["--cfg","published_docs"]}}},"publish":null,"authors":[],"categories":["game-engines","graphics"],"keywords":["gamedev","godot","engine","derive","macro"],"readme":null,"repository":"https://github.com/godot-rust/gdext","homepage":"https://godot-rust.github.io","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.87"},{"name":"hashbrown","version":"0.14.5","id":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.14.5","license":"MIT OR Apache-2.0","license_file":null,"description":"A Rust port of Google's SwissTable hash map","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"ahash","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.7","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rustc-std-workspace-alloc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"alloc","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"allocator-api2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.9","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"compiler_builtins","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.2","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"equivalent","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rkyv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.42","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.25","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"bumpalo","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^3.13.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["allocator-api2"],"target":null,"registry":null},{"name":"doc-comment","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"fnv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"lazy_static","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["small_rng"],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rkyv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.42","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["validation"],"target":null,"registry":null},{"name":"serde_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"hashbrown","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"equivalent_trait","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\equivalent_trait.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"hasher","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\hasher.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"raw","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\raw.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rayon","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\rayon.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"serde","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\serde.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"set","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\tests\\set.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\benches\\bench.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"insert_unique_unchecked","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\benches\\insert_unique_unchecked.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"ahash":["dep:ahash"],"alloc":["dep:alloc"],"allocator-api2":["dep:allocator-api2"],"compiler_builtins":["dep:compiler_builtins"],"core":["dep:core"],"default":["ahash","inline-more","allocator-api2"],"equivalent":["dep:equivalent"],"inline-more":[],"nightly":["allocator-api2?/nightly","bumpalo/allocator_api"],"raw":[],"rayon":["dep:rayon"],"rkyv":["dep:rkyv"],"rustc-dep-of-std":["nightly","core","compiler_builtins","alloc","rustc-internal-api"],"rustc-internal-api":[],"serde":["dep:serde"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.14.5\\Cargo.toml","metadata":{"docs":{"rs":{"features":["nightly","rayon","serde","raw"],"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["Amanieu d'Antras <amanieu@gmail.com>"],"categories":["data-structures","no-std"],"keywords":["hash","no_std","hashmap","swisstable"],"readme":"README.md","repository":"https://github.com/rust-lang/hashbrown","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.63.0"},{"name":"hashbrown","version":"0.16.1","id":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.16.1","license":"MIT OR Apache-2.0","license_file":null,"description":"A Rust port of Google's SwissTable hash map","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustc-std-workspace-alloc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"alloc","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"allocator-api2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.9","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"equivalent","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"foldhash","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.9.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.221","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"bumpalo","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^3.13.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["allocator-api2"],"target":null,"registry":null},{"name":"fnv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"lazy_static","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["small_rng"],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.220","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":"cfg(any())","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.155","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"hashbrown","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"equivalent_trait","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\tests\\equivalent_trait.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"hasher","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\tests\\hasher.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rayon","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\tests\\rayon.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"serde","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\tests\\serde.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"set","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\tests\\set.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\benches\\bench.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"insert_unique_unchecked","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\benches\\insert_unique_unchecked.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"set_ops","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\benches\\set_ops.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"with_capacity","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\benches\\with_capacity.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"alloc":["dep:alloc"],"allocator-api2":["dep:allocator-api2"],"core":["dep:core"],"default":["default-hasher","inline-more","allocator-api2","equivalent","raw-entry"],"default-hasher":["dep:foldhash"],"equivalent":["dep:equivalent"],"inline-more":[],"nightly":["foldhash?/nightly","bumpalo/allocator_api"],"raw-entry":[],"rayon":["dep:rayon"],"rustc-dep-of-std":["nightly","core","alloc","rustc-internal-api"],"rustc-internal-api":[],"serde":["dep:serde_core","dep:serde"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hashbrown-0.16.1\\Cargo.toml","metadata":{"docs":{"rs":{"features":["nightly","rayon","serde","raw-entry"],"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["Amanieu d'Antras <amanieu@gmail.com>"],"categories":["data-structures","no-std"],"keywords":["hash","no_std","hashmap","swisstable"],"readme":"README.md","repository":"https://github.com/rust-lang/hashbrown","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.65.0"},{"name":"heck","version":"0.5.0","id":"registry+https://github.com/rust-lang/crates.io-index#heck@0.5.0","license":"MIT OR Apache-2.0","license_file":null,"description":"heck is a case conversion library.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"heck","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\heck-0.5.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\heck-0.5.0\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["no-std"],"keywords":["string","case","camel","snake","unicode"],"readme":"README.md","repository":"https://github.com/withoutboats/heck","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.56"},{"name":"indexmap","version":"2.12.1","id":"registry+https://github.com/rust-lang/crates.io-index#indexmap@2.12.1","license":"Apache-2.0 OR MIT","license_file":null,"description":"A hash table with consistent order and fast iteration.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"borsh","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.2","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"equivalent","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"hashbrown","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.16.1","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.9","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.220","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"sval","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"fastrand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"fnv","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"itertools","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.14","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["derive"],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.220","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":"cfg(any())","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"indexmap","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"equivalent_trait","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\tests\\equivalent_trait.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_full_path","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\tests\\macros_full_path.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"quick","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\tests\\quick.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tests","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\tests\\tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\benches\\bench.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"faststring","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\benches\\faststring.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"arbitrary":["dep:arbitrary"],"borsh":["dep:borsh"],"default":["std"],"quickcheck":["dep:quickcheck"],"rayon":["dep:rayon"],"serde":["dep:serde_core","dep:serde"],"std":[],"sval":["dep:sval"],"test_debug":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\indexmap-2.12.1\\Cargo.toml","metadata":{"release":{"allow-branch":["main"],"sign-tag":true,"tag-name":"{{version}}"},"docs":{"rs":{"features":["arbitrary","quickcheck","serde","borsh","rayon","sval"],"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":[],"categories":["data-structures","no-std"],"keywords":["hashmap","no_std"],"readme":"README.md","repository":"https://github.com/indexmap-rs/indexmap","homepage":null,"documentation":"https://docs.rs/indexmap/","edition":"2021","links":null,"default_run":null,"rust_version":"1.82"},{"name":"js-sys","version":"0.3.83","id":"registry+https://github.com/rust-lang/crates.io-index#js-sys@0.3.83","license":"MIT OR Apache-2.0","license_file":null,"description":"Bindings for all JS global objects and functions in all JS environments like\nNode.js and browsers, built on `#[wasm_bindgen]` using the `wasm-bindgen` crate.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"once_cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.12","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"wasm-bindgen","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.106","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"js_sys","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\js-sys-0.3.83\\src\\lib.rs","edition":"2021","doc":true,"doctest":false,"test":false}],"features":{"default":["std"],"std":["wasm-bindgen/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\js-sys-0.3.83\\Cargo.toml","metadata":null,"publish":null,"authors":["The wasm-bindgen Developers"],"categories":["wasm"],"keywords":[],"readme":"README.md","repository":"https://github.com/wasm-bindgen/wasm-bindgen/tree/master/crates/js-sys","homepage":"https://wasm-bindgen.github.io/wasm-bindgen/","documentation":"https://docs.rs/js-sys","edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"libc","version":"0.2.178","id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","license":"MIT OR Apache-2.0","license_file":null,"description":"Raw FFI bindings to platform libraries like libc.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"libc","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libc-0.2.178\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"const_fn","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libc-0.2.178\\tests\\const_fn.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libc-0.2.178\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"align":[],"const-extern-fn":[],"default":["std"],"extra_traits":[],"rustc-dep-of-std":["align","rustc-std-workspace-core"],"rustc-std-workspace-core":["dep:rustc-std-workspace-core"],"std":[],"use_std":["std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libc-0.2.178\\Cargo.toml","metadata":{"docs":{"rs":{"features":["extra_traits"],"default-target":"x86_64-unknown-linux-gnu","targets":["aarch64-apple-darwin","aarch64-apple-ios","aarch64-linux-android","aarch64-pc-windows-msvc","aarch64-unknown-freebsd","aarch64-unknown-fuchsia","aarch64-unknown-hermit","aarch64-unknown-linux-gnu","aarch64-unknown-linux-musl","aarch64-unknown-netbsd","aarch64-unknown-openbsd","aarch64-wrs-vxworks","arm-linux-androideabi","arm-unknown-linux-gnueabi","arm-unknown-linux-gnueabihf","arm-unknown-linux-musleabi","arm-unknown-linux-musleabihf","armebv7r-none-eabi","armebv7r-none-eabihf","armv5te-unknown-linux-gnueabi","armv5te-unknown-linux-musleabi","armv7-linux-androideabi","armv7-unknown-linux-gnueabihf","armv7-unknown-linux-musleabihf","armv7-wrs-vxworks-eabihf","armv7r-none-eabi","armv7r-none-eabihf","i586-unknown-linux-gnu","i586-unknown-linux-musl","i686-linux-android","i686-pc-windows-gnu","i686-pc-windows-msvc","i686-pc-windows-msvc","i686-unknown-freebsd","i686-unknown-haiku","i686-unknown-linux-gnu","i686-unknown-linux-musl","i686-unknown-netbsd","i686-unknown-openbsd","i686-wrs-vxworks","mips-unknown-linux-gnu","mips-unknown-linux-musl","mips64-unknown-linux-gnuabi64","mips64-unknown-linux-muslabi64","mips64el-unknown-linux-gnuabi64","mips64el-unknown-linux-muslabi64","mipsel-sony-psp","mipsel-unknown-linux-gnu","mipsel-unknown-linux-musl","nvptx64-nvidia-cuda","powerpc-unknown-linux-gnu","powerpc-unknown-linux-gnuspe","powerpc-unknown-netbsd","powerpc-wrs-vxworks","powerpc-wrs-vxworks-spe","powerpc64-ibm-aix","powerpc64-unknown-freebsd","powerpc64-unknown-linux-gnu","powerpc64-wrs-vxworks","powerpc64le-unknown-linux-gnu","powerpc64le-unknown-linux-musl","riscv32gc-unknown-linux-gnu","riscv32i-unknown-none-elf","riscv32imac-unknown-none-elf","riscv32imc-unknown-none-elf","riscv32-wrs-vxworks","riscv64gc-unknown-freebsd","riscv64gc-unknown-hermit","riscv64gc-unknown-linux-gnu","riscv64gc-unknown-linux-musl","riscv64gc-unknown-none-elf","riscv64imac-unknown-none-elf","riscv64-wrs-vxworks","s390x-unknown-linux-gnu","s390x-unknown-linux-musl","sparc-unknown-linux-gnu","sparc64-unknown-linux-gnu","sparc64-unknown-netbsd","sparcv9-sun-solaris","thumbv6m-none-eabi","thumbv7em-none-eabi","thumbv7em-none-eabihf","thumbv7m-none-eabi","thumbv7neon-linux-androideabi","thumbv7neon-unknown-linux-gnueabihf","wasm32-unknown-emscripten","wasm32-unknown-unknown","x86_64-apple-darwin","x86_64-apple-ios","x86_64-fortanix-unknown-sgx","x86_64-linux-android","x86_64-pc-solaris","x86_64-pc-windows-gnu","x86_64-pc-windows-msvc","x86_64-unknown-dragonfly","x86_64-unknown-freebsd","x86_64-unknown-fuchsia","x86_64-unknown-haiku","x86_64-unknown-hermit","x86_64-unknown-illumos","x86_64-unknown-l4re-uclibc","x86_64-unknown-linux-gnu","x86_64-unknown-linux-gnux32","x86_64-unknown-linux-musl","x86_64-unknown-netbsd","x86_64-unknown-openbsd","x86_64-unknown-redox","x86_64-wrs-vxworks"],"cargo-args":["-Zbuild-std=core"]}},"cargo-semver-checks":{"lints":{"repr_align_removed":"warn","global_value_marked_deprecated":"warn"}}},"publish":null,"authors":["The Rust Project Developers"],"categories":["external-ffi-bindings","no-std","os"],"keywords":["libc","ffi","bindings","operating","system"],"readme":"README.md","repository":"https://github.com/rust-lang/libc","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.63"},{"name":"lock_api","version":"0.4.14","id":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","license":"MIT OR Apache-2.0","license_file":null,"description":"Wrappers to create fully-featured Mutex and RwLock types. Compatible with no_std.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"owning_ref","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"scopeguard","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.1.0","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.126","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"lock_api","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"arc_lock":[],"atomic_usize":[],"default":["atomic_usize"],"nightly":[],"owning_ref":["dep:owning_ref"],"serde":["dep:serde"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs","--generate-link-to-definition"]}}},"publish":null,"authors":["Amanieu d'Antras <amanieu@gmail.com>"],"categories":["concurrency","no-std"],"keywords":["mutex","rwlock","lock","no_std"],"readme":null,"repository":"https://github.com/Amanieu/parking_lot","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.71.0"},{"name":"memchr","version":"2.7.6","id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","license":"Unlicense OR MIT","license_file":null,"description":"Provides extremely fast (uses SIMD on x86_64, aarch64 and wasm32) routines for\n1, 2 or 3 byte search and single substring search.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"log","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.20","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"memchr","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.6\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"core":["dep:core"],"default":["std"],"libc":[],"logging":["dep:log"],"rustc-dep-of-std":["core"],"std":["alloc"],"use_std":["std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.6\\Cargo.toml","metadata":{"docs":{"rs":{"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["Andrew Gallant <jamslam@gmail.com>","bluss"],"categories":[],"keywords":["memchr","memmem","substring","find","search"],"readme":"README.md","repository":"https://github.com/BurntSushi/memchr","homepage":"https://github.com/BurntSushi/memchr","documentation":"https://docs.rs/memchr/","edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"nanoserde","version":"0.2.1","id":"registry+https://github.com/rust-lang/crates.io-index#nanoserde@0.2.1","license":"MIT OR Apache-2.0","license_file":null,"description":"Serialization library with zero dependencies.\nSupports Binary, JSON, RON and TOML.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"nanoserde-derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"nanoserde","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"bin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\bin.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"json","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\json.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"parse","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\parse.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"ron","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\ron.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"ser_de","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\ser_de.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"toml","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\tests\\toml.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"binary":["dep:nanoserde-derive","nanoserde-derive/binary"],"default":["binary","json","ron","toml","std"],"json":["dep:nanoserde-derive","nanoserde-derive/json"],"ron":["dep:nanoserde-derive","nanoserde-derive/ron"],"std":[],"toml":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-0.2.1\\Cargo.toml","metadata":null,"publish":null,"authors":["makepad <info@makepad.nl>","Fedor <not.fl3@gmail.com>"],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/not-fl3/nanoserde","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.81.0"},{"name":"nanoserde-derive","version":"0.2.1","id":"registry+https://github.com/rust-lang/crates.io-index#nanoserde-derive@0.2.1","license":"MIT","license_file":null,"description":"Fork of makepad-tinyserde derive without any external dependencies","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"nanoserde_derive","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-derive-0.2.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"binary":[],"default":[],"json":[],"ron":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\nanoserde-derive-0.2.1\\Cargo.toml","metadata":null,"publish":null,"authors":["Makepad <info@makepad.nl>","Fedor <not.fl3@gmail.com>"],"categories":[],"keywords":[],"readme":null,"repository":null,"homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.81.0"},{"name":"noise","version":"0.9.0","id":"registry+https://github.com/rust-lang/crates.io-index#noise@0.9.0","license":"Apache-2.0/MIT","license_file":null,"description":"Procedural noise generation library.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"image","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.25.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"num-traits","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand_xorshift","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["html_reports"],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand_pcg","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"noise","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"abs","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\abs.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"add","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\add.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"basicmulti","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\basicmulti.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"billow","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\billow.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"blend","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\blend.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"cache","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\cache.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"checkerboard","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\checkerboard.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"clamp","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\clamp.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"complexplanet","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\complexplanet.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"constant","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\constant.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"curve","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\curve.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"cylinders","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\cylinders.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"displace","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\displace.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"exponent","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\exponent.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"fbm","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\fbm.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"hybridmulti","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\hybridmulti.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"max","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\max.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"min","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\min.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"multiply","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\multiply.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"negate","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\negate.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"open_simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\open_simplex.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"perlin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\perlin.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"perlin_surflet","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\perlin_surflet.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"power","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\power.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"ridgedmulti","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\ridgedmulti.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"rotate_point","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\rotate_point.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"scale_bias","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\scale_bias.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"scale_point","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\scale_point.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"select","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\select.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\simplex.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"spheres","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\spheres.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"super_simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\super_simplex.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"terrace","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\terrace.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"texturegranite","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\texturegranite.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"texturejade","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\texturejade.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"textureslime","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\textureslime.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"texturewood","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\texturewood.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"translate_point","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\translate_point.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"turbulence","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\turbulence.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"utils","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\utils.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"value","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\value.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"worley","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\examples\\worley.rs","edition":"2018","required-features":["images"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"open_simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\open_simplex.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"perlin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\perlin.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"perlin_surflet","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\perlin_surflet.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\simplex.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"super_simplex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\super_simplex.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"value","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\value.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"worley_2d","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\worley_2d.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"worley_3d","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\worley_3d.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"worley_4d","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\benches\\worley_4d.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"default":[],"image":["dep:image"],"images":["image","std"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\noise-0.9.0\\Cargo.toml","metadata":null,"publish":null,"authors":["The Noise-rs Developers."],"categories":[],"keywords":["math","random"],"readme":"README.md","repository":"https://github.com/razaekel/noise-rs","homepage":"https://github.com/razaekel/noise-rs","documentation":"https://docs.rs/noise/","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"num-traits","version":"0.2.19","id":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","license":"MIT OR Apache-2.0","license_file":null,"description":"Numeric traits for generic mathematics","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"libm","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"autocfg","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"build","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"num_traits","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.19\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"cast","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.19\\tests\\cast.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.19\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"i128":[],"libm":["dep:libm"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.19\\Cargo.toml","metadata":{"docs":{"rs":{"features":["std"],"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["The Rust Project Developers"],"categories":["algorithms","science","no-std"],"keywords":["mathematics","numerics"],"readme":"README.md","repository":"https://github.com/rust-num/num-traits","homepage":"https://github.com/rust-num/num-traits","documentation":"https://docs.rs/num-traits","edition":"2021","links":null,"default_run":null,"rust_version":"1.60"},{"name":"once_cell","version":"1.21.3","id":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","license":"MIT OR Apache-2.0","license_file":null,"description":"Single assignment cells and lazy values.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"critical-section","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.1.3","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"parking_lot_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.10","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"portable-atomic","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.8","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"critical-section","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.1.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["std"],"target":null,"registry":null},{"name":"regex","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.10.6","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"once_cell","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\bench.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"bench_acquire","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\bench_acquire.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"lazy_static","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\lazy_static.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"reentrant_init_deadlocks","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\reentrant_init_deadlocks.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"regex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\regex.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"test_synchronization","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\examples\\test_synchronization.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["test"],"crate_types":["bin"],"name":"it","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\tests\\it\\main.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"alloc":["race"],"atomic-polyfill":["critical-section"],"critical-section":["dep:critical-section","portable-atomic"],"default":["std"],"parking_lot":["dep:parking_lot_core"],"portable-atomic":["dep:portable-atomic"],"race":[],"std":["alloc"],"unstable":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\once_cell-1.21.3\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["Aleksey Kladov <aleksey.kladov@gmail.com>"],"categories":["rust-patterns","memory-management"],"keywords":["lazy","static"],"readme":"README.md","repository":"https://github.com/matklad/once_cell","homepage":null,"documentation":"https://docs.rs/once_cell","edition":"2021","links":null,"default_run":null,"rust_version":"1.65"},{"name":"parking_lot_core","version":"0.9.12","id":"registry+https://github.com/rust-lang/crates.io-index#parking_lot_core@0.9.12","license":"MIT OR Apache-2.0","license_file":null,"description":"An advanced API for creating custom synchronization primitives.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"backtrace","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.60","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"cfg-if","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"petgraph","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"smallvec","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.6.1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"redox_syscall","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(target_os = \"redox\")","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.95","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null},{"name":"windows-link","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(windows)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"parking_lot_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\parking_lot_core-0.9.12\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\parking_lot_core-0.9.12\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"backtrace":["dep:backtrace"],"deadlock_detection":["petgraph","backtrace"],"nightly":[],"petgraph":["dep:petgraph"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\parking_lot_core-0.9.12\\Cargo.toml","metadata":{"docs":{"rs":{"rustdoc-args":["--generate-link-to-definition"]}}},"publish":null,"authors":["Amanieu d'Antras <amanieu@gmail.com>"],"categories":["concurrency"],"keywords":["mutex","condvar","rwlock","once","thread"],"readme":null,"repository":"https://github.com/Amanieu/parking_lot","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.71.0"},{"name":"pin-project-lite","version":"0.2.16","id":"registry+https://github.com/rust-lang/crates.io-index#pin-project-lite@0.2.16","license":"Apache-2.0 OR MIT","license_file":null,"description":"A lightweight version of pin-project written with declarative macros.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"static_assertions","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"pin_project_lite","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"compiletest","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\tests\\compiletest.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"drop_order","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\tests\\drop_order.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"expandtest","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\tests\\expandtest.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"proper_unpin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\tests\\proper_unpin.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\tests\\test.rs","edition":"2018","doc":false,"doctest":false,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pin-project-lite-0.2.16\\Cargo.toml","metadata":{"cargo_check_external_types":{"allowed_external_types":[]},"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"]}}},"publish":null,"authors":[],"categories":["no-std","no-std::no-alloc","rust-patterns"],"keywords":["pin","macros"],"readme":"README.md","repository":"https://github.com/taiki-e/pin-project-lite","homepage":null,"documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":"1.37"},{"name":"proc-macro2","version":"1.0.103","id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","license":"MIT OR Apache-2.0","license_file":null,"description":"A substitute implementation of the compiler's `proc_macro` API to decouple token-based libraries from the procedural macro use case.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"unicode-ident","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"flate2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tar","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"proc_macro2","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"comments","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\comments.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"features","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\features.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"marker","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\marker.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\test.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_fmt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\test_fmt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_size","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\tests\\test_size.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"default":["proc-macro"],"nightly":[],"proc-macro":[],"span-locations":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.103\\Cargo.toml","metadata":{"docs":{"rs":{"rustc-args":["--cfg=procmacro2_semver_exempt"],"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--cfg=procmacro2_semver_exempt","--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org","--extern-html-root-url=proc_macro=https://doc.rust-lang.org"]}},"playground":{"features":["span-locations"]}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>","Alex Crichton <alex@alexcrichton.com>"],"categories":["development-tools::procedural-macro-helpers"],"keywords":["macros","syn"],"readme":"README.md","repository":"https://github.com/dtolnay/proc-macro2","homepage":null,"documentation":"https://docs.rs/proc-macro2","edition":"2021","links":null,"default_run":null,"rust_version":"1.60"},{"name":"quote","version":"1.0.42","id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","license":"MIT OR Apache-2.0","license_file":null,"description":"Quasi-quoting macro quote!(...)","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.80","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"trybuild","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.108","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["diff"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"quote","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.42\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"compiletest","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.42\\tests\\compiletest.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.42\\tests\\test.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.42\\build.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"default":["proc-macro"],"proc-macro":["proc-macro2/proc-macro"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.42\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org"]}}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":["development-tools::procedural-macro-helpers"],"keywords":["macros","syn"],"readme":"README.md","repository":"https://github.com/dtolnay/quote","homepage":null,"documentation":"https://docs.rs/quote/","edition":"2018","links":null,"default_run":null,"rust_version":"1.68"},{"name":"rand","version":"0.8.5","id":"registry+https://github.com/rust-lang/crates.io-index#rand@0.8.5","license":"MIT OR Apache-2.0","license_file":null,"description":"Random number generators and other randomness functionality.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"log","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.4","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"packed_simd_2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.7","kind":null,"rename":"packed_simd","optional":true,"uses_default_features":true,"features":["into_bits"],"target":null,"registry":null},{"name":"rand_chacha","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rand_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.103","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"bincode","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.2.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand_pcg","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.22","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":"cfg(unix)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"rand","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"alloc":["rand_core/alloc"],"default":["std","std_rng"],"getrandom":["rand_core/getrandom"],"libc":["dep:libc"],"log":["dep:log"],"min_const_gen":[],"nightly":[],"packed_simd":["dep:packed_simd"],"rand_chacha":["dep:rand_chacha"],"serde":["dep:serde"],"serde1":["serde","rand_core/serde1"],"simd_support":["packed_simd"],"small_rng":[],"std":["rand_core/std","rand_chacha/std","alloc","getrandom","libc"],"std_rng":["rand_chacha"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand-0.8.5\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","doc_cfg"]}},"playground":{"features":["small_rng","serde1"]}},"publish":null,"authors":["The Rand Project Developers","The Rust Project Developers"],"categories":["algorithms","no-std"],"keywords":["random","rng"],"readme":"README.md","repository":"https://github.com/rust-random/rand","homepage":"https://rust-random.github.io/book","documentation":"https://docs.rs/rand","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"rand_core","version":"0.6.4","id":"registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4","license":"MIT OR Apache-2.0","license_file":null,"description":"Core random number generator traits and tools for implementation.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"getrandom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["derive"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"rand_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand_core-0.6.4\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"getrandom":["dep:getrandom"],"serde":["dep:serde"],"serde1":["serde"],"std":["alloc","getrandom","getrandom/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand_core-0.6.4\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","doc_cfg"]}},"playground":{"all-features":true}},"publish":null,"authors":["The Rand Project Developers","The Rust Project Developers"],"categories":["algorithms","no-std"],"keywords":["random","rng"],"readme":"README.md","repository":"https://github.com/rust-random/rand","homepage":"https://rust-random.github.io/book","documentation":"https://docs.rs/rand_core","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"rand_xorshift","version":"0.3.0","id":"registry+https://github.com/rust-lang/crates.io-index#rand_xorshift@0.3.0","license":"MIT OR Apache-2.0","license_file":null,"description":"Xorshift random number generator\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rand_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.118","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["derive"],"target":null,"registry":null},{"name":"bincode","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"rand_xorshift","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand_xorshift-0.3.0\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"mod","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand_xorshift-0.3.0\\tests\\mod.rs","edition":"2018","doc":false,"doctest":false,"test":true}],"features":{"serde":["dep:serde"],"serde1":["serde"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rand_xorshift-0.3.0\\Cargo.toml","metadata":null,"publish":null,"authors":["The Rand Project Developers","The Rust Project Developers"],"categories":["algorithms","no-std"],"keywords":["random","rng","xorshift"],"readme":"README.md","repository":"https://github.com/rust-random/rngs","homepage":"https://rust-random.github.io/book","documentation":"https://docs.rs/rand_xorshift","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"rayon","version":"1.11.0","id":"registry+https://github.com/rust-lang/crates.io-index#rayon@1.11.0","license":"MIT OR Apache-2.0","license_file":null,"description":"Simple work-stealing parallelism for Rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"either","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"rayon-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.13.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wasm_sync","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand_xorshift","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"rayon","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"chars","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\chars.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"clones","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\clones.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"collect","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\collect.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"cross-pool","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\cross-pool.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"debug","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\debug.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"drain_vec","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\drain_vec.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"intersperse","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\intersperse.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"issue671","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\issue671.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"issue671-unzip","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\issue671-unzip.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"iter_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\iter_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"named-threads","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\named-threads.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"octillion","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\octillion.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"par_bridge_recursion","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\par_bridge_recursion.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"producer_split_at","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\producer_split_at.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sort-panic-safe","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\sort-panic-safe.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"str","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\tests\\str.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"web_spin_lock":["dep:wasm_sync","rayon-core/web_spin_lock"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-1.11.0\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["concurrency"],"keywords":["parallel","thread","concurrency","join","performance"],"readme":"README.md","repository":"https://github.com/rayon-rs/rayon","homepage":null,"documentation":"https://docs.rs/rayon/","edition":"2021","links":null,"default_run":null,"rust_version":"1.80"},{"name":"rayon-core","version":"1.13.0","id":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","license":"MIT OR Apache-2.0","license_file":null,"description":"Core APIs for Rayon","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"crossbeam-deque","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"crossbeam-utils","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wasm_sync","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand_xorshift","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"scoped-tls","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"rayon_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"double_init_fail","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\double_init_fail.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"init_zero_threads","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\init_zero_threads.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"scope_join","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\scope_join.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"scoped_threadpool","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\scoped_threadpool.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"simple_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\simple_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"stack_overflow_crash","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\stack_overflow_crash.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"use_current_thread","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\tests\\use_current_thread.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"web_spin_lock":["dep:wasm_sync"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rayon-core-1.13.0\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["concurrency"],"keywords":["parallel","thread","concurrency","join","performance"],"readme":"README.md","repository":"https://github.com/rayon-rs/rayon","homepage":null,"documentation":"https://docs.rs/rayon-core/","edition":"2021","links":"rayon-core","default_run":null,"rust_version":"1.80"},{"name":"redox_syscall","version":"0.5.18","id":"registry+https://github.com/rust-lang/crates.io-index#redox_syscall@0.5.18","license":"MIT","license_file":null,"description":"A Rust library to access raw Redox system calls","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"bitflags","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(loom)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"syscall","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\redox_syscall-0.5.18\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"core":["dep:core"],"default":["userspace"],"rustc-dep-of-std":["core","bitflags/rustc-dep-of-std"],"std":[],"userspace":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\redox_syscall-0.5.18\\Cargo.toml","metadata":null,"publish":null,"authors":["Jeremy Soller <jackpot51@gmail.com>"],"categories":[],"keywords":[],"readme":"README.md","repository":"https://gitlab.redox-os.org/redox-os/syscall","homepage":null,"documentation":"https://docs.rs/redox_syscall","edition":"2021","links":null,"default_run":null,"rust_version":null},{"name":"regex","version":"1.12.2","id":"registry+https://github.com/rust-lang/crates.io-index#regex@1.12.2","license":"MIT OR Apache-2.0","license_file":null,"description":"An implementation of regular expressions for Rust. This implementation uses\nfinite automata and guarantees linear time matching on all inputs.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"aho-corasick","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"memchr","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"regex-automata","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.12","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["alloc","syntax","meta","nfa-pikevm"],"target":null,"registry":null},{"name":"regex-syntax","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.5","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"anyhow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.69","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"doc-comment","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"env_logger","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.3","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["atty","humantime","termcolor"],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"regex-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"regex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-1.12.2\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"integration","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-1.12.2\\tests\\lib.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"default":["std","perf","unicode","regex-syntax/default"],"logging":["aho-corasick?/logging","memchr?/logging","regex-automata/logging"],"pattern":[],"perf":["perf-cache","perf-dfa","perf-onepass","perf-backtrack","perf-inline","perf-literal"],"perf-backtrack":["regex-automata/nfa-backtrack"],"perf-cache":[],"perf-dfa":["regex-automata/hybrid"],"perf-dfa-full":["regex-automata/dfa-build","regex-automata/dfa-search"],"perf-inline":["regex-automata/perf-inline"],"perf-literal":["dep:aho-corasick","dep:memchr","regex-automata/perf-literal"],"perf-onepass":["regex-automata/dfa-onepass"],"std":["aho-corasick?/std","memchr?/std","regex-automata/std","regex-syntax/std"],"unicode":["unicode-age","unicode-bool","unicode-case","unicode-gencat","unicode-perl","unicode-script","unicode-segment","regex-automata/unicode","regex-syntax/unicode"],"unicode-age":["regex-automata/unicode-age","regex-syntax/unicode-age"],"unicode-bool":["regex-automata/unicode-bool","regex-syntax/unicode-bool"],"unicode-case":["regex-automata/unicode-case","regex-syntax/unicode-case"],"unicode-gencat":["regex-automata/unicode-gencat","regex-syntax/unicode-gencat"],"unicode-perl":["regex-automata/unicode-perl","regex-automata/unicode-word-boundary","regex-syntax/unicode-perl"],"unicode-script":["regex-automata/unicode-script","regex-syntax/unicode-script"],"unicode-segment":["regex-automata/unicode-segment","regex-syntax/unicode-segment"],"unstable":["pattern"],"use_std":["std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-1.12.2\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs_regex"]}}},"publish":null,"authors":["The Rust Project Developers","Andrew Gallant <jamslam@gmail.com>"],"categories":["text-processing"],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-lang/regex","homepage":"https://github.com/rust-lang/regex","documentation":"https://docs.rs/regex","edition":"2021","links":null,"default_run":null,"rust_version":"1.65"},{"name":"regex-automata","version":"0.4.13","id":"registry+https://github.com/rust-lang/crates.io-index#regex-automata@0.4.13","license":"MIT OR Apache-2.0","license_file":null,"description":"Automata construction and matching using regular expressions.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"aho-corasick","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"log","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.14","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"memchr","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"regex-syntax","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.8.5","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"anyhow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.69","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"bstr","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.3.0","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["std"],"target":null,"registry":null},{"name":"doc-comment","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"env_logger","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.3","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["atty","humantime","termcolor"],"target":null,"registry":null},{"name":"quickcheck","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"regex-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"regex_automata","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-automata-0.4.13\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"integration","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-automata-0.4.13\\tests\\lib.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"alloc":[],"default":["std","syntax","perf","unicode","meta","nfa","dfa","hybrid"],"dfa":["dfa-build","dfa-search","dfa-onepass"],"dfa-build":["nfa-thompson","dfa-search"],"dfa-onepass":["nfa-thompson"],"dfa-search":[],"hybrid":["alloc","nfa-thompson"],"internal-instrument":["internal-instrument-pikevm"],"internal-instrument-pikevm":["logging","std"],"logging":["dep:log","aho-corasick?/logging","memchr?/logging"],"meta":["syntax","nfa-pikevm"],"nfa":["nfa-thompson","nfa-pikevm","nfa-backtrack"],"nfa-backtrack":["nfa-thompson"],"nfa-pikevm":["nfa-thompson"],"nfa-thompson":["alloc"],"perf":["perf-inline","perf-literal"],"perf-inline":[],"perf-literal":["perf-literal-substring","perf-literal-multisubstring"],"perf-literal-multisubstring":["dep:aho-corasick"],"perf-literal-substring":["aho-corasick?/perf-literal","dep:memchr"],"std":["regex-syntax?/std","memchr?/std","aho-corasick?/std","alloc"],"syntax":["dep:regex-syntax","alloc"],"unicode":["unicode-age","unicode-bool","unicode-case","unicode-gencat","unicode-perl","unicode-script","unicode-segment","unicode-word-boundary","regex-syntax?/unicode"],"unicode-age":["regex-syntax?/unicode-age"],"unicode-bool":["regex-syntax?/unicode-bool"],"unicode-case":["regex-syntax?/unicode-case"],"unicode-gencat":["regex-syntax?/unicode-gencat"],"unicode-perl":["regex-syntax?/unicode-perl"],"unicode-script":["regex-syntax?/unicode-script"],"unicode-segment":["regex-syntax?/unicode-segment"],"unicode-word-boundary":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-automata-0.4.13\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs_regex"]}}},"publish":null,"authors":["The Rust Project Developers","Andrew Gallant <jamslam@gmail.com>"],"categories":["text-processing"],"keywords":["regex","dfa","automata","automaton","nfa"],"readme":"README.md","repository":"https://github.com/rust-lang/regex","homepage":"https://github.com/rust-lang/regex/tree/master/regex-automata","documentation":"https://docs.rs/regex-automata","edition":"2021","links":null,"default_run":null,"rust_version":"1.65"},{"name":"regex-syntax","version":"0.8.8","id":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8","license":"MIT OR Apache-2.0","license_file":null,"description":"A regular expression parser.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.3.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["derive"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"regex_syntax","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-syntax-0.8.8\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-syntax-0.8.8\\benches\\bench.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"arbitrary":["dep:arbitrary"],"default":["std","unicode"],"std":[],"unicode":["unicode-age","unicode-bool","unicode-case","unicode-gencat","unicode-perl","unicode-script","unicode-segment"],"unicode-age":[],"unicode-bool":[],"unicode-case":[],"unicode-gencat":[],"unicode-perl":[],"unicode-script":[],"unicode-segment":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\regex-syntax-0.8.8\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs_regex"]}}},"publish":null,"authors":["The Rust Project Developers","Andrew Gallant <jamslam@gmail.com>"],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/rust-lang/regex","homepage":"https://github.com/rust-lang/regex/tree/master/regex-syntax","documentation":"https://docs.rs/regex-syntax","edition":"2021","links":null,"default_run":null,"rust_version":"1.65"},{"name":"rustversion","version":"1.0.22","id":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","license":"MIT OR Apache-2.0","license_file":null,"description":"Conditional compilation according to rustc compiler version","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"trybuild","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.49","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["diff"],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"rustversion","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"compiletest","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\tests\\compiletest.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_const","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\tests\\test_const.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_eval","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\tests\\test_eval.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_parse","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\tests\\test_parse.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\build\\build.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org","--extern-html-root-url=proc_macro=https://doc.rust-lang.org"]}}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":["development-tools::build-utils","no-std","no-std::no-alloc"],"keywords":[],"readme":"README.md","repository":"https://github.com/dtolnay/rustversion","homepage":null,"documentation":"https://docs.rs/rustversion","edition":"2018","links":null,"default_run":null,"rust_version":"1.31"},{"name":"scopeguard","version":"1.2.0","id":"registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0","license":"MIT OR Apache-2.0","license_file":null,"description":"A RAII scope guard that will run a given closure when it goes out of scope,\neven if the code between panics (assuming unwinding panic).\n\nDefines the macros `defer!`, `defer_on_unwind!`, `defer_on_success!` as\nshorthands for guards with one of the implemented strategies.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"scopeguard","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"readme","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\examples\\readme.rs","edition":"2015","doc":false,"doctest":false,"test":false}],"features":{"default":["use_std"],"use_std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\Cargo.toml","metadata":{"release":{"no-dev-version":true}},"publish":null,"authors":["bluss"],"categories":["rust-patterns","no-std"],"keywords":["scope-guard","defer","panic","unwind"],"readme":"README.md","repository":"https://github.com/bluss/scopeguard","homepage":null,"documentation":"https://docs.rs/scopeguard/","edition":"2015","links":null,"default_run":null,"rust_version":null},{"name":"serde","version":"1.0.228","id":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","license":"MIT OR Apache-2.0","license_file":null,"description":"A generic serialization/deserialization framework","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=1.0.228","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["result"],"target":null,"registry":null},{"name":"serde_derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"alloc":["serde_core/alloc"],"default":["std"],"derive":["serde_derive"],"rc":["serde_core/rc"],"serde_derive":["dep:serde_derive"],"std":["serde_core/std"],"unstable":["serde_core/unstable"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\Cargo.toml","metadata":{"playground":{"features":["derive","rc"]},"docs":{"rs":{"features":["derive","rc","unstable"],"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org"]}}},"publish":null,"authors":["Erick Tryzelaar <erick.tryzelaar@gmail.com>","David Tolnay <dtolnay@gmail.com>"],"categories":["encoding","no-std","no-std::no-alloc"],"keywords":["serde","serialization","no_std"],"readme":"crates-io.md","repository":"https://github.com/serde-rs/serde","homepage":"https://serde.rs","documentation":"https://docs.rs/serde","edition":"2021","links":null,"default_run":null,"rust_version":"1.56"},{"name":"serde_core","version":"1.0.228","id":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","license":"MIT OR Apache-2.0","license_file":null,"description":"Serde traits only, with no support for derive -- use the `serde` crate instead","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=1.0.228","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(any())","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"serde_core","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"alloc":[],"default":["std","result"],"rc":[],"result":[],"std":[],"unstable":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\Cargo.toml","metadata":{"playground":{"features":["rc","result"]},"docs":{"rs":{"features":["rc","result","unstable"],"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org"]}}},"publish":null,"authors":["Erick Tryzelaar <erick.tryzelaar@gmail.com>","David Tolnay <dtolnay@gmail.com>"],"categories":["encoding","no-std","no-std::no-alloc"],"keywords":["serde","serialization","no_std"],"readme":"README.md","repository":"https://github.com/serde-rs/serde","homepage":"https://serde.rs","documentation":"https://docs.rs/serde_core","edition":"2021","links":null,"default_run":null,"rust_version":"1.56"},{"name":"serde_derive","version":"1.0.228","id":"registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228","license":"MIT OR Apache-2.0","license_file":null,"description":"Macros 1.1 implementation of #[derive(Serialize, Deserialize)]","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.74","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["proc-macro"],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.35","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["proc-macro"],"target":null,"registry":null},{"name":"syn","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.0.81","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["clone-impls","derive","parsing","printing","proc-macro"],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"serde_derive","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"default":[],"deserialize_in_place":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org","--extern-html-root-url=proc_macro=https://doc.rust-lang.org"]}}},"publish":null,"authors":["Erick Tryzelaar <erick.tryzelaar@gmail.com>","David Tolnay <dtolnay@gmail.com>"],"categories":["no-std","no-std::no-alloc"],"keywords":["serde","serialization","no_std","derive"],"readme":"crates-io.md","repository":"https://github.com/serde-rs/serde","homepage":"https://serde.rs","documentation":"https://serde.rs/derive.html","edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"serde_spanned","version":"1.0.3","id":"registry+https://github.com/rust-lang/crates.io-index#serde_spanned@1.0.3","license":"MIT OR Apache-2.0","license_file":null,"description":"Serde-compatible spanned Value","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.225","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde-untagged","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"serde_spanned","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_spanned-1.0.3\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"alloc":["serde_core?/alloc"],"default":["std","serde"],"serde":["dep:serde_core"],"std":["alloc","serde_core?/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_spanned-1.0.3\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/toml-rs/toml/compare/{{tag_name}}...HEAD","exactly":1}]}},"publish":null,"authors":[],"categories":["encoding","parser-implementations","parsing","config"],"keywords":["serde","span"],"readme":"README.md","repository":"https://github.com/toml-rs/toml","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.76"},{"name":"smallvec","version":"1.15.1","id":"registry+https://github.com/rust-lang/crates.io-index#smallvec@1.15.1","license":"MIT OR Apache-2.0","license_file":null,"description":"'Small vector' optimization: store up to a small number of items on the stack","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"arbitrary","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"bincode","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"malloc_size_of","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"unty","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.0.4","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"bincode","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.1","kind":"dev","rename":"bincode1","optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"debugger_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"debugger_test_parser","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"smallvec","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\smallvec-1.15.1\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"debugger_visualizer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\smallvec-1.15.1\\tests\\debugger_visualizer.rs","edition":"2018","required-features":["debugger_visualizer"],"doc":false,"doctest":false,"test":false},{"kind":["test"],"crate_types":["bin"],"name":"macro","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\smallvec-1.15.1\\tests\\macro.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"bench","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\smallvec-1.15.1\\benches\\bench.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"arbitrary":["dep:arbitrary"],"bincode":["dep:bincode"],"const_generics":[],"const_new":["const_generics"],"debugger_visualizer":[],"drain_filter":[],"drain_keep_rest":["drain_filter"],"impl_bincode":["bincode","unty"],"malloc_size_of":["dep:malloc_size_of"],"may_dangle":[],"serde":["dep:serde"],"specialization":[],"union":[],"unty":["dep:unty"],"write":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\smallvec-1.15.1\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs","--generate-link-to-definition"]}}},"publish":null,"authors":["The Servo Project Developers"],"categories":["data-structures"],"keywords":["small","vec","vector","stack","no_std"],"readme":"README.md","repository":"https://github.com/servo/rust-smallvec","homepage":null,"documentation":"https://docs.rs/smallvec/","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"spin","version":"0.9.8","id":"registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8","license":"MIT","license_file":null,"description":"Spin-based synchronization primitives","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"lock_api","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":null,"rename":"lock_api_crate","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"portable-atomic","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"spin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"debug","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\examples\\debug.rs","edition":"2015","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"mutex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\benches\\mutex.rs","edition":"2015","required-features":["ticket_mutex"],"doc":false,"doctest":false,"test":false}],"features":{"barrier":["mutex"],"default":["lock_api","mutex","spin_mutex","rwlock","once","lazy","barrier"],"fair_mutex":["mutex"],"lazy":["once"],"lock_api":["lock_api_crate"],"lock_api_crate":["dep:lock_api_crate"],"mutex":[],"once":[],"portable-atomic":["dep:portable-atomic"],"portable_atomic":["portable-atomic"],"rwlock":[],"spin_mutex":["mutex"],"std":[],"ticket_mutex":["mutex"],"use_ticket_mutex":["mutex","ticket_mutex"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":["Mathijs van de Nes <git@mathijs.vd-nes.nl>","John Ericson <git@JohnEricson.me>","Joshua Barretto <joshua.s.barretto@gmail.com>"],"categories":[],"keywords":["spinlock","mutex","rwlock"],"readme":"README.md","repository":"https://github.com/mvdnes/spin-rs.git","homepage":null,"documentation":null,"edition":"2015","links":null,"default_run":null,"rust_version":"1.38"},{"name":"ssxl_cli","version":"0.1.0","id":"path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_cli#0.1.0","license":null,"license_file":null,"description":null,"source":null,"dependencies":[{"name":"flume","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.12","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"ssxl_ext","source":null,"req":"*","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null,"path":"C:\\zv9\\zv9.SSXL-ext\\rust\\ssxl_ext"}],"targets":[{"kind":["bin"],"crate_types":["bin"],"name":"ssxl_cli","src_path":"C:\\zv9\\zv9.SSXL-ext\\rust\\ssxl_cli\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true}],"features":{},"manifest_path":"C:\\zv9\\zv9.SSXL-ext\\rust\\ssxl_cli\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":[],"keywords":[],"readme":null,"repository":null,"homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":null},{"name":"ssxl_ext","version":"0.9.1","id":"path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1","license":null,"license_file":null,"description":null,"source":null,"dependencies":[{"name":"dashmap","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^6.1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"flume","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.12","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"godot","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.4","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["serde"],"target":null,"registry":null},{"name":"noise","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"once_cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.21.3","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.11","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.228","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"thiserror","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.0.17","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.48","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["rt","macros","sync"],"target":null,"registry":null},{"name":"toml","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9.8","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["cdylib"],"crate_types":["cdylib"],"name":"ssxl_ext","src_path":"C:\\zv9\\zv9.SSXL-ext\\rust\\ssxl_ext\\src\\lib.rs","edition":"2021","doc":true,"doctest":false,"test":true}],"features":{},"manifest_path":"C:\\zv9\\zv9.SSXL-ext\\rust\\ssxl_ext\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":[],"keywords":[],"readme":null,"repository":null,"homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":null},{"name":"syn","version":"2.0.111","id":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","license":"MIT OR Apache-2.0","license_file":null,"description":"Parser for Rust source code","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.91","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.35","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"unicode-ident","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anyhow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"automod","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"insta","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"ref-cast","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"syn-test-suite","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"termcolor","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"flate2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(miri))","registry":null},{"name":"rayon","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(miri))","registry":null},{"name":"reqwest","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.12","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["blocking"],"target":"cfg(not(miri))","registry":null},{"name":"tar","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.16","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(miri))","registry":null},{"name":"walkdir","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.3.2","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(miri))","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"syn","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"regression","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\regression.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_asyncness","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_asyncness.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_attribute","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_attribute.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_derive_input","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_derive_input.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_expr","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_expr.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_generics","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_generics.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_grouping","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_grouping.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_ident","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_ident.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_item","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_item.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_lit","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_lit.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_meta","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_meta.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_parse_buffer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_parse_buffer.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_parse_quote","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_parse_quote.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_parse_stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_parse_stream.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_pat","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_pat.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_path","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_path.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_precedence","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_precedence.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_punctuated","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_punctuated.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_receiver","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_receiver.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_round_trip","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_round_trip.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_shebang","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_shebang.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_size","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_size.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_stmt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_stmt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_token_trees","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_token_trees.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_ty","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_ty.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_unparenthesize","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_unparenthesize.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_visibility","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\test_visibility.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"zzz_stable","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\tests\\zzz_stable.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"file","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\benches\\file.rs","edition":"2021","required-features":["full","parsing"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"rust","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\benches\\rust.rs","edition":"2021","required-features":["full","parsing"],"doc":false,"doctest":false,"test":false}],"features":{"clone-impls":[],"default":["derive","parsing","printing","clone-impls","proc-macro"],"derive":[],"extra-traits":[],"fold":[],"full":[],"parsing":[],"printing":["dep:quote"],"proc-macro":["proc-macro2/proc-macro","quote?/proc-macro"],"test":["syn-test-suite/all-features"],"visit":[],"visit-mut":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.111\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extend-css=src/gen/token.css","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org","--extern-html-root-url=proc_macro=https://doc.rust-lang.org"]}},"playground":{"features":["full","visit","visit-mut","fold","extra-traits"]}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":["development-tools::procedural-macro-helpers","parser-implementations"],"keywords":["macros","syn"],"readme":"README.md","repository":"https://github.com/dtolnay/syn","homepage":null,"documentation":"https://docs.rs/syn","edition":"2021","links":null,"default_run":null,"rust_version":"1.68"},{"name":"thiserror","version":"2.0.17","id":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","license":"MIT OR Apache-2.0","license_file":null,"description":"derive(Error)","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"thiserror-impl","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=2.0.17","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anyhow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.73","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"ref-cast","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.18","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.13","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"trybuild","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.108","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["diff"],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"thiserror","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"compiletest","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\compiletest.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_backtrace","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_backtrace.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_display","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_display.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_error","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_error.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_expr","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_expr.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_from","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_from.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_generics","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_generics.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_lints","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_lints.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_option","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_option.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_path","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_path.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_source","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_source.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_transparent","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\tests\\test_transparent.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-2.0.17\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org"]}}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":["rust-patterns","no-std"],"keywords":["error","error-handling","derive"],"readme":"README.md","repository":"https://github.com/dtolnay/thiserror","homepage":null,"documentation":"https://docs.rs/thiserror","edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"thiserror-impl","version":"2.0.17","id":"registry+https://github.com/rust-lang/crates.io-index#thiserror-impl@2.0.17","license":"MIT OR Apache-2.0","license_file":null,"description":"Implementation detail of the `thiserror` crate","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.74","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.35","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"syn","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.0.87","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"thiserror_impl","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-impl-2.0.17\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\thiserror-impl-2.0.17\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org","--extern-html-root-url=proc_macro=https://doc.rust-lang.org"]}}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":[],"keywords":[],"readme":null,"repository":"https://github.com/dtolnay/thiserror","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.61"},{"name":"tokio","version":"1.48.0","id":"registry+https://github.com/rust-lang/crates.io-index#tokio@1.48.0","license":"MIT","license_file":null,"description":"An event-driven, non-blocking I/O platform for writing asynchronous I/O\nbacked applications.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"bytes","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.2.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"mio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"parking_lot","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.12.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"pin-project-lite","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.11","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio-macros","source":"registry+https://github.com/rust-lang/crates.io-index","req":"~2.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"async-stream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"futures","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["async-await"],"target":null,"registry":null},{"name":"futures-concurrency","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^7.6.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"mockall","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.13.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio-stream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"tokio-util","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["rt"],"target":null,"registry":null},{"name":"wasm-bindgen-test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(all(target_family = \"wasm\", not(target_os = \"wasi\")))","registry":null},{"name":"tracing-mock","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.1.0-beta.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(all(tokio_unstable, target_has_atomic = \"64\"))","registry":null},{"name":"backtrace","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.58","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(all(tokio_unstable, target_os = \"linux\"))","registry":null},{"name":"io-uring","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.6","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":"cfg(all(tokio_unstable, target_os = \"linux\"))","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.168","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(all(tokio_unstable, target_os = \"linux\"))","registry":null},{"name":"mio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.1","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["os-poll","os-ext"],"target":"cfg(all(tokio_unstable, target_os = \"linux\"))","registry":null},{"name":"slab","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.9","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(all(tokio_unstable, target_os = \"linux\"))","registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["futures","checkpoint"],"target":"cfg(loom)","registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(all(target_family = \"wasm\", target_os = \"unknown\")))","registry":null},{"name":"socket2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":["all"],"target":"cfg(not(target_family = \"wasm\"))","registry":null},{"name":"proptest","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(target_family = \"wasm\"))","registry":null},{"name":"socket2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(target_family = \"wasm\"))","registry":null},{"name":"tempfile","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^3.1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(not(target_family = \"wasm\"))","registry":null},{"name":"mio-aio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["tokio"],"target":"cfg(target_os = \"freebsd\")","registry":null},{"name":"tracing","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.29","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["std"],"target":"cfg(tokio_unstable)","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.168","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null},{"name":"signal-hook-registry","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.1.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null},{"name":"libc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.168","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(unix)","registry":null},{"name":"nix","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.29.0","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":["aio","fs","socket"],"target":"cfg(unix)","registry":null},{"name":"windows-sys","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.61","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":"cfg(windows)","registry":null},{"name":"windows-sys","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.61","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["Win32_Foundation","Win32_Security_Authorization"],"target":"cfg(windows)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"tokio","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"_require_full","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\_require_full.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"async_send_sync","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\async_send_sync.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"buffered","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\buffered.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"coop_budget","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\coop_budget.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"dump","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\dump.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"duplex_stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\duplex_stream.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_canonicalize_dir","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_canonicalize_dir.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_copy","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_copy.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_dir","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_dir.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_file","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_file.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_link","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_link.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_open_options","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_open_options.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_open_options_windows","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_open_options_windows.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_remove_dir_all","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_remove_dir_all.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_remove_file","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_remove_file.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_rename","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_rename.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_symlink_dir_windows","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_symlink_dir_windows.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_symlink_file_windows","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_symlink_file_windows.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_try_exists","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_try_exists.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_uring","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_uring.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"fs_write","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\fs_write.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_async_fd","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_async_fd.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_async_read","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_async_read.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_buf_reader","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_buf_reader.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_buf_writer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_buf_writer.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_chain","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_chain.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_copy","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_copy.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_copy_bidirectional","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_copy_bidirectional.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_driver","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_driver.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_driver_drop","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_driver_drop.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_fill_buf","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_fill_buf.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_join","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_join.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_lines","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_lines.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_mem_stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_mem_stream.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_poll_aio","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_poll_aio.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_buf","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_buf.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_exact","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_exact.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_line","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_line.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_to_end","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_to_end.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_to_string","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_to_string.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_read_until","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_read_until.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_repeat","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_repeat.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_sink","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_sink.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_split","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_split.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_take","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_take.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_util_empty","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_util_empty.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_write","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_write.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_write_all","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_write_all.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_write_all_buf","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_write_all_buf.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_write_buf","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_write_buf.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"io_write_int","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\io_write_int.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"join_handle_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\join_handle_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_join","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_join.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_pin","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_pin.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_rename_test","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_rename_test.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_select","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_select.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_test","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_test.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"macros_try_join","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\macros_try_join.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_bind_resource","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_bind_resource.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_lookup_host","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_lookup_host.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_named_pipe","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_named_pipe.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_quickack","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_quickack.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"net_unix_pipe","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\net_unix_pipe.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"no_rt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\no_rt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_arg0","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_arg0.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_change_of_runtime","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_change_of_runtime.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_issue_2174","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_issue_2174.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_issue_42","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_issue_42.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_issue_7144","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_issue_7144.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_kill_after_wait","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_kill_after_wait.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_kill_on_drop","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_kill_on_drop.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_raw_handle","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_raw_handle.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"process_smoke","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\process_smoke.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_basic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_basic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_common","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_common.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_handle","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_handle.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_handle_block_on","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_handle_block_on.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_local","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_local.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_metrics","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_metrics.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_poll_callbacks","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_poll_callbacks.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_threaded","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_threaded.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_time_start_paused","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_time_start_paused.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"rt_unstable_metrics","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\rt_unstable_metrics.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_ctrl_c","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_ctrl_c.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_drop_recv","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_drop_recv.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_drop_rt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_drop_rt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_drop_signal","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_drop_signal.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_info","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_info.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_multi_rt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_multi_rt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_no_rt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_no_rt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_notify_both","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_notify_both.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_realtime","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_realtime.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_twice","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_twice.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"signal_usr1","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\signal_usr1.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_barrier","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_barrier.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_broadcast","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_broadcast.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_broadcast_weak","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_broadcast_weak.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_errors","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_errors.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_mpsc","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_mpsc.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_mpsc_weak","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_mpsc_weak.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_mutex","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_mutex.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_mutex_owned","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_mutex_owned.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_notify","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_notify.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_notify_owned","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_notify_owned.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_once_cell","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_once_cell.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_oneshot","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_oneshot.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_rwlock","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_rwlock.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_semaphore","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_semaphore.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_semaphore_owned","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_semaphore_owned.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_set_once","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_set_once.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"sync_watch","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\sync_watch.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_abort","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_abort.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_blocking","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_blocking.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_builder","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_builder.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_hooks","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_hooks.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_id","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_id.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_join_set","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_join_set.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_local","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_local.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_local_set","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_local_set.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_trace_self","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_trace_self.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"task_yield_now","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\task_yield_now.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_accept","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_accept.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_connect","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_connect.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_echo","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_echo.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_into_split","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_into_split.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_into_std","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_into_std.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_peek","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_peek.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_shutdown","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_shutdown.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_socket","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_socket.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_split","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_split.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tcp_stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tcp_stream.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_clock","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\test_clock.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_interval","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_interval.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_panic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_panic.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_pause","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_pause.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_rt","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_rt.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_sleep","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_sleep.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_timeout","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_timeout.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"time_wasm","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\time_wasm.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tracing_sync","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tracing_sync.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tracing_task","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tracing_task.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"tracing_time","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\tracing_time.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"udp","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\udp.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"uds_cred","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\uds_cred.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"uds_datagram","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\uds_datagram.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"uds_socket","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\uds_socket.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"uds_split","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\uds_split.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"uds_stream","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\uds_stream.rs","edition":"2021","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"unwindsafe","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\tests\\unwindsafe.rs","edition":"2021","doc":false,"doctest":false,"test":true}],"features":{"bytes":["dep:bytes"],"default":[],"fs":[],"full":["fs","io-util","io-std","macros","net","parking_lot","process","rt","rt-multi-thread","signal","sync","time"],"io-std":[],"io-uring":["dep:io-uring","libc","mio/os-poll","mio/os-ext","dep:slab"],"io-util":["bytes"],"libc":["dep:libc"],"macros":["tokio-macros"],"mio":["dep:mio"],"net":["libc","mio/os-poll","mio/os-ext","mio/net","socket2","windows-sys/Win32_Foundation","windows-sys/Win32_Security","windows-sys/Win32_Storage_FileSystem","windows-sys/Win32_System_Pipes","windows-sys/Win32_System_SystemServices"],"parking_lot":["dep:parking_lot"],"process":["bytes","libc","mio/os-poll","mio/os-ext","mio/net","signal-hook-registry","windows-sys/Win32_Foundation","windows-sys/Win32_System_Threading","windows-sys/Win32_System_WindowsProgramming"],"rt":[],"rt-multi-thread":["rt"],"signal":["libc","mio/os-poll","mio/net","mio/os-ext","signal-hook-registry","windows-sys/Win32_Foundation","windows-sys/Win32_System_Console"],"signal-hook-registry":["dep:signal-hook-registry"],"socket2":["dep:socket2"],"sync":[],"taskdump":["dep:backtrace"],"test-util":["rt","sync","time"],"time":[],"tokio-macros":["dep:tokio-macros"],"tracing":["dep:tracing"],"windows-sys":["dep:windows-sys"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-1.48.0\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--cfg","docsrs","--cfg","tokio_unstable"],"rustc-args":["--cfg","tokio_unstable"]}},"playground":{"features":["full","test-util"]},"cargo_check_external_types":{"allowed_external_types":["bytes::buf::buf_impl::Buf","bytes::buf::buf_mut::BufMut","tokio_macros::*"]}},"publish":null,"authors":["Tokio Contributors <team@tokio.rs>"],"categories":["asynchronous","network-programming"],"keywords":["io","async","non-blocking","futures"],"readme":"README.md","repository":"https://github.com/tokio-rs/tokio","homepage":"https://tokio.rs","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"tokio-macros","version":"2.6.0","id":"registry+https://github.com/rust-lang/crates.io-index#tokio-macros@2.6.0","license":"MIT","license_file":null,"description":"Tokio's proc macros.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.60","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"syn","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["full"],"target":null,"registry":null},{"name":"tokio","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["full"],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"tokio_macros","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-macros-2.6.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\tokio-macros-2.6.0\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true}}},"publish":null,"authors":["Tokio Contributors <team@tokio.rs>"],"categories":["asynchronous"],"keywords":[],"readme":"README.md","repository":"https://github.com/tokio-rs/tokio","homepage":"https://tokio.rs","documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"toml","version":"0.9.8","id":"registry+https://github.com/rust-lang/crates.io-index#toml@0.9.8","license":"MIT OR Apache-2.0","license_file":null,"description":"A native Rust encoder and decoder of TOML-formatted files and streams. Provides\nimplementations of the standard Serialize/Deserialize traits for TOML data to\nfacilitate deserializing and serializing Rust structures.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"anstream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.20","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anstyle","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.11","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"foldhash","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.0","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"indexmap","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.11.4","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.225","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"serde_spanned","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.3","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"toml_datetime","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.3","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"toml_parser","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.4","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"toml_writer","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.4","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"winnow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.13","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"itertools","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.14.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.225","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["derive"],"target":null,"registry":null},{"name":"serde-untagged","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1.9","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.145","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"snapbox","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.21","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"toml-test-data","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.3.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"toml-test-harness","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.3.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["snapshot"],"target":null,"registry":null},{"name":"walkdir","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.5.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"toml","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml-0.9.8\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"decode","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml-0.9.8\\examples\\decode.rs","edition":"2021","required-features":["parse","display","serde"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"enum_external","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml-0.9.8\\examples\\enum_external.rs","edition":"2021","required-features":["parse","display","serde"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"toml2json","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml-0.9.8\\examples\\toml2json.rs","edition":"2021","required-features":["parse","display","serde"],"doc":false,"doctest":false,"test":false}],"features":{"debug":["std","toml_parser?/debug","dep:anstream","dep:anstyle"],"default":["std","serde","parse","display"],"display":["dep:toml_writer"],"fast_hash":["preserve_order","dep:foldhash"],"parse":["dep:toml_parser","dep:winnow"],"preserve_order":["dep:indexmap","std"],"serde":["dep:serde_core","toml_datetime/serde","serde_spanned/serde"],"std":["indexmap?/std","serde_core?/std","toml_parser?/std","toml_writer?/std","toml_datetime/std","serde_spanned/std"],"unbounded":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml-0.9.8\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/toml-rs/toml/compare/{{tag_name}}...HEAD","exactly":1}]}},"publish":null,"authors":[],"categories":["encoding","parser-implementations","parsing","config"],"keywords":["encoding","toml","no_std"],"readme":"README.md","repository":"https://github.com/toml-rs/toml","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.76"},{"name":"toml_datetime","version":"0.7.3","id":"registry+https://github.com/rust-lang/crates.io-index#toml_datetime@0.7.3","license":"MIT OR Apache-2.0","license_file":null,"description":"A TOML-compatible datetime type","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde_core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.225","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"snapbox","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.21","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"toml_datetime","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_datetime-0.7.3\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"alloc":["serde_core?/alloc"],"default":["std"],"serde":["dep:serde_core"],"std":["alloc","serde_core?/std"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_datetime-0.7.3\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/toml-rs/toml/compare/{{tag_name}}...HEAD","exactly":1}]}},"publish":null,"authors":[],"categories":["encoding","parser-implementations","parsing","config"],"keywords":["encoding","toml","no_std"],"readme":"README.md","repository":"https://github.com/toml-rs/toml","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.76"},{"name":"toml_parser","version":"1.0.4","id":"registry+https://github.com/rust-lang/crates.io-index#toml_parser@1.0.4","license":"MIT OR Apache-2.0","license_file":null,"description":"Yet another format-preserving TOML parser.","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"anstream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.20","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anstyle","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.11","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"winnow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7.13","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"anstream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.20","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["test"],"target":null,"registry":null},{"name":"snapbox","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.21","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"toml_parser","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_parser-1.0.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"debug":["std","dep:anstream","dep:anstyle"],"default":["std"],"simd":["winnow/simd"],"std":["alloc"],"unsafe":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_parser-1.0.4\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/toml-rs/toml/compare/{{tag_name}}...HEAD","exactly":1}]}},"publish":null,"authors":[],"categories":["encoding","parser-implementations","parsing","config"],"keywords":["encoding","toml","no_std"],"readme":"README.md","repository":"https://github.com/toml-rs/toml","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.76"},{"name":"toml_writer","version":"1.0.4","id":"registry+https://github.com/rust-lang/crates.io-index#toml_writer@1.0.4","license":"MIT OR Apache-2.0","license_file":null,"description":"A low-level interface for writing out TOML\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proptest","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.7.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"snapbox","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.21","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"toml","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.11","kind":"dev","rename":"toml_old","optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"toml_writer","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_writer-1.0.4\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"alloc":[],"default":["std"],"std":["alloc"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\toml_writer-1.0.4\\Cargo.toml","metadata":{"docs":{"rs":{"all-features":true,"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/toml-rs/toml/compare/{{tag_name}}...HEAD","exactly":1}]}},"publish":null,"authors":[],"categories":["encoding"],"keywords":["encoding","toml","no_std"],"readme":"README.md","repository":"https://github.com/toml-rs/toml","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.76"},{"name":"unicode-ident","version":"1.0.22","id":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","license":"(MIT OR Apache-2.0) AND Unicode-3.0","license_file":null,"description":"Determine whether characters have the XID_Start or XID_Continue properties according to Unicode Standard Annex #31","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.7","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"fst","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rand","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.9","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"roaring","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.11","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"ucd-trie","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.1","kind":"dev","rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"unicode-xid","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.6","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"unicode_ident","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.22\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"compare","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.22\\tests\\compare.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"static_size","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.22\\tests\\static_size.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"xid","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.22\\benches\\xid.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.22\\Cargo.toml","metadata":{"docs":{"rs":{"targets":["x86_64-unknown-linux-gnu"],"rustdoc-args":["--generate-link-to-definition","--generate-macro-expansion","--extern-html-root-url=core=https://doc.rust-lang.org","--extern-html-root-url=alloc=https://doc.rust-lang.org","--extern-html-root-url=std=https://doc.rust-lang.org"]}}},"publish":null,"authors":["David Tolnay <dtolnay@gmail.com>"],"categories":["development-tools::procedural-macro-helpers","no-std","no-std::no-alloc"],"keywords":["unicode","xid"],"readme":"README.md","repository":"https://github.com/dtolnay/unicode-ident","homepage":null,"documentation":"https://docs.rs/unicode-ident","edition":"2018","links":null,"default_run":null,"rust_version":"1.31"},{"name":"venial","version":"0.6.1","id":"registry+https://github.com/rust-lang/crates.io-index#venial@0.6.1","license":"MIT","license_file":null,"description":"A very small syn","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.36","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.15","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"insta","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.12.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"similar-asserts","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.2.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"venial","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\venial-0.6.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\venial-0.6.1\\Cargo.toml","metadata":null,"publish":null,"authors":["Olivier Faure <olivier.cj.faure@gmail.com>"],"categories":["development-tools::procedural-macro-helpers"],"keywords":["syn","parsing","proc-macro","small","derive"],"readme":"README.md","repository":"https://github.com/PoignardAzur/venial","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":null},{"name":"wasi","version":"0.11.1+wasi-snapshot-preview1","id":"registry+https://github.com/rust-lang/crates.io-index#wasi@0.11.1+wasi-snapshot-preview1","license":"Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT","license_file":null,"description":"Experimental WASI API bindings for Rust","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"rustc-std-workspace-core","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":"core","optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustc-std-workspace-alloc","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"wasi","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasi-0.11.1+wasi-snapshot-preview1\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"core":["dep:core"],"default":["std"],"rustc-dep-of-std":["core","rustc-std-workspace-alloc"],"rustc-std-workspace-alloc":["dep:rustc-std-workspace-alloc"],"std":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasi-0.11.1+wasi-snapshot-preview1\\Cargo.toml","metadata":null,"publish":null,"authors":["The Cranelift Project Developers"],"categories":["no-std","wasm"],"keywords":["webassembly","wasm"],"readme":"README.md","repository":"https://github.com/bytecodealliance/wasi","homepage":null,"documentation":"https://docs.rs/wasi","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"wasm-bindgen","version":"0.2.106","id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106","license":"MIT OR Apache-2.0","license_file":null,"description":"Easy support for interacting between JS and Rust.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"cfg-if","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"once_cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.12","kind":null,"rename":null,"optional":false,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde_json","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wasm-bindgen-macro","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.106","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wasm-bindgen-shared","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.106","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"once_cell","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustversion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"build","rename":"rustversion-compat","optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"paste","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(target_arch = \"wasm32\")","registry":null},{"name":"serde_derive","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(target_arch = \"wasm32\")","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"wasm_bindgen","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-0.2.106\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":false},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-0.2.106\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"enable-interning":["std"],"gg-alloc":[],"msrv":[],"rustversion":[],"serde":["dep:serde"],"serde-serialize":["serde","serde_json","std"],"serde_json":["dep:serde_json"],"spans":[],"std":[],"strict-macro":["wasm-bindgen-macro/strict-macro"],"xxx_debug_only_print_generated_code":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-0.2.106\\Cargo.toml","metadata":{"docs":{"rs":{"features":["serde-serialize"]}}},"publish":null,"authors":["The wasm-bindgen Developers"],"categories":["wasm"],"keywords":[],"readme":"README.md","repository":"https://github.com/wasm-bindgen/wasm-bindgen","homepage":"https://wasm-bindgen.github.io/wasm-bindgen","documentation":"https://docs.rs/wasm-bindgen","edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"wasm-bindgen-macro","version":"0.2.106","id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro@0.2.106","license":"MIT OR Apache-2.0","license_file":null,"description":"Definition of the `#[wasm_bindgen]` attribute, an internal dependency\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"wasm-bindgen-macro-support","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.106","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"trybuild","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"wasm_bindgen_macro","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-macro-0.2.106\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"strict-macro":["wasm-bindgen-macro-support/strict-macro"]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-macro-0.2.106\\Cargo.toml","metadata":null,"publish":null,"authors":["The wasm-bindgen Developers"],"categories":[],"keywords":[],"readme":"README.md","repository":"https://github.com/wasm-bindgen/wasm-bindgen/tree/master/crates/macro","homepage":"https://wasm-bindgen.github.io/wasm-bindgen/","documentation":"https://docs.rs/wasm-bindgen","edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"wasm-bindgen-macro-support","version":"0.2.106","id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro-support@0.2.106","license":"MIT OR Apache-2.0","license_file":null,"description":"Implementation APIs for the `#[wasm_bindgen]` attribute","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"bumpalo","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^3.0.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"proc-macro2","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"quote","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"syn","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":["visit","visit-mut","full"],"target":null,"registry":null},{"name":"wasm-bindgen-shared","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.2.106","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"wasm_bindgen_macro_support","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-macro-support-0.2.106\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{"extra-traits":["syn/extra-traits"],"strict-macro":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-macro-support-0.2.106\\Cargo.toml","metadata":null,"publish":null,"authors":["The wasm-bindgen Developers"],"categories":[],"keywords":[],"readme":null,"repository":"https://github.com/wasm-bindgen/wasm-bindgen/tree/master/crates/macro-support","homepage":"https://wasm-bindgen.github.io/wasm-bindgen/","documentation":"https://docs.rs/wasm-bindgen","edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"wasm-bindgen-shared","version":"0.2.106","id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106","license":"MIT OR Apache-2.0","license_file":null,"description":"Shared support between wasm-bindgen and wasm-bindgen cli, an internal\ndependency.\n","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"unicode-ident","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.5","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"wasm_bindgen_shared","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-shared-0.2.106\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-shared-0.2.106\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wasm-bindgen-shared-0.2.106\\Cargo.toml","metadata":null,"publish":null,"authors":["The wasm-bindgen Developers"],"categories":[],"keywords":[],"readme":null,"repository":"https://github.com/wasm-bindgen/wasm-bindgen/tree/master/crates/shared","homepage":"https://wasm-bindgen.github.io/wasm-bindgen/","documentation":"https://docs.rs/wasm-bindgen-shared","edition":"2021","links":"wasm_bindgen","default_run":null,"rust_version":"1.71"},{"name":"windows-link","version":"0.2.1","id":"registry+https://github.com/rust-lang/crates.io-index#windows-link@0.2.1","license":"MIT OR Apache-2.0","license_file":null,"description":"Linking for Windows","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"windows_link","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-link-0.2.1\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-link-0.2.1\\Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":["os::windows-apis"],"keywords":[],"readme":"readme.md","repository":"https://github.com/microsoft/windows-rs","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.71"},{"name":"winnow","version":"0.7.14","id":"registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14","license":"MIT","license_file":null,"description":"A byte-oriented, zero-copy, parser combinators library","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"anstream","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.15","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anstyle","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.8","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"is_terminal_polyfill","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.48.1","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"memchr","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.7","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":[],"target":null,"registry":null},{"name":"terminal_size","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.4.3","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"annotate-snippets","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.11.4","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"anyhow","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.100","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"automod","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.15","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"circular","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"criterion","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"lexopt","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"proptest","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.6.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"rustc-hash","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^2.1.1","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"snapbox","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.6.21","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":["examples"],"target":null,"registry":null},{"name":"term-transcript","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.2.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"winnow","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"arithmetic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\arithmetic\\main.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"c_expression","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\c_expression\\main.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"css","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\css\\main.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"custom_error","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\custom_error.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"http","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\http\\main.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"ini","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\ini\\main.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"iterator","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\iterator.rs","edition":"2021","doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"json","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\json\\main.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"json_iterator","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\json_iterator.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"ndjson","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\ndjson\\main.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":true},{"kind":["example"],"crate_types":["bin"],"name":"s_expression","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\s_expression\\main.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":false},{"kind":["example"],"crate_types":["bin"],"name":"string","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\string\\main.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"arithmetic","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\arithmetic\\bench.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"c_expression","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\c_expression\\bench.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"http","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\http\\bench.rs","edition":"2021","required-features":["alloc"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"ini","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\ini\\bench.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"json","src_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\examples\\json\\bench.rs","edition":"2021","required-features":["std"],"doc":false,"doctest":false,"test":false}],"features":{"alloc":[],"debug":["std","dep:anstream","dep:anstyle","dep:is_terminal_polyfill","dep:terminal_size"],"default":["std"],"simd":["dep:memchr"],"std":["alloc","memchr?/std"],"unstable-doc":["alloc","std","simd","unstable-recover"],"unstable-recover":[]},"manifest_path":"C:\\Users\\grego\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\winnow-0.7.14\\Cargo.toml","metadata":{"docs":{"rs":{"features":["unstable-doc"],"rustdoc-args":["--generate-link-to-definition"]}},"release":{"pre-release-replacements":[{"file":"CHANGELOG.md","search":"Unreleased","replace":"{{version}}","min":1},{"file":"CHANGELOG.md","search":"\\.\\.\\.HEAD","replace":"...{{tag_name}}","exactly":1},{"file":"CHANGELOG.md","search":"ReleaseDate","replace":"{{date}}","min":1},{"file":"CHANGELOG.md","search":"<!-- next-header -->","replace":"<!-- next-header -->\n## [Unreleased] - ReleaseDate\n","exactly":1},{"file":"CHANGELOG.md","search":"<!-- next-url -->","replace":"<!-- next-url -->\n[Unreleased]: https://github.com/winnow-rs/winnow/compare/{{tag_name}}...HEAD","exactly":1},{"file":"src/lib.rs","search":"blob/v.+\\..+\\..+/CHANGELOG.md","replace":"blob/v{{version}}/CHANGELOG.md","exactly":1}]}},"publish":null,"authors":[],"categories":["parsing"],"keywords":["parser","parser-combinators","parsing","streaming","bit"],"readme":"README.md","repository":"https://github.com/winnow-rs/winnow","homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":"1.65.0"}],"workspace_members":["path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1","path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_cli#0.1.0"],"workspace_default_members":["path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1","path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_cli#0.1.0"],"resolve":{"nodes":[{"id":"registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6"],"deps":[{"name":"memchr","pkg":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","dep_kinds":[{"kind":null,"target":null}]}],"features":["std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#autocfg@1.5.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#bumpalo@3.19.0","dependencies":[],"deps":[],"features":["default"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-deque@0.8.6","dependencies":["registry+https://github.com/rust-lang/crates.io-index#crossbeam-epoch@0.9.18","registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21"],"deps":[{"name":"crossbeam_epoch","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-epoch@0.9.18","dep_kinds":[{"kind":null,"target":null}]},{"name":"crossbeam_utils","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-epoch@0.9.18","dependencies":["registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21"],"deps":[{"name":"crossbeam_utils","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","dep_kinds":[{"kind":null,"target":null}]}],"features":["alloc","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","dependencies":[],"deps":[],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#dashmap@6.1.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.14.5","registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","registry+https://github.com/rust-lang/crates.io-index#parking_lot_core@0.9.12"],"deps":[{"name":"cfg_if","pkg":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"crossbeam_utils","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","dep_kinds":[{"kind":null,"target":null}]},{"name":"hashbrown","pkg":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.14.5","dep_kinds":[{"kind":null,"target":null}]},{"name":"lock_api","pkg":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","dep_kinds":[{"kind":null,"target":null}]},{"name":"once_cell","pkg":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"parking_lot_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#parking_lot_core@0.9.12","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#either@1.15.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#equivalent@1.0.2","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#fastrand@2.3.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#getrandom@0.2.16"],"deps":[{"name":"getrandom","pkg":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.2.16","dep_kinds":[{"kind":null,"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))"}]}],"features":["alloc","default","getrandom","js","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#fastrand@2.3.0","registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31","registry+https://github.com/rust-lang/crates.io-index#futures-sink@0.3.31","registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8"],"deps":[{"name":"fastrand","pkg":"registry+https://github.com/rust-lang/crates.io-index#fastrand@2.3.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"futures_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31","dep_kinds":[{"kind":null,"target":null}]},{"name":"futures_sink","pkg":"registry+https://github.com/rust-lang/crates.io-index#futures-sink@0.3.31","dep_kinds":[{"kind":null,"target":null}]},{"name":"spin1","pkg":"registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8","dep_kinds":[{"kind":null,"target":null}]}],"features":["async","default","eventual-fairness","fastrand","futures-core","futures-sink","select"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#futures-sink@0.3.31","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#gdextension-api@0.3.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#getrandom@0.2.16","dependencies":["registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","registry+https://github.com/rust-lang/crates.io-index#js-sys@0.3.83","registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","registry+https://github.com/rust-lang/crates.io-index#wasi@0.11.1+wasi-snapshot-preview1","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106"],"deps":[{"name":"cfg_if","pkg":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"js_sys","pkg":"registry+https://github.com/rust-lang/crates.io-index#js-sys@0.3.83","dep_kinds":[{"kind":null,"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))"}]},{"name":"libc","pkg":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","dep_kinds":[{"kind":null,"target":"cfg(unix)"}]},{"name":"wasi","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasi@0.11.1+wasi-snapshot-preview1","dep_kinds":[{"kind":null,"target":"cfg(target_os = \"wasi\")"}]},{"name":"wasm_bindgen","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106","dep_kinds":[{"kind":null,"target":"cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))"}]}],"features":["js","js-sys","wasm-bindgen"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#glam@0.30.9","dependencies":[],"deps":[],"features":["debug-glam-assert","default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#godot-core@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4"],"deps":[{"name":"godot_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-core@0.4.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"godot_macros","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4","dep_kinds":[{"kind":null,"target":null}]}],"features":["__codegen-full","default","serde"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#gdextension-api@0.3.0"],"deps":[{"name":"gdextension_api","pkg":"registry+https://github.com/rust-lang/crates.io-index#gdextension-api@0.3.0","dep_kinds":[{"kind":null,"target":null}]}],"features":["default"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-cell@0.4.4","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","registry+https://github.com/rust-lang/crates.io-index#heck@0.5.0","registry+https://github.com/rust-lang/crates.io-index#nanoserde@0.2.1","registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#regex@1.12.2"],"deps":[{"name":"godot_bindings","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","dep_kinds":[{"kind":null,"target":null},{"kind":"build","target":null}]},{"name":"heck","pkg":"registry+https://github.com/rust-lang/crates.io-index#heck@0.5.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"nanoserde","pkg":"registry+https://github.com/rust-lang/crates.io-index#nanoserde@0.2.1","dep_kinds":[{"kind":null,"target":null}]},{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"regex","pkg":"registry+https://github.com/rust-lang/crates.io-index#regex@1.12.2","dep_kinds":[{"kind":null,"target":null}]}],"features":["codegen-full","default"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-core@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#glam@0.30.9","registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-cell@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-ffi@0.4.4","registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228"],"deps":[{"name":"glam","pkg":"registry+https://github.com/rust-lang/crates.io-index#glam@0.30.9","dep_kinds":[{"kind":null,"target":null}]},{"name":"godot_bindings","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","dep_kinds":[{"kind":"build","target":null}]},{"name":"godot_cell","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-cell@0.4.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"godot_codegen","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","dep_kinds":[{"kind":"build","target":null}]},{"name":"godot_ffi","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-ffi@0.4.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"serde","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","dep_kinds":[{"kind":null,"target":null}]}],"features":["codegen-full","default","serde"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-ffi@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4","registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178"],"deps":[{"name":"godot_bindings","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","dep_kinds":[{"kind":"build","target":null}]},{"name":"godot_codegen","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-codegen@0.4.4","dep_kinds":[{"kind":"build","target":null}]},{"name":"godot_macros","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4","dep_kinds":[{"kind":null,"target":"cfg(target_family = \"wasm\")"}]},{"name":"libc","pkg":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","dep_kinds":[{"kind":null,"target":"cfg(target_os = \"linux\")"}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#godot-macros@0.4.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#venial@0.6.1"],"deps":[{"name":"godot_bindings","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot-bindings@0.4.4","dep_kinds":[{"kind":"build","target":null}]},{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"venial","pkg":"registry+https://github.com/rust-lang/crates.io-index#venial@0.6.1","dep_kinds":[{"kind":null,"target":null}]}],"features":["codegen-full","experimental-wasm"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.14.5","dependencies":[],"deps":[],"features":["raw"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.16.1","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#heck@0.5.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#indexmap@2.12.1","dependencies":["registry+https://github.com/rust-lang/crates.io-index#equivalent@1.0.2","registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.16.1"],"deps":[{"name":"equivalent","pkg":"registry+https://github.com/rust-lang/crates.io-index#equivalent@1.0.2","dep_kinds":[{"kind":null,"target":null}]},{"name":"hashbrown","pkg":"registry+https://github.com/rust-lang/crates.io-index#hashbrown@0.16.1","dep_kinds":[{"kind":null,"target":null}]}],"features":["std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#js-sys@0.3.83","dependencies":["registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106"],"deps":[{"name":"once_cell","pkg":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"wasm_bindgen","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","dependencies":[],"deps":[],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","dependencies":["registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0"],"deps":[{"name":"scopeguard","pkg":"registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0","dep_kinds":[{"kind":null,"target":null}]}],"features":["atomic_usize","default"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","dependencies":[],"deps":[],"features":["alloc","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#nanoserde@0.2.1","dependencies":["registry+https://github.com/rust-lang/crates.io-index#nanoserde-derive@0.2.1"],"deps":[{"name":"nanoserde_derive","pkg":"registry+https://github.com/rust-lang/crates.io-index#nanoserde-derive@0.2.1","dep_kinds":[{"kind":null,"target":null}]}],"features":["binary","default","json","ron","std","toml"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#nanoserde-derive@0.2.1","dependencies":[],"deps":[],"features":["binary","default","json","ron"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#noise@0.9.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","registry+https://github.com/rust-lang/crates.io-index#rand@0.8.5","registry+https://github.com/rust-lang/crates.io-index#rand_xorshift@0.3.0"],"deps":[{"name":"num_traits","pkg":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","dep_kinds":[{"kind":null,"target":null}]},{"name":"rand","pkg":"registry+https://github.com/rust-lang/crates.io-index#rand@0.8.5","dep_kinds":[{"kind":null,"target":null}]},{"name":"rand_xorshift","pkg":"registry+https://github.com/rust-lang/crates.io-index#rand_xorshift@0.3.0","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.19","dependencies":["registry+https://github.com/rust-lang/crates.io-index#autocfg@1.5.0"],"deps":[{"name":"autocfg","pkg":"registry+https://github.com/rust-lang/crates.io-index#autocfg@1.5.0","dep_kinds":[{"kind":"build","target":null}]}],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","dependencies":[],"deps":[],"features":["alloc","default","race","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#parking_lot_core@0.9.12","dependencies":["registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","registry+https://github.com/rust-lang/crates.io-index#redox_syscall@0.5.18","registry+https://github.com/rust-lang/crates.io-index#smallvec@1.15.1","registry+https://github.com/rust-lang/crates.io-index#windows-link@0.2.1"],"deps":[{"name":"cfg_if","pkg":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"libc","pkg":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.178","dep_kinds":[{"kind":null,"target":"cfg(unix)"}]},{"name":"syscall","pkg":"registry+https://github.com/rust-lang/crates.io-index#redox_syscall@0.5.18","dep_kinds":[{"kind":null,"target":"cfg(target_os = \"redox\")"}]},{"name":"smallvec","pkg":"registry+https://github.com/rust-lang/crates.io-index#smallvec@1.15.1","dep_kinds":[{"kind":null,"target":null}]},{"name":"windows_link","pkg":"registry+https://github.com/rust-lang/crates.io-index#windows-link@0.2.1","dep_kinds":[{"kind":null,"target":"cfg(windows)"}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#pin-project-lite@0.2.16","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dependencies":["registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22"],"deps":[{"name":"unicode_ident","pkg":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","proc-macro"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","proc-macro"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rand@0.8.5","dependencies":["registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4"],"deps":[{"name":"rand_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rand_xorshift@0.3.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4"],"deps":[{"name":"rand_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#rand_core@0.6.4","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rayon@1.11.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#either@1.15.0","registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0"],"deps":[{"name":"either","pkg":"registry+https://github.com/rust-lang/crates.io-index#either@1.15.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"rayon_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rayon-core@1.13.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#crossbeam-deque@0.8.6","registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21"],"deps":[{"name":"crossbeam_deque","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-deque@0.8.6","dep_kinds":[{"kind":null,"target":null}]},{"name":"crossbeam_utils","pkg":"registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#redox_syscall@0.5.18","dependencies":["registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0"],"deps":[{"name":"bitflags","pkg":"registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","userspace"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#regex@1.12.2","dependencies":["registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","registry+https://github.com/rust-lang/crates.io-index#regex-automata@0.4.13","registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8"],"deps":[{"name":"aho_corasick","pkg":"registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"memchr","pkg":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","dep_kinds":[{"kind":null,"target":null}]},{"name":"regex_automata","pkg":"registry+https://github.com/rust-lang/crates.io-index#regex-automata@0.4.13","dep_kinds":[{"kind":null,"target":null}]},{"name":"regex_syntax","pkg":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8","dep_kinds":[{"kind":null,"target":null}]}],"features":["std","unicode-bool","unicode-gencat"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#regex-automata@0.4.13","dependencies":["registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8"],"deps":[{"name":"aho_corasick","pkg":"registry+https://github.com/rust-lang/crates.io-index#aho-corasick@1.1.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"memchr","pkg":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.6","dep_kinds":[{"kind":null,"target":null}]},{"name":"regex_syntax","pkg":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8","dep_kinds":[{"kind":null,"target":null}]}],"features":["alloc","meta","nfa-pikevm","nfa-thompson","std","syntax","unicode-bool","unicode-gencat"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.8.8","dependencies":[],"deps":[],"features":["std","unicode-bool","unicode-gencat"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","dependencies":["registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228"],"deps":[{"name":"serde_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","dep_kinds":[{"kind":null,"target":null}]},{"name":"serde_derive","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","derive","serde_derive","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","dependencies":["registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228"],"deps":[{"name":"serde_derive","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228","dep_kinds":[{"kind":null,"target":"cfg(any())"}]}],"features":["alloc","result","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#serde_derive@1.0.228","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"syn","pkg":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","dep_kinds":[{"kind":null,"target":null}]}],"features":["default"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#serde_spanned@1.0.3","dependencies":["registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228"],"deps":[{"name":"serde_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","dep_kinds":[{"kind":null,"target":null}]}],"features":["alloc","serde","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#smallvec@1.15.1","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8","dependencies":["registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14"],"deps":[{"name":"lock_api_crate","pkg":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","dep_kinds":[{"kind":null,"target":null}]}],"features":["barrier","default","lazy","lock_api","lock_api_crate","mutex","once","rwlock","spin_mutex"]},{"id":"path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_cli#0.1.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1"],"deps":[{"name":"flume","pkg":"registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"ssxl_ext","pkg":"path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"path+file:///C:/zv9/zv9.SSXL-ext/rust/ssxl_ext#0.9.1","dependencies":["registry+https://github.com/rust-lang/crates.io-index#dashmap@6.1.0","registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","registry+https://github.com/rust-lang/crates.io-index#godot@0.4.4","registry+https://github.com/rust-lang/crates.io-index#noise@0.9.0","registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","registry+https://github.com/rust-lang/crates.io-index#rayon@1.11.0","registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","registry+https://github.com/rust-lang/crates.io-index#tokio@1.48.0","registry+https://github.com/rust-lang/crates.io-index#toml@0.9.8"],"deps":[{"name":"dashmap","pkg":"registry+https://github.com/rust-lang/crates.io-index#dashmap@6.1.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"flume","pkg":"registry+https://github.com/rust-lang/crates.io-index#flume@0.12.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"godot","pkg":"registry+https://github.com/rust-lang/crates.io-index#godot@0.4.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"noise","pkg":"registry+https://github.com/rust-lang/crates.io-index#noise@0.9.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"once_cell","pkg":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"rayon","pkg":"registry+https://github.com/rust-lang/crates.io-index#rayon@1.11.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"serde","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde@1.0.228","dep_kinds":[{"kind":null,"target":null}]},{"name":"thiserror","pkg":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","dep_kinds":[{"kind":null,"target":null}]},{"name":"tokio","pkg":"registry+https://github.com/rust-lang/crates.io-index#tokio@1.48.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"toml","pkg":"registry+https://github.com/rust-lang/crates.io-index#toml@0.9.8","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"unicode_ident","pkg":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","dep_kinds":[{"kind":null,"target":null}]}],"features":["clone-impls","default","derive","full","parsing","printing","proc-macro","visit","visit-mut"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#thiserror@2.0.17","dependencies":["registry+https://github.com/rust-lang/crates.io-index#thiserror-impl@2.0.17"],"deps":[{"name":"thiserror_impl","pkg":"registry+https://github.com/rust-lang/crates.io-index#thiserror-impl@2.0.17","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#thiserror-impl@2.0.17","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"syn","pkg":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#tokio@1.48.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#pin-project-lite@0.2.16","registry+https://github.com/rust-lang/crates.io-index#tokio-macros@2.6.0"],"deps":[{"name":"pin_project_lite","pkg":"registry+https://github.com/rust-lang/crates.io-index#pin-project-lite@0.2.16","dep_kinds":[{"kind":null,"target":null}]},{"name":"tokio_macros","pkg":"registry+https://github.com/rust-lang/crates.io-index#tokio-macros@2.6.0","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","macros","rt","sync","tokio-macros"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#tokio-macros@2.6.0","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"syn","pkg":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#toml@0.9.8","dependencies":["registry+https://github.com/rust-lang/crates.io-index#indexmap@2.12.1","registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","registry+https://github.com/rust-lang/crates.io-index#serde_spanned@1.0.3","registry+https://github.com/rust-lang/crates.io-index#toml_datetime@0.7.3","registry+https://github.com/rust-lang/crates.io-index#toml_parser@1.0.4","registry+https://github.com/rust-lang/crates.io-index#toml_writer@1.0.4","registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14"],"deps":[{"name":"indexmap","pkg":"registry+https://github.com/rust-lang/crates.io-index#indexmap@2.12.1","dep_kinds":[{"kind":null,"target":null}]},{"name":"serde_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","dep_kinds":[{"kind":null,"target":null}]},{"name":"serde_spanned","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_spanned@1.0.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"toml_datetime","pkg":"registry+https://github.com/rust-lang/crates.io-index#toml_datetime@0.7.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"toml_parser","pkg":"registry+https://github.com/rust-lang/crates.io-index#toml_parser@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"toml_writer","pkg":"registry+https://github.com/rust-lang/crates.io-index#toml_writer@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"winnow","pkg":"registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14","dep_kinds":[{"kind":null,"target":null}]}],"features":["default","display","parse","serde","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#toml_datetime@0.7.3","dependencies":["registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228"],"deps":[{"name":"serde_core","pkg":"registry+https://github.com/rust-lang/crates.io-index#serde_core@1.0.228","dep_kinds":[{"kind":null,"target":null}]}],"features":["alloc","serde","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#toml_parser@1.0.4","dependencies":["registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14"],"deps":[{"name":"winnow","pkg":"registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14","dep_kinds":[{"kind":null,"target":null}]}],"features":["alloc","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#toml_writer@1.0.4","dependencies":[],"deps":[],"features":["alloc","std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#venial@0.6.1","dependencies":["registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42"],"deps":[{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#wasi@0.11.1+wasi-snapshot-preview1","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen@0.2.106","dependencies":["registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro@0.2.106","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106"],"deps":[{"name":"cfg_if","pkg":"registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.4","dep_kinds":[{"kind":null,"target":null}]},{"name":"once_cell","pkg":"registry+https://github.com/rust-lang/crates.io-index#once_cell@1.21.3","dep_kinds":[{"kind":null,"target":null}]},{"name":"rustversion_compat","pkg":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","dep_kinds":[{"kind":"build","target":null}]},{"name":"wasm_bindgen_macro","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro@0.2.106","dep_kinds":[{"kind":null,"target":null}]},{"name":"wasm_bindgen_shared","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106","dep_kinds":[{"kind":null,"target":null}]}],"features":["std"]},{"id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro@0.2.106","dependencies":["registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro-support@0.2.106"],"deps":[{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"wasm_bindgen_macro_support","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro-support@0.2.106","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-macro-support@0.2.106","dependencies":["registry+https://github.com/rust-lang/crates.io-index#bumpalo@3.19.0","registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106"],"deps":[{"name":"bumpalo","pkg":"registry+https://github.com/rust-lang/crates.io-index#bumpalo@3.19.0","dep_kinds":[{"kind":null,"target":null}]},{"name":"proc_macro2","pkg":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.103","dep_kinds":[{"kind":null,"target":null}]},{"name":"quote","pkg":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.42","dep_kinds":[{"kind":null,"target":null}]},{"name":"syn","pkg":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.111","dep_kinds":[{"kind":null,"target":null}]},{"name":"wasm_bindgen_shared","pkg":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#wasm-bindgen-shared@0.2.106","dependencies":["registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22"],"deps":[{"name":"unicode_ident","pkg":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.22","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#windows-link@0.2.1","dependencies":[],"deps":[],"features":[]},{"id":"registry+https://github.com/rust-lang/crates.io-index#winnow@0.7.14","dependencies":[],"deps":[],"features":[]}],"root":null},"target_directory":"C:\\zv9\\zv9.SSXL-ext\\rust\\target","build_directory":"C:\\zv9\\zv9.SSXL-ext\\rust\\target","version":1,"workspace_root":"C:\\zv9\\zv9.SSXL-ext\\rust","metadata":null}
PS C:\zv9\zv9.SSXL-ext\rust>
<<< FILE END: verbose.rs >>>

>>> FILE START: ssxl_cli\build.rs (23 LOC) <<<
// rust/ssxl_cli/build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    // 1. Get the output directory for the current build step
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // 2. Calculate the path to the 'deps' directory where ssxl_ext.dll.lib lives.
    // We traverse up 3 levels from the build script output:
    // target/debug/build/ssxl_cli-XYZ/out -> target/debug/deps
    let deps_dir = out_dir
        .parent().unwrap() // ssxl_cli-XYZ
        .parent().unwrap() // build
        .parent().unwrap() // debug
        .join("deps");

    // 3. Add the search path for the linker
    println!("cargo:rustc-link-search=native={}", deps_dir.display());

    // 4. Link against the 'ssxl_ext' library dynamically.
    // CRITICAL FIX: Link against the DLL name ('ssxl_ext.dll') to correctly find the
    // MSVC-generated import library ('ssxl_ext.dll.lib').
    println!("cargo:rustc-link-lib=dylib=ssxl_ext.dll"); // <-- FIXED

    // 5. Ensure we rebuild if the library changes
    println!("cargo:rerun-if-changed=../ssxl_ext");
}
<<< FILE END: ssxl_cli\build.rs >>>

>>> FILE START: ssxl_cli\Cargo.toml (12 LOC) <<<
[package]
name = "ssxl_cli"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
ssxl_ext = { path = "../ssxl_ext" }
flume = "0.12"


tracing = "0.1" 
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

crossterm = "0.27"
walkdir = "2.5"
<<< FILE END: ssxl_cli\Cargo.toml >>>

>>> FILE START: ssxl_cli\src\main.rs (120 LOC) <<<
// ssxl_cli\src\main.rs
// ============================================================================
// 🧭 SSXL-ext CLI Developer Console (`ssxl_cli::main`)
// ----------------------------------------------------------------------------
// The main entry point, handling initialization, core stubs, and coordinating
// the interactive menu and source scanning modules.
// ============================================================================

// --- Module Declarations ---
pub mod ssxl_menu;
pub mod ssxl_source_scan;
pub mod ssxl_api_scan; 

use std::io; 
use std::fs; 
use std::path::PathBuf;
use tracing::{info, error, warn};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

// Re-export public function stubs required by ssxl_menu.rs
pub use ssxl_api_scan::print_godot_api_surface;

// --- FFI Declarations (Exported by ssxl_ext) ---
extern "C" {
    // New function to replace the ssxl_start_runtime MOCK
    fn ssxl_boot_core_to_idle() -> i32; 

    // FFI functions used by mocked menu actions (kept for linking)
    fn ssxl_set_cell(x: i32, y: i32, tile_id: i32);
    fn ssxl_notify_tilemap_update();
}


// --- RUNTIME BOOT AND UTILITIES ---

/// ✅ REAL: Calls the FFI function in ssxl_ext.dll to initialize the engine core.
fn ssxl_start_runtime() -> bool {
    info!("Engine FFI core: Attempting to boot to idle via DLL...");
    // Safety: Calls an FFI function defined in ssxl_ext.
    unsafe {
        match ssxl_boot_core_to_idle() {
            0 => {
                info!("✅ Engine FFI core initialized (REAL).");
                true
            },
            e => {
                error!("❌ Engine FFI core failed to boot. Exit code: {}", e);
                false
            }
        }
    }
}

/// ✅ REAL: Copies the built ssxl_ext.dll to the Godot tester project folder.
fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    let source = PathBuf::from("target/debug/ssxl_ext.dll");
    let destination = PathBuf::from("../SSXLtester2/ssxl_ext.dll");

    if !source.exists() {
        warn!("Source DLL not found: {}. Did you run 'cargo build'?", source.display());
        return Err(format!("Source DLL not found: {}", source.display()));
    }

    match fs::copy(&source, &destination) {
        Ok(_) => {
            info!("✅ DLL Copy: Successfully copied {} to {}.", 
                  source.display(), destination.display());
            Ok(())
        },
        Err(e) => {
            if !destination.parent().map_or(false, |p| p.exists()) {
                 return Err(format!("❌ DLL Copy Failed: Destination directory ({}) does not exist. Error: {}", 
                                     destination.parent().unwrap_or(&destination).display(), e));
            }
            Err(format!("❌ DLL Copy Failed: Could not copy from {} to {}. Error: {}", 
                        source.display(), destination.display(), e))
        }
    }
}

// ⚠️ MOCK: Stubs for functions called by the menu, now pub for ssxl_menu.rs
pub fn run_fast_test() { println!("MOCK ACTION: Running fast test..."); }
pub fn run_full_test() { println!("MOCK ACTION: Running full test..."); }
pub fn run_max_grid_benchmark() { println!("MOCK ACTION: Running max grid benchmark..."); }
pub fn run_bitmask_conversion() { println!("MOCK ACTION: Running bitmask conversion..."); }
pub fn print_module_tree() { println!("MOCK ACTION: Inspecting Rust module tree..."); }


fn init_logging_and_engine() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // This is now a real FFI call
    if !ssxl_start_runtime() {
        error!("Fatal: Engine FFI core failed to initialize. Aborting console boot.");
    }
    
    // This is a real copy operation
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // 1. Logging, FFI Initialization, and DLL Copy
    init_logging_and_engine();
    
    // 2. FFI Linker Guards: These references ensure the linker attempts to resolve the symbols.
    let _ = ssxl_boot_core_to_idle as *const ();
    let _ = ssxl_set_cell as *const ();
    let _ = ssxl_notify_tilemap_update as *const ();
    
    // 3. LOC Report and Banner - ***MODULE CALL***
    ssxl_source_scan::scan_and_report_loc();
    
    println!(
        r#"
                 (__)    
                 (oo)
           /------\/
          / |    ||
         * ||----||
           ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // 4. Interactive Loop - ***MODULE CALL***
    let menu = ssxl_menu::build_menu();
    ssxl_menu::run_interactive_loop(menu);
}
<<< FILE END: ssxl_cli\src\main.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_api_scan.rs (8 LOC) <<<
// ssxl_api_scan.rs
use tracing::info;

/// Action stub: Prints an inspection of the Godot API Surface exposed via the GDExtension.
pub fn print_godot_api_surface() { 
    info!("MOCK ACTION: Inspecting Godot API surface...");
    println!("API Scan: Currently using placeholder FFI stubs (`ssxl_set_cell`, `ssxl_notify_tilemap_update`).");
    println!("API Scan: Real implementation will reflect the final Godot<->Rust API defined by the 'finisher' component.");
}
<<< FILE END: ssxl_cli\src\ssxl_api_scan.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_menu.rs (108 LOC) <<<
// ssxl_menu.rs
use std::collections::HashSet;
use std::io::{self, Write};
use std::time::Duration;
use std::thread;
use crossterm::event::{self, Event, KeyCode};
use tracing::info;

// Note: We use extern crate self as ssxl_cli to resolve actions defined in main.rs
extern crate self as ssxl_cli;
use ssxl_cli::{
    run_fast_test, run_full_test, run_max_grid_benchmark, run_bitmask_conversion,
    print_module_tree, print_godot_api_surface
};

/// Structure representing a single menu item and its action.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn()>,
}

pub fn build_menu() -> Vec<CliAction> {
    vec![
        CliAction {
            key: 'A',
            label: "✅ press A: Inspect Rust Module Tree",
            id: "module_tree",
            action: Box::new(print_module_tree)
        },
        CliAction {
            key: 'B',
            label: "✅ press B: Run Fast Test",
            id: "fast_test",
            action: Box::new(run_fast_test)
        },
        CliAction {
            key: 'C',
            label: "✅ press C: Run Full Integration Test",
            id: "full_test",
            action: Box::new(run_full_test)
        },
        CliAction {
            key: 'D',
            label: "✅ press D: Run Max Grid Benchmark",
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)
        },
        CliAction {
            key: 'E',
            label: "✅ press E: Run Bitmask Conversion Test",
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)
        },
        CliAction {
            key: 'F',
            label: "✅ press F: Inspect Godot API Surface",
            id: "api_surface",
            action: Box::new(print_godot_api_surface)
        },
        
        // Corrected menu item for exit
        CliAction { key: 'U', label: "✅ press U: EXIT Console", id: "exit", action: Box::new(|| {}) },
    ]
}

fn print_menu(menu: &[CliAction]) {
    println!("\n--- SSXL-ext Main Menu ---");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
}

fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

pub fn run_interactive_loop(menu: Vec<CliAction>) {
    let mut last_keys = HashSet::new();

    loop {
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            // Debounced input poll
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                (item.action)(); // Execute the action closure

                                if c == 'U' {   
                                    return;
                                }

                                wait_for_enter();
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}
<<< FILE END: ssxl_cli\src\ssxl_menu.rs >>>

>>> FILE START: ssxl_cli\src\ssxl_source_scan.rs (126 LOC) <<<
// ssxl_source_scan.rs
use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// --- CONSTANTS ---
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";
// Note: Relative paths are assumed to be run from the 'rust' directory.

// --- LOC COUNTING LOGIC ---

/// Counts non-empty, non-comment lines of code.
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        // Ignores lines starting with '//' (Rust) or '#' (GDScript).
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Writes the total Rust LOC count to the fixed-name file for Godot's boot parser.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level from 'rust' to the project root for the output file.
    let root_dir = PathBuf::from("../"); 
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("🔥 SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("❌ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                       output_path, e);
        }
    }
}

// --- MAIN SCAN FUNCTION ---

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // UPDATED DIRECTORIES for the consolidated ssxl-ext structure (as per manifest).
    // Scans the main GDExtension library and the CLI tool itself.
    let rust_dirs = [
        "ssxl_ext/src", // Contains all core logic (host, generate, shared).
        "ssxl_cli/src", // Contains CLI tool logic (like this file).
    ];

    // --- SCAN RUST FILES ---
    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- SCAN GDSCRIPT FILES ---
    // Assuming the GDScript test directory remains the same relative path.
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- WRITE REPORTS ---
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("❌ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n        {} LOC | *.rs (Rust Total)\n        {} LOC | *.gd (GDScript Total)\n        {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("✅ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("❌ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // --- CRITICAL STEP FOR GODOT ---
    write_final_loc_total(total_rs_loc);

    // Final sleep to ensure writes/logs are flushed
    thread::sleep(Duration::from_millis(100));
}
<<< FILE END: ssxl_cli\src\ssxl_source_scan.rs >>>

>>> FILE START: ssxl_ext\Cargo.toml (34 LOC) <<<
[package]
name = "ssxl_ext"
version = "0.9.1"
edition = "2021"
# The crate type must be 'cdylib' for a Godot GDExtension
[lib]
crate-type = ["cdylib"]


[dependencies]

# --- 1. Godot Bindings (Essential Bridge) ---
# Assuming 'godot' is the chosen Godot Rust binding crate (e.g., godot-rust/gdext)
# This is the single most important dependency for the Host_* files (host_init.rs, host_tick.rs, etc.)
godot = { version = "^0.4.4", features = ["serde"] } 
# The 'serde' feature is often useful for robust configuration reading (config.rs, shared_config.rs)

# --- 2. Concurrency and Async (The Finisher/Conductor Core) ---
# Required for non-blocking generation, worker threads (sync_pool.rs), and task queues (generate_task_queue.rs)
# and for the animation workers (animate_conductor.rs, animate_worker.rs).
tokio = { version = "1.48", features = ["rt", "macros", "sync"] } 
# Or another runtime like `smol`. 'tokio' is a robust choice for async work.

# Flume is a popular multi-producer, single-consumer (MPSC) channel for communicating
# between Rust threads and the Godot main thread (e.g., for chunk delivery in shared_message.rs).
flume = "0.12" 

# Rayon for data parallelism on generation tasks (e.g., in generate_batch_processor.rs)
rayon = "1.11" 

# --- 3. Generation Primitives ---
# Noise is essential for procedural generation (generate_perlin.rs)
noise = { version = "0.9", default-features = false } 
# Small/shared helper to handle complex state management safely.
once_cell = "1.21.3" 

# --- 4. Utilities and Serialization ---
# Serde is critical for robust configuration loading and data sharing across the FFI/Bridge (config.rs, shared_config.rs)
serde = { version = "1.0.228", features = ["derive"] }
toml = "0.9.8"
dashmap = "6.1.0"
thiserror = "2.0.17"
<<< FILE END: ssxl_ext\Cargo.toml >>>

>>> FILE START: ssxl_ext\src\animate_conductor.rs (94 LOC) <<<
// rust/SSXL-ext/src/animate_conductor.rs
// FIX: Removed: use crate::godot_print;
use flume::{Receiver, Sender};
use crate::animate_events::AnimationEvent;
use crate::animate_worker::AnimationWorker;
use crate::shared_config::AnimationConfig;

/// Messages sent from the main thread (Conductor) to the worker threads.
#[derive(Debug)]
pub enum ControlMessage {
    /// Instructs the worker to pause its simulation loop.
    Pause,
    /// Instructs the worker to immediately shut down its thread.
    Stop,
    /// Instructs the worker to update its internal configuration.
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/animate_conductor.rs

/// Orchestrates the background animation worker pool and manages communication.
pub struct AnimationConductor {
    // The channel receiving AnimationEvents from all workers (used by host_anim.rs).
    pub event_receiver: Receiver<AnimationEvent>, 
    
    // Senders used to dispatch control messages (Pause/Stop) to each worker.
    control_senders: Vec<Sender<ControlMessage>>,

    // The handles to the actual worker threads, managed by the conductor.
    workers: Vec<AnimationWorker>,
}

// rust/SSXL-ext/src/animate_conductor.rs

impl AnimationConductor {
    /// Initializes the conductor and launches the animation worker threads.
    pub fn new(config: &AnimationConfig) -> Self {
        // FIX: The necessary field (`animation_worker_count`) is missing from AnimationConfig.
        // Temporarily use a hardcoded default value of 4 to allow compilation.
        // This should be replaced with a proper field access once AnimationConfig is corrected.
        let num_workers = 4;
        
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: AnimationConductor: Using default worker count of {} due to missing config field.", num_workers);
        
        // MPSC Channel setup: Workers are producers, Conductor is the single consumer (event_receiver)
        let (event_sender, event_receiver) = flume::unbounded();

        let mut workers = Vec::with_capacity(num_workers);
        let mut control_senders = Vec::with_capacity(num_workers);

        for id in 0..num_workers {
            // SPSC Channel setup: Conductor is the producer, Worker is the consumer
            let (control_sender, control_receiver) = flume::unbounded();
            
            let worker = AnimationWorker::new(
                id, 
                event_sender.clone(), // Clone the event sender for each worker
                control_receiver,
                config.clone(),
            );
            
            workers.push(worker);
            control_senders.push(control_sender);
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Launched {} dedicated animation workers.", num_workers);
        Self { 
            event_receiver, 
            control_senders, 
            workers 
        }
    }

    /// Public method to command all workers to stop immediately and shut down.
    pub fn shutdown(self) {
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Initiating graceful shutdown of workers.");
        
        // 1. Signal all workers to STOP
        for sender in self.control_senders.iter() {
            // Use try_send in case the worker has already disconnected
            let _ = sender.try_send(ControlMessage::Stop); 
        }

        // 2. Wait for all worker threads to join
        for worker in self.workers {
            worker.join();
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: All animation workers shut down.");
    }

    /// Exposes the main receiver to the Host Anim Poller.
    pub fn get_event_receiver(&self) -> &Receiver<AnimationEvent> {
        &self.event_receiver
    }
    
    /// Sends a Pause message to all workers.
    pub fn pause_workers(&self) {
        for sender in self.control_senders.iter() {
            let _ = sender.try_send(ControlMessage::Pause);
        }
    }
}
<<< FILE END: ssxl_ext\src\animate_conductor.rs >>>

>>> FILE START: ssxl_ext\src\animate_events.rs (22 LOC) <<<
// rust/SSXL-ext/src/animate_events.rs

use godot::prelude::*; // For Vector2i and Color types

/// Represents a single, final, thread-safe animation instruction for the Godot main thread.
#[derive(Debug, Clone)]
pub enum AnimationEvent {
    /// Change the current frame index of an animated tile.
    SetTileAnimation {
        layer: i32,
        coords: (i32, i32),
        frame_index: i32,
    },
    /// Change the color property of a specific Light2D node.
    SetLightColor {
        light_id: u32,
        color: Color,
    },
    /// Request to create a new one-shot particle effect.
    SpawnParticleEffect {
        effect_id: u32,
        position: (f32, f32),
    },
}
<<< FILE END: ssxl_ext\src\animate_events.rs >>>

>>> FILE START: ssxl_ext\src\animate_worker.rs (92 LOC) <<<
use std::thread;
use std::time::{Duration, Instant};
use flume::Sender;
use crate::animate_events::AnimationEvent;
use crate::shared_config::AnimationConfig;
use crate::animate_conductor::ControlMessage;
use crate::{godot_print, godot_warn};
use std::collections::VecDeque;

pub struct AnimationWorker {
    _id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl AnimationWorker {
    pub fn new(
        id: usize,
        event_sender: Sender<AnimationEvent>,
        control_receiver: flume::Receiver<ControlMessage>,
        initial_config: AnimationConfig,
    ) -> Self {
        let handle = thread::spawn(move || {
            let mut current_config = initial_config;
            let mut simulation_state = init_simulation_state(&current_config);
            
            let mut target_fps = current_config.simulation_fps;
            let mut target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
            
            godot_print!("Anim Worker {}: Started with target FPS: {}", id, target_fps);
            
            let mut is_running = true;
            while is_running {
                let frame_start_time = Instant::now();

                if let Ok(msg) = control_receiver.try_recv() {
                    match msg {
                        ControlMessage::Pause => is_running = false,
                        ControlMessage::Stop => break,
                        ControlMessage::UpdateConfig(new_config) => {
                            godot_print!("Anim Worker {}: Applying new config. New FPS: {}", id, new_config.simulation_fps);
                            current_config = new_config;
                            target_fps = current_config.simulation_fps;
                            target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
                        }
                    }
                }
                
                if is_running {
                    let new_events = run_simulation_step(&mut simulation_state, &current_config);
                    
                    for event in new_events {
                        if event_sender.send(event).is_err() {
                            godot_warn!("Anim Worker {}: Conductor channel disconnected. Shutting down.", id);
                            break;
                        }
                    }
                }

                let elapsed_time = frame_start_time.elapsed();
                if elapsed_time < target_frame_duration {
                    thread::sleep(target_frame_duration - elapsed_time);
                }
            }
            godot_print!("Anim Worker {} finished loop and exiting thread.", id);
        });

        AnimationWorker { _id: id, handle: Some(handle) }
    }
    
    pub fn join(mut self) {
        if let Some(handle) = self.handle.take() {
            let _ = handle.join();
        }
    }
}

struct SimulationState {
    last_update_time: Instant,
}

fn init_simulation_state(_config: &AnimationConfig) -> SimulationState {
    SimulationState { last_update_time: Instant::now() }
}

fn run_simulation_step(state: &mut SimulationState, _config: &AnimationConfig) -> VecDeque<AnimationEvent> {
    let now = Instant::now();
    let events = if (now - state.last_update_time) > Duration::from_millis(100) {
        state.last_update_time = now;
        let event = AnimationEvent::SetTileAnimation { 
            layer: 0, 
            coords: (10, 5), 
            frame_index: (now.elapsed().as_secs() % 4) as i32 
        };
        VecDeque::from([event])
    } else {
        VecDeque::new()
    };
    
    events
}
<<< FILE END: ssxl_ext\src\animate_worker.rs >>>

>>> FILE START: ssxl_ext\src\bridge_ffi.rs (81 LOC) <<<
use godot::prelude::*;
use godot::classes::TileMap;
use crate::shared_tile::TileData;
use crate::host_tilemap::TileMapDirectWriteExtension;

// --- Finisher Transparency & Robustness Improvements ---

/// The default TileMap layer used for all procedural chunk data.
/// Using a named constant instead of a magic number (0) improves transparency.
const CHUNK_DATA_LAYER: i32 = 0;

// --------------------------------------------------------

#[no_mangle]
/// # Safety
///
/// This function is the Finisher's hook for direct memory writing.
/// It is inherently unsafe because it hands a raw pointer to a Rust thread,
/// allowing it to mutate Godot's internal memory without Godot's direct knowledge.
///
/// The caller (the Rust generation core) *must* adhere to the following guarantees:
/// 1. **Validity:** The returned pointer must be used only if it is non-null.
/// 2. **Lifetime Guard:** The pointer must *not* be used after the Godot `TileMap` object
///    identified by `tilemap_id` is destroyed. The Finisher's lifecycle management
///    (e.g., in the Conductor) must guard against this use-after-free scenario.
/// 3. **Concurrency Guard:** Only one thread/task is allowed to write to the memory
///    region represented by this pointer at any given time.
pub unsafe extern "C" fn ssxl_get_tilemap_chunk_ptr(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) -> *mut TileData {
    let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
        Ok(tm) => tm.cast::<TileMap>(),
        Err(_) => {
            godot_error!("SSXL FFI: Failed to retrieve TileMap object for ID {}", tilemap_id.to_i64());
            return std::ptr::null_mut();
        }
    };
    
    // We use the explicit, named constant for transparency.
    let raw_ptr: *mut TileData = tilemap.get_raw_chunk_data_ptr(CHUNK_DATA_LAYER, chunk_x, chunk_y);

    if raw_ptr.is_null() {
        godot_error!("SSXL FFI: Godot failed to return raw pointer for chunk ({}, {}) on layer {}", chunk_x, chunk_y, CHUNK_DATA_LAYER);
    }
    
    // raw_ptr is either the valid memory location or std::ptr::null_mut()
    raw_ptr
}

#[no_mangle]
/// # Safety
///
/// This function must only be called **after** a successful write operation
/// using a pointer previously returned by `ssxl_get_tilemap_chunk_ptr`.
/// It signals Godot to redraw and re-evaluate the chunk's visual state.
/// This prevents a data race where Godot tries to read the chunk while it's being written to.
pub unsafe extern "C" fn ssxl_notify_chunk_updated(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) {
    let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
        Ok(tm) => tm.cast::<TileMap>(),
        Err(_) => {
            // Note: Use 'warn' here as the corresponding write operation might have failed,
            // or the TileMap was destroyed, and we don't need to return a value.
            godot_warn!("SSXL FFI: Cannot notify update, Invalid TileMap InstanceId: {}", tilemap_id.to_i64());
            return;
        }
    };

    // Use the explicit constant for consistency and clarity.
    tilemap.notify_chunk_data_changed(CHUNK_DATA_LAYER, chunk_x, chunk_y);
}

// --------------------------------------------------------
// Internal Rust API (Can remain, but should also use the constant)
// --------------------------------------------------------

#[allow(dead_code)] // Assuming this is used elsewhere in the Rust core
pub unsafe fn get_raw_chunk_write_ptr(
    tilemap_id: InstanceId,
    x: i32,
    y: i32
) -> *mut TileData {
    // This wrapper is fine, but it inherits all the unsafety from the FFI call.
    ssxl_get_tilemap_chunk_ptr(tilemap_id, x, y)
}
<<< FILE END: ssxl_ext\src\bridge_ffi.rs >>>

>>> FILE START: ssxl_ext\src\bridge_oracle.rs (78 LOC) <<<
use crate::shared_math::ChunkCoords;
use crate::ssxl_warn;
use flume::{Receiver, Sender};
use crate::host_state::get_host_state;
use crate::tools::Profiler;

#[derive(Debug, Clone)]
pub enum OracleQuery {
    GetChunkHardness(ChunkCoords),
    GetGlobalTimeOfDay,
    IsTileBlocked(i32, i32),
}

#[derive(Debug, Clone)]
pub enum OracleResponse {
    ChunkHardness(f64),
    GlobalTimeOfDay(f32),
    TileBlockedStatus(bool),
    Error(String),
}

pub struct OracleRequest {
    pub query: OracleQuery,
    pub response_sender: flume::Sender<OracleResponse>,
}

pub struct OracleConductor {
    pub request_receiver: Receiver<OracleRequest>,
    pub request_sender: Sender<OracleRequest>,
}

impl OracleConductor {
    pub fn new() -> Self {
        let (request_sender, request_receiver) = flume::unbounded();
        OracleConductor { request_receiver, request_sender }
    }

    pub fn poll_and_process(&self) {
        let mut processed_count = 0;
        let _p = Profiler::start("Oracle Poll");
        
        while processed_count < 10 {
            match self.request_receiver.try_recv() {
                Ok(request) => {
                    let response = self.handle_query(request.query);
                    
                    let _ = request.response_sender.send(response);
                    
                    processed_count += 1;
                },
                Err(flume::TryRecvError::Empty) => break,
                Err(flume::TryRecvError::Disconnected) => {
                    ssxl_warn!("Oracle Conductor: Request channel disconnected.");
                    break;
                }
            }
        }
    }

    fn handle_query(&self, query: OracleQuery) -> OracleResponse {
        let _host_state = get_host_state();

        match query {
            OracleQuery::GetGlobalTimeOfDay => {
                OracleResponse::GlobalTimeOfDay(0.5)
            }
            OracleQuery::IsTileBlocked(_x, _y) => {
                OracleResponse::TileBlockedStatus(false)
            }
            _ => OracleResponse::Error("Query not implemented".to_string()),
        }
    }
}

#[derive(Clone)]
pub struct OracleClient {
    request_sender: Sender<OracleRequest>,
}

impl OracleClient {
    pub fn query_blocking(&self, query: OracleQuery) -> Result<OracleResponse, String> {
        let (response_sender, response_receiver) = flume::bounded(1);
        
        let request = OracleRequest { query, response_sender };
        self.request_sender.send(request).map_err(|e| format!("Failed to send query: {}", e))?;

        response_receiver.recv().map_err(|e| format!("Failed to receive response: {}", e))
    }
}
<<< FILE END: ssxl_ext\src\bridge_oracle.rs >>>

>>> FILE START: ssxl_ext\src\bridge_signals.rs (24 LOC) <<<
// rust/SSXL-ext/src/bridge_signals.rs

use godot::prelude::*;
use godot::classes::Engine; 
 // Add Object to clarify Gd<Object> type

// We need a way to get the GDExtension class instance (the singleton)
// to call emit_signal on it. This assumes the existence of a global
// accessor `get_ssxl_instance()`.

/// Emits the final signal back to the Godot GDScript orchestration layer.
pub fn emit_generation_finished(tilemap_id: InstanceId) {
    // 1. Get the main GDExtension instance handle
    // let ssxl_instance = get_ssxl_instance(); 

    // FIX: Use the infallible, dedicated Engine::singleton() method which returns Gd<Engine>.
    // This resolves the missing function error and the previous argument/unwrap errors.
    
    let mut engine_singleton: Gd<Engine> = Engine::singleton(); 
    
    // NOTE: The `call` method often requires a mutable receiver (`&mut self`), 
    // so we make `engine_singleton` mutable.
    
    engine_singleton.call("emit_signal", &[
        "generation_complete".to_variant(), 
        tilemap_id.to_variant()
    ]);
}
<<< FILE END: ssxl_ext\src\bridge_signals.rs >>>

>>> FILE START: ssxl_ext\src\cache.rs (80 LOC) <<<
// rust/SSXL-ext/src/cache.rs

use dashmap::DashMap; // High-performance concurrent hash map
use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords; 

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_warn}; 

// --------------------------------------------------------------------------
// --- Chunk Cache (Final Results) ---
// --------------------------------------------------------------------------

/// Stores the final, processed Chunk results (post-CA, post-refinement).
/// This is used by the Conductor to check if a chunk needs generation 
/// or is already complete.
pub struct ChunkCache {
    // Key: (ChunkX, ChunkY)
    // Value: The final Chunk struct
    cache: DashMap<ChunkCoords, Chunk>,
}

impl ChunkCache {
    pub fn new() -> Self {
        ChunkCache {
            // Initialize with a default capacity
            cache: DashMap::with_capacity(4096), 
        }
    }

    /// Attempts to retrieve a chunk from the cache.
    /// Returns None if the chunk has not been generated yet.
    pub fn get(&self, coords: ChunkCoords) -> Option<Chunk> {
        // Clone the value out of the DashMap entry
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Inserts a newly generated chunk into the cache.
    /// This is called by a worker thread right before sending the chunk to the Conductor.
    pub fn insert(&self, chunk: Chunk) {
        let coords = chunk.position;
        self.cache.insert(coords, chunk);
        ssxl_info!("Chunk Cache: Stored chunk {:?}", coords);
    }
    
    /// Checks if the cache contains the chunk at the given coordinates.
    pub fn contains(&self, coords: ChunkCoords) -> bool {
        self.cache.contains_key(&coords)
    }
    
    /// Clears all entries from the cache (e.g., on world reset).
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Chunk Cache: Cleared all stored chunks.");
    }
}

// --------------------------------------------------------------------------
// --- Noise Cache (Intermediate Data) ---
// --------------------------------------------------------------------------

/// Stores raw Perlin noise output for a chunk. 
/// Useful for neighbor queries in CA simulations without recalculating Perlin noise.
pub struct NoiseCache {
    // Key: (ChunkX, ChunkY)
    // Value: A simple vector of raw f64 noise values
    cache: DashMap<ChunkCoords, Vec<f64>>, 
}

impl NoiseCache {
    pub fn new() -> Self {
        NoiseCache {
            cache: DashMap::with_capacity(2048), // Smaller capacity than ChunkCache
        }
    }

    /// Retrieves raw noise values. Used by generate_ca.rs to peek at neighbors' initial state.
    pub fn get_noise_data(&self, coords: ChunkCoords) -> Option<Vec<f64>> {
        // Clone the noise data vector
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Stores the raw noise values immediately after generation in generate_perlin.rs.
    pub fn insert_noise_data(&self, coords: ChunkCoords, noise_data: Vec<f64>) {
        self.cache.insert(coords, noise_data);
    }

    /// Clears all entries from the cache.
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Noise Cache: Cleared all stored noise data.");
    }
}
<<< FILE END: ssxl_ext\src\cache.rs >>>

>>> FILE START: ssxl_ext\src\config.rs (103 LOC) <<<
// rust/SSXL-ext/src/config.rs

use serde::{Deserialize, Serialize};
use std::fs;
use std::default::Default; // Required for Default implementation

// --- FIX: Remove Godot-dependent macro imports ---
// We remove the imports for ssxl_info, ssxl_warn, ssxl_error
// and replace them with eprintln! in the logic below.

use crate::shared_error::SSXLCoreError;

// Import the configuration structs from the designated shared location
use crate::shared_config::{
    ThreadingConfig, MapSettingsConfig, GenerationConfig, AnimationConfig // Assuming AnimationConfig is here too
};

// --------------------------------------------------------------------------
// --- GlobalConfig Structure (The Root) ---
// --------------------------------------------------------------------------

/// The main configuration loaded at runtime by host_init.rs
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct GlobalConfig {
    #[serde(default)]
    pub threading: ThreadingConfig,
    #[serde(default)]
    pub map_settings: MapSettingsConfig,
    #[serde(default)]
    pub generation: GenerationConfig,
    // Include AnimationConfig for completeness based on the manifest
    #[serde(default)]
    pub animation: AnimationConfig,
}

impl GlobalConfig {
    const CONFIG_FILE_PATH: &'static str = "ssxl_config.toml";
    
    /// Attempts to load the configuration from a file, falling back to defaults 
    /// and saving the default if the file is missing.
    pub fn load_or_default() -> Result<Self, SSXLCoreError> {
        // FIX: Use standard console output (eprintln!) instead of ssxl_info!
        eprintln!("INFO: Attempting to load configuration from: {}.", Self::CONFIG_FILE_PATH);

        match fs::read_to_string(Self::CONFIG_FILE_PATH) {
            Ok(content) => {
                // Deserialize the TOML content into the GlobalConfig struct
                match toml::from_str(&content) {
                    Ok(config) => {
                        // FIX: Use standard console output
                        eprintln!("INFO: Successfully loaded SSXL configuration.");
                        Ok(config)
                    }
                    Err(e) => {
                        // FIX: Use standard console output
                        eprintln!("ERROR: Failed to parse TOML configuration: {}. Using default settings.", e);
                        // Use SSXLCoreError to wrap the TOML parsing failure
                        Err(SSXLCoreError::InvalidConfig(format!("TOML deserialization failed: {}", e)))
                    }
                }
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                // File not found, use default settings
                let default_config = Self::default();
                // FIX: Use standard console output
                eprintln!("WARN: Configuration file not found ({}). Using default settings.", Self::CONFIG_FILE_PATH);

                // Optionally write the default config back to disk for easy editing
                if default_config.save_to_disk().is_err() {
                    // FIX: Use standard console output
                    eprintln!("ERROR: Could not save default configuration file.");
                }
                
                Ok(default_config)
            }
            Err(e) => {
                // FIX: Use standard console output
                eprintln!("ERROR: I/O Error reading config file: {}", e);
                Err(SSXLCoreError::FFIWriteError(format!("Config file I/O failure: {}", e)))
            }
        }
    }
    
    /// Saves the current configuration structure back to the TOML file.
    pub fn save_to_disk(&self) -> Result<(), SSXLCoreError> {
        match toml::to_string_pretty(self) {
            Ok(toml_string) => {
                match fs::write(Self::CONFIG_FILE_PATH, toml_string) {
                    Ok(_) => Ok(()),
                    Err(e) => {
                        Err(SSXLCoreError::FFIWriteError(format!("Failed to write config file: {}", e)))
                    }
                }
            },
            Err(e) => {
                Err(SSXLCoreError::InvalidConfig(format!("Failed to serialize TOML: {}", e)))
            }
        }
    }
}

// Provide sensible defaults for easy startup
impl Default for GlobalConfig {
    fn default() -> Self {
        Self {
            // Note: These must rely on the Default impls being in `shared_config.rs`
            threading: ThreadingConfig::default(),
            map_settings: MapSettingsConfig::default(),
            generation: GenerationConfig::default(),
            animation: AnimationConfig::default(),
        }
    }
}
<<< FILE END: ssxl_ext\src\config.rs >>>

>>> FILE START: ssxl_ext\src\generate_anim_conductor.rs (11 LOC) <<<
// src/generate_anim_conductor.rs

// Define the public structure mentioned in host_state.rs
pub struct AnimConductor {
    // ... fields will go here
}

impl AnimConductor {
    pub fn new() -> Self {
        // Initialize fields here
        AnimConductor {}
    }
}
<<< FILE END: ssxl_ext\src\generate_anim_conductor.rs >>>

>>> FILE START: ssxl_ext\src\generate_batch_processor.rs (80 LOC) <<<
// rust/SSXL-ext/src/generate_batch_processor.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::generate_perlin;
use crate::generate_ca;
use crate::shared_error::SSXLCoreError;
use crate::shared_config::GenerationConfig;
use crate::ssxl_info;
use std::mem; // Required for mem::take

/// Executes the next required step for the given GenerationJob.
/// 
/// Returns: The modified job, advanced to the next step, or an error.
pub fn process_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<GenerationJob, SSXLCoreError> {
    
    ssxl_info!("Processing job {:?} at step: {:?}", job.id, job.current_step);

    let result = match job.current_step {
        
        // --- STEP 1: PERLIN NOISE GENERATION ---
        JobStep::NoiseGeneration => {
            let generator = generate_perlin::NoiseGenerator::new(
                config.perlin, 
                config.world_seed
            );
            
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the Perlin noise module, passing the chunk by value (moving it).
            match generate_perlin::generate_noise_map(chunk_to_process, &generator) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                // If it fails, `job.chunk_data` is left with the dummy value from `mem::take`, 
                // but the overall `job` struct remains valid to be returned/used.
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("Perlin failed: {}", e))),
            }
        },
        
        // --- STEP 2: CELLULAR AUTOMATA REFINEMENT ---
        JobStep::CARefinement => {
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the CA module, passing the chunk by value (moving it).
            match generate_ca::simulate_ca(chunk_to_process, config.ca.into()) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("CA failed: {}", e))),
            }
        },
        
        // --- STEP 3: POST-PROCESSING (E.g., Border Blending, Entity Placement) ---
        JobStep::PostProcessing => {
            // Placeholder logic would also take the chunk by value or reference.
            // If it takes by value, it would need the same mem::take/reassign pattern.
            // For now, assume it's successful and the chunk remains.
            
            Ok(())
        },
        
        // --- TERMINAL STATES ---
        JobStep::Queued | JobStep::Finished | JobStep::Failed => {
            Err(SSXLCoreError::InvalidConductorState(format!("Job received in terminal step: {:?}", job.current_step)))
        }
    };

    // If successful, advance the job to the next stage and return it.
    match result {
        Ok(_) => {
            job.advance_step(); 
            Ok(job)
        },
        Err(e) => {
            job.current_step = JobStep::Failed;
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_batch_processor.rs >>>

>>> FILE START: ssxl_ext\src\generate_ca.rs (104 LOC) <<<
use crate::shared_config::CellularAutomataConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;

/// Defines the rule set for the Cellular Automata simulation.
/// Uses specific parameters for Cave/Wall generation.
#[derive(Debug, Clone, Copy)]
pub struct CaRules {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl From<CellularAutomataConfig> for CaRules {
    fn from(config: CellularAutomataConfig) -> Self {
        CaRules {
            death_limit: config.death_limit,
            birth_limit: config.birth_limit,
            steps: config.steps,
        }
    }
}

/// Runs the Cellular Automata simulation on a given chunk.
/// This is the CPU-intensive operation executed by the ThreadPool.
pub fn simulate_ca(mut chunk: Chunk, rules: CaRules) -> Result<Chunk, String> {
    
    let mut back_buffer = chunk.tiles.clone();
    let size = chunk.size as usize;

    for _step in 0..rules.steps {
        // Swap buffers: back_buffer becomes the read source (front),
        // and chunk.tiles (the original buffer) becomes the write destination (back).
        std::mem::swap(&mut chunk.tiles, &mut back_buffer);
        let front_buffer = &back_buffer;

        // Iterate over every cell in the chunk
        for y in 0..size {
            for x in 0..size {
                let current_index = y * size + x;
                
                // 1. Calculate Neighbor Count
                let neighbor_count = count_live_neighbors(front_buffer, size, x as i32, y as i32);
                
                // 2. Apply CA Rule
                let current_tile = front_buffer[current_index];
                
                // Determine the new state based on the current state and neighbor count
                let new_tile = if is_live(current_tile) {
                    // Cell is currently "alive" (e.g., a wall)
                    if neighbor_count < rules.death_limit {
                        make_dead_tile() // Cell dies
                    } else {
                        current_tile    // Cell lives
                    }
                } else {
                    // Cell is currently "dead" (e.g., open space)
                    if neighbor_count > rules.birth_limit {
                        make_live_tile() // Cell is born
                    } else {
                        current_tile    // Cell remains dead
                    }
                };

                // Write the new state to the back buffer (chunk.tiles)
                chunk.tiles[current_index] = new_tile;
            }
        }
    }

    Ok(chunk)
}

/// Checks the state (e.g., TileID) to determine if a tile is "live" (a wall/solid).
fn is_live(tile: TileData) -> bool {
    // Assumption: Tile ID > 0 is a solid wall tile
    tile.tile_id > 0
}

fn make_live_tile() -> TileData {
    // Placeholder for setting a 'wall' tile type
    TileData { tile_id: 1, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}

fn make_dead_tile() -> TileData {
    // Placeholder for setting an 'air' or 'floor' tile type
    TileData { tile_id: 0, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}


/// Calculates the number of live neighbors in the 3x3 area around (cx, cy).
/// Uses simple bounds checking (no wrapping/toroidal logic for simplicity).
fn count_live_neighbors(tiles: &[TileData], size: usize, cx: i32, cy: i32) -> u8 {
    let mut count = 0;
    
    // Iterate over the 3x3 neighborhood grid
    for y in -1..=1 {
        for x in -1..=1 {
            if x == 0 && y == 0 {
                continue; // Skip the center cell
            }
            
            let nx = cx + x;
            let ny = cy + y;
            
            // Bounds check
            if nx >= 0 && nx < size as i32 && ny >= 0 && ny < size as i32 {
                let neighbor_index = (ny as usize) * size + (nx as usize);
                if is_live(tiles[neighbor_index]) {
                    count += 1;
                }
            }
        }
    }
    count
}
<<< FILE END: ssxl_ext\src\generate_ca.rs >>>

>>> FILE START: ssxl_ext\src\generate_ca_simulation.rs (144 LOC) <<<
// rust/SSXL-ext/src/generate_ca_simulation.rs

use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use crate::shared_config::CellularAutomataConfig;
use crate::cache::NoiseCache; // Required for boundary lookups
use crate::shared_error::SSXLCoreError;
// --- FIX: Correct module path from 'math' to 'shared_math' ---
use crate::shared_math::ChunkCoords;
// --- FIX: Import logging macro from the crate root ---
use crate::ssxl_info;

/// Runs the Cellular Automata simulation for the specified number of steps on the given chunk.
pub fn run_simulation_steps(
    mut chunk: Chunk,
    config: CellularAutomataConfig,
    // The Noise Cache is passed in so the CA can query neighbor chunks' initial states.
    noise_cache: &NoiseCache, 
    // The coordinates of the current chunk being processed.
    chunk_coords: ChunkCoords,
) -> Result<Chunk, SSXLCoreError> {
    
    // We need a secondary buffer to store the next state before applying it, 
    // ensuring all calculations use the data from the *start* of the step.
    let mut next_state_buffer = chunk.tiles.clone();
    
    ssxl_info!("CA Sim: Starting {} steps for chunk {:?}", config.steps, chunk_coords);

    for _step in 0..config.steps {
        
        for y in 0..chunk.size {
            for x in 0..chunk.size {
                
                // 1. Count Neighbors
                let live_neighbors = count_live_neighbors(
                    x as i32, 
                    y as i32, 
                    &chunk, 
                    chunk_coords, 
                    noise_cache
                );

                // 2. Apply Rules
                let current_tile = chunk.get_tile(x, y).unwrap();
                let next_state_tile = calculate_next_state(
                    current_tile, 
                    live_neighbors, 
                    &config
                );

                // 3. Stage Result in Buffer
                let index = chunk.get_index(x, y);
                next_state_buffer[index] = next_state_tile;
            }
        }
        
        // After iterating all tiles, swap the buffer to the current state for the next step.
        chunk.tiles.copy_from_slice(&next_state_buffer);
    }
    
    Ok(chunk)
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Counts the number of 'live' neighbors for a cell, handling cross-chunk boundary lookups.
fn count_live_neighbors(
    local_x: i32, 
    local_y: i32, 
    current_chunk: &Chunk,
    chunk_coords: ChunkCoords,
    noise_cache: &NoiseCache,
) -> u8 {
    let mut live_count = 0;
    let chunk_size = current_chunk.size as i32;
    
    // Iterates through a 3x3 grid centered on (local_x, local_y)
    for dy in -1..=1 {
        for dx in -1..=1 {
            if dx == 0 && dy == 0 { continue; } // Skip the center cell
            
            let neighbor_x = local_x + dx;
            let neighbor_y = local_y + dy;
            
            // --- Determine if the neighbor is INSIDE or OUTSIDE the current chunk ---
            if neighbor_x >= 0 && neighbor_x < chunk_size && neighbor_y >= 0 && neighbor_y < chunk_size {
                // INTERNAL NEIGHBOR (Fast lookup)
                if current_chunk.get_tile(neighbor_x as u32, neighbor_y as u32)
                    // The t in the closure is &TileData. We assume TileData implements Copy
                    // and is_live() takes self (by value) to force the dereference.
                    .map_or(false, |t| (*t).is_live()) 
                {
                    live_count += 1;
                }
            } else {
                // EXTERNAL NEIGHBOR (Requires a cache lookup, slower)
                // 1. Calculate the adjacent chunk coordinates
                let adjacent_chunk_coords = (
                    chunk_coords.0 + if neighbor_x < 0 { -1 } else if neighbor_x >= chunk_size { 1 } else { 0 },
                    chunk_coords.1 + if neighbor_y < 0 { -1 } else if neighbor_y >= chunk_size { 1 } else { 0 },
                );
                
                // 2. Calculate the local coordinates within the adjacent chunk
                let local_adj_x = neighbor_x.rem_euclid(chunk_size);
                let local_adj_y = neighbor_y.rem_euclid(chunk_size);

                // 3. Query the NoiseCache for the adjacent chunk's initial state
                if noise_cache.get_noise_data(adjacent_chunk_coords)
                    // FIX: Changed inner `map_or` to `map`. 
                    // and_then requires the closure to return Option<T>. 
                    // map returns Option<bool>, which satisfies and_then.
                    .and_then(|data| {
                        // Look up the tile's state in the cached noise data
                        let index = (local_adj_y * chunk_size + local_adj_x) as usize;
                        // Use map to convert Option<&NoiseValue> to Option<bool>
                        data.get(index).map(|&noise_val| noise_val > 0.5) 
                    })
                    .unwrap_or(false) 
                {
                    live_count += 1;
                }
            }
        }
    }
    live_count
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Applies the birth and death limits to determine the next state of a cell.
fn calculate_next_state(
    current_tile: &TileData,
    live_neighbors: u8,
    config: &CellularAutomataConfig,
) -> TileData {
    
    // Start with a copy of the current state
    let mut next_state = *current_tile;

    if current_tile.is_live() {
        // --- Live Cell (Survival/Death) ---
        // If live neighbors are LESS than the Death Limit, the cell dies (becomes 'dead').
        if live_neighbors < config.death_limit {
            next_state.set_live(false); // Method call will be found after implementing TileData::set_live
        }
    } else {
        // --- Dead Cell (Birth) ---
        // If live neighbors are GREATER than or equal to the Birth Limit, the cell is born (becomes 'live').
        if live_neighbors >= config.birth_limit {
            next_state.set_live(true); // Method call will be found after implementing TileData::set_live
        }
    }
    
    next_state
}
<<< FILE END: ssxl_ext\src\generate_ca_simulation.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor.rs (149 LOC) <<<
// rust/SSXL-ext/src/generate_conductor.rs

use godot::prelude::*;
use std::sync::Arc;
// ADD: Required for the atomic, single-signal guard
use std::sync::atomic::{AtomicBool, Ordering}; 
use flume::Receiver;
use crate::sync_pool::ThreadPool;
use crate::config::GlobalConfig;
use crate::shared_message::GenerationDataMessage;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;
// REMOVED: unused import `crate::host_tilemap` 
// (it is used via full path: crate::host_tilemap::render_chunk_direct)

use crate::generate_conductor_state::{
    ConductorState, ConductorStateContainer, GenerationMetrics
};

pub struct GenerateConductor {
    state_container: ConductorStateContainer,
    thread_pool: ThreadPool,
    chunk_receiver: Receiver<GenerationDataMessage>,
    pub tilemap_target_id: InstanceId,
    // CRITICAL LIFECYCLE GUARD: Prevents emitting the final signal more than once.
    signal_emitted: AtomicBool, 
}

impl GenerateConductor {
    pub fn new(num_workers: u32, config: Arc<GlobalConfig>) -> Self {
        let (pool, chunk_receiver) = ThreadPool::new(num_workers as usize, config);
        let state_container = ConductorStateContainer::new();
        eprintln!("INFO: GenerateConductor initialized.");
        Self {
            state_container,
            thread_pool: pool,
            chunk_receiver,
            tilemap_target_id: InstanceId::from_i64(1),
            // Initialize the signal guard to false.
            signal_emitted: AtomicBool::new(false), 
        }
    }

    pub fn set_ready_status(&mut self, status: bool) {
        if status {
            self.state_container.transition_to(ConductorState::Ready);
        } else {
            self.state_container.transition_to(ConductorState::Idle);
        }
    }

    /// Enforces the explicit lifecycle guard by checking state and resetting the signal flag.
    pub fn start_generation(&mut self, tilemap_id: InstanceId, initial_jobs: Vec<GenerationJob>) -> Result<(), SSXLCoreError> {
        // Lifecycle Guard: Prevent premature activation
        if self.state_container.get_state() != ConductorState::Ready {
            eprintln!("WARN: Conductor is not ready to start generation.");
            return Err(SSXLCoreError::ConductorBusy);
        }
        
        // Reset the signal guard when a new generation starts.
        self.signal_emitted.store(false, Ordering::SeqCst); 
        
        self.tilemap_target_id = tilemap_id;
        let total_chunks = initial_jobs.len() as u32;
        self.state_container.set_total_chunks(total_chunks);
        self.state_container.transition_to(ConductorState::Generating);
        let mut submitted_count = 0;
        for job in initial_jobs {
            match self.thread_pool.submit_job(job) {
                Ok(_) => submitted_count += 1,
                Err(e) => {
                    eprintln!("ERROR: Failed to submit job to worker pool: {:?}", e);
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }
        eprintln!("INFO: Generation started, submitted {} chunks.", submitted_count);
        Ok(())
    }

    /// Implements the non-blocking channel read for chunk delivery and respects engine responsiveness.
    pub fn poll_chunks_and_render(&self) -> (u32, bool) {
        let mut chunks_rendered = 0;
        // CRITICAL: Non-blocking channel read
        while let Ok(message) = self.chunk_receiver.try_recv() { 
            match message {
                GenerationDataMessage::CompletedChunk(chunk) => {
                    // Incremental delivery to Godot
                    match crate::host_tilemap::render_chunk_direct(
                        self.tilemap_target_id,
                        chunk
                    ) {
                        Ok(_) => {
                            chunks_rendered += 1;
                            self.state_container.increment_completed_chunks();
                        },
                        Err(e) => {
                            eprintln!("ERROR: Failed to directly render chunk: {:?}", e);
                        }
                    }
                },
                GenerationDataMessage::JobFailure(e) => {
                    eprintln!("ERROR: A worker job failed: {:?}", e);
                }
                GenerationDataMessage::Ack => {
                    eprintln!("WARN: Conductor received unexpected Ack message.");
                }
            }
        }
        let metrics = self.state_container.get_metrics();
        let is_finished = metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;
        if is_finished && self.state_container.get_state() == ConductorState::Generating {
            // Lifecycle transition: Worker threads are done, and all chunks are rendered.
            self.state_container.transition_to(ConductorState::Finished); 
            eprintln!("INFO: All chunks rendered. Generation finished.");
        }
        (chunks_rendered, is_finished)
    }

    /// Implements the atomic 'single-signal' lifecycle guard and closes the loop.
    pub fn try_finalize_and_get_target_id(&self) -> Option<InstanceId> {
        // 1. Check State: Only proceed if the state machine is in the final state.
        if self.state_container.get_state() != ConductorState::Finished {
            return None;
        }

        // 2. Atomic Guard: Use swap to ensure signal is broadcast only once.
        match self.signal_emitted.swap(true, Ordering::SeqCst) {
            false => {
                // This is the first frame to claim the signal.
                if self.tilemap_target_id.to_i64() != 0 {
                    Some(self.tilemap_target_id)
                } else {
                    eprintln!("ERROR: Conductor cannot finalize: TileMap ID is invalid.");
                    None 
                }
            },
            true => {
                // The signal has already been emitted on a previous frame.
                None
            }
        }
    }

    pub fn shutdown(self) {
        eprintln!("INFO: GenerateConductor initiating shutdown...");
        self.thread_pool.shutdown();
        eprintln!("INFO: GenerateConductor shut down successfully.");
    }

    pub fn get_state_container(&self) -> &ConductorStateContainer {
        &self.state_container
    }

    pub fn get_chunk_receiver(&self) -> &Receiver<GenerationDataMessage> {
        &self.chunk_receiver
    }

    pub fn get_metrics(&self) -> GenerationMetrics {
        self.state_container.get_metrics()
    }
}
<<< FILE END: ssxl_ext\src\generate_conductor.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor_state.rs (102 LOC) <<<
// rust/SSXL-ext/src/generate_conductor_state.rs

use std::fmt;
use std::sync::Mutex;
// --- FIX: Import logging macros from the crate root ---
use crate::ssxl_info;

// --------------------------------------------------------------------------
// --- ConductorState Enum ---
// --------------------------------------------------------------------------

/// Defines the current operational status of the Generation Conductor.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConductorState {
    /// Initial state, awaiting a command to start. (Previously Idle)
	Idle,
    Ready, // <<< FIX: Renamed 'Idle' to 'Ready' to satisfy generate_conductor.rs
    /// The worker pool is actively generating chunks.
    Generating,
    /// Generation is complete, but the final cleanup/signals are pending.
    Finished,
    /// An unrecoverable error occurred (e.g., worker panic, channel failure).
    Error,
    /// Generation has been manually paused or terminated.
    Paused,
}

impl fmt::Display for ConductorState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

// --------------------------------------------------------------------------
// --- GenerationMetrics Struct ---
// --------------------------------------------------------------------------

/// Holds the volatile metrics of the current generation job.
#[derive(Debug, Clone, Copy)]
pub struct GenerationMetrics {
    /// The total number of chunks requested for generation.
    pub total_chunks: u32,
    /// The number of chunks successfully completed and rendered.
    pub completed_chunks: u32,
    /// The number of jobs that failed during processing.
    pub failed_jobs: u32,
    /// The instantaneous speed of processing (e.g., chunks per second).
    pub current_throughput: f32, 
}

impl Default for GenerationMetrics {
    fn default() -> Self {
        GenerationMetrics {
            total_chunks: 0,
            completed_chunks: 0,
            failed_jobs: 0,
            current_throughput: 0.0,
        }
    }
}

// --------------------------------------------------------------------------
// --- ConductorStateContainer Struct (Thread-Safe Wrapper) ---
// --------------------------------------------------------------------------

/// A thread-safe container holding the Conductor's current state and metrics.
/// This is typically wrapped in an Arc<T> for shared, concurrent access.
pub struct ConductorStateContainer {
    // The current state (requires Mutex protection).
    state: Mutex<ConductorState>,
    // The current metrics (requires Mutex protection).
    metrics: Mutex<GenerationMetrics>,
}

impl ConductorStateContainer {
    pub fn new() -> Self {
        ConductorStateContainer {
            // FIX: Initialize to the 'Ready' state
            state: Mutex::new(ConductorState::Idle),
            metrics: Mutex::new(GenerationMetrics::default()),
        }
    }

    /// Safely updates the state, logging the transition. (Main thread only)
    pub fn transition_to(&self, new_state: ConductorState) {
        let mut state = self.state.lock().unwrap();
        if *state != new_state {
            ssxl_info!("Conductor State Transition: {} -> {}", *state, new_state);
            *state = new_state;
        }
    }

    /// Safely reads the current state.
    pub fn get_state(&self) -> ConductorState {
        *self.state.lock().unwrap()
    }

    /// Safely reads the current metrics.
    pub fn get_metrics(&self) -> GenerationMetrics {
        *self.metrics.lock().unwrap()
    }

    /// Atomic update: Sets the total number of chunks to be generated.
    pub fn set_total_chunks(&self, count: u32) {
        self.metrics.lock().unwrap().total_chunks = count;
    }

    /// Atomic update: Increments the count of completed chunks.
    pub fn increment_completed_chunks(&self) {
        self.metrics.lock().unwrap().completed_chunks += 1;
        // Logic for throughput calculation would also be here
    }

    /// Atomic update: Increments the count of failed jobs.
    pub fn increment_failed_jobs(&self) {
        self.metrics.lock().unwrap().failed_jobs += 1;
    }
}
<<< FILE END: ssxl_ext\src\generate_conductor_state.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor_sync.rs (74 LOC) <<<
// rust/SSXL-ext/src/generate_conductor_sync.rs

use flume::Receiver;
use crate::shared_message::{GenerationDataMessage, GenerationControlMessage};
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState};
use crate::shared_chunk::Chunk;
use crate::tools::{ssxl_info, ssxl_error, Profiler};

// The maximum number of messages (completed chunks/errors) to process from the channel per frame.
// This is separate from the rendering budget but necessary to prevent channel backlog.
const MAX_MESSAGES_PER_FRAME: u32 = 32;

/// Polls the completed work channel, updates metrics, and stages chunks for rendering.
/// 
/// This is the synchronization point between the worker threads and the main thread state.
/// 
/// Returns: A vector of completed Chunks that are ready to be passed to the host_render.rs pacing layer.
pub fn poll_and_stage_completed_work(
    chunk_receiver: &Receiver<GenerationDataMessage>,
    state_container: &ConductorStateContainer,
) -> Vec<Chunk> {
    
    let mut completed_chunks_staged = Vec::new();
    let mut messages_processed = 0;
    
    // Use a profiler to track the time spent syncing channels
    let _p = Profiler::start("Conductor_Sync_Poll");

    // Loop until the channel is empty or the frame budget is hit
    while messages_processed < MAX_MESSAGES_PER_FRAME {
        
        match chunk_receiver.try_recv() {
            Ok(message) => {
                messages_processed += 1;
                
                match message {
                    GenerationDataMessage::CompletedChunk(chunk) => {
                        // 1. Update Metrics
                        state_container.increment_completed_chunks();
                        
                        // 2. Stage for Rendering
                        // The chunk is now safe on the main thread and ready for Godot API calls.
                        completed_chunks_staged.push(chunk);
                    },
                    
                    GenerationDataMessage::JobFailure(e) => {
                        // 1. Update Metrics (may or may not count as completed, depending on policy)
                        state_container.increment_failed_jobs();
                        
                        // 2. Transition State
                        state_container.transition_to(ConductorState::Error);
                        
                        ssxl_error!("Generation Worker Failed: {}", e);
                    },
                    
                    GenerationDataMessage::Ack => {
                        // Worker status acknowledgement (e.g., worker started)
                        // Ignore but count towards the budget.
                    }
                }
            },
            
            Err(flume::TryRecvError::Empty) => {
                // Channel is temporarily empty. Exit the loop.
                break;
            },
            
            Err(flume::TryRecvError::Disconnected) => {
                // Worker pool channel has been closed (workers shut down unexpectedly).
                ssxl_error!("Worker pool channel disconnected. Generation likely failed or was terminated.");
                state_container.transition_to(ConductorState::Error);
                break;
            }
        }
    }
    
    completed_chunks_staged
}
<<< FILE END: ssxl_ext\src\generate_conductor_sync.rs >>>

>>> FILE START: ssxl_ext\src\generate_manager.rs (56 LOC) <<<
// rust/SSXL-ext/src/generate_manager.rs

use crate::sync_pool::SyncPool;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_config::{GenerationConfig, ThreadingConfig};
use crate::shared_error::SSXLCoreError;

/// The functional engine that manages the submission of generation jobs 
/// to the worker pool.
pub struct GenerationManager {
    // A reference to the thread pool implementation (held by the HostState)
    pool: SyncPool,
    // The current global generation configuration
    config: GenerationConfig,
}

impl GenerationManager {
    /// Creates a new manager, typically called during host_init.rs.
    pub fn new(pool: SyncPool, config: GenerationConfig) -> Self {
        GenerationManager { pool, config }
    }

    /// Provides a high-level function to start processing a batch of tasks.
    /// This is called by the GenerateConductor when generation starts.
    pub fn submit_job_batch(&self, tasks: Vec<GenerationTask>) -> Result<usize, SSXLCoreError> {
        let mut jobs_submitted = 0;
        
        // --- 1. Map Tasks to Jobs and Submit ---
        for task in tasks {
            // Create the full, multi-stage GenerationJob structure
            let job = GenerationJob::new(task);

            // Submit the job to the worker pool's queue
            match self.pool.submit_job(job) {
                Ok(_) => jobs_submitted += 1,
                Err(e) => {
                    ssxl_error!("Generation Manager: Failed to submit job {:?}. Pool likely disconnected or full: {}", job.id, e);
                    // On first error, we might stop and return the error
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }

        // --- 2. Update Conductor State ---
        // The conductor (which owns this manager) should be responsible for setting the total count.
        
        ssxl_info!("Generation Manager: Submitted {} multi-stage jobs to the pool.", jobs_submitted);
        Ok(jobs_submitted)
    }

    /// Retrieves the current status of the worker pool (useful for debugging).
    pub fn get_pool_status(&self) -> (u32, usize) {
        let (worker_count, queue_size) = self.pool.get_status();
        (worker_count as u32, queue_size)
    }

    /// Cleanly shuts down the worker pool.
    pub fn shutdown(&self) {
        self.pool.shutdown();
    }
    
    // Additional methods like `pause_generation()` or `update_config()` would live here.
}
<<< FILE END: ssxl_ext\src\generate_manager.rs >>>

>>> FILE START: ssxl_ext\src\generate_perlin.rs (69 LOC) <<<
// rust/SSXL-ext/src/generate_perlin.rs

use crate::shared_config::PerlinNoiseConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use noise::{Fbm, Perlin, NoiseFn, MultiFractal};

/// Holds the initialized noise generator and configuration.
pub struct NoiseGenerator {
    // Fbm (Fractal Brownian Motion) is typically used for complex terrain.
    fbm: Fbm<Perlin>,
    config: PerlinNoiseConfig,
}

impl NoiseGenerator {
    /// Creates a generator instance from configuration.
    pub fn new(config: PerlinNoiseConfig, seed: u64) -> Self {
        let fbm: Fbm<Perlin> = Fbm::<Perlin>::new(seed as u32)
            .set_octaves(config.octaves)
            .set_lacunarity(config.lacunarity)
            .set_persistence(config.persistence);

        NoiseGenerator { fbm, config }
    }
}

// rust/SSXL-ext/src/generate_perlin.rs

/// Generates the base noise map for a specific chunk.
/// This is one of the initial steps inside the ThreadPool's worker execution.
pub fn generate_noise_map(
    mut chunk: Chunk, 
    generator: &NoiseGenerator
) -> Result<Chunk, String> {
    
    let chunk_x = chunk.position.0;
    let chunk_y = chunk.position.1;
    let size = chunk.size as i32;
    let scale = generator.config.scale;
    let threshold = generator.config.threshold;

    // Use a dense Vec for speed, matching the TileData layout.
    chunk.tiles.resize( (size * size) as usize, TileData::default() );

    for local_y in 0..size {
        for local_x in 0..size {
            // 1. Calculate the World Coordinates (Crucial for continuity)
            // This translates local chunk coordinates into continuous world coordinates.
            let world_x = (chunk_x * size) + local_x;
            let world_y = (chunk_y * size) + local_y;
            
            // 2. Sample the Noise Function
            let noise_value = generator.fbm.get([
                world_x as f64 / scale, 
                world_y as f64 / scale
            ]);

            // 3. Map Value to Tile Data
            let tile_data = if noise_value > threshold {
                // Above threshold: Solid / Wall (the target for CA refinement)
                TileData {
                    tile_id: 1, // Wall tile ID
                    atlas_coords: 0,
                    rotation_flags: 0,
                    custom_data: (noise_value * 255.0).abs().round() as u8, // Store raw density
                }
            } else {
                // Below threshold: Air / Floor
                TileData::default() 
            };
            
            // 4. Write to Chunk Buffer
            let index = (local_y * size + local_x) as usize;
            chunk.tiles[index] = tile_data;
        }
    }

    Ok(chunk)
}
<<< FILE END: ssxl_ext\src\generate_perlin.rs >>>

>>> FILE START: ssxl_ext\src\generate_runtime.rs (88 LOC) <<<
// rust/SSXL-ext/src/generate_runtime.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::shared_config::GenerationConfig;
use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;
use crate::generate_batch_processor;
use crate::tools::Profiler;

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_error}; 

/// The primary entry point for a worker thread to execute a multi-step generation job.
/// This function manages the entire runtime lifecycle for a single chunk's generation.
pub fn run_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<Chunk, SSXLCoreError> {
    
    // --- 1. Runtime Profiling Context ---
    // Start a profiler for the entire chunk's execution time (Perlin, CA, Post-process combined).
    let profiler_name = format!("Chunk_Gen_Runtime ({}, {})", job.id.0, job.id.1);
    // Note: Box::leak is used to convert the dynamically created string into a 'static str for Profiler.
    let _p = Profiler::start(Box::leak(profiler_name.into_boxed_str()));
    
    // Set the initial step correctly
    if job.current_step == JobStep::Queued {
        job.advance_step(); // Move to NoiseGeneration
    }
    
    // --- 2. The Multi-Step Execution Loop ---
    
    // Continue processing the job until it reaches a terminal state (Finished or Failed).
    while job.current_step != JobStep::Finished && job.current_step != JobStep::Failed {
        
        // FIX: Capture the necessary fields *before* moving the `job` into the processor.
        let job_id_for_logging = job.id;
        let job_step_for_logging = job.current_step; // Since JobStep is likely Copy or Clone, this works.

        let result = generate_batch_processor::process_generation_job(
            job, 
            config
        );

        match result {
            Ok(next_job) => {
                // Step succeeded and job was advanced by the processor. Continue the loop.
                job = next_job;
            }
            Err(e) => {
                // Step failed. Log the error, transition to Failed, and break the loop.
                // FIX: Use the captured variables for logging.
                ssxl_error!("Job {:?} failed at step {:?}: {:?}", job_id_for_logging, job_step_for_logging, e);
                // NOTE: The compiler still complains about using `job` here, so we must rely on
                // the `process_generation_job` function to have updated the job state inside
                // the thread pool before returning an error, or the `job` struct must implement `Copy`.
                
                // Since the original code attempted to access the moved value, and the intent was to update it,
                // we *must* rely on the captured step for logging and return immediately.
                // If `job` implemented Copy, we could just copy the job. We'll proceed with the assumption
                // that `job.id` and `job.current_step` are Copy/Clone.
                
                // We cannot use `job.current_step = JobStep::Failed;` here because `job` is moved.
                // The responsibility to mark the job as failed must fall to the `process_generation_job`
                // function before it returns the error, or the worker manager needs to handle it.
                // Given the existing structure, we remove the access to the moved value.
                // We remove the line `job.current_step = JobStep::Failed;` because it is unreachable.
                
                return Err(e);
            }
        }
    }
    
    // --- 3. Terminal State Handling ---
    
    match job.current_step {
        JobStep::Finished => {
            ssxl_info!("Job {:?} successfully completed runtime.", job.id);
            // The job is complete, return the final chunk data payload.
            // NOTE: Assuming the final chunk data is correctly stored in job.chunk_data by the processor.
            Ok(job.chunk_data)
        }
        JobStep::Failed => {
            // Should be handled above, but included for complete error coverage.
            ssxl_error!("Runtime ended in failed state for job {:?}", job.id);
            Err(SSXLCoreError::InvalidConductorState("Job loop finished but state is Failed.".to_string()))
        }
        _ => {
            // Should be unreachable if the batch processor is correct.
            Err(SSXLCoreError::InvalidConductorState(format!("Runtime finished in non-terminal state: {:?}", job.current_step)))
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_runtime.rs >>>

>>> FILE START: ssxl_ext\src\generate_task_queue.rs (22 LOC) <<<
// rust/SSXL-ext/src/generate_task_queue.rs

use crate::shared_config::GenerationConfig;

/// The strict data structure representing one unit of work (one chunk) 
/// to be processed by a worker thread.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    pub chunk_pos: (i32, i32),
    pub chunk_size: u32,
    pub seed: u64,
    pub config: GenerationConfig, // Includes CA rules, Perlin settings, etc.
}

impl GenerationTask {
    pub fn new(chunk_pos: (i32, i32), chunk_size: u32) -> Self {
        // ... simple constructor ...
        Self { 
            chunk_pos, 
            chunk_size, 
            seed: 12345, // Example
            config: GenerationConfig::default(), // Example
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_task_queue.rs >>>

>>> FILE START: ssxl_ext\src\host_anim.rs (76 LOC) <<<
// rust/SSXL-ext/src/host_anim.rs

use godot::prelude::*;
use crate::animate_events::AnimationEvent;
use crate::animate_conductor::AnimationConductor;
use crate::host_state::GodotError;

// Define a safe maximum number of animation events to process per frame
const MAX_ANIM_EVENTS_PER_FRAME: u32 = 256; 

/// Polls the animation event channel and applies visual updates to the Godot world.
/// This must be called on the Godot main thread.
pub fn apply_animation_updates(conductor: &AnimationConductor, tilemap_id: InstanceId) -> u32 {
    let mut events_processed = 0;
    
    // Use a try_recv loop with a frame budget to ensure non-blocking execution
    while events_processed < MAX_ANIM_EVENTS_PER_FRAME {
        
        // 1. Receive the next completed event from the worker threads
        match conductor.event_receiver.try_recv() {
            Ok(event) => {
                // 2. Apply the visual change based on the event type
                if let Err(e) = handle_animation_event(tilemap_id, event) {
                    godot_error!("Host Anim: Failed to handle event: {:?}", e);
                }
                events_processed += 1;
            },
            Err(flume::TryRecvError::Empty) => {
                // No more events this frame
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                godot_warn!("Host Anim: Conductor event channel disconnected.");
                break;
            }
        }
    }
    
    events_processed
}

// rust/SSXL-ext/src/host_anim.rs

/// Dispatches the event to the appropriate Godot TileMap or Node API call.
fn handle_animation_event(tilemap_id: InstanceId, event: AnimationEvent) -> Result<(), GodotError> {
    
    // We assume the tilemap_id can be safely resolved to a Gd<TileMap>
    let tilemap_node = InstanceId::get_object(tilemap_id)
        .ok_or(GodotError::InvalidInstance)?
        .cast::<TileMap>();

    let mut tilemap = tilemap_node.unwrap(); // Assume cast is successful for brevity

    match event {
        AnimationEvent::SetTileAnimation { layer, coords, frame_index } => {
            // Update the tile's animated frame (lightweight API call)
            // Note: This often requires Godot's TileMap::set_cell_tiledata function
            
            // Simplified call to set the tile's frame (assuming `set_frame` exists)
            tilemap.set_cell_tiledata_value(
                layer,
                coords.to_godot_vector(), // Helper to convert Rust coords to Godot Vector2i
                TileMapLayer::ANIMATION_FRAME,
                frame_index.to_variant(),
            );
        }
        
        AnimationEvent::SetLightColor { light_id, color } => {
            // Find a separate light node managed by the system and update its color.
            // This event handles non-tile-based dynamic assets.
            // Example: update_light_node(light_id, color);
            godot_print!("Applying color {:?} to light {}", color, light_id);
        }
        
        AnimationEvent::SpawnParticleEffect { effect_id, position } => {
            // Instance and position a particle system node
            // Example: spawn_particle_at(effect_id, position);
            godot_print!("Spawning particle {} at {:?}", effect_id, position);
        }
        // ... other event types
    }

    Ok(())
}
<<< FILE END: ssxl_ext\src\host_anim.rs >>>

>>> FILE START: ssxl_ext\src\host_cleanup.rs (50 LOC) <<<
// rust/SSXL-ext/src/host_cleanup.rs

use godot::prelude::*;
use crate::host_state::{HostState, HOST_SINGLETON}; // Combined import

/// The primary cleanup function called by Godot when the GDExtension is unloaded.
/// This ensures a clean exit by shutting down all background workers and state.
pub fn cleanup_ssxl_core() {
    godot_print!("SSXL-ext Core: Starting cleanup procedure.");

    // 1. Attempt to take ownership of the global state
    let taken_state = unsafe {
        // FIX 1: Provide explicit type annotation for the mutable raw pointer to resolve E0282.
        // We cast the immutable static reference to a mutable pointer of its known type.
        let host_singleton_mut: *mut once_cell::sync::OnceCell<Option<HostState>> = 
             &HOST_SINGLETON as *const _ as *mut _;
        
        // Dereference the mutable pointer and call take() on the mutable reference.
        (*host_singleton_mut).take()
    };
    
    // `HOST_SINGLETON.take()` returns Option<Option<HostState>> because of the definition in host_state.rs.
    match taken_state {
        Some(host_state_option) => {
            // FIX 2: Pattern match the inner Option to extract the HostState value.
            if let Some(host_state) = host_state_option {
                
                // 2. Safely dismantle the Conductor and its resources
                // FIX 3: Destructure HostState to take ownership of 'conductor' and ignore other non-Copy fields (Partial Move fix).
                let HostState { 
                    conductor, 
                    anim_conductor: _, // Take ownership but ignore the value if cleanup isn't done here
                    .. // Ignore all other fields
                } = host_state;

                // 3. Initiate Thread Pool Shutdown (The most critical step)
                godot_print!("Cleanup: Instructing Conductor to shut down worker threads...");
                conductor.shutdown(); // Assume a shutdown method exists on the Conductor

                // 4. Cleanup other Godot-related resources (e.g., cached InstanceIds, etc.)
                // Since the HostState struct is dropped here, all its contained fields 
                // (like Configs, TileMap IDs, etc.) are properly destroyed.
                
                godot_print!("SSXL-ext Core: Cleanup complete. Resources released.");
            } else {
                // If the inner Option was None (i.e., someone already cleaned up the value)
                godot_warn!("Cleanup called but HostState was already cleaned up (Inner Option::None).");
            }
        }
        None => {
            // If the outer Option was None (i.e., OnceCell was never set)
            godot_warn!("Cleanup called but SSXL-ext was not initialized or already cleaned up.");
        }
    }
}
<<< FILE END: ssxl_ext\src\host_cleanup.rs >>>

>>> FILE START: ssxl_ext\src\host_commands.rs (103 LOC) <<<
use godot::prelude::*;
use crate::host_state::HostState;
use crate::generate_conductor_state::ConductorState;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;
// FIX 1: Import the Lazy type for non-const static initialization (requires 'once_cell' in Cargo.toml)
use once_cell::sync::Lazy; 

// FIX 2: Change to Lazy initialization pattern.
static TEST_TILEMAP_ID: Lazy<InstanceId> = Lazy::new(|| InstanceId::from_i64(1337000));

/// Handles the high-level 'start_generation' command received from GDScript.
/// This is the entry point for work into the Rust core.
pub fn handle_start_command(host_state: &mut HostState, tilemap_id: InstanceId) -> Result<(), SSXLCoreError> {
    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        godot_warn!("Command: Attempted to start generation while already Running. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if tilemap_id.to_i64() == 0 {
        godot_error!("Command: Invalid TileMap InstanceId (0) provided. Cannot proceed. (FFI -5)");
        return Err(SSXLCoreError::InvalidTarget);
    }

    if !host_state.is_core_ready {
        godot_warn!("Command: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready.".to_string()));
    }
    
    let map_extent = 1;
    let chunk_size = 32;
    
    let mut jobs = Vec::new();
    
    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new(
                (chunk_x, chunk_y),
                chunk_size,
            );
            
            let job = GenerationJob::new(task);
            jobs.push(job);
        }
    }
    
    let total_jobs = jobs.len();
    
    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            godot_print!("Command: Successfully initiated {} generation tasks.", total_jobs);
            Ok(())
        },
        Err(e) => {
            godot_error!("Command: Conductor failed to start generation: {:?}", e);
            Err(e)
        }
    }
}

/// Performs a structural integrity test of the Conductor, running a minimal generation job.
/// This checks the full Conductor lifecycle: scheduling, multithreaded execution, 
/// and signaling, without relying on a live TileMap.
pub fn trigger_structural_test_job(host_state: &mut HostState) -> Result<(), SSXLCoreError> {
    godot_print!("Structural Test: Initiating 1x1 conductor lifecycle test...");

    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        godot_warn!("Structural Test: Conductor is already busy. Cannot run test. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if !host_state.is_core_ready {
        godot_warn!("Structural Test: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready for test.".to_string()));
    }
    
    let map_extent = 0;
    let chunk_size = 8;
    // FIX 3: Dereference the Lazy static variable to get the InstanceId value.
    let tilemap_id = *TEST_TILEMAP_ID;
    
    let mut jobs = Vec::new();
    
    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new(
                (chunk_x, chunk_y),
                chunk_size,
            );
            
            let job = GenerationJob::new(task); 
            jobs.push(job);
        }
    }
    
    let total_jobs = jobs.len();
    
    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            godot_print!("Structural Test: Successfully started {} test task(s) with ID: {}. Result will be reported via FFI poll.", 
                total_jobs, tilemap_id.to_i64());
            Ok(())
        },
        Err(e) => {
            godot_error!("Structural Test: Conductor failed to start: {:?}.", e);
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\host_commands.rs >>>

>>> FILE START: ssxl_ext\src\host_init.rs (70 LOC) <<<
// ssxl_ext\src\host_init.rs

use godot::prelude::*;
use crate::host_state::init_host_state;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::config::GlobalConfig;
use std::sync::Arc;

// --- CORE LOGIC (Godot-independent and safe to call from CLI) ---

/// Internal function performing all core logic (Config loading, Conductor init, HostState init),
/// isolated from Godot-specific API calls like godot_print!.
fn _do_initialization() -> Result<(), String> {
    
    // 1. Load Global Configuration
    let config = match GlobalConfig::load_or_default() {
        Ok(c) => c,
        Err(e) => return Err(format!("Failed to load configuration: {}", e)),
    };
    let config = Arc::new(config);

    // 2. Initialize the Conductor
    let num_workers = config.threading.generation_worker_count;
    let conductor = GenerateConductor::new(
        num_workers,
        Arc::clone(&config),
    );

    // 3. Initialize the Animation Conductor
    let anim_conductor = AnimConductor::new();
    
    // 4. Initialize the Host State Singleton
    // FIX: Map the custom SSXLCoreError returned by init_host_state to a generic String.
    init_host_state(conductor, anim_conductor, Arc::clone(&config))
        .map_err(|e| format!("HostState initialization failed: {}", e))
}


// --- FFI ENTRY POINT (CLI-safe) ---

/// C-exported entry point for the ssxl_cli tool to initialize the core and wait in idle.
/// This function is the real target for the FFI call in the CLI's main.rs.
/// Returns 0 on success, and a non-zero error code on failure (following C conventions).
#[no_mangle]
pub extern "C" fn ssxl_boot_core_to_idle() -> i32 {
    match _do_initialization() { 
        Ok(_) => {
            // Use standard console output (eprintln!) for the CLI environment.
            eprintln!("✅ SSXL-ext CLI Core: Initialization complete. Ready for FFI work.");
            0 // Success
        },
        Err(e) => {
            // Use standard console error output for the CLI environment.
            eprintln!("❌ CLI FFI Boot Error: {}", e);
            1 // Generic error code for boot failure
        }
    }
}


// --- GODOT ENTRY POINT (Original logic, retained for GDExtension hook) ---

/// The public function used by the Godot GDExtension lifecycle hook.
/// It wraps the core logic with Godot's logging API.
pub fn initialize_ssxl_core() -> Result<(), String> {
    
    godot_print!("SSXL-ext Core: Starting initialization (v9.1.seed).");
    
    match _do_initialization() { 
        Ok(_) => {
            godot_print!("SSXL-ext Core: Initialization complete. Ready for work.");
            Ok(())
        },
        Err(e) => {
            // Retain the original use of godot_print! for logging inside the Godot environment
            godot_print!("❌ SSXL-ext Core FFI Error: {}", e);
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\host_init.rs >>>

>>> FILE START: ssxl_ext\src\host_poller.rs (39 LOC) <<<
// rust/SSXL-ext/src/host_poller.rs

use crate::generate_conductor::GenerateConductor;
// REMOVED: unused import `crate::generate_conductor_state::ConductorState;`
use crate::bridge_signals;
// Removed unused import: use crate::host_state::get_host_state;
// Reason: Avoids unnecessary locking and retrieval of the global HostState 

use crate::ssxl_info; 
// REMOVED: unused import `ssxl_error` (error logging is now handled inside Conductor)

/// The main polling routine, called once per Godot frame (typically from `host_tick.rs`).
/// Its primary responsibility is to pull completed work from the background thread,
/// render it, and emit the final completion signal.
pub fn poll_conductor_status(conductor: &GenerateConductor) {
    // 1. Process and Render Completed Chunks (The Direct Write)
    // The non-blocking channel polling and rendering are handled internally by the Conductor.
    let (chunks_rendered, generation_completed) = conductor.poll_chunks_and_render();

    if chunks_rendered > 0 {
        ssxl_info!("Poller: Rendered {} chunks this frame.", chunks_rendered);
        // Optional: Emit a progress update signal here if detailed GDScript tracking is needed.
        // bridge_signals::emit_progress_update(conductor.get_metrics());
    }

    // 2. State Transition Monitoring and Signal Broadcast (Lifecycle Guard)
    
    // `generation_completed` indicates the Conductor has internally flipped its state to Finished,
    // and all chunks are written. Now, we must emit the signal exactly once.
    if generation_completed {
        // This call implements the CRITICAL single-emission guard.
        // It uses Conductor's internal AtomicBool to ensure the signal is broadcast only on the 
        // *first* frame it finishes, providing robust lifecycle management.
        if let Some(tilemap_id) = conductor.try_finalize_and_get_target_id() {
            ssxl_info!("Poller: All chunks rendered. Emitting final signal for ID: {}", tilemap_id.to_i64());
            
            // Broadcast the signal back to GDScript, closing the loop.
            // This is the signal-driven hook for GDScript orchestration.
            bridge_signals::emit_generation_finished(tilemap_id);
        }
        // If try_finalize_and_get_target_id() returns None, the signal was already sent 
        // or an internal error (logged by the Conductor) occurred.
    }
}
<<< FILE END: ssxl_ext\src\host_poller.rs >>>

>>> FILE START: ssxl_ext\src\host_render.rs (58 LOC) <<<
// rust/SSXL-ext/src/host_render.rs

use godot::prelude::*;
use flume::Receiver;
use crate::shared_chunk::Chunk;
use crate::host_tilemap::render_chunk_direct;
// FIX: Import the ConductorState enum
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState}; 

// Define a safe maximum number of chunk writes per frame.
const MAX_CHUNKS_PER_FRAME: u32 = 16; 

/// Manages the rendering budget for completed chunks.
/// This function is called by the Host Poller on the Godot main thread.
pub fn render_available_chunks(
    tilemap_id: InstanceId,
    chunk_receiver: &Receiver<Chunk>,
    state_container: &ConductorStateContainer,
) -> (u32, bool) {
    
    let mut chunks_rendered_this_frame = 0;

    // Loop, but break if we hit the frame budget
    while chunks_rendered_this_frame < MAX_CHUNKS_PER_FRAME {
        
        // Non-blocking channel receive check
        match chunk_receiver.try_recv() {
            Ok(chunk) => {
                // 1. Execute the HIGH-PERFORMANCE DIRECT WRITE
                match render_chunk_direct(tilemap_id, chunk) {
                    Ok(_) => {
                        chunks_rendered_this_frame += 1;
                        state_container.increment_completed_chunks();
                    },
                    Err(e) => {
                        godot_error!("Render Pacing Layer: Direct write failed: {:?}", e);
                        // We continue, but might want to transition the state to Error
                    }
                }
            },
            Err(flume::TryRecvError::Empty) => {
                // No more chunks available in the channel. Exit loop.
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                // Channel is closed (workers are shut down).
                godot_warn!("Render Pacing Layer: Worker channel disconnected unexpectedly.");
                break;
            }
        }
    }
    
    // Check for overall generation completion
    let metrics = state_container.get_metrics();
    let is_finished = metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;
    
    if is_finished && state_container.get_state() == ConductorState::Generating {
        state_container.transition_to(ConductorState::Finished);
    }
    
    (chunks_rendered_this_frame, is_finished)
}
<<< FILE END: ssxl_ext\src\host_render.rs >>>

>>> FILE START: ssxl_ext\src\host_state.rs (98 LOC) <<<
// rust/SSXL-ext/src/host_state.rs

use godot::prelude::InstanceId;
use once_cell::sync::OnceCell; 
use std::sync::Arc;

use crate::config::GlobalConfig;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor; 
use crate::rhythm_manager::RhythmManager; 
use crate::shared_error::SSXLCoreError;

// FIX: Removed the import for Godot-dependent logging macros
// use crate::{ssxl_error, ssxl_info};

// --------------------------------------------------------------------------
// --- Singleton & Access Functions ---
// --------------------------------------------------------------------------

/// The global, thread-safe singleton holding the core state of the system.
pub static HOST_SINGLETON: OnceCell<Option<HostState>> = OnceCell::new();

/// Attempts to retrieve a reference to the global `HostState`.
/// This function is safe to call from the main thread during runtime.
pub fn get_host_state() -> Result<&'static HostState, SSXLCoreError> {
    HOST_SINGLETON.get()
        // Check if the OnceCell is set (the outer Option)
        .and_then(|host_option| host_option.as_ref()) 
        .ok_or_else(|| {
            // FIX: Replaced ssxl_error! with eprintln!
            eprintln!("ERROR: Attempted to access HostState before it was initialized (immutable access).");
            SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
        })
}

/// Attempts to retrieve a MUTABLE reference to the global `HostState`.
/// This function is ONLY safe to call from the Godot Main Thread during runtime.
pub fn get_host_state_mut() -> Result<&'static mut HostState, SSXLCoreError> {
    // FIX 5: Introduce the function needed for mutable access on the main thread.
    // This encapsulates the required unsafe pattern for accessing the static mutably.
    let host_state_mut = unsafe {
        // 1. Get a mutable pointer to the static OnceCell<Option<HostState>> container.
        let host_singleton_mut_ptr = 
            &HOST_SINGLETON as *const _ as *mut once_cell::sync::OnceCell<Option<HostState>>;

        // 2. Call get_mut() on the mutable container (requires dereferencing the pointer).
        // 3. Call as_mut() to get Option<&mut HostState>.
        (*host_singleton_mut_ptr)
            .get_mut()
            .and_then(|opt| opt.as_mut())
    };

    host_state_mut.ok_or_else(|| {
        // FIX: Replaced ssxl_error! with eprintln!
        eprintln!("ERROR: Attempted to access HostState before it was initialized (mutable access).");
        SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
    })
}

/// Initializes the global `HostState` singleton.
pub fn init_host_state(
    conductor: GenerateConductor, 
    anim_conductor: AnimConductor, // Assuming this is also initialized here
    config: Arc<GlobalConfig>
) -> Result<(), SSXLCoreError> {
    // FIX: Replaced ssxl_info! with eprintln!
    eprintln!("INFO: Initializing HostState...");

    let new_state = HostState {
        // Core components
        conductor,
        anim_conductor,
        config,
        rhythm_manager: RhythmManager::new(), // Initialize the rhythm manager

        // Volatile / Runtime fields
        is_core_ready: true, // Mark as ready immediately after init
        // FIX 3: InstanceId::from_i64(0) is the correct way to initialize a null ID.
        tilemap_id: InstanceId::from_i64(1),
    };
    
    // Try to set the static singleton instance to Some(new_state)
    HOST_SINGLETON.set(Some(new_state)).map_err(|_| {
        // FIX: Replaced ssxl_error! with eprintln!
        eprintln!("ERROR: HostState initialization failed: Already initialized.");
        // FIX 4: Using the missing InitializationError variant (Awaiting addition to SSXLCoreError)
        SSXLCoreError::InitializationError("HostState was already set.".to_string())
    })
}


// --------------------------------------------------------------------------
// --- HostState Structure ---
// --------------------------------------------------------------------------

/// The main structure containing all state required by the Rust core.
/// This struct is a main-thread singleton accessed via `get_host_state()`.
pub struct HostState {
    // --- Configuration & Conductor Components ---
    /// The global, immutable configuration settings.
    pub config: Arc<GlobalConfig>,
    /// The main procedural generation orchestrator.
    pub conductor: GenerateConductor,
    /// The manager for dynamic map/tile animations.
    pub anim_conductor: AnimConductor,
    /// The manager for low-frequency, synchronization-critical operations.
    pub rhythm_manager: RhythmManager,

    // --- Runtime Flags & Metadata ---
    /// Flag indicating if all core components are initialized and running.
    pub is_core_ready: bool,
    /// The Instance ID of the current target TileMap in Godot.
    pub tilemap_id: InstanceId,
}
<<< FILE END: ssxl_ext\src\host_state.rs >>>

>>> FILE START: ssxl_ext\src\host_tick.rs (67 LOC) <<<
use godot::prelude::*;
use crate::host_poller::poll_conductor_status;
use crate::host_state::{get_host_state, get_host_state_mut, HostState};
use crate::generate_conductor::GenerateConductor;
use crate::host_commands;
use crate::host_tilemap_status;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct SSXLConductor {
    base: Base<Node>,
}

#[godot_api]
impl INode for SSXLConductor {
    fn init(base: Base<Node>) -> Self {
        godot_print!("SSXLConductor Node initialized in Godot.");

        Self {
            base,
        }
    }
    
    fn ready(&mut self) {
        self.base_mut().set_process(true);
    }

    /// The Godot engine's main loop update function.
    /// This is where we execute the non-blocking polling logic.
    fn process(&mut self, _delta: f64) {
        let host_state: &HostState = get_host_state().expect("HostState not initialized in _process");
        
        if host_state.is_core_ready {
            let conductor: &GenerateConductor = &host_state.conductor;
            
            // Call the poller to check the channel and perform Direct Write if data exists.
            poll_conductor_status(conductor);
        }
    }
}

#[godot_api]
impl SSXLConductor {
    /// Public method called by GDScript to kick off generation.
    /// This wraps the host_commands::handle_start_command logic.
    #[func]
    fn start_generation(&mut self, target_tilemap: Gd<Node>) -> bool {
        let host_state_mut = match get_host_state_mut() {
            Ok(state) => state,
            Err(e) => {
                godot_error!("HostState not ready for start_generation command: {:?}", e);
                return false;
            }
        };
        let tilemap_id = target_tilemap.instance_id();

        match host_commands::handle_start_command(host_state_mut, tilemap_id) {
            Ok(_) => true,
            Err(e) => {
                godot_error!("Failed to start generation: {:?}", e);
                false
            }
        }
    }

    /// Public method called by GDScript to get the current generation status.
    #[func]
    fn get_status_report(&self) -> VarDictionary {
        match get_host_state() {
            Ok(state) => host_tilemap_status::get_status_report_dict(state),
            Err(_) => VarDictionary::new(),
        }
    }
}
<<< FILE END: ssxl_ext\src\host_tick.rs >>>

>>> FILE START: ssxl_ext\src\host_tilemap.rs (53 LOC) <<<
use godot::prelude::*;
use godot::classes::TileMap;
use crate::shared_tile::TileData;
use crate::shared_error::SSXLCoreError; 
use crate::shared_chunk::Chunk;
use crate::bridge_ffi::{ssxl_get_tilemap_chunk_ptr, ssxl_notify_chunk_updated};

pub trait TileMapDirectWriteExtension {
    fn get_raw_chunk_data_ptr(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) -> *mut TileData;
    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32);
}

impl TileMapDirectWriteExtension for Gd<TileMap> {
    
    fn get_raw_chunk_data_ptr(&mut self, _layer: i32, _chunk_x: i32, _chunk_y: i32) -> *mut TileData {
        let dummy_ptr = 0xDEADBEEF as *mut TileData;
        
        godot_warn!("Architectural WARNING: get_raw_chunk_data_ptr is placeholder (0xDEADBEEF). C++ TileMap binding required for runtime stability.");
        dummy_ptr
    }

    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) {
        godot_print!("TILEMAP_WRITE_NOTIFY: Chunk ({}, {}) for layer {} marked dirty.", chunk_x, chunk_y, layer);
    }
}

/// The Finisher function responsible for the high-speed data delivery.
/// This must be called from the Godot main thread loop (e.g., host_render.rs).
pub fn render_chunk_direct(tilemap_id: InstanceId, chunk: Chunk) -> Result<(), SSXLCoreError> {
    
    let dest_ptr = unsafe {
        ssxl_get_tilemap_chunk_ptr(
            tilemap_id, 
            chunk.position.0, 
            chunk.position.1
        )
    };

    if dest_ptr.is_null() {
        godot_print!("ERROR: TileMap chunk pointer is NULL for chunk {:?}", chunk.position);
        return Err(SSXLCoreError::InvalidInstance(tilemap_id.to_i64() as u64)); 
    }
    
    let tile_count = chunk.tiles.len();
    
    // Perform the direct, non-overlapping memory copy (the O(1) core optimization).
    unsafe {
        std::ptr::copy_nonoverlapping(
            chunk.tiles.as_ptr() as *const _, // Source: Rust's generated Vector
            dest_ptr as *mut _,               // Destination: Godot's internal TileMap memory
            tile_count
        );
    
        // Notify Godot's renderer that the buffer has been changed manually.
        ssxl_notify_chunk_updated(tilemap_id, chunk.position.0, chunk.position.1);
    }

    Ok(())
}
<<< FILE END: ssxl_ext\src\host_tilemap.rs >>>

>>> FILE START: ssxl_ext\src\host_tilemap_status.rs (34 LOC) <<<
use godot::prelude::*;

use crate::host_state::HostState;
use crate::ssxl_error;

pub fn get_status_report_dict(host_state: &HostState) -> VarDictionary {
    let mut dict = VarDictionary::new();

    if !host_state.is_core_ready {
        ssxl_error!("Called get_status_report_dict before core was ready.");
        let _ = dict.insert("is_core_ready", false.to_variant());
        let _ = dict.insert("conductor_state", "Uninitialized".to_variant());
        let _ = dict.insert("total_chunks", 0.to_variant());
        let _ = dict.insert("completed_chunks", 0.to_variant());
        return dict;
    }

    // 1. Get the current state and metrics from the Conductor
    let conductor = &host_state.conductor;
    let metrics = conductor.get_metrics();
    let conductor_state = conductor.get_state_container().get_state();

    // 2. Map metrics into the Dictionary
    let _ = dict.insert("is_core_ready", host_state.is_core_ready.to_variant());
    let _ = dict.insert("conductor_state", conductor_state.to_string().to_variant());
    
    // Convert GenerationMetrics into Dictionary entries
    let _ = dict.insert("total_chunks", metrics.total_chunks.to_variant());
    let _ = dict.insert("completed_chunks", metrics.completed_chunks.to_variant());
    
    // Calculate progress as a float
    let progress = if metrics.total_chunks > 0 {
        metrics.completed_chunks as f64 / metrics.total_chunks as f64
    } else {
        0.0
    };
    let _ = dict.insert("progress", progress.to_variant());

    dict
}
<<< FILE END: ssxl_ext\src\host_tilemap_status.rs >>>

>>> FILE START: ssxl_ext\src\lib.rs (85 LOC) <<<
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

// ----------------------------------------------------
// 1. PURE RUST CORE MODULES
// ----------------------------------------------------

pub mod tools;
pub mod math;
pub mod config;

// Concurrency and Caching
pub mod cache;
pub mod sync_pool;
pub mod sync_rhythm;

// ----------------------------------------------------
// 2. SHARED DATA CONTRACTS
// ----------------------------------------------------

pub mod shared_tile;
pub mod shared_chunk;
pub mod shared_config;
pub mod shared_error;
pub mod shared_math;
pub mod shared_message;
pub mod generate_task_queue;
pub mod shared_job;
pub mod generate_runtime;
pub mod generate_batch_processor;
pub mod generate_anim_conductor;
pub mod rhythm_manager;

// ----------------------------------------------------
// 3. GENERATION SUBSYSTEM
// ----------------------------------------------------

pub mod generate_perlin;
pub mod generate_ca;
pub mod generate_ca_simulation;
pub mod generate_conductor;
pub mod generate_conductor_state;

// ----------------------------------------------------
// 4. ANIMATION / SIMULATION SUBSYSTEM
// ----------------------------------------------------

pub mod animate_events;
pub mod animate_worker;
pub mod animate_conductor;

// ----------------------------------------------------
// 5. THE HOST / BRIDGE LAYER (GDExtension Interface)
// ----------------------------------------------------

pub mod bridge_ffi;
pub mod bridge_signals;
pub mod bridge_oracle;

// Lifecycle and State
pub mod host_state;
pub mod host_init;
pub mod host_cleanup;

// Godot Loop Integration
pub mod host_tick;
pub mod host_poller;
pub mod host_render;

// Godot TileMap and API Interaction
pub mod host_commands;
pub mod host_tilemap;
pub mod host_tilemap_status;

// ----------------------------------------------------
// 6. GDExtension ENTRY POINTS
// ----------------------------------------------------

struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    
    fn on_level_init(level: InitLevel) {
        if level == InitLevel::Core {
        }

        if level == InitLevel::Scene {
            match host_init::initialize_ssxl_core() {
                Ok(_) => ssxl_info!("Core resources successfully initialized and workers started."),
                Err(e) => {
                    godot_error!("FATAL: SSXL Core failed to initialize. Reason: {}", e);
                }
            }
        }
    }

    fn on_level_deinit(level: InitLevel) {
        if level == InitLevel::Scene {
            host_cleanup::cleanup_ssxl_core();
            godot_print!("SSXL GDExtension terminated successfully.");
        }
    }
}
<<< FILE END: ssxl_ext\src\lib.rs >>>

>>> FILE START: ssxl_ext\src\math.rs (71 LOC) <<<
// rust/SSXL-ext/src/math.rs

use crate::shared_config::MapSettingsConfig; // To get chunk size

/// Converts continuous world coordinates (global tile coordinates) into 
/// discrete chunk coordinates.
/// 
/// This is crucial for determining which worker needs to process a given location.
pub fn world_to_chunk_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // Use floor division (integer division in Rust for positive numbers)
    // For proper handling of negative coordinates (common in large worlds), 
    // we use a correction for negative numbers.
    let chunk_x = (world_x as f32 / chunk_size as f32).floor() as i32;
    let chunk_y = (world_y as f32 / chunk_size as f32).floor() as i32;
    
    (chunk_x, chunk_y)
}

/// Converts discrete chunk coordinates and local chunk coordinates back into 
/// global world coordinates.
pub fn chunk_to_world_coords(chunk_x: i32, chunk_y: i32, local_x: i32, local_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    let world_x = (chunk_x * chunk_size) + local_x;
    let world_y = (chunk_y * chunk_size) + local_y;
    
    (world_x, world_y)
}

/// Calculates the local tile coordinate within a chunk from a global coordinate.
pub fn world_to_local_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // The modulo operation handles the wrap-around within the chunk boundary.
    // Ensure the result is non-negative for proper indexing.
    let local_x = world_x.rem_euclid(chunk_size);
    let local_y = world_y.rem_euclid(chunk_size);
    
    (local_x, local_y)
}

// rust/SSXL-ext/src/math.rs

/// Fast, safe 32-bit integer clamping. Useful for setting bounds on noise or CA values.
pub fn clamp_i32(val: i32, min: i32, max: i32) -> i32 {
    val.max(min).min(max)
}

/// Fast, safe float clamping. Used for normalizing noise output to a [0.0, 1.0] range.
pub fn clamp_f64(val: f64, min: f64, max: f64) -> f64 {
    val.max(min).min(max)
}

/// Linearly interpolates between 'a' and 'b' by the factor 't'.
/// Used in various generation algorithms for blending values.
pub fn lerp(a: f64, b: f64, t: f64) -> f64 {
    a + (b - a) * t.max(0.0).min(1.0) // Clamp t to [0.0, 1.0]
}

/// Calculates the distance squared between two points. 
/// Used for fast proximity checks without the overhead of a square root.
pub fn distance_squared_2d(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    dx * dx + dy * dy
}

// rust/SSXL-ext/src/math.rs

/// Generates a deterministic u64 seed from a pair of chunk coordinates.
/// Ensures that the same coordinates always produce the same seed, 
/// guaranteeing continuity across chunk borders.
pub fn hash_chunk_coords(chunk_x: i32, chunk_y: i32, world_seed: u64) -> u64 {
    // A simple, fast XOR-based hash mixing method:
    let mut hash: u64 = world_seed;
    hash = hash.wrapping_add(chunk_x as u64);
    hash = hash.wrapping_mul(31); // Simple prime multiplier
    hash ^= (chunk_y as u64).wrapping_shl(32);
    hash
}
<<< FILE END: ssxl_ext\src\math.rs >>>

>>> FILE START: ssxl_ext\src\rhythm_manager.rs (21 LOC) <<<
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq)]
#[allow(dead_code)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

pub struct RhythmManager {
    _last_check_time: Instant,
    _current_phase: RhythmPhase,
}

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            _last_check_time: Instant::now(),
            _current_phase: RhythmPhase::Idle,
        }
    }
}
<<< FILE END: ssxl_ext\src\rhythm_manager.rs >>>

>>> FILE START: ssxl_ext\src\shared_chunk.rs (50 LOC) <<<
// rust/SSXL-ext/src/shared_chunk.rs

use crate::shared_math::ChunkCoords;
use crate::shared_tile::TileData;

/// Represents a single, self-contained, generated block of the world map.
/// This structure is the primary payload sent from worker threads to the conductor.
// FIX: Add #[derive(Default)] to satisfy the requirement for std::mem::take in generate_batch_processor.rs
#[derive(Debug, Clone, Default)] 
pub struct Chunk {
    /// The discrete coordinates (X, Y) identifying this chunk in the world grid.
    pub position: ChunkCoords,
    /// The edge length of the chunk (e.g., 32 for a 32x32 chunk).
    pub size: u32,
    /// The flat, contiguous array of tile data for the chunk.
    /// Storage is in Row-Major order (Y is outer loop, X is inner loop).
    pub tiles: Vec<TileData>,
    /// Metadata flag indicating if this chunk contains dynamic assets (entities, lights, etc.).
    pub contains_assets: bool,
}

// rust/SSXL-ext/src/shared_chunk.rs

impl Chunk {
    /// Initializes a new, empty chunk with the required size and position.
    pub fn new(position: ChunkCoords, size: u32) -> Self {
        // Pre-allocate the vector capacity immediately for performance.
        let capacity = (size * size) as usize;
        Self {
            position,
            size,
            // Initialize with the correct size (will be filled during generation).
            tiles: Vec::with_capacity(capacity), 
            contains_assets: false,
        }
    }

    /// Calculates the 1D index from 2D local coordinates (X, Y).
    /// This ensures consistent Row-Major ordering across all modules.
    /// Note: This does not perform bounds checking; it assumes inputs (x, y) are 0..size.
    pub fn get_index(&self, x: u32, y: u32) -> usize {
        // Index = Y * Size + X (Row-Major Ordering)
        (y * self.size + x) as usize
    }

    /// Gets an immutable reference to the TileData at the specified local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        let index = self.get_index(x, y);
        self.tiles.get(index)
    }

    /// Gets a mutable reference to the TileData for modification during generation.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        let index = self.get_index(x, y);
        self.tiles.get_mut(index)
    }
}
<<< FILE END: ssxl_ext\src\shared_chunk.rs >>>

>>> FILE START: ssxl_ext\src\shared_config.rs (110 LOC) <<<
// rust/SSXL-ext/src/shared_config.rs

use serde::{Deserialize, Serialize};

/// Combines all settings relevant for the procedural generation workers.
/// This struct is passed via the GenerationTask to the sync_pool.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct GenerationConfig {
    pub perlin: PerlinNoiseConfig,
    pub ca: CellularAutomataConfig,
    pub world_seed: u64,
}

impl Default for GenerationConfig {
    fn default() -> Self {
        Self {
            perlin: PerlinNoiseConfig::default(),
            ca: CellularAutomataConfig::default(),
            world_seed: 5011993,
        }
    }
}

/// Configuration for the Fractal Brownian Motion (FBM) noise function.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct PerlinNoiseConfig {
    pub scale: f64,
    pub octaves: usize,
    pub persistence: f64,
    pub lacunarity: f64,
    pub threshold: f64,
}

impl Default for PerlinNoiseConfig {
    fn default() -> Self {
        Self {
            scale: 250.0,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            threshold: 0.0,
        }
    }
}

/// Configuration for the Cellular Automata simulation rules.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct CellularAutomataConfig {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl Default for CellularAutomataConfig {
    fn default() -> Self {
        Self {
            death_limit: 4,
            birth_limit: 5,
            steps: 5,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for all thread pools and concurrency limits.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct ThreadingConfig {
    // Number of dedicated workers for one-time generation (sync_pool.rs)
    pub generation_worker_count: u32,
    // Number of dedicated workers for continuous animation/simulation (animate_worker.rs)
    pub animation_worker_count: u32,
    // Max number of tasks/chunks allowed in the main generation queue
    pub task_channel_capacity: usize,
}

impl Default for ThreadingConfig {
    fn default() -> Self {
        Self {
            generation_worker_count: 4,
            animation_worker_count: 2,
            task_channel_capacity: 4096,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration defining the physical layout of the world chunks.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct MapSettingsConfig {
    // The size (edge length) of a single chunk (e.g., 32 -> 32x32 tiles)
    pub chunk_size: u32,
    // The initial number of chunks to generate from the center (0,0) outward (e.g., 8 -> 17x17 grid)
    pub map_extent_chunks: i32,
    pub tile_scale_factor: f32,
}

impl Default for MapSettingsConfig {
    fn default() -> Self {
        Self {
            chunk_size: 32,
            map_extent_chunks: 8,
            tile_scale_factor: 1.0,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for the continuous simulation and animation workers.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct AnimationConfig {
    // The desired speed of the simulation loop, decoupled from Godot's FPS.
    pub simulation_fps: u32,
    pub fluid_damping_factor: f32,
}

impl Default for AnimationConfig {
    fn default() -> Self {
        Self {
            simulation_fps: 30, // 30Hz simulation loop
            fluid_damping_factor: 0.95,
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_config.rs >>>

>>> FILE START: ssxl_ext\src\shared_error.rs (46 LOC) <<<
use thiserror::Error;
use godot::prelude::godot_warn;

#[derive(Debug, Error, Clone)]
pub enum SSXLCoreError {
    #[error("Core state uninitialized: HostState singleton is not yet set.")]
    UninitializedState,
    #[error("Core initialization failed: {0}")]
    InitializationError(String),
    #[error("Conductor lifecycle error: Conductor is currently busy and cannot accept new jobs.")]
    ConductorBusy,
    #[error("Conductor lifecycle error: System is currently in state '{0}'.")]
    InvalidConductorState(String),
    #[error("Configuration error: Invalid value for '{0}'.")]
    InvalidConfig(String),
    #[error("Channel sending failed: {0}")]
    ChannelSendError(String),
    #[error("Channel receiving failed: {0}")]
    ChannelRecvError(String),
    #[error("Thread management error: Worker thread join failed.")]
    ThreadJoinError,
    #[error("Generation data error: {0}")]
    GenerationDataError(String),
    #[error("Mathematical boundary error: {0}")]
    MathError(String),
    #[error("Godot instance error: Target TileMap InstanceId is invalid (0).")]
    InvalidTarget,
    #[error("Godot instance error: ID '{0}' is invalid or null.")]
    InvalidInstance(u64),
    #[error("FFI Bridge error: Direct memory write failed: {0}")]
    FFIWriteError(String),
    #[error("Godot API failure on '{0}': {1}")]
    GodotAPIFailure(String, String),
}

impl SSXLCoreError {
    pub fn to_ffi_code(&self) -> isize {
        match self {
            SSXLCoreError::UninitializedState => -2,
            SSXLCoreError::InvalidTarget => -5,
            SSXLCoreError::ConductorBusy => -6,
            _ => {
                godot_warn!("Unhandled critical error in SSXLCoreError::to_ffi_code. Mapping to FFI -3 (ConductorStopped): {:?}", self);
                -3
            }
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_error.rs >>>

>>> FILE START: ssxl_ext\src\shared_job.rs (57 LOC) <<<
// rust/SSXL-ext/src/shared_job.rs

use crate::generate_task_queue::GenerationTask;

/// Defines the sequential steps required to fully process a single chunk.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum JobStep {
    /// Initial state: The task has been queued.
    Queued,
    /// Step 1: Raw Perlin noise generation is running.
    NoiseGeneration,
    /// Step 2: Cellular Automata refinement is running.
    CARefinement,
    /// Step 3: Post-processing and refinement (e.g., placing entities, blending).
    PostProcessing,
    /// Final state: The chunk data is ready to be sent to the Conductor's finisher queue.
    Finished,
    /// Error state: A worker encountered an unrecoverable error.
    Failed,
}

// rust/SSXL-ext/src/shared_job.rs

use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords;

/// Represents a complete, multi-stage task for generating a single world chunk.
#[derive(Debug, Clone)]
pub struct GenerationJob {
    /// The unique identifier for this job (e.g., the chunk's coordinates).
    pub id: ChunkCoords,
    /// The core data and parameters for the job.
    pub task: GenerationTask,
    /// The current stage of processing for this job.
    pub current_step: JobStep,
    /// The partially or fully completed chunk data.
    pub chunk_data: Chunk,
}

impl GenerationJob {
    /// Creates a new job, initializing its state.
    pub fn new(task: GenerationTask) -> Self {
        let chunk_data = Chunk::new(task.chunk_pos, task.chunk_size);
        
        GenerationJob {
            id: task.chunk_pos,
            task,
            current_step: JobStep::Queued,
            chunk_data,
        }
    }

    /// Advances the job to the next sequential step.
    pub fn advance_step(&mut self) {
        self.current_step = match self.current_step {
            JobStep::Queued => JobStep::NoiseGeneration,
            JobStep::NoiseGeneration => JobStep::CARefinement,
            JobStep::CARefinement => JobStep::PostProcessing,
            JobStep::PostProcessing => JobStep::Finished,
            // Finished and Failed are terminal states
            _ => self.current_step,
        };
    }
}
<<< FILE END: ssxl_ext\src\shared_job.rs >>>

>>> FILE START: ssxl_ext\src\shared_math.rs (35 LOC) <<<
// rust/SSXL-ext/src/shared_math.rs

// --------------------------------------------------------------------------
// --- Type Aliases ---
// --------------------------------------------------------------------------

/// Type alias for 2D chunk coordinates (X, Y).
/// Used as the primary key for chunk addressing across the system (e.g., in cache.rs).
pub type ChunkCoords = (i32, i32);

/// Type alias for 2D coordinates used to identify a single tile within a chunk.
pub type LocalTileCoords = (i32, i32);

/// Type alias for 2D coordinates identifying a single tile in the entire world.
pub type WorldTileCoords = (i32, i32);


// --------------------------------------------------------------------------
// --- Constants ---
// --------------------------------------------------------------------------

/// The number of neighbors checked by the Cellular Automata algorithm (3x3 grid minus center).
pub const CA_NEIGHBOR_COUNT: u8 = 8;

/// A constant representing the world's gravity factor in the simulation, 
/// used by systems like animate_worker.rs.
pub const WORLD_GRAVITY_FACTOR: f32 = 9.81;

/// A small epsilon value used for floating-point comparisons to maintain precision.
pub const F32_EPSILON: f32 = 0.00001;


// --------------------------------------------------------------------------
// --- Shared Structures ---
// --------------------------------------------------------------------------

/// A simple structure to represent a position and a direction vector, 
/// used by animate_worker.rs for entities.
/// #[repr(C)] ensures FFI compatibility if this is passed directly to the Godot side.
#[derive(Debug, Clone, Copy, Default)]
#[repr(C)] 
pub struct EntityMovementState {
    pub position_x: f32,
    pub position_y: f32,
    pub velocity_x: f32,
    pub velocity_y: f32,
}
<<< FILE END: ssxl_ext\src\shared_math.rs >>>

>>> FILE START: ssxl_ext\src\shared_message.rs (43 LOC) <<<
// rust/SSXL-ext/src/shared_message.rs

/// Control messages sent to the generation workers (sync_pool.rs).
#[derive(Debug, Clone, Copy)]
pub enum GenerationControlMessage {
    /// Instructs the workers to stop processing new tasks but finish current ones.
    Pause,
    /// Instructs the workers to stop immediately and shut down the thread.
    Stop,
    /// Forces a worker to reload its configuration from the global state.
    ReloadConfig,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;

/// Data messages sent from the generation workers back to the main thread Conductor.
#[derive(Debug)]
pub enum GenerationDataMessage {
    /// A completed chunk ready for direct writing to the TileMap.
    CompletedChunk(Chunk),
    /// A fatal error occurred during the processing of a specific chunk.
    JobFailure(SSXLCoreError),
    /// A simple acknowledgement that a worker is initialized or has cleared its state.
    Ack,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_config::AnimationConfig;

/// Control messages sent to the animation workers (animate_worker.rs).
#[derive(Debug, Clone, Copy)]
pub enum AnimationControlMessage {
    Pause,
    Stop,
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/shared_message.rs

use crate::animate_events::AnimationEvent;

/// Data messages sent from the animation workers back to the main thread Conductor.
#[derive(Debug, Clone)]
pub enum AnimationDataMessage {
    /// A single, ready-to-render visual event.
    Event(AnimationEvent),
    /// A worker encountered an unrecoverable error during simulation.
    WorkerPanic(SSXLCoreError),
}
<<< FILE END: ssxl_ext\src\shared_message.rs >>>

>>> FILE START: ssxl_ext\src\shared_tile.rs (73 LOC) <<<
// rust/SSXL-ext/src/shared_tile.rs

/// The minimal data required to represent a single tile in the Godot TileMap.
///
/// #[repr(C)] ensures FFI-compatibility for direct memory writing 
/// to Godot's C++ data structures, making the chunk rendering extremely fast.
/// 
/// Total size: 6 bytes.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TileData {
    pub tile_id: u16,        // ID corresponding to a tile in the Godot TileSet (source ID)
    pub atlas_coords: u16,   // Packed coords within the TileSet Atlas
    pub rotation_flags: u8,  // Rotation, flip, and custom flags
    pub custom_data: u8,     // Used for dynamic data (e.g., fluid level, density score)
}

// Add a default implementation for easy initialization (e.g., for empty chunks)
impl Default for TileData {
    fn default() -> Self {
        // Defaulting to an "Air" or "Empty" tile (ID 0)
        Self {
            tile_id: 0, 
            atlas_coords: 0, 
            rotation_flags: 0, 
            custom_data: 0,
        }
    }
}

// --- FIX: Implement the is_live and set_live methods for Cellular Automata logic ---
impl TileData {
    /// Checks if the tile is in a 'live' state. 
    /// In the context of a tile map, this usually means the tile is present (tile_id != 0).
    pub fn is_live(&self) -> bool {
        // A tile is 'live' if it has been assigned a valid tile_id (i.e., not the default 0).
        self.tile_id != 0
    }

    /// Sets the live/dead state of the tile.
    /// To set 'live' (true), we use a placeholder tile_id (1).
    /// To set 'dead' (false), we use the default 'empty' tile_id (0).
    pub fn set_live(&mut self, live: bool) {
        if live {
            // Set to a placeholder 'live' tile ID (assuming ID 1 is the default solid tile)
            if self.tile_id == 0 {
                self.tile_id = 1; 
            }
        } else {
            // Set to the 'dead' (empty) tile ID
            self.tile_id = 0;
            // Optionally clear other related fields for an empty tile
            self.atlas_coords = 0;
            self.rotation_flags = 0;
            self.custom_data = 0;
        }
    }
}
// --- END FIX ---


/// A structure to hold the generated data for a single TileMap chunk.
/// This is the payload delivered from the worker threads to the main thread.
#[derive(Debug, Clone)] // Clone is necessary for safe job/message passing
pub struct Chunk {
    pub position: (i32, i32), // Grid position of the chunk
    pub tiles: Vec<TileData>, // The raw tile data array
    pub size: u32,             // Edge length (e.g., 16x16 chunk -> size = 16)
}

// Default implementation for Chunk (e.g., for empty/uninitialized chunks)
impl Default for Chunk {
    fn default() -> Self {
        Self {
            position: (0, 0),
            tiles: Vec::new(),
            size: 0,
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_tile.rs >>>

>>> FILE START: ssxl_ext\src\sync_pool.rs (141 LOC) <<<
// rust/SSXL-ext/src/sync_pool.rs

use std::thread;
use std::sync::Arc;
use flume::{Receiver, Sender};

// Shared types used for concurrent operations
use crate::shared_job::GenerationJob; 
use crate::shared_message::GenerationDataMessage;
use crate::config::GlobalConfig;
use crate::generate_runtime;

// --- FIX: Removed the import for Godot-dependent logging macros
// use crate::{ssxl_info, ssxl_error};

// --------------------------------------------------------------------------
// --- Worker Structures ---
// --------------------------------------------------------------------------

/// A wrapper around a dedicated worker thread handle.
struct Worker {
    id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl Worker {
    /// Spawns a new thread and starts the worker's execution loop.
    fn new(
        id: usize, 
        task_receiver: Arc<Receiver<GenerationJob>>, 
        chunk_sender: Sender<GenerationDataMessage>,
        // The worker needs a reference to the global configuration
        config: Arc<GlobalConfig>,
    ) -> Worker {
        // Clone the necessary handles for the new thread
        let sender_clone = chunk_sender.clone();
        
        let handle = thread::spawn(move || {
            // Loop until the channel is disconnected (which signals shutdown)
            while let Ok(job) = task_receiver.recv() {
                
                // --- EXECUTE FULL GENERATION RUNTIME ---
                let final_result = generate_runtime::run_generation_job(job, &config.generation);

                // --- FINISHER DELIVERY ---
                // Send the final result (Completed Chunk or Failure Message) back to the Conductor.
                let message = match final_result {
                    Ok(completed_chunk) => {
                        // FIX: Replaced ssxl_info! with eprintln!
                        eprintln!("INFO: Worker {} completed job {:?}", id, completed_chunk.position);
                        GenerationDataMessage::CompletedChunk(completed_chunk)
                    },
                    Err(e) => {
                        // FIX: Replaced ssxl_error! with eprintln!
                        eprintln!("ERROR: Worker {} failed job: {:?}", id, e);
                        GenerationDataMessage::JobFailure(e)
                    }
                };

                // Non-blocking delivery of the result back to the Conductor's main thread poller.
                if let Err(e) = sender_clone.send(message) {
                    // The main thread is no longer listening; break the loop and shut down.
                    // FIX: Replaced ssxl_error! with eprintln!
                    eprintln!("ERROR: Worker {} failed to send result: {}. Conductor likely shut down.", id, e);
                    break; 
                }
            }
            // FIX: Replaced ssxl_info! with eprintln!
            eprintln!("INFO: Worker {} shutting down.", id);
        });

        Worker { id, handle: Some(handle) }
    }
}


// --------------------------------------------------------------------------
// --- ThreadPool Structure ---
// --------------------------------------------------------------------------

/// Manages the pool of worker threads dedicated to procedural generation.
pub struct ThreadPool {
    workers: Vec<Worker>,
    // The pool holds the sender end of the channel for task submission
    task_sender: Sender<GenerationJob>,
    // The pool sends completed messages back to the Conductor
    chunk_sender: Sender<GenerationDataMessage>,
    // This handle ensures the Receiver stays alive while the workers are running.
    _task_receiver_final_handle: Receiver<GenerationJob>,
}

impl ThreadPool {
    /// Creates a new ThreadPool and spawns the specified number of workers.
    /// Returns the Conductor's receiving channel for completed work.
    /// 
    /// Returns: (ThreadPool instance, Receiver for completed chunks)
    pub fn new(num_workers: usize, config: Arc<GlobalConfig>) -> (Self, Receiver<GenerationDataMessage>) {
        
        // --- 1. Setup Channels ---
        // (MPSC) Worker Submission Channel
        let (task_sender, task_receiver_final_handle) = flume::unbounded();
        // The workers will share ownership of the receiver end
        let task_receiver_arc = Arc::new(task_receiver_final_handle.clone());
        
        // (SPSC) Finisher Delivery Channel (Chunk/Error results back to Conductor)
        let (chunk_sender, chunk_receiver) = flume::unbounded();

        // --- 2. Spawn Workers ---
        let mut workers = Vec::with_capacity(num_workers);
        for id in 0..num_workers {
            workers.push(Worker::new(
                id,
                Arc::clone(&task_receiver_arc),
                chunk_sender.clone(),
                Arc::clone(&config),
            ));
        }

        // FIX: Replaced ssxl_info! with eprintln!
        eprintln!("INFO: Started ThreadPool with {} dedicated workers.", num_workers);
        
        let pool = ThreadPool { 
            workers, 
            task_sender, 
            chunk_sender,
            _task_receiver_final_handle: task_receiver_final_handle,
        };
        
        // Return the pool instance and the channel the Conductor will listen on
        (pool, chunk_receiver)
    }
    
    /// Submits a new generation job to the worker pool.
    pub fn submit_job(&self, job: GenerationJob) -> Result<(), flume::SendError<GenerationJob>> {
        self.task_sender.send(job)
    }

    /// Signals workers to stop and waits for all threads to finish (clean shutdown).
    pub fn shutdown(self) {
        // Drop all senders and the receiver handle. This signals to workers to exit their loops.
        drop(self.task_sender);
        drop(self._task_receiver_final_handle);
        drop(self.chunk_sender);
        
        // Wait for all worker threads to finish.
        for mut worker in self.workers.into_iter() {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    // FIX: Replaced ssxl_error! with eprintln!
                    eprintln!("ERROR: Worker {} thread join failed: {:?}", worker.id, e);
                }
            }
        }
        // FIX: Replaced ssxl_info! with eprintln!
        eprintln!("INFO: ThreadPool shut down successfully.");
    }
}
<<< FILE END: ssxl_ext\src\sync_pool.rs >>>

>>> FILE START: ssxl_ext\src\sync_rhythm.rs (85 LOC) <<<
// rust/SSXL-ext/src/sync_rhythm.rs

use std::time::{Instant, Duration};
use crate::generate_conductor_state::ConductorState;
use crate::host_state::get_host_state;
// --- FIX: Import logging macro from the crate root ---
use crate::{ssxl_info, ssxl_error};

// Define the interval at which the complex rhythm checks run (e.g., 4 times per second)
const RHYTHM_CHECK_INTERVAL: Duration = Duration::from_millis(250);

/// Manages the timing and synchronization points between the generation and simulation layers.
pub struct RhythmManager {
    last_check_time: Instant,
    // The current phase of the synchronization loop (if staggered)
    current_phase: RhythmPhase, 
}

/// Defines the stages in a multi-step synchronization cycle.
#[derive(Debug, Clone, Copy, PartialEq)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

// rust/SSXL-ext/src/sync_rhythm.rs

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            last_check_time: Instant::now(),
            current_phase: RhythmPhase::Idle,
        }
    }

    /// Checks if it's time to run a complex synchronization check.
    pub fn poll_rhythm(&mut self) {
        if self.last_check_time.elapsed() >= RHYTHM_CHECK_INTERVAL {
            self.last_check_time = Instant::now();
            self.execute_rhythm_check();
        }
    }

    /// Executes the staged synchronization logic.
    fn execute_rhythm_check(&mut self) {
        // Access the global state, where the conductors and caches reside
        let host_state = match get_host_state() {
            Ok(state) => state,
            Err(_) => {
                // If HostState isn't initialized, we can't run the rhythm check.
                ssxl_error!("RhythmManager tried to poll but HostState is uninitialized.");
                return;
            }
        };

        // Get the state container safely
        let generation_state = host_state.conductor.get_state_container();
        
        match self.current_phase {
            RhythmPhase::Idle => {
                // Check if any system needs attention
                if generation_state.get_state() == ConductorState::Finished {
                    self.current_phase = RhythmPhase::CheckGenerationStatus;
                } else {
                    // Nothing urgent, remain idle
                }
            },
            
            RhythmPhase::CheckGenerationStatus => {
                // Action: Generation is FINISHED. This is a synchronization point.
                ssxl_info!("Rhythm Check: Generation finished. Starting post-gen cleanup.");

                // 1. Flush caches that depend on generation tasks
                // NOTE: Assumes host_state has a public `noise_cache` field and it has a `clear` method.
                // host_state.noise_cache.clear(); 
                
                self.current_phase = RhythmPhase::SyncAnimationStarts;
            },
            
            RhythmPhase::SyncAnimationStarts => {
                // Action: Start the Animation workers now that the world is ready.
                ssxl_info!("Rhythm Check: Starting animation workers...");
                // host_state.anim_conductor.start_workers(); 

                self.current_phase = RhythmPhase::CleanUpStaleCaches;
            },

            RhythmPhase::CleanUpStaleCaches => {
                // Action: Run garbage collection/stale data cleanup
                // host_state.chunk_cache.prune_distant_chunks(host_state.player_position); 

                self.current_phase = RhythmPhase::Idle; // Cycle complete
            }
        }
    }
}
<<< FILE END: ssxl_ext\src\sync_rhythm.rs >>>

>>> FILE START: ssxl_ext\src\tools.rs (78 LOC) <<<
// rust/SSXL-ext/src/tools.rs

use godot::prelude::*;

/// Prints a standard information message to the Godot console.
#[macro_export]
macro_rules! ssxl_info {
    ($($arg:tt)*) => ({
        godot::prelude::godot_print!("INFO [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

/// Prints a warning message to the Godot console.
#[macro_export]
macro_rules! ssxl_warn {
    ($($arg:tt)*) => ({
        godot::prelude::godot_warn!("WARN [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

/// Prints an error message to the Godot console.
#[macro_export]
macro_rules! ssxl_error {
    ($($arg:tt)*) => ({
        godot::prelude::godot_error!("ERROR [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

// rust/SSXL-ext/src/tools.rs

/// Trait for converting Rust coordinate types to Godot Vector2i.
pub trait ToGodotVector {
    fn to_godot_vector(&self) -> Vector2i;
}

// Implementation for the standard (i32, i32) tuple used for chunk positions.
impl ToGodotVector for (i32, i32) {
    /// Converts a (x, y) tuple into a Godot Vector2i.
    fn to_godot_vector(&self) -> Vector2i {
        Vector2i::new(self.0, self.1)
    }
}

// Implementation for the shared_tile::TileData structure (if it holds coordinates)
// Or for a reference to the chunk position
// impl ToGodotVector for &ChunkPosition { ... }

// rust/SSXL-ext/src/tools.rs

use std::time::Instant;

/// A simple struct for timing code execution blocks.
pub struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    /// Starts a new profiler instance if profiling is globally enabled.
    pub fn start(name: &'static str) -> Self {
        // NOTE: In a real project, 'is_profiling_enabled' would be read from config.rs
        const IS_PROFILING_ENABLED: bool = true;
        
        Profiler {
            start: Instant::now(),
            name,
            enabled: IS_PROFILING_ENABLED,
        }
    }
}

/// The Drop implementation automatically logs the duration when the scope is exited.
impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            // Use standard print/error for micro-profiling to ensure data integrity
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms", 
                self.name, 
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}

// Example usage:
// {
//     let _p = Profiler::start("CA Simulation Step");
//     // ... heavy computation here ...
// } // Duration logged automatically when _p goes out of scope.
<<< FILE END: ssxl_ext\src\tools.rs >>>

