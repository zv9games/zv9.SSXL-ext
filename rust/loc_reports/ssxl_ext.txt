>>> FILE START: ssxl_ext\Cargo.toml (34 LOC) <<<
[package]
name = "ssxl_ext"
version = "0.9.1"
edition = "2021"
# The crate type must be 'cdylib' for a Godot GDExtension
[lib]
crate-type = ["cdylib"]


[dependencies]

# --- 1. Godot Bindings (Essential Bridge) ---
# Assuming 'godot' is the chosen Godot Rust binding crate (e.g., godot-rust/gdext)
# This is the single most important dependency for the Host_* files (host_init.rs, host_tick.rs, etc.)
godot = { version = "^0.4.4", features = ["serde"] } 
# The 'serde' feature is often useful for robust configuration reading (config.rs, shared_config.rs)

# --- 2. Concurrency and Async (The Finisher/Conductor Core) ---
# Required for non-blocking generation, worker threads (sync_pool.rs), and task queues (generate_task_queue.rs)
# and for the animation workers (animate_conductor.rs, animate_worker.rs).
tokio = { version = "1.48", features = ["rt", "macros", "sync"] } 
# Or another runtime like `smol`. 'tokio' is a robust choice for async work.

# Flume is a popular multi-producer, single-consumer (MPSC) channel for communicating
# between Rust threads and the Godot main thread (e.g., for chunk delivery in shared_message.rs).
flume = "0.12" 

# Rayon for data parallelism on generation tasks (e.g., in generate_batch_processor.rs)
rayon = "1.11" 

# --- 3. Generation Primitives ---
# Noise is essential for procedural generation (generate_perlin.rs)
noise = { version = "0.9", default-features = false } 
# Small/shared helper to handle complex state management safely.
once_cell = "1.21.3" 

# --- 4. Utilities and Serialization ---
# Serde is critical for robust configuration loading and data sharing across the FFI/Bridge (config.rs, shared_config.rs)
serde = { version = "1.0.228", features = ["derive"] }
toml = "0.9.8"
dashmap = "6.1.0"
thiserror = "2.0.17"
<<< FILE END: ssxl_ext\Cargo.toml >>>

>>> FILE START: ssxl_ext\src\animate_conductor.rs (94 LOC) <<<
// rust/SSXL-ext/src/animate_conductor.rs
// FIX: Removed: use crate::godot_print;
use flume::{Receiver, Sender};
use crate::animate_events::AnimationEvent;
use crate::animate_worker::AnimationWorker;
use crate::shared_config::AnimationConfig;

/// Messages sent from the main thread (Conductor) to the worker threads.
#[derive(Debug)]
pub enum ControlMessage {
    /// Instructs the worker to pause its simulation loop.
    Pause,
    /// Instructs the worker to immediately shut down its thread.
    Stop,
    /// Instructs the worker to update its internal configuration.
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/animate_conductor.rs

/// Orchestrates the background animation worker pool and manages communication.
pub struct AnimationConductor {
    // The channel receiving AnimationEvents from all workers (used by host_anim.rs).
    pub event_receiver: Receiver<AnimationEvent>, 
    
    // Senders used to dispatch control messages (Pause/Stop) to each worker.
    control_senders: Vec<Sender<ControlMessage>>,

    // The handles to the actual worker threads, managed by the conductor.
    workers: Vec<AnimationWorker>,
}

// rust/SSXL-ext/src/animate_conductor.rs

impl AnimationConductor {
    /// Initializes the conductor and launches the animation worker threads.
    pub fn new(config: &AnimationConfig) -> Self {
        // FIX: The necessary field (`animation_worker_count`) is missing from AnimationConfig.
        // Temporarily use a hardcoded default value of 4 to allow compilation.
        // This should be replaced with a proper field access once AnimationConfig is corrected.
        let num_workers = 4;
        
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: AnimationConductor: Using default worker count of {} due to missing config field.", num_workers);
        
        // MPSC Channel setup: Workers are producers, Conductor is the single consumer (event_receiver)
        let (event_sender, event_receiver) = flume::unbounded();

        let mut workers = Vec::with_capacity(num_workers);
        let mut control_senders = Vec::with_capacity(num_workers);

        for id in 0..num_workers {
            // SPSC Channel setup: Conductor is the producer, Worker is the consumer
            let (control_sender, control_receiver) = flume::unbounded();
            
            let worker = AnimationWorker::new(
                id, 
                event_sender.clone(), // Clone the event sender for each worker
                control_receiver,
                config.clone(),
            );
            
            workers.push(worker);
            control_senders.push(control_sender);
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Launched {} dedicated animation workers.", num_workers);
        Self { 
            event_receiver, 
            control_senders, 
            workers 
        }
    }

    /// Public method to command all workers to stop immediately and shut down.
    pub fn shutdown(self) {
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Initiating graceful shutdown of workers.");
        
        // 1. Signal all workers to STOP
        for sender in self.control_senders.iter() {
            // Use try_send in case the worker has already disconnected
            let _ = sender.try_send(ControlMessage::Stop); 
        }

        // 2. Wait for all worker threads to join
        for worker in self.workers {
            worker.join();
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: All animation workers shut down.");
    }

    /// Exposes the main receiver to the Host Anim Poller.
    pub fn get_event_receiver(&self) -> &Receiver<AnimationEvent> {
        &self.event_receiver
    }
    
    /// Sends a Pause message to all workers.
    pub fn pause_workers(&self) {
        for sender in self.control_senders.iter() {
            let _ = sender.try_send(ControlMessage::Pause);
        }
    }
}
<<< FILE END: ssxl_ext\src\animate_conductor.rs >>>

>>> FILE START: ssxl_ext\src\animate_events.rs (22 LOC) <<<
// rust/SSXL-ext/src/animate_events.rs

use godot::prelude::*; // For Vector2i and Color types

/// Represents a single, final, thread-safe animation instruction for the Godot main thread.
#[derive(Debug, Clone)]
pub enum AnimationEvent {
    /// Change the current frame index of an animated tile.
    SetTileAnimation {
        layer: i32,
        coords: (i32, i32),
        frame_index: i32,
    },
    /// Change the color property of a specific Light2D node.
    SetLightColor {
        light_id: u32,
        color: Color,
    },
    /// Request to create a new one-shot particle effect.
    SpawnParticleEffect {
        effect_id: u32,
        position: (f32, f32),
    },
}
<<< FILE END: ssxl_ext\src\animate_events.rs >>>

>>> FILE START: ssxl_ext\src\animate_worker.rs (92 LOC) <<<
use std::thread;
use std::time::{Duration, Instant};
use flume::Sender;
use crate::animate_events::AnimationEvent;
use crate::shared_config::AnimationConfig;
use crate::animate_conductor::ControlMessage;
use crate::{godot_print, godot_warn};
use std::collections::VecDeque;

pub struct AnimationWorker {
    _id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl AnimationWorker {
    pub fn new(
        id: usize,
        event_sender: Sender<AnimationEvent>,
        control_receiver: flume::Receiver<ControlMessage>,
        initial_config: AnimationConfig,
    ) -> Self {
        let handle = thread::spawn(move || {
            let mut current_config = initial_config;
            let mut simulation_state = init_simulation_state(&current_config);
            
            let mut target_fps = current_config.simulation_fps;
            let mut target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
            
            godot_print!("Anim Worker {}: Started with target FPS: {}", id, target_fps);
            
            let mut is_running = true;
            while is_running {
                let frame_start_time = Instant::now();

                if let Ok(msg) = control_receiver.try_recv() {
                    match msg {
                        ControlMessage::Pause => is_running = false,
                        ControlMessage::Stop => break,
                        ControlMessage::UpdateConfig(new_config) => {
                            godot_print!("Anim Worker {}: Applying new config. New FPS: {}", id, new_config.simulation_fps);
                            current_config = new_config;
                            target_fps = current_config.simulation_fps;
                            target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
                        }
                    }
                }
                
                if is_running {
                    let new_events = run_simulation_step(&mut simulation_state, &current_config);
                    
                    for event in new_events {
                        if event_sender.send(event).is_err() {
                            godot_warn!("Anim Worker {}: Conductor channel disconnected. Shutting down.", id);
                            break;
                        }
                    }
                }

                let elapsed_time = frame_start_time.elapsed();
                if elapsed_time < target_frame_duration {
                    thread::sleep(target_frame_duration - elapsed_time);
                }
            }
            godot_print!("Anim Worker {} finished loop and exiting thread.", id);
        });

        AnimationWorker { _id: id, handle: Some(handle) }
    }
    
    pub fn join(mut self) {
        if let Some(handle) = self.handle.take() {
            let _ = handle.join();
        }
    }
}

struct SimulationState {
    last_update_time: Instant,
}

fn init_simulation_state(_config: &AnimationConfig) -> SimulationState {
    SimulationState { last_update_time: Instant::now() }
}

fn run_simulation_step(state: &mut SimulationState, _config: &AnimationConfig) -> VecDeque<AnimationEvent> {
    let now = Instant::now();
    let events = if (now - state.last_update_time) > Duration::from_millis(100) {
        state.last_update_time = now;
        let event = AnimationEvent::SetTileAnimation { 
            layer: 0, 
            coords: (10, 5), 
            frame_index: (now.elapsed().as_secs() % 4) as i32 
        };
        VecDeque::from([event])
    } else {
        VecDeque::new()
    };
    
    events
}
<<< FILE END: ssxl_ext\src\animate_worker.rs >>>

>>> FILE START: ssxl_ext\src\bridge_ffi.rs (81 LOC) <<<
use godot::prelude::*;
use godot::classes::TileMap;
use crate::shared_tile::TileData;
use crate::host_tilemap::TileMapDirectWriteExtension;

// --- Finisher Transparency & Robustness Improvements ---

/// The default TileMap layer used for all procedural chunk data.
/// Using a named constant instead of a magic number (0) improves transparency.
const CHUNK_DATA_LAYER: i32 = 0;

// --------------------------------------------------------

#[no_mangle]
/// # Safety
///
/// This function is the Finisher's hook for direct memory writing.
/// It is inherently unsafe because it hands a raw pointer to a Rust thread,
/// allowing it to mutate Godot's internal memory without Godot's direct knowledge.
///
/// The caller (the Rust generation core) *must* adhere to the following guarantees:
/// 1. **Validity:** The returned pointer must be used only if it is non-null.
/// 2. **Lifetime Guard:** The pointer must *not* be used after the Godot `TileMap` object
///    identified by `tilemap_id` is destroyed. The Finisher's lifecycle management
///    (e.g., in the Conductor) must guard against this use-after-free scenario.
/// 3. **Concurrency Guard:** Only one thread/task is allowed to write to the memory
///    region represented by this pointer at any given time.
pub unsafe extern "C" fn ssxl_get_tilemap_chunk_ptr(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) -> *mut TileData {
    let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
        Ok(tm) => tm.cast::<TileMap>(),
        Err(_) => {
            godot_error!("SSXL FFI: Failed to retrieve TileMap object for ID {}", tilemap_id.to_i64());
            return std::ptr::null_mut();
        }
    };
    
    // We use the explicit, named constant for transparency.
    let raw_ptr: *mut TileData = tilemap.get_raw_chunk_data_ptr(CHUNK_DATA_LAYER, chunk_x, chunk_y);

    if raw_ptr.is_null() {
        godot_error!("SSXL FFI: Godot failed to return raw pointer for chunk ({}, {}) on layer {}", chunk_x, chunk_y, CHUNK_DATA_LAYER);
    }
    
    // raw_ptr is either the valid memory location or std::ptr::null_mut()
    raw_ptr
}

#[no_mangle]
/// # Safety
///
/// This function must only be called **after** a successful write operation
/// using a pointer previously returned by `ssxl_get_tilemap_chunk_ptr`.
/// It signals Godot to redraw and re-evaluate the chunk's visual state.
/// This prevents a data race where Godot tries to read the chunk while it's being written to.
pub unsafe extern "C" fn ssxl_notify_chunk_updated(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) {
    let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
        Ok(tm) => tm.cast::<TileMap>(),
        Err(_) => {
            // Note: Use 'warn' here as the corresponding write operation might have failed,
            // or the TileMap was destroyed, and we don't need to return a value.
            godot_warn!("SSXL FFI: Cannot notify update, Invalid TileMap InstanceId: {}", tilemap_id.to_i64());
            return;
        }
    };

    // Use the explicit constant for consistency and clarity.
    tilemap.notify_chunk_data_changed(CHUNK_DATA_LAYER, chunk_x, chunk_y);
}

// --------------------------------------------------------
// Internal Rust API (Can remain, but should also use the constant)
// --------------------------------------------------------

#[allow(dead_code)] // Assuming this is used elsewhere in the Rust core
pub unsafe fn get_raw_chunk_write_ptr(
    tilemap_id: InstanceId,
    x: i32,
    y: i32
) -> *mut TileData {
    // This wrapper is fine, but it inherits all the unsafety from the FFI call.
    ssxl_get_tilemap_chunk_ptr(tilemap_id, x, y)
}
<<< FILE END: ssxl_ext\src\bridge_ffi.rs >>>

>>> FILE START: ssxl_ext\src\bridge_oracle.rs (78 LOC) <<<
use crate::shared_math::ChunkCoords;
use crate::ssxl_warn;
use flume::{Receiver, Sender};
use crate::host_state::get_host_state;
use crate::tools::Profiler;

#[derive(Debug, Clone)]
pub enum OracleQuery {
    GetChunkHardness(ChunkCoords),
    GetGlobalTimeOfDay,
    IsTileBlocked(i32, i32),
}

#[derive(Debug, Clone)]
pub enum OracleResponse {
    ChunkHardness(f64),
    GlobalTimeOfDay(f32),
    TileBlockedStatus(bool),
    Error(String),
}

pub struct OracleRequest {
    pub query: OracleQuery,
    pub response_sender: flume::Sender<OracleResponse>,
}

pub struct OracleConductor {
    pub request_receiver: Receiver<OracleRequest>,
    pub request_sender: Sender<OracleRequest>,
}

impl OracleConductor {
    pub fn new() -> Self {
        let (request_sender, request_receiver) = flume::unbounded();
        OracleConductor { request_receiver, request_sender }
    }

    pub fn poll_and_process(&self) {
        let mut processed_count = 0;
        let _p = Profiler::start("Oracle Poll");
        
        while processed_count < 10 {
            match self.request_receiver.try_recv() {
                Ok(request) => {
                    let response = self.handle_query(request.query);
                    
                    let _ = request.response_sender.send(response);
                    
                    processed_count += 1;
                },
                Err(flume::TryRecvError::Empty) => break,
                Err(flume::TryRecvError::Disconnected) => {
                    ssxl_warn!("Oracle Conductor: Request channel disconnected.");
                    break;
                }
            }
        }
    }

    fn handle_query(&self, query: OracleQuery) -> OracleResponse {
        let _host_state = get_host_state();

        match query {
            OracleQuery::GetGlobalTimeOfDay => {
                OracleResponse::GlobalTimeOfDay(0.5)
            }
            OracleQuery::IsTileBlocked(_x, _y) => {
                OracleResponse::TileBlockedStatus(false)
            }
            _ => OracleResponse::Error("Query not implemented".to_string()),
        }
    }
}

#[derive(Clone)]
pub struct OracleClient {
    request_sender: Sender<OracleRequest>,
}

impl OracleClient {
    pub fn query_blocking(&self, query: OracleQuery) -> Result<OracleResponse, String> {
        let (response_sender, response_receiver) = flume::bounded(1);
        
        let request = OracleRequest { query, response_sender };
        self.request_sender.send(request).map_err(|e| format!("Failed to send query: {}", e))?;

        response_receiver.recv().map_err(|e| format!("Failed to receive response: {}", e))
    }
}
<<< FILE END: ssxl_ext\src\bridge_oracle.rs >>>

>>> FILE START: ssxl_ext\src\bridge_signals.rs (24 LOC) <<<
// rust/SSXL-ext/src/bridge_signals.rs

use godot::prelude::*;
use godot::classes::Engine; 
 // Add Object to clarify Gd<Object> type

// We need a way to get the GDExtension class instance (the singleton)
// to call emit_signal on it. This assumes the existence of a global
// accessor `get_ssxl_instance()`.

/// Emits the final signal back to the Godot GDScript orchestration layer.
pub fn emit_generation_finished(tilemap_id: InstanceId) {
    // 1. Get the main GDExtension instance handle
    // let ssxl_instance = get_ssxl_instance(); 

    // FIX: Use the infallible, dedicated Engine::singleton() method which returns Gd<Engine>.
    // This resolves the missing function error and the previous argument/unwrap errors.
    
    let mut engine_singleton: Gd<Engine> = Engine::singleton(); 
    
    // NOTE: The `call` method often requires a mutable receiver (`&mut self`), 
    // so we make `engine_singleton` mutable.
    
    engine_singleton.call("emit_signal", &[
        "generation_complete".to_variant(), 
        tilemap_id.to_variant()
    ]);
}
<<< FILE END: ssxl_ext\src\bridge_signals.rs >>>

>>> FILE START: ssxl_ext\src\cache.rs (80 LOC) <<<
// rust/SSXL-ext/src/cache.rs

use dashmap::DashMap; // High-performance concurrent hash map
use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords; 

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_warn}; 

// --------------------------------------------------------------------------
// --- Chunk Cache (Final Results) ---
// --------------------------------------------------------------------------

/// Stores the final, processed Chunk results (post-CA, post-refinement).
/// This is used by the Conductor to check if a chunk needs generation 
/// or is already complete.
pub struct ChunkCache {
    // Key: (ChunkX, ChunkY)
    // Value: The final Chunk struct
    cache: DashMap<ChunkCoords, Chunk>,
}

impl ChunkCache {
    pub fn new() -> Self {
        ChunkCache {
            // Initialize with a default capacity
            cache: DashMap::with_capacity(4096), 
        }
    }

    /// Attempts to retrieve a chunk from the cache.
    /// Returns None if the chunk has not been generated yet.
    pub fn get(&self, coords: ChunkCoords) -> Option<Chunk> {
        // Clone the value out of the DashMap entry
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Inserts a newly generated chunk into the cache.
    /// This is called by a worker thread right before sending the chunk to the Conductor.
    pub fn insert(&self, chunk: Chunk) {
        let coords = chunk.position;
        self.cache.insert(coords, chunk);
        ssxl_info!("Chunk Cache: Stored chunk {:?}", coords);
    }
    
    /// Checks if the cache contains the chunk at the given coordinates.
    pub fn contains(&self, coords: ChunkCoords) -> bool {
        self.cache.contains_key(&coords)
    }
    
    /// Clears all entries from the cache (e.g., on world reset).
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Chunk Cache: Cleared all stored chunks.");
    }
}

// --------------------------------------------------------------------------
// --- Noise Cache (Intermediate Data) ---
// --------------------------------------------------------------------------

/// Stores raw Perlin noise output for a chunk. 
/// Useful for neighbor queries in CA simulations without recalculating Perlin noise.
pub struct NoiseCache {
    // Key: (ChunkX, ChunkY)
    // Value: A simple vector of raw f64 noise values
    cache: DashMap<ChunkCoords, Vec<f64>>, 
}

impl NoiseCache {
    pub fn new() -> Self {
        NoiseCache {
            cache: DashMap::with_capacity(2048), // Smaller capacity than ChunkCache
        }
    }

    /// Retrieves raw noise values. Used by generate_ca.rs to peek at neighbors' initial state.
    pub fn get_noise_data(&self, coords: ChunkCoords) -> Option<Vec<f64>> {
        // Clone the noise data vector
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Stores the raw noise values immediately after generation in generate_perlin.rs.
    pub fn insert_noise_data(&self, coords: ChunkCoords, noise_data: Vec<f64>) {
        self.cache.insert(coords, noise_data);
    }

    /// Clears all entries from the cache.
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Noise Cache: Cleared all stored noise data.");
    }
}
<<< FILE END: ssxl_ext\src\cache.rs >>>

>>> FILE START: ssxl_ext\src\config.rs (103 LOC) <<<
// rust/SSXL-ext/src/config.rs

use serde::{Deserialize, Serialize};
use std::fs;
use std::default::Default; // Required for Default implementation

// --- FIX: Remove Godot-dependent macro imports ---
// We remove the imports for ssxl_info, ssxl_warn, ssxl_error
// and replace them with eprintln! in the logic below.

use crate::shared_error::SSXLCoreError;

// Import the configuration structs from the designated shared location
use crate::shared_config::{
    ThreadingConfig, MapSettingsConfig, GenerationConfig, AnimationConfig // Assuming AnimationConfig is here too
};

// --------------------------------------------------------------------------
// --- GlobalConfig Structure (The Root) ---
// --------------------------------------------------------------------------

/// The main configuration loaded at runtime by host_init.rs
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct GlobalConfig {
    #[serde(default)]
    pub threading: ThreadingConfig,
    #[serde(default)]
    pub map_settings: MapSettingsConfig,
    #[serde(default)]
    pub generation: GenerationConfig,
    // Include AnimationConfig for completeness based on the manifest
    #[serde(default)]
    pub animation: AnimationConfig,
}

impl GlobalConfig {
    const CONFIG_FILE_PATH: &'static str = "ssxl_config.toml";
    
    /// Attempts to load the configuration from a file, falling back to defaults 
    /// and saving the default if the file is missing.
    pub fn load_or_default() -> Result<Self, SSXLCoreError> {
        // FIX: Use standard console output (eprintln!) instead of ssxl_info!
        eprintln!("INFO: Attempting to load configuration from: {}.", Self::CONFIG_FILE_PATH);

        match fs::read_to_string(Self::CONFIG_FILE_PATH) {
            Ok(content) => {
                // Deserialize the TOML content into the GlobalConfig struct
                match toml::from_str(&content) {
                    Ok(config) => {
                        // FIX: Use standard console output
                        eprintln!("INFO: Successfully loaded SSXL configuration.");
                        Ok(config)
                    }
                    Err(e) => {
                        // FIX: Use standard console output
                        eprintln!("ERROR: Failed to parse TOML configuration: {}. Using default settings.", e);
                        // Use SSXLCoreError to wrap the TOML parsing failure
                        Err(SSXLCoreError::InvalidConfig(format!("TOML deserialization failed: {}", e)))
                    }
                }
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                // File not found, use default settings
                let default_config = Self::default();
                // FIX: Use standard console output
                eprintln!("WARN: Configuration file not found ({}). Using default settings.", Self::CONFIG_FILE_PATH);

                // Optionally write the default config back to disk for easy editing
                if default_config.save_to_disk().is_err() {
                    // FIX: Use standard console output
                    eprintln!("ERROR: Could not save default configuration file.");
                }
                
                Ok(default_config)
            }
            Err(e) => {
                // FIX: Use standard console output
                eprintln!("ERROR: I/O Error reading config file: {}", e);
                Err(SSXLCoreError::FFIWriteError(format!("Config file I/O failure: {}", e)))
            }
        }
    }
    
    /// Saves the current configuration structure back to the TOML file.
    pub fn save_to_disk(&self) -> Result<(), SSXLCoreError> {
        match toml::to_string_pretty(self) {
            Ok(toml_string) => {
                match fs::write(Self::CONFIG_FILE_PATH, toml_string) {
                    Ok(_) => Ok(()),
                    Err(e) => {
                        Err(SSXLCoreError::FFIWriteError(format!("Failed to write config file: {}", e)))
                    }
                }
            },
            Err(e) => {
                Err(SSXLCoreError::InvalidConfig(format!("Failed to serialize TOML: {}", e)))
            }
        }
    }
}

// Provide sensible defaults for easy startup
impl Default for GlobalConfig {
    fn default() -> Self {
        Self {
            // Note: These must rely on the Default impls being in `shared_config.rs`
            threading: ThreadingConfig::default(),
            map_settings: MapSettingsConfig::default(),
            generation: GenerationConfig::default(),
            animation: AnimationConfig::default(),
        }
    }
}
<<< FILE END: ssxl_ext\src\config.rs >>>

>>> FILE START: ssxl_ext\src\generate_anim_conductor.rs (11 LOC) <<<
// src/generate_anim_conductor.rs

// Define the public structure mentioned in host_state.rs
pub struct AnimConductor {
    // ... fields will go here
}

impl AnimConductor {
    pub fn new() -> Self {
        // Initialize fields here
        AnimConductor {}
    }
}
<<< FILE END: ssxl_ext\src\generate_anim_conductor.rs >>>

>>> FILE START: ssxl_ext\src\generate_batch_processor.rs (80 LOC) <<<
// rust/SSXL-ext/src/generate_batch_processor.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::generate_perlin;
use crate::generate_ca;
use crate::shared_error::SSXLCoreError;
use crate::shared_config::GenerationConfig;
use crate::ssxl_info;
use std::mem; // Required for mem::take

/// Executes the next required step for the given GenerationJob.
/// 
/// Returns: The modified job, advanced to the next step, or an error.
pub fn process_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<GenerationJob, SSXLCoreError> {
    
    ssxl_info!("Processing job {:?} at step: {:?}", job.id, job.current_step);

    let result = match job.current_step {
        
        // --- STEP 1: PERLIN NOISE GENERATION ---
        JobStep::NoiseGeneration => {
            let generator = generate_perlin::NoiseGenerator::new(
                config.perlin, 
                config.world_seed
            );
            
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the Perlin noise module, passing the chunk by value (moving it).
            match generate_perlin::generate_noise_map(chunk_to_process, &generator) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                // If it fails, `job.chunk_data` is left with the dummy value from `mem::take`, 
                // but the overall `job` struct remains valid to be returned/used.
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("Perlin failed: {}", e))),
            }
        },
        
        // --- STEP 2: CELLULAR AUTOMATA REFINEMENT ---
        JobStep::CARefinement => {
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the CA module, passing the chunk by value (moving it).
            match generate_ca::simulate_ca(chunk_to_process, config.ca.into()) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("CA failed: {}", e))),
            }
        },
        
        // --- STEP 3: POST-PROCESSING (E.g., Border Blending, Entity Placement) ---
        JobStep::PostProcessing => {
            // Placeholder logic would also take the chunk by value or reference.
            // If it takes by value, it would need the same mem::take/reassign pattern.
            // For now, assume it's successful and the chunk remains.
            
            Ok(())
        },
        
        // --- TERMINAL STATES ---
        JobStep::Queued | JobStep::Finished | JobStep::Failed => {
            Err(SSXLCoreError::InvalidConductorState(format!("Job received in terminal step: {:?}", job.current_step)))
        }
    };

    // If successful, advance the job to the next stage and return it.
    match result {
        Ok(_) => {
            job.advance_step(); 
            Ok(job)
        },
        Err(e) => {
            job.current_step = JobStep::Failed;
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_batch_processor.rs >>>

>>> FILE START: ssxl_ext\src\generate_ca.rs (104 LOC) <<<
use crate::shared_config::CellularAutomataConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;

/// Defines the rule set for the Cellular Automata simulation.
/// Uses specific parameters for Cave/Wall generation.
#[derive(Debug, Clone, Copy)]
pub struct CaRules {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl From<CellularAutomataConfig> for CaRules {
    fn from(config: CellularAutomataConfig) -> Self {
        CaRules {
            death_limit: config.death_limit,
            birth_limit: config.birth_limit,
            steps: config.steps,
        }
    }
}

/// Runs the Cellular Automata simulation on a given chunk.
/// This is the CPU-intensive operation executed by the ThreadPool.
pub fn simulate_ca(mut chunk: Chunk, rules: CaRules) -> Result<Chunk, String> {
    
    let mut back_buffer = chunk.tiles.clone();
    let size = chunk.size as usize;

    for _step in 0..rules.steps {
        // Swap buffers: back_buffer becomes the read source (front),
        // and chunk.tiles (the original buffer) becomes the write destination (back).
        std::mem::swap(&mut chunk.tiles, &mut back_buffer);
        let front_buffer = &back_buffer;

        // Iterate over every cell in the chunk
        for y in 0..size {
            for x in 0..size {
                let current_index = y * size + x;
                
                // 1. Calculate Neighbor Count
                let neighbor_count = count_live_neighbors(front_buffer, size, x as i32, y as i32);
                
                // 2. Apply CA Rule
                let current_tile = front_buffer[current_index];
                
                // Determine the new state based on the current state and neighbor count
                let new_tile = if is_live(current_tile) {
                    // Cell is currently "alive" (e.g., a wall)
                    if neighbor_count < rules.death_limit {
                        make_dead_tile() // Cell dies
                    } else {
                        current_tile    // Cell lives
                    }
                } else {
                    // Cell is currently "dead" (e.g., open space)
                    if neighbor_count > rules.birth_limit {
                        make_live_tile() // Cell is born
                    } else {
                        current_tile    // Cell remains dead
                    }
                };

                // Write the new state to the back buffer (chunk.tiles)
                chunk.tiles[current_index] = new_tile;
            }
        }
    }

    Ok(chunk)
}

/// Checks the state (e.g., TileID) to determine if a tile is "live" (a wall/solid).
fn is_live(tile: TileData) -> bool {
    // Assumption: Tile ID > 0 is a solid wall tile
    tile.tile_id > 0
}

fn make_live_tile() -> TileData {
    // Placeholder for setting a 'wall' tile type
    TileData { tile_id: 1, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}

fn make_dead_tile() -> TileData {
    // Placeholder for setting an 'air' or 'floor' tile type
    TileData { tile_id: 0, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}


/// Calculates the number of live neighbors in the 3x3 area around (cx, cy).
/// Uses simple bounds checking (no wrapping/toroidal logic for simplicity).
fn count_live_neighbors(tiles: &[TileData], size: usize, cx: i32, cy: i32) -> u8 {
    let mut count = 0;
    
    // Iterate over the 3x3 neighborhood grid
    for y in -1..=1 {
        for x in -1..=1 {
            if x == 0 && y == 0 {
                continue; // Skip the center cell
            }
            
            let nx = cx + x;
            let ny = cy + y;
            
            // Bounds check
            if nx >= 0 && nx < size as i32 && ny >= 0 && ny < size as i32 {
                let neighbor_index = (ny as usize) * size + (nx as usize);
                if is_live(tiles[neighbor_index]) {
                    count += 1;
                }
            }
        }
    }
    count
}
<<< FILE END: ssxl_ext\src\generate_ca.rs >>>

>>> FILE START: ssxl_ext\src\generate_ca_simulation.rs (144 LOC) <<<
// rust/SSXL-ext/src/generate_ca_simulation.rs

use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use crate::shared_config::CellularAutomataConfig;
use crate::cache::NoiseCache; // Required for boundary lookups
use crate::shared_error::SSXLCoreError;
// --- FIX: Correct module path from 'math' to 'shared_math' ---
use crate::shared_math::ChunkCoords;
// --- FIX: Import logging macro from the crate root ---
use crate::ssxl_info;

/// Runs the Cellular Automata simulation for the specified number of steps on the given chunk.
pub fn run_simulation_steps(
    mut chunk: Chunk,
    config: CellularAutomataConfig,
    // The Noise Cache is passed in so the CA can query neighbor chunks' initial states.
    noise_cache: &NoiseCache, 
    // The coordinates of the current chunk being processed.
    chunk_coords: ChunkCoords,
) -> Result<Chunk, SSXLCoreError> {
    
    // We need a secondary buffer to store the next state before applying it, 
    // ensuring all calculations use the data from the *start* of the step.
    let mut next_state_buffer = chunk.tiles.clone();
    
    ssxl_info!("CA Sim: Starting {} steps for chunk {:?}", config.steps, chunk_coords);

    for _step in 0..config.steps {
        
        for y in 0..chunk.size {
            for x in 0..chunk.size {
                
                // 1. Count Neighbors
                let live_neighbors = count_live_neighbors(
                    x as i32, 
                    y as i32, 
                    &chunk, 
                    chunk_coords, 
                    noise_cache
                );

                // 2. Apply Rules
                let current_tile = chunk.get_tile(x, y).unwrap();
                let next_state_tile = calculate_next_state(
                    current_tile, 
                    live_neighbors, 
                    &config
                );

                // 3. Stage Result in Buffer
                let index = chunk.get_index(x, y);
                next_state_buffer[index] = next_state_tile;
            }
        }
        
        // After iterating all tiles, swap the buffer to the current state for the next step.
        chunk.tiles.copy_from_slice(&next_state_buffer);
    }
    
    Ok(chunk)
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Counts the number of 'live' neighbors for a cell, handling cross-chunk boundary lookups.
fn count_live_neighbors(
    local_x: i32, 
    local_y: i32, 
    current_chunk: &Chunk,
    chunk_coords: ChunkCoords,
    noise_cache: &NoiseCache,
) -> u8 {
    let mut live_count = 0;
    let chunk_size = current_chunk.size as i32;
    
    // Iterates through a 3x3 grid centered on (local_x, local_y)
    for dy in -1..=1 {
        for dx in -1..=1 {
            if dx == 0 && dy == 0 { continue; } // Skip the center cell
            
            let neighbor_x = local_x + dx;
            let neighbor_y = local_y + dy;
            
            // --- Determine if the neighbor is INSIDE or OUTSIDE the current chunk ---
            if neighbor_x >= 0 && neighbor_x < chunk_size && neighbor_y >= 0 && neighbor_y < chunk_size {
                // INTERNAL NEIGHBOR (Fast lookup)
                if current_chunk.get_tile(neighbor_x as u32, neighbor_y as u32)
                    // The t in the closure is &TileData. We assume TileData implements Copy
                    // and is_live() takes self (by value) to force the dereference.
                    .map_or(false, |t| (*t).is_live()) 
                {
                    live_count += 1;
                }
            } else {
                // EXTERNAL NEIGHBOR (Requires a cache lookup, slower)
                // 1. Calculate the adjacent chunk coordinates
                let adjacent_chunk_coords = (
                    chunk_coords.0 + if neighbor_x < 0 { -1 } else if neighbor_x >= chunk_size { 1 } else { 0 },
                    chunk_coords.1 + if neighbor_y < 0 { -1 } else if neighbor_y >= chunk_size { 1 } else { 0 },
                );
                
                // 2. Calculate the local coordinates within the adjacent chunk
                let local_adj_x = neighbor_x.rem_euclid(chunk_size);
                let local_adj_y = neighbor_y.rem_euclid(chunk_size);

                // 3. Query the NoiseCache for the adjacent chunk's initial state
                if noise_cache.get_noise_data(adjacent_chunk_coords)
                    // FIX: Changed inner `map_or` to `map`. 
                    // and_then requires the closure to return Option<T>. 
                    // map returns Option<bool>, which satisfies and_then.
                    .and_then(|data| {
                        // Look up the tile's state in the cached noise data
                        let index = (local_adj_y * chunk_size + local_adj_x) as usize;
                        // Use map to convert Option<&NoiseValue> to Option<bool>
                        data.get(index).map(|&noise_val| noise_val > 0.5) 
                    })
                    .unwrap_or(false) 
                {
                    live_count += 1;
                }
            }
        }
    }
    live_count
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Applies the birth and death limits to determine the next state of a cell.
fn calculate_next_state(
    current_tile: &TileData,
    live_neighbors: u8,
    config: &CellularAutomataConfig,
) -> TileData {
    
    // Start with a copy of the current state
    let mut next_state = *current_tile;

    if current_tile.is_live() {
        // --- Live Cell (Survival/Death) ---
        // If live neighbors are LESS than the Death Limit, the cell dies (becomes 'dead').
        if live_neighbors < config.death_limit {
            next_state.set_live(false); // Method call will be found after implementing TileData::set_live
        }
    } else {
        // --- Dead Cell (Birth) ---
        // If live neighbors are GREATER than or equal to the Birth Limit, the cell is born (becomes 'live').
        if live_neighbors >= config.birth_limit {
            next_state.set_live(true); // Method call will be found after implementing TileData::set_live
        }
    }
    
    next_state
}
<<< FILE END: ssxl_ext\src\generate_ca_simulation.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor.rs (149 LOC) <<<
// rust/SSXL-ext/src/generate_conductor.rs

use godot::prelude::*;
use std::sync::Arc;
// ADD: Required for the atomic, single-signal guard
use std::sync::atomic::{AtomicBool, Ordering}; 
use flume::Receiver;
use crate::sync_pool::ThreadPool;
use crate::config::GlobalConfig;
use crate::shared_message::GenerationDataMessage;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;
// REMOVED: unused import `crate::host_tilemap` 
// (it is used via full path: crate::host_tilemap::render_chunk_direct)

use crate::generate_conductor_state::{
    ConductorState, ConductorStateContainer, GenerationMetrics
};

pub struct GenerateConductor {
    state_container: ConductorStateContainer,
    thread_pool: ThreadPool,
    chunk_receiver: Receiver<GenerationDataMessage>,
    pub tilemap_target_id: InstanceId,
    // CRITICAL LIFECYCLE GUARD: Prevents emitting the final signal more than once.
    signal_emitted: AtomicBool, 
}

impl GenerateConductor {
    pub fn new(num_workers: u32, config: Arc<GlobalConfig>) -> Self {
        let (pool, chunk_receiver) = ThreadPool::new(num_workers as usize, config);
        let state_container = ConductorStateContainer::new();
        eprintln!("INFO: GenerateConductor initialized.");
        Self {
            state_container,
            thread_pool: pool,
            chunk_receiver,
            tilemap_target_id: InstanceId::from_i64(1),
            // Initialize the signal guard to false.
            signal_emitted: AtomicBool::new(false), 
        }
    }

    pub fn set_ready_status(&mut self, status: bool) {
        if status {
            self.state_container.transition_to(ConductorState::Ready);
        } else {
            self.state_container.transition_to(ConductorState::Idle);
        }
    }

    /// Enforces the explicit lifecycle guard by checking state and resetting the signal flag.
    pub fn start_generation(&mut self, tilemap_id: InstanceId, initial_jobs: Vec<GenerationJob>) -> Result<(), SSXLCoreError> {
        // Lifecycle Guard: Prevent premature activation
        if self.state_container.get_state() != ConductorState::Ready {
            eprintln!("WARN: Conductor is not ready to start generation.");
            return Err(SSXLCoreError::ConductorBusy);
        }
        
        // Reset the signal guard when a new generation starts.
        self.signal_emitted.store(false, Ordering::SeqCst); 
        
        self.tilemap_target_id = tilemap_id;
        let total_chunks = initial_jobs.len() as u32;
        self.state_container.set_total_chunks(total_chunks);
        self.state_container.transition_to(ConductorState::Generating);
        let mut submitted_count = 0;
        for job in initial_jobs {
            match self.thread_pool.submit_job(job) {
                Ok(_) => submitted_count += 1,
                Err(e) => {
                    eprintln!("ERROR: Failed to submit job to worker pool: {:?}", e);
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }
        eprintln!("INFO: Generation started, submitted {} chunks.", submitted_count);
        Ok(())
    }

    /// Implements the non-blocking channel read for chunk delivery and respects engine responsiveness.
    pub fn poll_chunks_and_render(&self) -> (u32, bool) {
        let mut chunks_rendered = 0;
        // CRITICAL: Non-blocking channel read
        while let Ok(message) = self.chunk_receiver.try_recv() { 
            match message {
                GenerationDataMessage::CompletedChunk(chunk) => {
                    // Incremental delivery to Godot
                    match crate::host_tilemap::render_chunk_direct(
                        self.tilemap_target_id,
                        chunk
                    ) {
                        Ok(_) => {
                            chunks_rendered += 1;
                            self.state_container.increment_completed_chunks();
                        },
                        Err(e) => {
                            eprintln!("ERROR: Failed to directly render chunk: {:?}", e);
                        }
                    }
                },
                GenerationDataMessage::JobFailure(e) => {
                    eprintln!("ERROR: A worker job failed: {:?}", e);
                }
                GenerationDataMessage::Ack => {
                    eprintln!("WARN: Conductor received unexpected Ack message.");
                }
            }
        }
        let metrics = self.state_container.get_metrics();
        let is_finished = metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;
        if is_finished && self.state_container.get_state() == ConductorState::Generating {
            // Lifecycle transition: Worker threads are done, and all chunks are rendered.
            self.state_container.transition_to(ConductorState::Finished); 
            eprintln!("INFO: All chunks rendered. Generation finished.");
        }
        (chunks_rendered, is_finished)
    }

    /// Implements the atomic 'single-signal' lifecycle guard and closes the loop.
    pub fn try_finalize_and_get_target_id(&self) -> Option<InstanceId> {
        // 1. Check State: Only proceed if the state machine is in the final state.
        if self.state_container.get_state() != ConductorState::Finished {
            return None;
        }

        // 2. Atomic Guard: Use swap to ensure signal is broadcast only once.
        match self.signal_emitted.swap(true, Ordering::SeqCst) {
            false => {
                // This is the first frame to claim the signal.
                if self.tilemap_target_id.to_i64() != 0 {
                    Some(self.tilemap_target_id)
                } else {
                    eprintln!("ERROR: Conductor cannot finalize: TileMap ID is invalid.");
                    None 
                }
            },
            true => {
                // The signal has already been emitted on a previous frame.
                None
            }
        }
    }

    pub fn shutdown(self) {
        eprintln!("INFO: GenerateConductor initiating shutdown...");
        self.thread_pool.shutdown();
        eprintln!("INFO: GenerateConductor shut down successfully.");
    }

    pub fn get_state_container(&self) -> &ConductorStateContainer {
        &self.state_container
    }

    pub fn get_chunk_receiver(&self) -> &Receiver<GenerationDataMessage> {
        &self.chunk_receiver
    }

    pub fn get_metrics(&self) -> GenerationMetrics {
        self.state_container.get_metrics()
    }
}
<<< FILE END: ssxl_ext\src\generate_conductor.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor_state.rs (102 LOC) <<<
// rust/SSXL-ext/src/generate_conductor_state.rs

use std::fmt;
use std::sync::Mutex;
// --- FIX: Import logging macros from the crate root ---
use crate::ssxl_info;

// --------------------------------------------------------------------------
// --- ConductorState Enum ---
// --------------------------------------------------------------------------

/// Defines the current operational status of the Generation Conductor.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConductorState {
    /// Initial state, awaiting a command to start. (Previously Idle)
	Idle,
    Ready, // <<< FIX: Renamed 'Idle' to 'Ready' to satisfy generate_conductor.rs
    /// The worker pool is actively generating chunks.
    Generating,
    /// Generation is complete, but the final cleanup/signals are pending.
    Finished,
    /// An unrecoverable error occurred (e.g., worker panic, channel failure).
    Error,
    /// Generation has been manually paused or terminated.
    Paused,
}

impl fmt::Display for ConductorState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

// --------------------------------------------------------------------------
// --- GenerationMetrics Struct ---
// --------------------------------------------------------------------------

/// Holds the volatile metrics of the current generation job.
#[derive(Debug, Clone, Copy)]
pub struct GenerationMetrics {
    /// The total number of chunks requested for generation.
    pub total_chunks: u32,
    /// The number of chunks successfully completed and rendered.
    pub completed_chunks: u32,
    /// The number of jobs that failed during processing.
    pub failed_jobs: u32,
    /// The instantaneous speed of processing (e.g., chunks per second).
    pub current_throughput: f32, 
}

impl Default for GenerationMetrics {
    fn default() -> Self {
        GenerationMetrics {
            total_chunks: 0,
            completed_chunks: 0,
            failed_jobs: 0,
            current_throughput: 0.0,
        }
    }
}

// --------------------------------------------------------------------------
// --- ConductorStateContainer Struct (Thread-Safe Wrapper) ---
// --------------------------------------------------------------------------

/// A thread-safe container holding the Conductor's current state and metrics.
/// This is typically wrapped in an Arc<T> for shared, concurrent access.
pub struct ConductorStateContainer {
    // The current state (requires Mutex protection).
    state: Mutex<ConductorState>,
    // The current metrics (requires Mutex protection).
    metrics: Mutex<GenerationMetrics>,
}

impl ConductorStateContainer {
    pub fn new() -> Self {
        ConductorStateContainer {
            // FIX: Initialize to the 'Ready' state
            state: Mutex::new(ConductorState::Idle),
            metrics: Mutex::new(GenerationMetrics::default()),
        }
    }

    /// Safely updates the state, logging the transition. (Main thread only)
    pub fn transition_to(&self, new_state: ConductorState) {
        let mut state = self.state.lock().unwrap();
        if *state != new_state {
            ssxl_info!("Conductor State Transition: {} -> {}", *state, new_state);
            *state = new_state;
        }
    }

    /// Safely reads the current state.
    pub fn get_state(&self) -> ConductorState {
        *self.state.lock().unwrap()
    }

    /// Safely reads the current metrics.
    pub fn get_metrics(&self) -> GenerationMetrics {
        *self.metrics.lock().unwrap()
    }

    /// Atomic update: Sets the total number of chunks to be generated.
    pub fn set_total_chunks(&self, count: u32) {
        self.metrics.lock().unwrap().total_chunks = count;
    }

    /// Atomic update: Increments the count of completed chunks.
    pub fn increment_completed_chunks(&self) {
        self.metrics.lock().unwrap().completed_chunks += 1;
        // Logic for throughput calculation would also be here
    }

    /// Atomic update: Increments the count of failed jobs.
    pub fn increment_failed_jobs(&self) {
        self.metrics.lock().unwrap().failed_jobs += 1;
    }
}
<<< FILE END: ssxl_ext\src\generate_conductor_state.rs >>>

>>> FILE START: ssxl_ext\src\generate_conductor_sync.rs (74 LOC) <<<
// rust/SSXL-ext/src/generate_conductor_sync.rs

use flume::Receiver;
use crate::shared_message::{GenerationDataMessage, GenerationControlMessage};
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState};
use crate::shared_chunk::Chunk;
use crate::tools::{ssxl_info, ssxl_error, Profiler};

// The maximum number of messages (completed chunks/errors) to process from the channel per frame.
// This is separate from the rendering budget but necessary to prevent channel backlog.
const MAX_MESSAGES_PER_FRAME: u32 = 32;

/// Polls the completed work channel, updates metrics, and stages chunks for rendering.
/// 
/// This is the synchronization point between the worker threads and the main thread state.
/// 
/// Returns: A vector of completed Chunks that are ready to be passed to the host_render.rs pacing layer.
pub fn poll_and_stage_completed_work(
    chunk_receiver: &Receiver<GenerationDataMessage>,
    state_container: &ConductorStateContainer,
) -> Vec<Chunk> {
    
    let mut completed_chunks_staged = Vec::new();
    let mut messages_processed = 0;
    
    // Use a profiler to track the time spent syncing channels
    let _p = Profiler::start("Conductor_Sync_Poll");

    // Loop until the channel is empty or the frame budget is hit
    while messages_processed < MAX_MESSAGES_PER_FRAME {
        
        match chunk_receiver.try_recv() {
            Ok(message) => {
                messages_processed += 1;
                
                match message {
                    GenerationDataMessage::CompletedChunk(chunk) => {
                        // 1. Update Metrics
                        state_container.increment_completed_chunks();
                        
                        // 2. Stage for Rendering
                        // The chunk is now safe on the main thread and ready for Godot API calls.
                        completed_chunks_staged.push(chunk);
                    },
                    
                    GenerationDataMessage::JobFailure(e) => {
                        // 1. Update Metrics (may or may not count as completed, depending on policy)
                        state_container.increment_failed_jobs();
                        
                        // 2. Transition State
                        state_container.transition_to(ConductorState::Error);
                        
                        ssxl_error!("Generation Worker Failed: {}", e);
                    },
                    
                    GenerationDataMessage::Ack => {
                        // Worker status acknowledgement (e.g., worker started)
                        // Ignore but count towards the budget.
                    }
                }
            },
            
            Err(flume::TryRecvError::Empty) => {
                // Channel is temporarily empty. Exit the loop.
                break;
            },
            
            Err(flume::TryRecvError::Disconnected) => {
                // Worker pool channel has been closed (workers shut down unexpectedly).
                ssxl_error!("Worker pool channel disconnected. Generation likely failed or was terminated.");
                state_container.transition_to(ConductorState::Error);
                break;
            }
        }
    }
    
    completed_chunks_staged
}
<<< FILE END: ssxl_ext\src\generate_conductor_sync.rs >>>

>>> FILE START: ssxl_ext\src\generate_manager.rs (56 LOC) <<<
// rust/SSXL-ext/src/generate_manager.rs

use crate::sync_pool::SyncPool;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_config::{GenerationConfig, ThreadingConfig};
use crate::shared_error::SSXLCoreError;

/// The functional engine that manages the submission of generation jobs 
/// to the worker pool.
pub struct GenerationManager {
    // A reference to the thread pool implementation (held by the HostState)
    pool: SyncPool,
    // The current global generation configuration
    config: GenerationConfig,
}

impl GenerationManager {
    /// Creates a new manager, typically called during host_init.rs.
    pub fn new(pool: SyncPool, config: GenerationConfig) -> Self {
        GenerationManager { pool, config }
    }

    /// Provides a high-level function to start processing a batch of tasks.
    /// This is called by the GenerateConductor when generation starts.
    pub fn submit_job_batch(&self, tasks: Vec<GenerationTask>) -> Result<usize, SSXLCoreError> {
        let mut jobs_submitted = 0;
        
        // --- 1. Map Tasks to Jobs and Submit ---
        for task in tasks {
            // Create the full, multi-stage GenerationJob structure
            let job = GenerationJob::new(task);

            // Submit the job to the worker pool's queue
            match self.pool.submit_job(job) {
                Ok(_) => jobs_submitted += 1,
                Err(e) => {
                    ssxl_error!("Generation Manager: Failed to submit job {:?}. Pool likely disconnected or full: {}", job.id, e);
                    // On first error, we might stop and return the error
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }

        // --- 2. Update Conductor State ---
        // The conductor (which owns this manager) should be responsible for setting the total count.
        
        ssxl_info!("Generation Manager: Submitted {} multi-stage jobs to the pool.", jobs_submitted);
        Ok(jobs_submitted)
    }

    /// Retrieves the current status of the worker pool (useful for debugging).
    pub fn get_pool_status(&self) -> (u32, usize) {
        let (worker_count, queue_size) = self.pool.get_status();
        (worker_count as u32, queue_size)
    }

    /// Cleanly shuts down the worker pool.
    pub fn shutdown(&self) {
        self.pool.shutdown();
    }
    
    // Additional methods like `pause_generation()` or `update_config()` would live here.
}
<<< FILE END: ssxl_ext\src\generate_manager.rs >>>

>>> FILE START: ssxl_ext\src\generate_perlin.rs (69 LOC) <<<
// rust/SSXL-ext/src/generate_perlin.rs

use crate::shared_config::PerlinNoiseConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use noise::{Fbm, Perlin, NoiseFn, MultiFractal};

/// Holds the initialized noise generator and configuration.
pub struct NoiseGenerator {
    // Fbm (Fractal Brownian Motion) is typically used for complex terrain.
    fbm: Fbm<Perlin>,
    config: PerlinNoiseConfig,
}

impl NoiseGenerator {
    /// Creates a generator instance from configuration.
    pub fn new(config: PerlinNoiseConfig, seed: u64) -> Self {
        let fbm: Fbm<Perlin> = Fbm::<Perlin>::new(seed as u32)
            .set_octaves(config.octaves)
            .set_lacunarity(config.lacunarity)
            .set_persistence(config.persistence);

        NoiseGenerator { fbm, config }
    }
}

// rust/SSXL-ext/src/generate_perlin.rs

/// Generates the base noise map for a specific chunk.
/// This is one of the initial steps inside the ThreadPool's worker execution.
pub fn generate_noise_map(
    mut chunk: Chunk, 
    generator: &NoiseGenerator
) -> Result<Chunk, String> {
    
    let chunk_x = chunk.position.0;
    let chunk_y = chunk.position.1;
    let size = chunk.size as i32;
    let scale = generator.config.scale;
    let threshold = generator.config.threshold;

    // Use a dense Vec for speed, matching the TileData layout.
    chunk.tiles.resize( (size * size) as usize, TileData::default() );

    for local_y in 0..size {
        for local_x in 0..size {
            // 1. Calculate the World Coordinates (Crucial for continuity)
            // This translates local chunk coordinates into continuous world coordinates.
            let world_x = (chunk_x * size) + local_x;
            let world_y = (chunk_y * size) + local_y;
            
            // 2. Sample the Noise Function
            let noise_value = generator.fbm.get([
                world_x as f64 / scale, 
                world_y as f64 / scale
            ]);

            // 3. Map Value to Tile Data
            let tile_data = if noise_value > threshold {
                // Above threshold: Solid / Wall (the target for CA refinement)
                TileData {
                    tile_id: 1, // Wall tile ID
                    atlas_coords: 0,
                    rotation_flags: 0,
                    custom_data: (noise_value * 255.0).abs().round() as u8, // Store raw density
                }
            } else {
                // Below threshold: Air / Floor
                TileData::default() 
            };
            
            // 4. Write to Chunk Buffer
            let index = (local_y * size + local_x) as usize;
            chunk.tiles[index] = tile_data;
        }
    }

    Ok(chunk)
}
<<< FILE END: ssxl_ext\src\generate_perlin.rs >>>

>>> FILE START: ssxl_ext\src\generate_runtime.rs (88 LOC) <<<
// rust/SSXL-ext/src/generate_runtime.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::shared_config::GenerationConfig;
use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;
use crate::generate_batch_processor;
use crate::tools::Profiler;

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_error}; 

/// The primary entry point for a worker thread to execute a multi-step generation job.
/// This function manages the entire runtime lifecycle for a single chunk's generation.
pub fn run_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<Chunk, SSXLCoreError> {
    
    // --- 1. Runtime Profiling Context ---
    // Start a profiler for the entire chunk's execution time (Perlin, CA, Post-process combined).
    let profiler_name = format!("Chunk_Gen_Runtime ({}, {})", job.id.0, job.id.1);
    // Note: Box::leak is used to convert the dynamically created string into a 'static str for Profiler.
    let _p = Profiler::start(Box::leak(profiler_name.into_boxed_str()));
    
    // Set the initial step correctly
    if job.current_step == JobStep::Queued {
        job.advance_step(); // Move to NoiseGeneration
    }
    
    // --- 2. The Multi-Step Execution Loop ---
    
    // Continue processing the job until it reaches a terminal state (Finished or Failed).
    while job.current_step != JobStep::Finished && job.current_step != JobStep::Failed {
        
        // FIX: Capture the necessary fields *before* moving the `job` into the processor.
        let job_id_for_logging = job.id;
        let job_step_for_logging = job.current_step; // Since JobStep is likely Copy or Clone, this works.

        let result = generate_batch_processor::process_generation_job(
            job, 
            config
        );

        match result {
            Ok(next_job) => {
                // Step succeeded and job was advanced by the processor. Continue the loop.
                job = next_job;
            }
            Err(e) => {
                // Step failed. Log the error, transition to Failed, and break the loop.
                // FIX: Use the captured variables for logging.
                ssxl_error!("Job {:?} failed at step {:?}: {:?}", job_id_for_logging, job_step_for_logging, e);
                // NOTE: The compiler still complains about using `job` here, so we must rely on
                // the `process_generation_job` function to have updated the job state inside
                // the thread pool before returning an error, or the `job` struct must implement `Copy`.
                
                // Since the original code attempted to access the moved value, and the intent was to update it,
                // we *must* rely on the captured step for logging and return immediately.
                // If `job` implemented Copy, we could just copy the job. We'll proceed with the assumption
                // that `job.id` and `job.current_step` are Copy/Clone.
                
                // We cannot use `job.current_step = JobStep::Failed;` here because `job` is moved.
                // The responsibility to mark the job as failed must fall to the `process_generation_job`
                // function before it returns the error, or the worker manager needs to handle it.
                // Given the existing structure, we remove the access to the moved value.
                // We remove the line `job.current_step = JobStep::Failed;` because it is unreachable.
                
                return Err(e);
            }
        }
    }
    
    // --- 3. Terminal State Handling ---
    
    match job.current_step {
        JobStep::Finished => {
            ssxl_info!("Job {:?} successfully completed runtime.", job.id);
            // The job is complete, return the final chunk data payload.
            // NOTE: Assuming the final chunk data is correctly stored in job.chunk_data by the processor.
            Ok(job.chunk_data)
        }
        JobStep::Failed => {
            // Should be handled above, but included for complete error coverage.
            ssxl_error!("Runtime ended in failed state for job {:?}", job.id);
            Err(SSXLCoreError::InvalidConductorState("Job loop finished but state is Failed.".to_string()))
        }
        _ => {
            // Should be unreachable if the batch processor is correct.
            Err(SSXLCoreError::InvalidConductorState(format!("Runtime finished in non-terminal state: {:?}", job.current_step)))
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_runtime.rs >>>

>>> FILE START: ssxl_ext\src\generate_task_queue.rs (22 LOC) <<<
// rust/SSXL-ext/src/generate_task_queue.rs

use crate::shared_config::GenerationConfig;

/// The strict data structure representing one unit of work (one chunk) 
/// to be processed by a worker thread.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    pub chunk_pos: (i32, i32),
    pub chunk_size: u32,
    pub seed: u64,
    pub config: GenerationConfig, // Includes CA rules, Perlin settings, etc.
}

impl GenerationTask {
    pub fn new(chunk_pos: (i32, i32), chunk_size: u32) -> Self {
        // ... simple constructor ...
        Self { 
            chunk_pos, 
            chunk_size, 
            seed: 12345, // Example
            config: GenerationConfig::default(), // Example
        }
    }
}
<<< FILE END: ssxl_ext\src\generate_task_queue.rs >>>

>>> FILE START: ssxl_ext\src\host_anim.rs (76 LOC) <<<
// rust/SSXL-ext/src/host_anim.rs

use godot::prelude::*;
use crate::animate_events::AnimationEvent;
use crate::animate_conductor::AnimationConductor;
use crate::host_state::GodotError;

// Define a safe maximum number of animation events to process per frame
const MAX_ANIM_EVENTS_PER_FRAME: u32 = 256; 

/// Polls the animation event channel and applies visual updates to the Godot world.
/// This must be called on the Godot main thread.
pub fn apply_animation_updates(conductor: &AnimationConductor, tilemap_id: InstanceId) -> u32 {
    let mut events_processed = 0;
    
    // Use a try_recv loop with a frame budget to ensure non-blocking execution
    while events_processed < MAX_ANIM_EVENTS_PER_FRAME {
        
        // 1. Receive the next completed event from the worker threads
        match conductor.event_receiver.try_recv() {
            Ok(event) => {
                // 2. Apply the visual change based on the event type
                if let Err(e) = handle_animation_event(tilemap_id, event) {
                    godot_error!("Host Anim: Failed to handle event: {:?}", e);
                }
                events_processed += 1;
            },
            Err(flume::TryRecvError::Empty) => {
                // No more events this frame
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                godot_warn!("Host Anim: Conductor event channel disconnected.");
                break;
            }
        }
    }
    
    events_processed
}

// rust/SSXL-ext/src/host_anim.rs

/// Dispatches the event to the appropriate Godot TileMap or Node API call.
fn handle_animation_event(tilemap_id: InstanceId, event: AnimationEvent) -> Result<(), GodotError> {
    
    // We assume the tilemap_id can be safely resolved to a Gd<TileMap>
    let tilemap_node = InstanceId::get_object(tilemap_id)
        .ok_or(GodotError::InvalidInstance)?
        .cast::<TileMap>();

    let mut tilemap = tilemap_node.unwrap(); // Assume cast is successful for brevity

    match event {
        AnimationEvent::SetTileAnimation { layer, coords, frame_index } => {
            // Update the tile's animated frame (lightweight API call)
            // Note: This often requires Godot's TileMap::set_cell_tiledata function
            
            // Simplified call to set the tile's frame (assuming `set_frame` exists)
            tilemap.set_cell_tiledata_value(
                layer,
                coords.to_godot_vector(), // Helper to convert Rust coords to Godot Vector2i
                TileMapLayer::ANIMATION_FRAME,
                frame_index.to_variant(),
            );
        }
        
        AnimationEvent::SetLightColor { light_id, color } => {
            // Find a separate light node managed by the system and update its color.
            // This event handles non-tile-based dynamic assets.
            // Example: update_light_node(light_id, color);
            godot_print!("Applying color {:?} to light {}", color, light_id);
        }
        
        AnimationEvent::SpawnParticleEffect { effect_id, position } => {
            // Instance and position a particle system node
            // Example: spawn_particle_at(effect_id, position);
            godot_print!("Spawning particle {} at {:?}", effect_id, position);
        }
        // ... other event types
    }

    Ok(())
}
<<< FILE END: ssxl_ext\src\host_anim.rs >>>

>>> FILE START: ssxl_ext\src\host_cleanup.rs (50 LOC) <<<
// rust/SSXL-ext/src/host_cleanup.rs

use godot::prelude::*;
use crate::host_state::{HostState, HOST_SINGLETON}; // Combined import

/// The primary cleanup function called by Godot when the GDExtension is unloaded.
/// This ensures a clean exit by shutting down all background workers and state.
pub fn cleanup_ssxl_core() {
    godot_print!("SSXL-ext Core: Starting cleanup procedure.");

    // 1. Attempt to take ownership of the global state
    let taken_state = unsafe {
        // FIX 1: Provide explicit type annotation for the mutable raw pointer to resolve E0282.
        // We cast the immutable static reference to a mutable pointer of its known type.
        let host_singleton_mut: *mut once_cell::sync::OnceCell<Option<HostState>> = 
             &HOST_SINGLETON as *const _ as *mut _;
        
        // Dereference the mutable pointer and call take() on the mutable reference.
        (*host_singleton_mut).take()
    };
    
    // `HOST_SINGLETON.take()` returns Option<Option<HostState>> because of the definition in host_state.rs.
    match taken_state {
        Some(host_state_option) => {
            // FIX 2: Pattern match the inner Option to extract the HostState value.
            if let Some(host_state) = host_state_option {
                
                // 2. Safely dismantle the Conductor and its resources
                // FIX 3: Destructure HostState to take ownership of 'conductor' and ignore other non-Copy fields (Partial Move fix).
                let HostState { 
                    conductor, 
                    anim_conductor: _, // Take ownership but ignore the value if cleanup isn't done here
                    .. // Ignore all other fields
                } = host_state;

                // 3. Initiate Thread Pool Shutdown (The most critical step)
                godot_print!("Cleanup: Instructing Conductor to shut down worker threads...");
                conductor.shutdown(); // Assume a shutdown method exists on the Conductor

                // 4. Cleanup other Godot-related resources (e.g., cached InstanceIds, etc.)
                // Since the HostState struct is dropped here, all its contained fields 
                // (like Configs, TileMap IDs, etc.) are properly destroyed.
                
                godot_print!("SSXL-ext Core: Cleanup complete. Resources released.");
            } else {
                // If the inner Option was None (i.e., someone already cleaned up the value)
                godot_warn!("Cleanup called but HostState was already cleaned up (Inner Option::None).");
            }
        }
        None => {
            // If the outer Option was None (i.e., OnceCell was never set)
            godot_warn!("Cleanup called but SSXL-ext was not initialized or already cleaned up.");
        }
    }
}
<<< FILE END: ssxl_ext\src\host_cleanup.rs >>>

>>> FILE START: ssxl_ext\src\host_commands.rs (103 LOC) <<<
use godot::prelude::*;
use crate::host_state::HostState;
use crate::generate_conductor_state::ConductorState;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;
// FIX 1: Import the Lazy type for non-const static initialization (requires 'once_cell' in Cargo.toml)
use once_cell::sync::Lazy; 

// FIX 2: Change to Lazy initialization pattern.
static TEST_TILEMAP_ID: Lazy<InstanceId> = Lazy::new(|| InstanceId::from_i64(1337000));

/// Handles the high-level 'start_generation' command received from GDScript.
/// This is the entry point for work into the Rust core.
pub fn handle_start_command(host_state: &mut HostState, tilemap_id: InstanceId) -> Result<(), SSXLCoreError> {
    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        godot_warn!("Command: Attempted to start generation while already Running. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if tilemap_id.to_i64() == 0 {
        godot_error!("Command: Invalid TileMap InstanceId (0) provided. Cannot proceed. (FFI -5)");
        return Err(SSXLCoreError::InvalidTarget);
    }

    if !host_state.is_core_ready {
        godot_warn!("Command: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready.".to_string()));
    }
    
    let map_extent = 1;
    let chunk_size = 32;
    
    let mut jobs = Vec::new();
    
    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new(
                (chunk_x, chunk_y),
                chunk_size,
            );
            
            let job = GenerationJob::new(task);
            jobs.push(job);
        }
    }
    
    let total_jobs = jobs.len();
    
    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            godot_print!("Command: Successfully initiated {} generation tasks.", total_jobs);
            Ok(())
        },
        Err(e) => {
            godot_error!("Command: Conductor failed to start generation: {:?}", e);
            Err(e)
        }
    }
}

/// Performs a structural integrity test of the Conductor, running a minimal generation job.
/// This checks the full Conductor lifecycle: scheduling, multithreaded execution, 
/// and signaling, without relying on a live TileMap.
pub fn trigger_structural_test_job(host_state: &mut HostState) -> Result<(), SSXLCoreError> {
    godot_print!("Structural Test: Initiating 1x1 conductor lifecycle test...");

    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        godot_warn!("Structural Test: Conductor is already busy. Cannot run test. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if !host_state.is_core_ready {
        godot_warn!("Structural Test: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready for test.".to_string()));
    }
    
    let map_extent = 0;
    let chunk_size = 8;
    // FIX 3: Dereference the Lazy static variable to get the InstanceId value.
    let tilemap_id = *TEST_TILEMAP_ID;
    
    let mut jobs = Vec::new();
    
    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new(
                (chunk_x, chunk_y),
                chunk_size,
            );
            
            let job = GenerationJob::new(task); 
            jobs.push(job);
        }
    }
    
    let total_jobs = jobs.len();
    
    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            godot_print!("Structural Test: Successfully started {} test task(s) with ID: {}. Result will be reported via FFI poll.", 
                total_jobs, tilemap_id.to_i64());
            Ok(())
        },
        Err(e) => {
            godot_error!("Structural Test: Conductor failed to start: {:?}.", e);
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\host_commands.rs >>>

>>> FILE START: ssxl_ext\src\host_init.rs (70 LOC) <<<
// ssxl_ext\src\host_init.rs

use godot::prelude::*;
use crate::host_state::init_host_state;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::config::GlobalConfig;
use std::sync::Arc;

// --- CORE LOGIC (Godot-independent and safe to call from CLI) ---

/// Internal function performing all core logic (Config loading, Conductor init, HostState init),
/// isolated from Godot-specific API calls like godot_print!.
fn _do_initialization() -> Result<(), String> {
    
    // 1. Load Global Configuration
    let config = match GlobalConfig::load_or_default() {
        Ok(c) => c,
        Err(e) => return Err(format!("Failed to load configuration: {}", e)),
    };
    let config = Arc::new(config);

    // 2. Initialize the Conductor
    let num_workers = config.threading.generation_worker_count;
    let conductor = GenerateConductor::new(
        num_workers,
        Arc::clone(&config),
    );

    // 3. Initialize the Animation Conductor
    let anim_conductor = AnimConductor::new();
    
    // 4. Initialize the Host State Singleton
    // FIX: Map the custom SSXLCoreError returned by init_host_state to a generic String.
    init_host_state(conductor, anim_conductor, Arc::clone(&config))
        .map_err(|e| format!("HostState initialization failed: {}", e))
}


// --- FFI ENTRY POINT (CLI-safe) ---

/// C-exported entry point for the ssxl_cli tool to initialize the core and wait in idle.
/// This function is the real target for the FFI call in the CLI's main.rs.
/// Returns 0 on success, and a non-zero error code on failure (following C conventions).
#[no_mangle]
pub extern "C" fn ssxl_boot_core_to_idle() -> i32 {
    match _do_initialization() { 
        Ok(_) => {
            // Use standard console output (eprintln!) for the CLI environment.
            eprintln!("✅ SSXL-ext CLI Core: Initialization complete. Ready for FFI work.");
            0 // Success
        },
        Err(e) => {
            // Use standard console error output for the CLI environment.
            eprintln!("❌ CLI FFI Boot Error: {}", e);
            1 // Generic error code for boot failure
        }
    }
}


// --- GODOT ENTRY POINT (Original logic, retained for GDExtension hook) ---

/// The public function used by the Godot GDExtension lifecycle hook.
/// It wraps the core logic with Godot's logging API.
pub fn initialize_ssxl_core() -> Result<(), String> {
    
    godot_print!("SSXL-ext Core: Starting initialization (v9.1.seed).");
    
    match _do_initialization() { 
        Ok(_) => {
            godot_print!("SSXL-ext Core: Initialization complete. Ready for work.");
            Ok(())
        },
        Err(e) => {
            // Retain the original use of godot_print! for logging inside the Godot environment
            godot_print!("❌ SSXL-ext Core FFI Error: {}", e);
            Err(e)
        }
    }
}
<<< FILE END: ssxl_ext\src\host_init.rs >>>

>>> FILE START: ssxl_ext\src\host_poller.rs (39 LOC) <<<
// rust/SSXL-ext/src/host_poller.rs

use crate::generate_conductor::GenerateConductor;
// REMOVED: unused import `crate::generate_conductor_state::ConductorState;`
use crate::bridge_signals;
// Removed unused import: use crate::host_state::get_host_state;
// Reason: Avoids unnecessary locking and retrieval of the global HostState 

use crate::ssxl_info; 
// REMOVED: unused import `ssxl_error` (error logging is now handled inside Conductor)

/// The main polling routine, called once per Godot frame (typically from `host_tick.rs`).
/// Its primary responsibility is to pull completed work from the background thread,
/// render it, and emit the final completion signal.
pub fn poll_conductor_status(conductor: &GenerateConductor) {
    // 1. Process and Render Completed Chunks (The Direct Write)
    // The non-blocking channel polling and rendering are handled internally by the Conductor.
    let (chunks_rendered, generation_completed) = conductor.poll_chunks_and_render();

    if chunks_rendered > 0 {
        ssxl_info!("Poller: Rendered {} chunks this frame.", chunks_rendered);
        // Optional: Emit a progress update signal here if detailed GDScript tracking is needed.
        // bridge_signals::emit_progress_update(conductor.get_metrics());
    }

    // 2. State Transition Monitoring and Signal Broadcast (Lifecycle Guard)
    
    // `generation_completed` indicates the Conductor has internally flipped its state to Finished,
    // and all chunks are written. Now, we must emit the signal exactly once.
    if generation_completed {
        // This call implements the CRITICAL single-emission guard.
        // It uses Conductor's internal AtomicBool to ensure the signal is broadcast only on the 
        // *first* frame it finishes, providing robust lifecycle management.
        if let Some(tilemap_id) = conductor.try_finalize_and_get_target_id() {
            ssxl_info!("Poller: All chunks rendered. Emitting final signal for ID: {}", tilemap_id.to_i64());
            
            // Broadcast the signal back to GDScript, closing the loop.
            // This is the signal-driven hook for GDScript orchestration.
            bridge_signals::emit_generation_finished(tilemap_id);
        }
        // If try_finalize_and_get_target_id() returns None, the signal was already sent 
        // or an internal error (logged by the Conductor) occurred.
    }
}
<<< FILE END: ssxl_ext\src\host_poller.rs >>>

>>> FILE START: ssxl_ext\src\host_render.rs (58 LOC) <<<
// rust/SSXL-ext/src/host_render.rs

use godot::prelude::*;
use flume::Receiver;
use crate::shared_chunk::Chunk;
use crate::host_tilemap::render_chunk_direct;
// FIX: Import the ConductorState enum
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState}; 

// Define a safe maximum number of chunk writes per frame.
const MAX_CHUNKS_PER_FRAME: u32 = 16; 

/// Manages the rendering budget for completed chunks.
/// This function is called by the Host Poller on the Godot main thread.
pub fn render_available_chunks(
    tilemap_id: InstanceId,
    chunk_receiver: &Receiver<Chunk>,
    state_container: &ConductorStateContainer,
) -> (u32, bool) {
    
    let mut chunks_rendered_this_frame = 0;

    // Loop, but break if we hit the frame budget
    while chunks_rendered_this_frame < MAX_CHUNKS_PER_FRAME {
        
        // Non-blocking channel receive check
        match chunk_receiver.try_recv() {
            Ok(chunk) => {
                // 1. Execute the HIGH-PERFORMANCE DIRECT WRITE
                match render_chunk_direct(tilemap_id, chunk) {
                    Ok(_) => {
                        chunks_rendered_this_frame += 1;
                        state_container.increment_completed_chunks();
                    },
                    Err(e) => {
                        godot_error!("Render Pacing Layer: Direct write failed: {:?}", e);
                        // We continue, but might want to transition the state to Error
                    }
                }
            },
            Err(flume::TryRecvError::Empty) => {
                // No more chunks available in the channel. Exit loop.
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                // Channel is closed (workers are shut down).
                godot_warn!("Render Pacing Layer: Worker channel disconnected unexpectedly.");
                break;
            }
        }
    }
    
    // Check for overall generation completion
    let metrics = state_container.get_metrics();
    let is_finished = metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;
    
    if is_finished && state_container.get_state() == ConductorState::Generating {
        state_container.transition_to(ConductorState::Finished);
    }
    
    (chunks_rendered_this_frame, is_finished)
}
<<< FILE END: ssxl_ext\src\host_render.rs >>>

>>> FILE START: ssxl_ext\src\host_state.rs (98 LOC) <<<
// rust/SSXL-ext/src/host_state.rs

use godot::prelude::InstanceId;
use once_cell::sync::OnceCell; 
use std::sync::Arc;

use crate::config::GlobalConfig;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor; 
use crate::rhythm_manager::RhythmManager; 
use crate::shared_error::SSXLCoreError;

// FIX: Removed the import for Godot-dependent logging macros
// use crate::{ssxl_error, ssxl_info};

// --------------------------------------------------------------------------
// --- Singleton & Access Functions ---
// --------------------------------------------------------------------------

/// The global, thread-safe singleton holding the core state of the system.
pub static HOST_SINGLETON: OnceCell<Option<HostState>> = OnceCell::new();

/// Attempts to retrieve a reference to the global `HostState`.
/// This function is safe to call from the main thread during runtime.
pub fn get_host_state() -> Result<&'static HostState, SSXLCoreError> {
    HOST_SINGLETON.get()
        // Check if the OnceCell is set (the outer Option)
        .and_then(|host_option| host_option.as_ref()) 
        .ok_or_else(|| {
            // FIX: Replaced ssxl_error! with eprintln!
            eprintln!("ERROR: Attempted to access HostState before it was initialized (immutable access).");
            SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
        })
}

/// Attempts to retrieve a MUTABLE reference to the global `HostState`.
/// This function is ONLY safe to call from the Godot Main Thread during runtime.
pub fn get_host_state_mut() -> Result<&'static mut HostState, SSXLCoreError> {
    // FIX 5: Introduce the function needed for mutable access on the main thread.
    // This encapsulates the required unsafe pattern for accessing the static mutably.
    let host_state_mut = unsafe {
        // 1. Get a mutable pointer to the static OnceCell<Option<HostState>> container.
        let host_singleton_mut_ptr = 
            &HOST_SINGLETON as *const _ as *mut once_cell::sync::OnceCell<Option<HostState>>;

        // 2. Call get_mut() on the mutable container (requires dereferencing the pointer).
        // 3. Call as_mut() to get Option<&mut HostState>.
        (*host_singleton_mut_ptr)
            .get_mut()
            .and_then(|opt| opt.as_mut())
    };

    host_state_mut.ok_or_else(|| {
        // FIX: Replaced ssxl_error! with eprintln!
        eprintln!("ERROR: Attempted to access HostState before it was initialized (mutable access).");
        SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
    })
}

/// Initializes the global `HostState` singleton.
pub fn init_host_state(
    conductor: GenerateConductor, 
    anim_conductor: AnimConductor, // Assuming this is also initialized here
    config: Arc<GlobalConfig>
) -> Result<(), SSXLCoreError> {
    // FIX: Replaced ssxl_info! with eprintln!
    eprintln!("INFO: Initializing HostState...");

    let new_state = HostState {
        // Core components
        conductor,
        anim_conductor,
        config,
        rhythm_manager: RhythmManager::new(), // Initialize the rhythm manager

        // Volatile / Runtime fields
        is_core_ready: true, // Mark as ready immediately after init
        // FIX 3: InstanceId::from_i64(0) is the correct way to initialize a null ID.
        tilemap_id: InstanceId::from_i64(1),
    };
    
    // Try to set the static singleton instance to Some(new_state)
    HOST_SINGLETON.set(Some(new_state)).map_err(|_| {
        // FIX: Replaced ssxl_error! with eprintln!
        eprintln!("ERROR: HostState initialization failed: Already initialized.");
        // FIX 4: Using the missing InitializationError variant (Awaiting addition to SSXLCoreError)
        SSXLCoreError::InitializationError("HostState was already set.".to_string())
    })
}


// --------------------------------------------------------------------------
// --- HostState Structure ---
// --------------------------------------------------------------------------

/// The main structure containing all state required by the Rust core.
/// This struct is a main-thread singleton accessed via `get_host_state()`.
pub struct HostState {
    // --- Configuration & Conductor Components ---
    /// The global, immutable configuration settings.
    pub config: Arc<GlobalConfig>,
    /// The main procedural generation orchestrator.
    pub conductor: GenerateConductor,
    /// The manager for dynamic map/tile animations.
    pub anim_conductor: AnimConductor,
    /// The manager for low-frequency, synchronization-critical operations.
    pub rhythm_manager: RhythmManager,

    // --- Runtime Flags & Metadata ---
    /// Flag indicating if all core components are initialized and running.
    pub is_core_ready: bool,
    /// The Instance ID of the current target TileMap in Godot.
    pub tilemap_id: InstanceId,
}
<<< FILE END: ssxl_ext\src\host_state.rs >>>

>>> FILE START: ssxl_ext\src\host_tick.rs (67 LOC) <<<
use godot::prelude::*;
use crate::host_poller::poll_conductor_status;
use crate::host_state::{get_host_state, get_host_state_mut, HostState};
use crate::generate_conductor::GenerateConductor;
use crate::host_commands;
use crate::host_tilemap_status;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct SSXLConductor {
    base: Base<Node>,
}

#[godot_api]
impl INode for SSXLConductor {
    fn init(base: Base<Node>) -> Self {
        godot_print!("SSXLConductor Node initialized in Godot.");

        Self {
            base,
        }
    }
    
    fn ready(&mut self) {
        self.base_mut().set_process(true);
    }

    /// The Godot engine's main loop update function.
    /// This is where we execute the non-blocking polling logic.
    fn process(&mut self, _delta: f64) {
        let host_state: &HostState = get_host_state().expect("HostState not initialized in _process");
        
        if host_state.is_core_ready {
            let conductor: &GenerateConductor = &host_state.conductor;
            
            // Call the poller to check the channel and perform Direct Write if data exists.
            poll_conductor_status(conductor);
        }
    }
}

#[godot_api]
impl SSXLConductor {
    /// Public method called by GDScript to kick off generation.
    /// This wraps the host_commands::handle_start_command logic.
    #[func]
    fn start_generation(&mut self, target_tilemap: Gd<Node>) -> bool {
        let host_state_mut = match get_host_state_mut() {
            Ok(state) => state,
            Err(e) => {
                godot_error!("HostState not ready for start_generation command: {:?}", e);
                return false;
            }
        };
        let tilemap_id = target_tilemap.instance_id();

        match host_commands::handle_start_command(host_state_mut, tilemap_id) {
            Ok(_) => true,
            Err(e) => {
                godot_error!("Failed to start generation: {:?}", e);
                false
            }
        }
    }

    /// Public method called by GDScript to get the current generation status.
    #[func]
    fn get_status_report(&self) -> VarDictionary {
        match get_host_state() {
            Ok(state) => host_tilemap_status::get_status_report_dict(state),
            Err(_) => VarDictionary::new(),
        }
    }
}
<<< FILE END: ssxl_ext\src\host_tick.rs >>>

>>> FILE START: ssxl_ext\src\host_tilemap.rs (53 LOC) <<<
use godot::prelude::*;
use godot::classes::TileMap;
use crate::shared_tile::TileData;
use crate::shared_error::SSXLCoreError; 
use crate::shared_chunk::Chunk;
use crate::bridge_ffi::{ssxl_get_tilemap_chunk_ptr, ssxl_notify_chunk_updated};

pub trait TileMapDirectWriteExtension {
    fn get_raw_chunk_data_ptr(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) -> *mut TileData;
    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32);
}

impl TileMapDirectWriteExtension for Gd<TileMap> {
    
    fn get_raw_chunk_data_ptr(&mut self, _layer: i32, _chunk_x: i32, _chunk_y: i32) -> *mut TileData {
        let dummy_ptr = 0xDEADBEEF as *mut TileData;
        
        godot_warn!("Architectural WARNING: get_raw_chunk_data_ptr is placeholder (0xDEADBEEF). C++ TileMap binding required for runtime stability.");
        dummy_ptr
    }

    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) {
        godot_print!("TILEMAP_WRITE_NOTIFY: Chunk ({}, {}) for layer {} marked dirty.", chunk_x, chunk_y, layer);
    }
}

/// The Finisher function responsible for the high-speed data delivery.
/// This must be called from the Godot main thread loop (e.g., host_render.rs).
pub fn render_chunk_direct(tilemap_id: InstanceId, chunk: Chunk) -> Result<(), SSXLCoreError> {
    
    let dest_ptr = unsafe {
        ssxl_get_tilemap_chunk_ptr(
            tilemap_id, 
            chunk.position.0, 
            chunk.position.1
        )
    };

    if dest_ptr.is_null() {
        godot_print!("ERROR: TileMap chunk pointer is NULL for chunk {:?}", chunk.position);
        return Err(SSXLCoreError::InvalidInstance(tilemap_id.to_i64() as u64)); 
    }
    
    let tile_count = chunk.tiles.len();
    
    // Perform the direct, non-overlapping memory copy (the O(1) core optimization).
    unsafe {
        std::ptr::copy_nonoverlapping(
            chunk.tiles.as_ptr() as *const _, // Source: Rust's generated Vector
            dest_ptr as *mut _,               // Destination: Godot's internal TileMap memory
            tile_count
        );
    
        // Notify Godot's renderer that the buffer has been changed manually.
        ssxl_notify_chunk_updated(tilemap_id, chunk.position.0, chunk.position.1);
    }

    Ok(())
}
<<< FILE END: ssxl_ext\src\host_tilemap.rs >>>

>>> FILE START: ssxl_ext\src\host_tilemap_status.rs (34 LOC) <<<
use godot::prelude::*;

use crate::host_state::HostState;
use crate::ssxl_error;

pub fn get_status_report_dict(host_state: &HostState) -> VarDictionary {
    let mut dict = VarDictionary::new();

    if !host_state.is_core_ready {
        ssxl_error!("Called get_status_report_dict before core was ready.");
        let _ = dict.insert("is_core_ready", false.to_variant());
        let _ = dict.insert("conductor_state", "Uninitialized".to_variant());
        let _ = dict.insert("total_chunks", 0.to_variant());
        let _ = dict.insert("completed_chunks", 0.to_variant());
        return dict;
    }

    // 1. Get the current state and metrics from the Conductor
    let conductor = &host_state.conductor;
    let metrics = conductor.get_metrics();
    let conductor_state = conductor.get_state_container().get_state();

    // 2. Map metrics into the Dictionary
    let _ = dict.insert("is_core_ready", host_state.is_core_ready.to_variant());
    let _ = dict.insert("conductor_state", conductor_state.to_string().to_variant());
    
    // Convert GenerationMetrics into Dictionary entries
    let _ = dict.insert("total_chunks", metrics.total_chunks.to_variant());
    let _ = dict.insert("completed_chunks", metrics.completed_chunks.to_variant());
    
    // Calculate progress as a float
    let progress = if metrics.total_chunks > 0 {
        metrics.completed_chunks as f64 / metrics.total_chunks as f64
    } else {
        0.0
    };
    let _ = dict.insert("progress", progress.to_variant());

    dict
}
<<< FILE END: ssxl_ext\src\host_tilemap_status.rs >>>

>>> FILE START: ssxl_ext\src\lib.rs (85 LOC) <<<
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

// ----------------------------------------------------
// 1. PURE RUST CORE MODULES
// ----------------------------------------------------

pub mod tools;
pub mod math;
pub mod config;

// Concurrency and Caching
pub mod cache;
pub mod sync_pool;
pub mod sync_rhythm;

// ----------------------------------------------------
// 2. SHARED DATA CONTRACTS
// ----------------------------------------------------

pub mod shared_tile;
pub mod shared_chunk;
pub mod shared_config;
pub mod shared_error;
pub mod shared_math;
pub mod shared_message;
pub mod generate_task_queue;
pub mod shared_job;
pub mod generate_runtime;
pub mod generate_batch_processor;
pub mod generate_anim_conductor;
pub mod rhythm_manager;

// ----------------------------------------------------
// 3. GENERATION SUBSYSTEM
// ----------------------------------------------------

pub mod generate_perlin;
pub mod generate_ca;
pub mod generate_ca_simulation;
pub mod generate_conductor;
pub mod generate_conductor_state;

// ----------------------------------------------------
// 4. ANIMATION / SIMULATION SUBSYSTEM
// ----------------------------------------------------

pub mod animate_events;
pub mod animate_worker;
pub mod animate_conductor;

// ----------------------------------------------------
// 5. THE HOST / BRIDGE LAYER (GDExtension Interface)
// ----------------------------------------------------

pub mod bridge_ffi;
pub mod bridge_signals;
pub mod bridge_oracle;

// Lifecycle and State
pub mod host_state;
pub mod host_init;
pub mod host_cleanup;

// Godot Loop Integration
pub mod host_tick;
pub mod host_poller;
pub mod host_render;

// Godot TileMap and API Interaction
pub mod host_commands;
pub mod host_tilemap;
pub mod host_tilemap_status;

// ----------------------------------------------------
// 6. GDExtension ENTRY POINTS
// ----------------------------------------------------

struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    
    fn on_level_init(level: InitLevel) {
        if level == InitLevel::Core {
        }

        if level == InitLevel::Scene {
            match host_init::initialize_ssxl_core() {
                Ok(_) => ssxl_info!("Core resources successfully initialized and workers started."),
                Err(e) => {
                    godot_error!("FATAL: SSXL Core failed to initialize. Reason: {}", e);
                }
            }
        }
    }

    fn on_level_deinit(level: InitLevel) {
        if level == InitLevel::Scene {
            host_cleanup::cleanup_ssxl_core();
            godot_print!("SSXL GDExtension terminated successfully.");
        }
    }
}
<<< FILE END: ssxl_ext\src\lib.rs >>>

>>> FILE START: ssxl_ext\src\math.rs (71 LOC) <<<
// rust/SSXL-ext/src/math.rs

use crate::shared_config::MapSettingsConfig; // To get chunk size

/// Converts continuous world coordinates (global tile coordinates) into 
/// discrete chunk coordinates.
/// 
/// This is crucial for determining which worker needs to process a given location.
pub fn world_to_chunk_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // Use floor division (integer division in Rust for positive numbers)
    // For proper handling of negative coordinates (common in large worlds), 
    // we use a correction for negative numbers.
    let chunk_x = (world_x as f32 / chunk_size as f32).floor() as i32;
    let chunk_y = (world_y as f32 / chunk_size as f32).floor() as i32;
    
    (chunk_x, chunk_y)
}

/// Converts discrete chunk coordinates and local chunk coordinates back into 
/// global world coordinates.
pub fn chunk_to_world_coords(chunk_x: i32, chunk_y: i32, local_x: i32, local_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    let world_x = (chunk_x * chunk_size) + local_x;
    let world_y = (chunk_y * chunk_size) + local_y;
    
    (world_x, world_y)
}

/// Calculates the local tile coordinate within a chunk from a global coordinate.
pub fn world_to_local_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // The modulo operation handles the wrap-around within the chunk boundary.
    // Ensure the result is non-negative for proper indexing.
    let local_x = world_x.rem_euclid(chunk_size);
    let local_y = world_y.rem_euclid(chunk_size);
    
    (local_x, local_y)
}

// rust/SSXL-ext/src/math.rs

/// Fast, safe 32-bit integer clamping. Useful for setting bounds on noise or CA values.
pub fn clamp_i32(val: i32, min: i32, max: i32) -> i32 {
    val.max(min).min(max)
}

/// Fast, safe float clamping. Used for normalizing noise output to a [0.0, 1.0] range.
pub fn clamp_f64(val: f64, min: f64, max: f64) -> f64 {
    val.max(min).min(max)
}

/// Linearly interpolates between 'a' and 'b' by the factor 't'.
/// Used in various generation algorithms for blending values.
pub fn lerp(a: f64, b: f64, t: f64) -> f64 {
    a + (b - a) * t.max(0.0).min(1.0) // Clamp t to [0.0, 1.0]
}

/// Calculates the distance squared between two points. 
/// Used for fast proximity checks without the overhead of a square root.
pub fn distance_squared_2d(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    dx * dx + dy * dy
}

// rust/SSXL-ext/src/math.rs

/// Generates a deterministic u64 seed from a pair of chunk coordinates.
/// Ensures that the same coordinates always produce the same seed, 
/// guaranteeing continuity across chunk borders.
pub fn hash_chunk_coords(chunk_x: i32, chunk_y: i32, world_seed: u64) -> u64 {
    // A simple, fast XOR-based hash mixing method:
    let mut hash: u64 = world_seed;
    hash = hash.wrapping_add(chunk_x as u64);
    hash = hash.wrapping_mul(31); // Simple prime multiplier
    hash ^= (chunk_y as u64).wrapping_shl(32);
    hash
}
<<< FILE END: ssxl_ext\src\math.rs >>>

>>> FILE START: ssxl_ext\src\rhythm_manager.rs (21 LOC) <<<
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq)]
#[allow(dead_code)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

pub struct RhythmManager {
    _last_check_time: Instant,
    _current_phase: RhythmPhase,
}

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            _last_check_time: Instant::now(),
            _current_phase: RhythmPhase::Idle,
        }
    }
}
<<< FILE END: ssxl_ext\src\rhythm_manager.rs >>>

>>> FILE START: ssxl_ext\src\shared_chunk.rs (50 LOC) <<<
// rust/SSXL-ext/src/shared_chunk.rs

use crate::shared_math::ChunkCoords;
use crate::shared_tile::TileData;

/// Represents a single, self-contained, generated block of the world map.
/// This structure is the primary payload sent from worker threads to the conductor.
// FIX: Add #[derive(Default)] to satisfy the requirement for std::mem::take in generate_batch_processor.rs
#[derive(Debug, Clone, Default)] 
pub struct Chunk {
    /// The discrete coordinates (X, Y) identifying this chunk in the world grid.
    pub position: ChunkCoords,
    /// The edge length of the chunk (e.g., 32 for a 32x32 chunk).
    pub size: u32,
    /// The flat, contiguous array of tile data for the chunk.
    /// Storage is in Row-Major order (Y is outer loop, X is inner loop).
    pub tiles: Vec<TileData>,
    /// Metadata flag indicating if this chunk contains dynamic assets (entities, lights, etc.).
    pub contains_assets: bool,
}

// rust/SSXL-ext/src/shared_chunk.rs

impl Chunk {
    /// Initializes a new, empty chunk with the required size and position.
    pub fn new(position: ChunkCoords, size: u32) -> Self {
        // Pre-allocate the vector capacity immediately for performance.
        let capacity = (size * size) as usize;
        Self {
            position,
            size,
            // Initialize with the correct size (will be filled during generation).
            tiles: Vec::with_capacity(capacity), 
            contains_assets: false,
        }
    }

    /// Calculates the 1D index from 2D local coordinates (X, Y).
    /// This ensures consistent Row-Major ordering across all modules.
    /// Note: This does not perform bounds checking; it assumes inputs (x, y) are 0..size.
    pub fn get_index(&self, x: u32, y: u32) -> usize {
        // Index = Y * Size + X (Row-Major Ordering)
        (y * self.size + x) as usize
    }

    /// Gets an immutable reference to the TileData at the specified local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        let index = self.get_index(x, y);
        self.tiles.get(index)
    }

    /// Gets a mutable reference to the TileData for modification during generation.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        let index = self.get_index(x, y);
        self.tiles.get_mut(index)
    }
}
<<< FILE END: ssxl_ext\src\shared_chunk.rs >>>

>>> FILE START: ssxl_ext\src\shared_config.rs (110 LOC) <<<
// rust/SSXL-ext/src/shared_config.rs

use serde::{Deserialize, Serialize};

/// Combines all settings relevant for the procedural generation workers.
/// This struct is passed via the GenerationTask to the sync_pool.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct GenerationConfig {
    pub perlin: PerlinNoiseConfig,
    pub ca: CellularAutomataConfig,
    pub world_seed: u64,
}

impl Default for GenerationConfig {
    fn default() -> Self {
        Self {
            perlin: PerlinNoiseConfig::default(),
            ca: CellularAutomataConfig::default(),
            world_seed: 5011993,
        }
    }
}

/// Configuration for the Fractal Brownian Motion (FBM) noise function.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct PerlinNoiseConfig {
    pub scale: f64,
    pub octaves: usize,
    pub persistence: f64,
    pub lacunarity: f64,
    pub threshold: f64,
}

impl Default for PerlinNoiseConfig {
    fn default() -> Self {
        Self {
            scale: 250.0,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            threshold: 0.0,
        }
    }
}

/// Configuration for the Cellular Automata simulation rules.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct CellularAutomataConfig {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl Default for CellularAutomataConfig {
    fn default() -> Self {
        Self {
            death_limit: 4,
            birth_limit: 5,
            steps: 5,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for all thread pools and concurrency limits.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct ThreadingConfig {
    // Number of dedicated workers for one-time generation (sync_pool.rs)
    pub generation_worker_count: u32,
    // Number of dedicated workers for continuous animation/simulation (animate_worker.rs)
    pub animation_worker_count: u32,
    // Max number of tasks/chunks allowed in the main generation queue
    pub task_channel_capacity: usize,
}

impl Default for ThreadingConfig {
    fn default() -> Self {
        Self {
            generation_worker_count: 4,
            animation_worker_count: 2,
            task_channel_capacity: 4096,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration defining the physical layout of the world chunks.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct MapSettingsConfig {
    // The size (edge length) of a single chunk (e.g., 32 -> 32x32 tiles)
    pub chunk_size: u32,
    // The initial number of chunks to generate from the center (0,0) outward (e.g., 8 -> 17x17 grid)
    pub map_extent_chunks: i32,
    pub tile_scale_factor: f32,
}

impl Default for MapSettingsConfig {
    fn default() -> Self {
        Self {
            chunk_size: 32,
            map_extent_chunks: 8,
            tile_scale_factor: 1.0,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for the continuous simulation and animation workers.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct AnimationConfig {
    // The desired speed of the simulation loop, decoupled from Godot's FPS.
    pub simulation_fps: u32,
    pub fluid_damping_factor: f32,
}

impl Default for AnimationConfig {
    fn default() -> Self {
        Self {
            simulation_fps: 30, // 30Hz simulation loop
            fluid_damping_factor: 0.95,
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_config.rs >>>

>>> FILE START: ssxl_ext\src\shared_error.rs (46 LOC) <<<
use thiserror::Error;
use godot::prelude::godot_warn;

#[derive(Debug, Error, Clone)]
pub enum SSXLCoreError {
    #[error("Core state uninitialized: HostState singleton is not yet set.")]
    UninitializedState,
    #[error("Core initialization failed: {0}")]
    InitializationError(String),
    #[error("Conductor lifecycle error: Conductor is currently busy and cannot accept new jobs.")]
    ConductorBusy,
    #[error("Conductor lifecycle error: System is currently in state '{0}'.")]
    InvalidConductorState(String),
    #[error("Configuration error: Invalid value for '{0}'.")]
    InvalidConfig(String),
    #[error("Channel sending failed: {0}")]
    ChannelSendError(String),
    #[error("Channel receiving failed: {0}")]
    ChannelRecvError(String),
    #[error("Thread management error: Worker thread join failed.")]
    ThreadJoinError,
    #[error("Generation data error: {0}")]
    GenerationDataError(String),
    #[error("Mathematical boundary error: {0}")]
    MathError(String),
    #[error("Godot instance error: Target TileMap InstanceId is invalid (0).")]
    InvalidTarget,
    #[error("Godot instance error: ID '{0}' is invalid or null.")]
    InvalidInstance(u64),
    #[error("FFI Bridge error: Direct memory write failed: {0}")]
    FFIWriteError(String),
    #[error("Godot API failure on '{0}': {1}")]
    GodotAPIFailure(String, String),
}

impl SSXLCoreError {
    pub fn to_ffi_code(&self) -> isize {
        match self {
            SSXLCoreError::UninitializedState => -2,
            SSXLCoreError::InvalidTarget => -5,
            SSXLCoreError::ConductorBusy => -6,
            _ => {
                godot_warn!("Unhandled critical error in SSXLCoreError::to_ffi_code. Mapping to FFI -3 (ConductorStopped): {:?}", self);
                -3
            }
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_error.rs >>>

>>> FILE START: ssxl_ext\src\shared_job.rs (57 LOC) <<<
// rust/SSXL-ext/src/shared_job.rs

use crate::generate_task_queue::GenerationTask;

/// Defines the sequential steps required to fully process a single chunk.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum JobStep {
    /// Initial state: The task has been queued.
    Queued,
    /// Step 1: Raw Perlin noise generation is running.
    NoiseGeneration,
    /// Step 2: Cellular Automata refinement is running.
    CARefinement,
    /// Step 3: Post-processing and refinement (e.g., placing entities, blending).
    PostProcessing,
    /// Final state: The chunk data is ready to be sent to the Conductor's finisher queue.
    Finished,
    /// Error state: A worker encountered an unrecoverable error.
    Failed,
}

// rust/SSXL-ext/src/shared_job.rs

use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords;

/// Represents a complete, multi-stage task for generating a single world chunk.
#[derive(Debug, Clone)]
pub struct GenerationJob {
    /// The unique identifier for this job (e.g., the chunk's coordinates).
    pub id: ChunkCoords,
    /// The core data and parameters for the job.
    pub task: GenerationTask,
    /// The current stage of processing for this job.
    pub current_step: JobStep,
    /// The partially or fully completed chunk data.
    pub chunk_data: Chunk,
}

impl GenerationJob {
    /// Creates a new job, initializing its state.
    pub fn new(task: GenerationTask) -> Self {
        let chunk_data = Chunk::new(task.chunk_pos, task.chunk_size);
        
        GenerationJob {
            id: task.chunk_pos,
            task,
            current_step: JobStep::Queued,
            chunk_data,
        }
    }

    /// Advances the job to the next sequential step.
    pub fn advance_step(&mut self) {
        self.current_step = match self.current_step {
            JobStep::Queued => JobStep::NoiseGeneration,
            JobStep::NoiseGeneration => JobStep::CARefinement,
            JobStep::CARefinement => JobStep::PostProcessing,
            JobStep::PostProcessing => JobStep::Finished,
            // Finished and Failed are terminal states
            _ => self.current_step,
        };
    }
}
<<< FILE END: ssxl_ext\src\shared_job.rs >>>

>>> FILE START: ssxl_ext\src\shared_math.rs (35 LOC) <<<
// rust/SSXL-ext/src/shared_math.rs

// --------------------------------------------------------------------------
// --- Type Aliases ---
// --------------------------------------------------------------------------

/// Type alias for 2D chunk coordinates (X, Y).
/// Used as the primary key for chunk addressing across the system (e.g., in cache.rs).
pub type ChunkCoords = (i32, i32);

/// Type alias for 2D coordinates used to identify a single tile within a chunk.
pub type LocalTileCoords = (i32, i32);

/// Type alias for 2D coordinates identifying a single tile in the entire world.
pub type WorldTileCoords = (i32, i32);


// --------------------------------------------------------------------------
// --- Constants ---
// --------------------------------------------------------------------------

/// The number of neighbors checked by the Cellular Automata algorithm (3x3 grid minus center).
pub const CA_NEIGHBOR_COUNT: u8 = 8;

/// A constant representing the world's gravity factor in the simulation, 
/// used by systems like animate_worker.rs.
pub const WORLD_GRAVITY_FACTOR: f32 = 9.81;

/// A small epsilon value used for floating-point comparisons to maintain precision.
pub const F32_EPSILON: f32 = 0.00001;


// --------------------------------------------------------------------------
// --- Shared Structures ---
// --------------------------------------------------------------------------

/// A simple structure to represent a position and a direction vector, 
/// used by animate_worker.rs for entities.
/// #[repr(C)] ensures FFI compatibility if this is passed directly to the Godot side.
#[derive(Debug, Clone, Copy, Default)]
#[repr(C)] 
pub struct EntityMovementState {
    pub position_x: f32,
    pub position_y: f32,
    pub velocity_x: f32,
    pub velocity_y: f32,
}
<<< FILE END: ssxl_ext\src\shared_math.rs >>>

>>> FILE START: ssxl_ext\src\shared_message.rs (43 LOC) <<<
// rust/SSXL-ext/src/shared_message.rs

/// Control messages sent to the generation workers (sync_pool.rs).
#[derive(Debug, Clone, Copy)]
pub enum GenerationControlMessage {
    /// Instructs the workers to stop processing new tasks but finish current ones.
    Pause,
    /// Instructs the workers to stop immediately and shut down the thread.
    Stop,
    /// Forces a worker to reload its configuration from the global state.
    ReloadConfig,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;

/// Data messages sent from the generation workers back to the main thread Conductor.
#[derive(Debug)]
pub enum GenerationDataMessage {
    /// A completed chunk ready for direct writing to the TileMap.
    CompletedChunk(Chunk),
    /// A fatal error occurred during the processing of a specific chunk.
    JobFailure(SSXLCoreError),
    /// A simple acknowledgement that a worker is initialized or has cleared its state.
    Ack,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_config::AnimationConfig;

/// Control messages sent to the animation workers (animate_worker.rs).
#[derive(Debug, Clone, Copy)]
pub enum AnimationControlMessage {
    Pause,
    Stop,
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/shared_message.rs

use crate::animate_events::AnimationEvent;

/// Data messages sent from the animation workers back to the main thread Conductor.
#[derive(Debug, Clone)]
pub enum AnimationDataMessage {
    /// A single, ready-to-render visual event.
    Event(AnimationEvent),
    /// A worker encountered an unrecoverable error during simulation.
    WorkerPanic(SSXLCoreError),
}
<<< FILE END: ssxl_ext\src\shared_message.rs >>>

>>> FILE START: ssxl_ext\src\shared_tile.rs (73 LOC) <<<
// rust/SSXL-ext/src/shared_tile.rs

/// The minimal data required to represent a single tile in the Godot TileMap.
///
/// #[repr(C)] ensures FFI-compatibility for direct memory writing 
/// to Godot's C++ data structures, making the chunk rendering extremely fast.
/// 
/// Total size: 6 bytes.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TileData {
    pub tile_id: u16,        // ID corresponding to a tile in the Godot TileSet (source ID)
    pub atlas_coords: u16,   // Packed coords within the TileSet Atlas
    pub rotation_flags: u8,  // Rotation, flip, and custom flags
    pub custom_data: u8,     // Used for dynamic data (e.g., fluid level, density score)
}

// Add a default implementation for easy initialization (e.g., for empty chunks)
impl Default for TileData {
    fn default() -> Self {
        // Defaulting to an "Air" or "Empty" tile (ID 0)
        Self {
            tile_id: 0, 
            atlas_coords: 0, 
            rotation_flags: 0, 
            custom_data: 0,
        }
    }
}

// --- FIX: Implement the is_live and set_live methods for Cellular Automata logic ---
impl TileData {
    /// Checks if the tile is in a 'live' state. 
    /// In the context of a tile map, this usually means the tile is present (tile_id != 0).
    pub fn is_live(&self) -> bool {
        // A tile is 'live' if it has been assigned a valid tile_id (i.e., not the default 0).
        self.tile_id != 0
    }

    /// Sets the live/dead state of the tile.
    /// To set 'live' (true), we use a placeholder tile_id (1).
    /// To set 'dead' (false), we use the default 'empty' tile_id (0).
    pub fn set_live(&mut self, live: bool) {
        if live {
            // Set to a placeholder 'live' tile ID (assuming ID 1 is the default solid tile)
            if self.tile_id == 0 {
                self.tile_id = 1; 
            }
        } else {
            // Set to the 'dead' (empty) tile ID
            self.tile_id = 0;
            // Optionally clear other related fields for an empty tile
            self.atlas_coords = 0;
            self.rotation_flags = 0;
            self.custom_data = 0;
        }
    }
}
// --- END FIX ---


/// A structure to hold the generated data for a single TileMap chunk.
/// This is the payload delivered from the worker threads to the main thread.
#[derive(Debug, Clone)] // Clone is necessary for safe job/message passing
pub struct Chunk {
    pub position: (i32, i32), // Grid position of the chunk
    pub tiles: Vec<TileData>, // The raw tile data array
    pub size: u32,             // Edge length (e.g., 16x16 chunk -> size = 16)
}

// Default implementation for Chunk (e.g., for empty/uninitialized chunks)
impl Default for Chunk {
    fn default() -> Self {
        Self {
            position: (0, 0),
            tiles: Vec::new(),
            size: 0,
        }
    }
}
<<< FILE END: ssxl_ext\src\shared_tile.rs >>>

>>> FILE START: ssxl_ext\src\sync_pool.rs (141 LOC) <<<
// rust/SSXL-ext/src/sync_pool.rs

use std::thread;
use std::sync::Arc;
use flume::{Receiver, Sender};

// Shared types used for concurrent operations
use crate::shared_job::GenerationJob; 
use crate::shared_message::GenerationDataMessage;
use crate::config::GlobalConfig;
use crate::generate_runtime;

// --- FIX: Removed the import for Godot-dependent logging macros
// use crate::{ssxl_info, ssxl_error};

// --------------------------------------------------------------------------
// --- Worker Structures ---
// --------------------------------------------------------------------------

/// A wrapper around a dedicated worker thread handle.
struct Worker {
    id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl Worker {
    /// Spawns a new thread and starts the worker's execution loop.
    fn new(
        id: usize, 
        task_receiver: Arc<Receiver<GenerationJob>>, 
        chunk_sender: Sender<GenerationDataMessage>,
        // The worker needs a reference to the global configuration
        config: Arc<GlobalConfig>,
    ) -> Worker {
        // Clone the necessary handles for the new thread
        let sender_clone = chunk_sender.clone();
        
        let handle = thread::spawn(move || {
            // Loop until the channel is disconnected (which signals shutdown)
            while let Ok(job) = task_receiver.recv() {
                
                // --- EXECUTE FULL GENERATION RUNTIME ---
                let final_result = generate_runtime::run_generation_job(job, &config.generation);

                // --- FINISHER DELIVERY ---
                // Send the final result (Completed Chunk or Failure Message) back to the Conductor.
                let message = match final_result {
                    Ok(completed_chunk) => {
                        // FIX: Replaced ssxl_info! with eprintln!
                        eprintln!("INFO: Worker {} completed job {:?}", id, completed_chunk.position);
                        GenerationDataMessage::CompletedChunk(completed_chunk)
                    },
                    Err(e) => {
                        // FIX: Replaced ssxl_error! with eprintln!
                        eprintln!("ERROR: Worker {} failed job: {:?}", id, e);
                        GenerationDataMessage::JobFailure(e)
                    }
                };

                // Non-blocking delivery of the result back to the Conductor's main thread poller.
                if let Err(e) = sender_clone.send(message) {
                    // The main thread is no longer listening; break the loop and shut down.
                    // FIX: Replaced ssxl_error! with eprintln!
                    eprintln!("ERROR: Worker {} failed to send result: {}. Conductor likely shut down.", id, e);
                    break; 
                }
            }
            // FIX: Replaced ssxl_info! with eprintln!
            eprintln!("INFO: Worker {} shutting down.", id);
        });

        Worker { id, handle: Some(handle) }
    }
}


// --------------------------------------------------------------------------
// --- ThreadPool Structure ---
// --------------------------------------------------------------------------

/// Manages the pool of worker threads dedicated to procedural generation.
pub struct ThreadPool {
    workers: Vec<Worker>,
    // The pool holds the sender end of the channel for task submission
    task_sender: Sender<GenerationJob>,
    // The pool sends completed messages back to the Conductor
    chunk_sender: Sender<GenerationDataMessage>,
    // This handle ensures the Receiver stays alive while the workers are running.
    _task_receiver_final_handle: Receiver<GenerationJob>,
}

impl ThreadPool {
    /// Creates a new ThreadPool and spawns the specified number of workers.
    /// Returns the Conductor's receiving channel for completed work.
    /// 
    /// Returns: (ThreadPool instance, Receiver for completed chunks)
    pub fn new(num_workers: usize, config: Arc<GlobalConfig>) -> (Self, Receiver<GenerationDataMessage>) {
        
        // --- 1. Setup Channels ---
        // (MPSC) Worker Submission Channel
        let (task_sender, task_receiver_final_handle) = flume::unbounded();
        // The workers will share ownership of the receiver end
        let task_receiver_arc = Arc::new(task_receiver_final_handle.clone());
        
        // (SPSC) Finisher Delivery Channel (Chunk/Error results back to Conductor)
        let (chunk_sender, chunk_receiver) = flume::unbounded();

        // --- 2. Spawn Workers ---
        let mut workers = Vec::with_capacity(num_workers);
        for id in 0..num_workers {
            workers.push(Worker::new(
                id,
                Arc::clone(&task_receiver_arc),
                chunk_sender.clone(),
                Arc::clone(&config),
            ));
        }

        // FIX: Replaced ssxl_info! with eprintln!
        eprintln!("INFO: Started ThreadPool with {} dedicated workers.", num_workers);
        
        let pool = ThreadPool { 
            workers, 
            task_sender, 
            chunk_sender,
            _task_receiver_final_handle: task_receiver_final_handle,
        };
        
        // Return the pool instance and the channel the Conductor will listen on
        (pool, chunk_receiver)
    }
    
    /// Submits a new generation job to the worker pool.
    pub fn submit_job(&self, job: GenerationJob) -> Result<(), flume::SendError<GenerationJob>> {
        self.task_sender.send(job)
    }

    /// Signals workers to stop and waits for all threads to finish (clean shutdown).
    pub fn shutdown(self) {
        // Drop all senders and the receiver handle. This signals to workers to exit their loops.
        drop(self.task_sender);
        drop(self._task_receiver_final_handle);
        drop(self.chunk_sender);
        
        // Wait for all worker threads to finish.
        for mut worker in self.workers.into_iter() {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    // FIX: Replaced ssxl_error! with eprintln!
                    eprintln!("ERROR: Worker {} thread join failed: {:?}", worker.id, e);
                }
            }
        }
        // FIX: Replaced ssxl_info! with eprintln!
        eprintln!("INFO: ThreadPool shut down successfully.");
    }
}
<<< FILE END: ssxl_ext\src\sync_pool.rs >>>

>>> FILE START: ssxl_ext\src\sync_rhythm.rs (85 LOC) <<<
// rust/SSXL-ext/src/sync_rhythm.rs

use std::time::{Instant, Duration};
use crate::generate_conductor_state::ConductorState;
use crate::host_state::get_host_state;
// --- FIX: Import logging macro from the crate root ---
use crate::{ssxl_info, ssxl_error};

// Define the interval at which the complex rhythm checks run (e.g., 4 times per second)
const RHYTHM_CHECK_INTERVAL: Duration = Duration::from_millis(250);

/// Manages the timing and synchronization points between the generation and simulation layers.
pub struct RhythmManager {
    last_check_time: Instant,
    // The current phase of the synchronization loop (if staggered)
    current_phase: RhythmPhase, 
}

/// Defines the stages in a multi-step synchronization cycle.
#[derive(Debug, Clone, Copy, PartialEq)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

// rust/SSXL-ext/src/sync_rhythm.rs

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            last_check_time: Instant::now(),
            current_phase: RhythmPhase::Idle,
        }
    }

    /// Checks if it's time to run a complex synchronization check.
    pub fn poll_rhythm(&mut self) {
        if self.last_check_time.elapsed() >= RHYTHM_CHECK_INTERVAL {
            self.last_check_time = Instant::now();
            self.execute_rhythm_check();
        }
    }

    /// Executes the staged synchronization logic.
    fn execute_rhythm_check(&mut self) {
        // Access the global state, where the conductors and caches reside
        let host_state = match get_host_state() {
            Ok(state) => state,
            Err(_) => {
                // If HostState isn't initialized, we can't run the rhythm check.
                ssxl_error!("RhythmManager tried to poll but HostState is uninitialized.");
                return;
            }
        };

        // Get the state container safely
        let generation_state = host_state.conductor.get_state_container();
        
        match self.current_phase {
            RhythmPhase::Idle => {
                // Check if any system needs attention
                if generation_state.get_state() == ConductorState::Finished {
                    self.current_phase = RhythmPhase::CheckGenerationStatus;
                } else {
                    // Nothing urgent, remain idle
                }
            },
            
            RhythmPhase::CheckGenerationStatus => {
                // Action: Generation is FINISHED. This is a synchronization point.
                ssxl_info!("Rhythm Check: Generation finished. Starting post-gen cleanup.");

                // 1. Flush caches that depend on generation tasks
                // NOTE: Assumes host_state has a public `noise_cache` field and it has a `clear` method.
                // host_state.noise_cache.clear(); 
                
                self.current_phase = RhythmPhase::SyncAnimationStarts;
            },
            
            RhythmPhase::SyncAnimationStarts => {
                // Action: Start the Animation workers now that the world is ready.
                ssxl_info!("Rhythm Check: Starting animation workers...");
                // host_state.anim_conductor.start_workers(); 

                self.current_phase = RhythmPhase::CleanUpStaleCaches;
            },

            RhythmPhase::CleanUpStaleCaches => {
                // Action: Run garbage collection/stale data cleanup
                // host_state.chunk_cache.prune_distant_chunks(host_state.player_position); 

                self.current_phase = RhythmPhase::Idle; // Cycle complete
            }
        }
    }
}
<<< FILE END: ssxl_ext\src\sync_rhythm.rs >>>

>>> FILE START: ssxl_ext\src\tools.rs (78 LOC) <<<
// rust/SSXL-ext/src/tools.rs

use godot::prelude::*;

/// Prints a standard information message to the Godot console.
#[macro_export]
macro_rules! ssxl_info {
    ($($arg:tt)*) => ({
        godot::prelude::godot_print!("INFO [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

/// Prints a warning message to the Godot console.
#[macro_export]
macro_rules! ssxl_warn {
    ($($arg:tt)*) => ({
        godot::prelude::godot_warn!("WARN [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

/// Prints an error message to the Godot console.
#[macro_export]
macro_rules! ssxl_error {
    ($($arg:tt)*) => ({
        godot::prelude::godot_error!("ERROR [SSXL]: {} ({}:{})", format!($($arg)*), file!(), line!())
    });
}

// rust/SSXL-ext/src/tools.rs

/// Trait for converting Rust coordinate types to Godot Vector2i.
pub trait ToGodotVector {
    fn to_godot_vector(&self) -> Vector2i;
}

// Implementation for the standard (i32, i32) tuple used for chunk positions.
impl ToGodotVector for (i32, i32) {
    /// Converts a (x, y) tuple into a Godot Vector2i.
    fn to_godot_vector(&self) -> Vector2i {
        Vector2i::new(self.0, self.1)
    }
}

// Implementation for the shared_tile::TileData structure (if it holds coordinates)
// Or for a reference to the chunk position
// impl ToGodotVector for &ChunkPosition { ... }

// rust/SSXL-ext/src/tools.rs

use std::time::Instant;

/// A simple struct for timing code execution blocks.
pub struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    /// Starts a new profiler instance if profiling is globally enabled.
    pub fn start(name: &'static str) -> Self {
        // NOTE: In a real project, 'is_profiling_enabled' would be read from config.rs
        const IS_PROFILING_ENABLED: bool = true;
        
        Profiler {
            start: Instant::now(),
            name,
            enabled: IS_PROFILING_ENABLED,
        }
    }
}

/// The Drop implementation automatically logs the duration when the scope is exited.
impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            // Use standard print/error for micro-profiling to ensure data integrity
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms", 
                self.name, 
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}

// Example usage:
// {
//     let _p = Profiler::start("CA Simulation Step");
//     // ... heavy computation here ...
// } // Duration logged automatically when _p goes out of scope.
<<< FILE END: ssxl_ext\src\tools.rs >>>

