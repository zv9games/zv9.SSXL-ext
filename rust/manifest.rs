SSXL-ext is a mythic core â€” a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ â†’).

ğŸª¶ Manifest v9.0.seed


#files


C:/ZV9/zv9.SSXL-ext/rust

Crate: ssxl_cache/src
â”œâ”€â”€ [CORE]  lib.rs $

ğŸ” Crate: ssxl_engine_ffi/src
â”œâ”€â”€ [CORE]  lib.rs $

ğŸ” Crate: ssxl_generate/src
â”‚Â  Â â””â”€â”€  batch_processor.rs $
â”‚Â  Â â””â”€â”€  benchmark_logic.rs $
â”‚Â  Â â””â”€â”€  ca\mod.rs $
â”‚Â  Â â””â”€â”€  ca\neighbor_check.rs $
â”‚Â  Â â””â”€â”€  ca\rule_set.rs $
â”‚Â  Â â””â”€â”€  cellular_automata_generator.rs $
â”‚Â  Â â””â”€â”€  conductor.rs $
â”‚Â  Â â””â”€â”€  conductor_state.rs $
â”‚Â  Â â””â”€â”€  config_validator.rs $
â”‚Â  Â â””â”€â”€  generator.rs $
â”‚Â  Â â””â”€â”€  generator_manager.rs $
â”œâ”€â”€ [CORE]  lib.rs $
â”‚Â  Â â””â”€â”€  perlin_generator.rs $
â”‚Â  Â â””â”€â”€  runtime_manager.rs $
â”‚Â  Â â””â”€â”€  sync.rs $
â”‚Â  Â â””â”€â”€  task_queue.rs $

ğŸ” Crate: ssxl_godot/src
â”‚Â  Â â””â”€â”€  animation_api.rs $
â”‚Â  Â â””â”€â”€  api_initializers.rs $
â”‚Â  Â â””â”€â”€  async_poll.rs $
â”‚Â  Â â””â”€â”€  build.rs $
â”‚Â  Â â””â”€â”€  channel_handler.rs $
â”‚Â  Â â””â”€â”€  chunk_presenter.rs $
â”‚Â  Â â””â”€â”€  gde_api_defs.rs $
â”‚Â  Â â””â”€â”€  generation_api.rs $
â”œâ”€â”€ [CORE]  lib.rs $
â”‚Â  Â â””â”€â”€  ssxl_engine.rs $
â”‚Â  Â â””â”€â”€  ssxl_oracle.rs $
â”‚Â  Â â””â”€â”€  ssxl_signals.rs $

ğŸ” Crate: ssxl_math/src
â”‚Â  Â â””â”€â”€  coordinate_system.rs $
â”‚Â  Â â””â”€â”€  generation_utils.rs $
â”‚Â  Â â””â”€â”€  hashing.rs $
â”œâ”€â”€ [CORE]  lib.rs $
â”‚Â  Â â””â”€â”€  primitives.rs $

ğŸ” Crate: ssxl_shared/src
â”‚Â  Â â””â”€â”€  chunk_data.rs $
â”‚Â  Â â””â”€â”€  config.rs $
â”‚Â  Â â””â”€â”€  errors.rs $
â”‚Â  Â â””â”€â”€  generation_message.rs $
â”‚Â  Â â””â”€â”€  grid_bounds.rs $
â”œâ”€â”€ [CORE]  lib.rs $
â”‚Â  Â â””â”€â”€  math_primitives.rs $
â”‚Â  Â â””â”€â”€  messages.rs $
â”‚Â  Â â””â”€â”€  tile_data.rs $
â”‚Â  Â â””â”€â”€  tile_type.rs $

ğŸ” Crate: ssxl_sync/src
â”‚Â  Â â””â”€â”€  animation_conductor.rs $
â”œâ”€â”€ [CORE]  lib.rs $
â”‚Â  Â â””â”€â”€  pool_manager.rs $
â”‚Â  Â â””â”€â”€  primitives.rs $

ğŸ” Crate: ssxl_tools/src
â”œâ”€â”€ [CORE]  lib.rs $

ğŸ” Crate: ssxl_cli/src
â”‚Â  Â â””â”€â”€  actions\benchmarking.rs $
â”‚Â  Â â””â”€â”€  actions\godot_harness.rs $
â”‚Â  Â â””â”€â”€  actions\mod.rs $
â”‚Â  Â â””â”€â”€  actions\testing.rs $
â”‚Â  Â â””â”€â”€  cli_util_bench.rs $
â”‚Â  Â â””â”€â”€  cli_util_inspect.rs $
â”‚Â  Â â””â”€â”€  cli_util_menu.rs $
â”œâ”€â”€ [CORE]  main.rs $
â”‚Â  Â â””â”€â”€  scan\file_walker.rs $
â”‚Â  Â â””â”€â”€  scan\mod.rs $
â”‚Â  Â â””â”€â”€  scan\report_formatter.rs $


# SSXL ENGINE API MANIFEST: QUANTUM ALIGNMENT GUIDE

## ğŸ¯ SSXL PARADIGM: CONTROL VS. EVENT

The SSXL Engine operates at high velocity by separating **Control** (synchronous Godot calls to Rust) from **Data/Event** (asynchronous Rust signals back to Godot). All heavy work runs on a **worker thread**, ensuring Godot's main thread maintains **subzero-cold latency** (zero stutter).

---

## 1. CONTROL PLANE: SYNCHRONOUS FFI METHODS (`SSXLEngine`)

These functions are callable directly from Godot and execute instantly on the main thread.

### A. SETUP & LIFECYCLE
| Method | Parameters | Return | Description |
| :--- | :--- | :--- | :--- |
| `set_signals_node` | `signals_node: Gd<Node>` | `()` | **REQUIRED FIRST CALL.** Registers the Godot `Node` (the signal emitter) that the Rust engine uses for all asynchronous communication (`chunk_ready`, etc.). |
| `set_tilemap` | `tilemap_node: Gd<TileMap>` | `()` | Provides the engine a reference to the TileMap node for future rendering utility hooks. |
| `shutdown_engine` | `()` | `()` | Initiates a graceful teardown of the Rust Tokio runtime and all worker threads. |

### B. GENERATION & CONTROL
| Method | Parameters | Return | Description |
| :--- | :--- | :--- | :--- |
| `build_map` | `width: u32, height: u32, seed_str: GString, generator_name: GString` | `()` | **Starts map generation on a worker thread.** Immediately returns control to Godot. Results are streamed via the `chunk_ready` signal. |
| `stop_generation` | `()` | `()` | Signals the worker thread to stop map generation gracefully. |
| `set_generator` | `tile_type_name: GString` | `()` | Sets the procedural generation algorithm (e.g., "perlin_basic_2d"). |

### C. STATUS & UTILITY
| Method | Parameters | Return | Description |
| :--- | :--- | :--- | :--- |
| `get_status` | `()` | `GString` | Returns the current engine status ("Running," "Idle," etc.). |
| `get_current_tile_count` | `()` | `u64` | Returns a running count of tiles generated by the worker. |
| `tick` | `_current_tick: u64` | `()` | Optional frame update hook (use sparingly). |
| `set_animation_enabled`| `enabled: bool` | `()` | Toggles the low-latency animation conductor (e.g., flow fields). |
| `stop_animation` | `()` | `()` | Graceful shutdown of the animation conductor. |

---

## 2. DATA PLANE: ASYNCHRONOUS SIGNALS (`SSXL_Signals.gd`)

These are **outbound events** emitted from the Rust worker thread and queued for safe processing by the Godot main thread. They **do not** appear in the FFI method list.

### A. SIGNAL CONTRACT
The `signals_node` must declare and emit these signals:

| Signal Name | Emitter Thread | Godot Handler | Purpose |
| :--- | :--- | :--- | :--- |
| `chunk_ready` | Worker | Main (Queued) | **PRIMARY DATA CHANNEL.** Delivers a batch of tiles for rendering. |
| `generation_complete` | Worker | Main (Queued) | Fired when `build_map` finishes all work or `stop_generation` completes. |
| `status_update` | Worker | Main (Queued) | Live logging/progress updates from the asynchronous work. |

### B. CRYPTO-CODED PAYLOAD (`chunk_ready` Data Structure)

The `chunk_ready` signal handler in GDScript must expect this exact signature and dictionary structure for FFI integrity:

```gdscript
signal chunk_ready(chunk_data_dict: Dictionary, chunk_pos_x: int, chunk_pos_y: int)