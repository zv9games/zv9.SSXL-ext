SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1765828288
Root Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
        58 LOC | rust/ssxl_ext/src\animate_conductor.rs
// --- START: rust/ssxl_ext/src\animate_conductor.rs ---
// rust/SSXL-ext/src/animate_conductor.rs
// FIX: Removed: use crate::godot_print;
use flume::{Receiver, Sender};
use crate::animate_events::AnimationEvent;
use crate::animate_worker::AnimationWorker;
use crate::shared_config::AnimationConfig;

/// Messages sent from the main thread (Conductor) to the worker threads.
#[derive(Debug)]
pub enum ControlMessage {
    /// Instructs the worker to pause its simulation loop.
    Pause,
    /// Instructs the worker to immediately shut down its thread.
    Stop,
    /// Instructs the worker to update its internal configuration.
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/animate_conductor.rs

/// Orchestrates the background animation worker pool and manages communication.
pub struct AnimationConductor {
    // The channel receiving AnimationEvents from all workers (used by host_anim.rs).
    pub event_receiver: Receiver<AnimationEvent>, 
    
    // Senders used to dispatch control messages (Pause/Stop) to each worker.
    control_senders: Vec<Sender<ControlMessage>>,

    // The handles to the actual worker threads, managed by the conductor.
    workers: Vec<AnimationWorker>,
}

// rust/SSXL-ext/src/animate_conductor.rs

impl AnimationConductor {
    /// Initializes the conductor and launches the animation worker threads.
    pub fn new(config: &AnimationConfig) -> Self {
        // FIX: The necessary field (`animation_worker_count`) is missing from AnimationConfig.
        // Temporarily use a hardcoded default value of 4 to allow compilation.
        // This should be replaced with a proper field access once AnimationConfig is corrected.
        let num_workers = 4;
        
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: AnimationConductor: Using default worker count of {} due to missing config field.", num_workers);
        
        // MPSC Channel setup: Workers are producers, Conductor is the single consumer (event_receiver)
        let (event_sender, event_receiver) = flume::unbounded();

        let mut workers = Vec::with_capacity(num_workers);
        let mut control_senders = Vec::with_capacity(num_workers);

        for id in 0..num_workers {
            // SPSC Channel setup: Conductor is the producer, Worker is the consumer
            let (control_sender, control_receiver) = flume::unbounded();
            
            let worker = AnimationWorker::new(
                id, 
                event_sender.clone(), // Clone the event sender for each worker
                control_receiver,
                config.clone(),
            );
            
            workers.push(worker);
            control_senders.push(control_sender);
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Launched {} dedicated animation workers.", num_workers);
        Self { 
            event_receiver, 
            control_senders, 
            workers 
        }
    }

    /// Public method to command all workers to stop immediately and shut down.
    pub fn shutdown(self) {
        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: Initiating graceful shutdown of workers.");
        
        // 1. Signal all workers to STOP
        for sender in self.control_senders.iter() {
            // Use try_send in case the worker has already disconnected
            let _ = sender.try_send(ControlMessage::Stop); 
        }

        // 2. Wait for all worker threads to join
        for worker in self.workers {
            worker.join();
        }

        // FIX: Use eprintln! for CLI-safe logging
        eprintln!("INFO: Animation Conductor: All animation workers shut down.");
    }

    /// Exposes the main receiver to the Host Anim Poller.
    pub fn get_event_receiver(&self) -> &Receiver<AnimationEvent> {
        &self.event_receiver
    }
    
    /// Sends a Pause message to all workers.
    pub fn pause_workers(&self) {
        for sender in self.control_senders.iter() {
            let _ = sender.try_send(ControlMessage::Pause);
        }
    }
}
// --- END: rust/ssxl_ext/src\animate_conductor.rs ---
        17 LOC | rust/ssxl_ext/src\animate_events.rs
// --- START: rust/ssxl_ext/src\animate_events.rs ---
// rust/SSXL-ext/src/animate_events.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate the Godot import
#[cfg(feature = "godot-binding")]
use godot::prelude::*; // For Vector2i and Color types

// ðŸŽ¯ CRITICAL FIX: Define mock types for the CLI build (where godot-binding is OFF)
// Vector2i is defined in tools.rs, but we need to define Color here or in a shared place.
#[cfg(not(feature = "godot-binding"))]
type Color = u32; // Placeholder for Godot's Color type

/// Represents a single, final, thread-safe animation instruction for the Godot main thread.
#[derive(Debug, Clone)]
pub enum AnimationEvent {
    /// Change the current frame index of an animated tile.
    SetTileAnimation {
        layer: i32,
        coords: (i32, i32),
        frame_index: i32,
    },
    /// Change the color property of a specific Light2D node.
    SetLightColor {
        light_id: u32,
        // The type 'Color' here will resolve to 'godot::builtin::Color' when 
        // godot-binding is on, and to the 'u32' alias when it is off.
        color: Color, 
    },
    /// Request to create a new one-shot particle effect.
    SpawnParticleEffect {
        effect_id: u32,
        position: (f32, f32),
    },
}
// --- END: rust/ssxl_ext/src\animate_events.rs ---
        85 LOC | rust/ssxl_ext/src\animate_worker.rs
// --- START: rust/ssxl_ext/src\animate_worker.rs ---
use std::thread;
use std::time::{Duration, Instant};
use flume::Sender;
use crate::animate_events::AnimationEvent;
use crate::shared_config::AnimationConfig;
use crate::animate_conductor::ControlMessage;
use crate::{ssxl_info, ssxl_warn}; // ðŸ”¥ FIX 1: Use custom logger macros
// use crate::{godot_print, godot_warn}; // REMOVED: Replaced by ssxl_*
use std::collections::VecDeque;

pub struct AnimationWorker {
    _id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl AnimationWorker {
    pub fn new(
        id: usize,
        event_sender: Sender<AnimationEvent>,
        control_receiver: flume::Receiver<ControlMessage>,
        initial_config: AnimationConfig,
    ) -> Self {
        let handle = thread::spawn(move || {
            let mut current_config = initial_config;
            let mut simulation_state = init_simulation_state(&current_config);
            
            let mut target_fps = current_config.simulation_fps;
            let mut target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
            
            // ðŸ”¥ FIX 2: Replaced godot_print! with ssxl_info!
            ssxl_info!("Anim Worker {}: Started with target FPS: {}", id, target_fps);
            
            let mut is_running = true;
            while is_running {
                let frame_start_time = Instant::now();

                if let Ok(msg) = control_receiver.try_recv() {
                    match msg {
                        ControlMessage::Pause => is_running = false,
                        ControlMessage::Stop => break,
                        ControlMessage::UpdateConfig(new_config) => {
                            // ðŸ”¥ FIX 3: Replaced godot_print! with ssxl_info!
                            ssxl_info!("Anim Worker {}: Applying new config. New FPS: {}", id, new_config.simulation_fps);
                            current_config = new_config;
                            target_fps = current_config.simulation_fps;
                            target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
                        }
                    }
                }
                
                if is_running {
                    let new_events = run_simulation_step(&mut simulation_state, &current_config);
                    
                    for event in new_events {
                        if event_sender.send(event).is_err() {
                            // ðŸ”¥ FIX 4: Replaced godot_warn! with ssxl_warn!
                            ssxl_warn!("Anim Worker {}: Conductor channel disconnected. Shutting down.", id);
                            break;
                        }
                    }
                }

                let elapsed_time = frame_start_time.elapsed();
                if elapsed_time < target_frame_duration {
                    thread::sleep(target_frame_duration - elapsed_time);
                }
            }
            // ðŸ”¥ FIX 5: Replaced godot_print! with ssxl_info!
            ssxl_info!("Anim Worker {} finished loop and exiting thread.", id);
        });

        AnimationWorker { _id: id, handle: Some(handle) }
    }
    
    pub fn join(mut self) {
        if let Some(handle) = self.handle.take() {
            let _ = handle.join();
        }
    }
}

struct SimulationState {
    last_update_time: Instant,
}

fn init_simulation_state(_config: &AnimationConfig) -> SimulationState {
    SimulationState { last_update_time: Instant::now() }
}

fn run_simulation_step(state: &mut SimulationState, _config: &AnimationConfig) -> VecDeque<AnimationEvent> {
    let now = Instant::now();
    let events = if (now - state.last_update_time) > Duration::from_millis(100) {
        state.last_update_time = now;
        let event = AnimationEvent::SetTileAnimation { 
            layer: 0, 
            coords: (10, 5), 
            frame_index: (now.elapsed().as_secs() % 4) as i32 
        };
        VecDeque::from([event])
    } else {
        VecDeque::new()
    };
    
    events
}
// --- END: rust/ssxl_ext/src\animate_worker.rs ---
        61 LOC | rust/ssxl_ext/src\bridge_ffi.rs
// --- START: rust/ssxl_ext/src\bridge_ffi.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(not(feature = "godot-binding"))]
type InstanceId = u64;

use crate::shared_tile::TileData;

#[cfg(feature = "godot-binding")]
const CHUNK_DATA_LAYER: i32 = 0;

#[no_mangle]
pub unsafe extern "C" fn ssxl_get_tilemap_chunk_ptr(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) -> *mut TileData {
    #[cfg(feature = "godot-binding")]
    {
        use godot::classes::TileMap;
        use crate::host_tilemap::TileMapDirectWriteExtension;
        
        let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
            Ok(tm) => tm.cast::<TileMap>(),
            Err(_) => {
                let id_for_logging = tilemap_id.to_i64();
                crate::ssxl_error!("SSXL FFI: Failed to retrieve TileMap object for ID {}", id_for_logging);
                return std::ptr::null_mut();
            }
        };

        let layer = CHUNK_DATA_LAYER;
        let raw_ptr: *mut TileData = tilemap.get_raw_chunk_data_ptr(layer, chunk_x, chunk_y);

        if raw_ptr.is_null() {
            crate::ssxl_error!("SSXL FFI: Godot failed to return raw pointer for chunk ({}, {})", chunk_x, chunk_y);
        }

        return raw_ptr;
    }

    #[cfg(not(feature = "godot-binding"))]
    {
        let _tilemap_id = tilemap_id;
        let _chunk_x = chunk_x;
        let _chunk_y = chunk_y;

        eprintln!("FFI_EXPORT: CLI MOCK: Attempted to get TileMap pointer (Godot FFI disabled)");
        return std::ptr::null_mut();
    }
}

#[no_mangle]
pub unsafe extern "C" fn ssxl_notify_chunk_updated(
    tilemap_id: InstanceId,
    chunk_x: i32,
    chunk_y: i32,
) {
    #[cfg(feature = "godot-binding")]
    {
        use godot::classes::TileMap;
        use crate::host_tilemap::TileMapDirectWriteExtension;
        
        let mut tilemap = match Gd::<TileMap>::try_from_instance_id(tilemap_id) {
            Ok(tm) => tm.cast::<TileMap>(),
            Err(_) => {
                let id_for_logging = tilemap_id.to_i64();
                crate::ssxl_warn!("SSXL FFI: Cannot notify update, Invalid TileMap InstanceId: {}", id_for_logging);
                return;
            }
        };

        let layer = CHUNK_DATA_LAYER;
        tilemap.notify_chunk_data_changed(layer, chunk_x, chunk_y);
    }
    
    #[cfg(not(feature = "godot-binding"))]
    {
        let _tilemap_id = tilemap_id;
        let _chunk_x = chunk_x;
        let _chunk_y = chunk_y;

        eprintln!("FFI_EXPORT: CLI MOCK: TileMap update notification for chunk ({}, {}) (Godot FFI disabled)", _chunk_x, _chunk_y);
    }
}

// --- END: rust/ssxl_ext/src\bridge_ffi.rs ---
        71 LOC | rust/ssxl_ext/src\bridge_oracle.rs
// --- START: rust/ssxl_ext/src\bridge_oracle.rs ---
use crate::shared_math::ChunkCoords;
use crate::ssxl_warn;
use flume::{Receiver, Sender};
use crate::host_state::get_host_state;
use crate::tools::Profiler;

#[derive(Debug, Clone)]
pub enum OracleQuery {
    GetChunkHardness(ChunkCoords),
    GetGlobalTimeOfDay,
    IsTileBlocked(i32, i32),
}

#[derive(Debug, Clone)]
pub enum OracleResponse {
    ChunkHardness(f64),
    GlobalTimeOfDay(f32),
    TileBlockedStatus(bool),
    Error(String),
}

pub struct OracleRequest {
    pub query: OracleQuery,
    pub response_sender: flume::Sender<OracleResponse>,
}

pub struct OracleConductor {
    pub request_receiver: Receiver<OracleRequest>,
    pub request_sender: Sender<OracleRequest>,
}

impl OracleConductor {
    pub fn new() -> Self {
        let (request_sender, request_receiver) = flume::unbounded();
        OracleConductor { request_receiver, request_sender }
    }

    pub fn poll_and_process(&self) {
        let mut processed_count = 0;
        let _p = Profiler::start("Oracle Poll");
        
        while processed_count < 10 {
            match self.request_receiver.try_recv() {
                Ok(request) => {
                    let response = self.handle_query(request.query);
                    
                    let _ = request.response_sender.send(response);
                    
                    processed_count += 1;
                },
                Err(flume::TryRecvError::Empty) => break,
                Err(flume::TryRecvError::Disconnected) => {
                    ssxl_warn!("Oracle Conductor: Request channel disconnected.");
                    break;
                }
            }
        }
    }

    fn handle_query(&self, query: OracleQuery) -> OracleResponse {
        let _host_state = get_host_state();

        match query {
            OracleQuery::GetGlobalTimeOfDay => {
                OracleResponse::GlobalTimeOfDay(0.5)
            }
            OracleQuery::IsTileBlocked(_x, _y) => {
                OracleResponse::TileBlockedStatus(false)
            }
            _ => OracleResponse::Error("Query not implemented".to_string()),
        }
    }
}

#[derive(Clone)]
pub struct OracleClient {
    request_sender: Sender<OracleRequest>,
}

impl OracleClient {
    pub fn query_blocking(&self, query: OracleQuery) -> Result<OracleResponse, String> {
        let (response_sender, response_receiver) = flume::bounded(1);
        
        let request = OracleRequest { query, response_sender };
        self.request_sender.send(request).map_err(|e| format!("Failed to send query: {}", e))?;

        response_receiver.recv().map_err(|e| format!("Failed to receive response: {}", e))
    }
}
// --- END: rust/ssxl_ext/src\bridge_oracle.rs ---
        13 LOC | rust/ssxl_ext/src\bridge_signals.rs
// --- START: rust/ssxl_ext/src\bridge_signals.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::classes::Engine;

use crate::generate_conductor::InstanceType;

#[cfg(feature = "godot-binding")]
pub fn emit_generation_finished(tilemap_id: InstanceType) {
    let mut engine_singleton: Gd<Engine> = Engine::singleton();
    engine_singleton.call("emit_signal", &[
        "generation_complete".to_variant(),
        tilemap_id.to_variant(),
    ]);
}

#[cfg(not(feature = "godot-binding"))]
pub fn emit_generation_finished(tilemap_id: InstanceType) {
    eprintln!("INFO: CLI Mode - Skipped emitting generation_finished signal for ID: {}", tilemap_id);
}

// --- END: rust/ssxl_ext/src\bridge_signals.rs ---
        49 LOC | rust/ssxl_ext/src\cache.rs
// --- START: rust/ssxl_ext/src\cache.rs ---
// rust/SSXL-ext/src/cache.rs

use dashmap::DashMap; // High-performance concurrent hash map
use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords; 

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_warn}; 

// --------------------------------------------------------------------------
// --- Chunk Cache (Final Results) ---
// --------------------------------------------------------------------------

/// Stores the final, processed Chunk results (post-CA, post-refinement).
/// This is used by the Conductor to check if a chunk needs generation 
/// or is already complete.
pub struct ChunkCache {
    // Key: (ChunkX, ChunkY)
    // Value: The final Chunk struct
    cache: DashMap<ChunkCoords, Chunk>,
}

impl ChunkCache {
    pub fn new() -> Self {
        ChunkCache {
            // Initialize with a default capacity
            cache: DashMap::with_capacity(4096), 
        }
    }

    /// Attempts to retrieve a chunk from the cache.
    /// Returns None if the chunk has not been generated yet.
    pub fn get(&self, coords: ChunkCoords) -> Option<Chunk> {
        // Clone the value out of the DashMap entry
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Inserts a newly generated chunk into the cache.
    /// This is called by a worker thread right before sending the chunk to the Conductor.
    pub fn insert(&self, chunk: Chunk) {
        let coords = chunk.position;
        self.cache.insert(coords, chunk);
        ssxl_info!("Chunk Cache: Stored chunk {:?}", coords);
    }
    
    /// Checks if the cache contains the chunk at the given coordinates.
    pub fn contains(&self, coords: ChunkCoords) -> bool {
        self.cache.contains_key(&coords)
    }
    
    /// Clears all entries from the cache (e.g., on world reset).
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Chunk Cache: Cleared all stored chunks.");
    }
}

// --------------------------------------------------------------------------
// --- Noise Cache (Intermediate Data) ---
// --------------------------------------------------------------------------

/// Stores raw Perlin noise output for a chunk. 
/// Useful for neighbor queries in CA simulations without recalculating Perlin noise.
pub struct NoiseCache {
    // Key: (ChunkX, ChunkY)
    // Value: A simple vector of raw f64 noise values
    cache: DashMap<ChunkCoords, Vec<f64>>, 
}

impl NoiseCache {
    pub fn new() -> Self {
        NoiseCache {
            cache: DashMap::with_capacity(2048), // Smaller capacity than ChunkCache
        }
    }

    /// Retrieves raw noise values. Used by generate_ca.rs to peek at neighbors' initial state.
    pub fn get_noise_data(&self, coords: ChunkCoords) -> Option<Vec<f64>> {
        // Clone the noise data vector
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Stores the raw noise values immediately after generation in generate_perlin.rs.
    pub fn insert_noise_data(&self, coords: ChunkCoords, noise_data: Vec<f64>) {
        self.cache.insert(coords, noise_data);
    }

    /// Clears all entries from the cache.
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Noise Cache: Cleared all stored noise data.");
    }
}
// --- END: rust/ssxl_ext/src\cache.rs ---
        70 LOC | rust/ssxl_ext/src\config.rs
// --- START: rust/ssxl_ext/src\config.rs ---
// rust/SSXL-ext/src/config.rs

use serde::{Deserialize, Serialize};
use std::fs;
use std::default::Default; // Required for Default implementation

// --- FIX: Remove Godot-dependent macro imports ---
// We remove the imports for ssxl_info, ssxl_warn, ssxl_error
// and replace them with eprintln! in the logic below.

use crate::shared_error::SSXLCoreError;

// Import the configuration structs from the designated shared location
use crate::shared_config::{
    ThreadingConfig, MapSettingsConfig, GenerationConfig, AnimationConfig // Assuming AnimationConfig is here too
};

// --------------------------------------------------------------------------
// --- GlobalConfig Structure (The Root) ---
// --------------------------------------------------------------------------

/// The main configuration loaded at runtime by host_init.rs
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct GlobalConfig {
    #[serde(default)]
    pub threading: ThreadingConfig,
    #[serde(default)]
    pub map_settings: MapSettingsConfig,
    #[serde(default)]
    pub generation: GenerationConfig,
    // Include AnimationConfig for completeness based on the manifest
    #[serde(default)]
    pub animation: AnimationConfig,
}

impl GlobalConfig {
    const CONFIG_FILE_PATH: &'static str = "ssxl_config.toml";
    
    /// Attempts to load the configuration from a file, falling back to defaults 
    /// and saving the default if the file is missing.
    pub fn load_or_default() -> Result<Self, SSXLCoreError> {
        // FIX: Use standard console output (eprintln!) instead of ssxl_info!
        eprintln!("INFO: Attempting to load configuration from: {}.", Self::CONFIG_FILE_PATH);

        match fs::read_to_string(Self::CONFIG_FILE_PATH) {
            Ok(content) => {
                // Deserialize the TOML content into the GlobalConfig struct
                match toml::from_str(&content) {
                    Ok(config) => {
                        // FIX: Use standard console output
                        eprintln!("INFO: Successfully loaded SSXL configuration.");
                        Ok(config)
                    }
                    Err(e) => {
                        // FIX: Use standard console output
                        eprintln!("ERROR: Failed to parse TOML configuration: {}. Using default settings.", e);
                        // Use SSXLCoreError to wrap the TOML parsing failure
                        Err(SSXLCoreError::InvalidConfig(format!("TOML deserialization failed: {}", e)))
                    }
                }
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                // File not found, use default settings
                let default_config = Self::default();
                // FIX: Use standard console output
                eprintln!("WARN: Configuration file not found ({}). Using default settings.", Self::CONFIG_FILE_PATH);

                // Optionally write the default config back to disk for easy editing
                if default_config.save_to_disk().is_err() {
                    // FIX: Use standard console output
                    eprintln!("ERROR: Could not save default configuration file.");
                }
                
                Ok(default_config)
            }
            Err(e) => {
                // FIX: Use standard console output
                eprintln!("ERROR: I/O Error reading config file: {}", e);
                Err(SSXLCoreError::FFIWriteError(format!("Config file I/O failure: {}", e)))
            }
        }
    }
    
    /// Saves the current configuration structure back to the TOML file.
    pub fn save_to_disk(&self) -> Result<(), SSXLCoreError> {
        match toml::to_string_pretty(self) {
            Ok(toml_string) => {
                match fs::write(Self::CONFIG_FILE_PATH, toml_string) {
                    Ok(_) => Ok(()),
                    Err(e) => {
                        Err(SSXLCoreError::FFIWriteError(format!("Failed to write config file: {}", e)))
                    }
                }
            },
            Err(e) => {
                Err(SSXLCoreError::InvalidConfig(format!("Failed to serialize TOML: {}", e)))
            }
        }
    }
}

// Provide sensible defaults for easy startup
impl Default for GlobalConfig {
    fn default() -> Self {
        Self {
            // Note: These must rely on the Default impls being in `shared_config.rs`
            threading: ThreadingConfig::default(),
            map_settings: MapSettingsConfig::default(),
            generation: GenerationConfig::default(),
            animation: AnimationConfig::default(),
        }
    }
}
// --- END: rust/ssxl_ext/src\config.rs ---
         7 LOC | rust/ssxl_ext/src\generate_anim_conductor.rs
// --- START: rust/ssxl_ext/src\generate_anim_conductor.rs ---
// src/generate_anim_conductor.rs

// Define the public structure mentioned in host_state.rs
pub struct AnimConductor {
    // ... fields will go here
}

impl AnimConductor {
    pub fn new() -> Self {
        // Initialize fields here
        AnimConductor {}
    }
}
// --- END: rust/ssxl_ext/src\generate_anim_conductor.rs ---
        55 LOC | rust/ssxl_ext/src\generate_batch_processor.rs
// --- START: rust/ssxl_ext/src\generate_batch_processor.rs ---
// rust/SSXL-ext/src/generate_batch_processor.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::generate_perlin;
use crate::generate_ca;
use crate::shared_error::SSXLCoreError;
use crate::shared_config::GenerationConfig;
use crate::ssxl_info;
use std::mem; // Required for mem::take

/// Executes the next required step for the given GenerationJob.
/// 
/// Returns: The modified job, advanced to the next step, or an error.
pub fn process_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<GenerationJob, SSXLCoreError> {
    
    ssxl_info!("Processing job {:?} at step: {:?}", job.id, job.current_step);

    let result = match job.current_step {
        
        // --- STEP 1: PERLIN NOISE GENERATION ---
        JobStep::NoiseGeneration => {
            let generator = generate_perlin::NoiseGenerator::new(
                config.perlin, 
                config.world_seed
            );
            
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the Perlin noise module, passing the chunk by value (moving it).
            match generate_perlin::generate_noise_map(chunk_to_process, &generator) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                // If it fails, `job.chunk_data` is left with the dummy value from `mem::take`, 
                // but the overall `job` struct remains valid to be returned/used.
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("Perlin failed: {}", e))),
            }
        },
        
        // --- STEP 2: CELLULAR AUTOMATA REFINEMENT ---
        JobStep::CARefinement => {
            // FIX: Use mem::take() to safely extract the Chunk value for the move.
            let chunk_to_process = mem::take(&mut job.chunk_data); 

            // Call the CA module, passing the chunk by value (moving it).
            match generate_ca::simulate_ca(chunk_to_process, config.ca.into()) {
                Ok(chunk) => {
                    job.chunk_data = chunk; // Reassign the returned chunk.
                    Ok(())
                }
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!("CA failed: {}", e))),
            }
        },
        
        // --- STEP 3: POST-PROCESSING (E.g., Border Blending, Entity Placement) ---
        JobStep::PostProcessing => {
            // Placeholder logic would also take the chunk by value or reference.
            // If it takes by value, it would need the same mem::take/reassign pattern.
            // For now, assume it's successful and the chunk remains.
            
            Ok(())
        },
        
        // --- TERMINAL STATES ---
        JobStep::Queued | JobStep::Finished | JobStep::Failed => {
            Err(SSXLCoreError::InvalidConductorState(format!("Job received in terminal step: {:?}", job.current_step)))
        }
    };

    // If successful, advance the job to the next stage and return it.
    match result {
        Ok(_) => {
            job.advance_step(); 
            Ok(job)
        },
        Err(e) => {
            job.current_step = JobStep::Failed;
            Err(e)
        }
    }
}
// --- END: rust/ssxl_ext/src\generate_batch_processor.rs ---
        75 LOC | rust/ssxl_ext/src\generate_ca.rs
// --- START: rust/ssxl_ext/src\generate_ca.rs ---
use crate::shared_config::CellularAutomataConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;

/// Defines the rule set for the Cellular Automata simulation.
/// Uses specific parameters for Cave/Wall generation.
#[derive(Debug, Clone, Copy)]
pub struct CaRules {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl From<CellularAutomataConfig> for CaRules {
    fn from(config: CellularAutomataConfig) -> Self {
        CaRules {
            death_limit: config.death_limit,
            birth_limit: config.birth_limit,
            steps: config.steps,
        }
    }
}

/// Runs the Cellular Automata simulation on a given chunk.
/// This is the CPU-intensive operation executed by the ThreadPool.
pub fn simulate_ca(mut chunk: Chunk, rules: CaRules) -> Result<Chunk, String> {
    
    let mut back_buffer = chunk.tiles.clone();
    let size = chunk.size as usize;

    for _step in 0..rules.steps {
        // Swap buffers: back_buffer becomes the read source (front),
        // and chunk.tiles (the original buffer) becomes the write destination (back).
        std::mem::swap(&mut chunk.tiles, &mut back_buffer);
        let front_buffer = &back_buffer;

        // Iterate over every cell in the chunk
        for y in 0..size {
            for x in 0..size {
                let current_index = y * size + x;
                
                // 1. Calculate Neighbor Count
                let neighbor_count = count_live_neighbors(front_buffer, size, x as i32, y as i32);
                
                // 2. Apply CA Rule
                let current_tile = front_buffer[current_index];
                
                // Determine the new state based on the current state and neighbor count
                let new_tile = if is_live(current_tile) {
                    // Cell is currently "alive" (e.g., a wall)
                    if neighbor_count < rules.death_limit {
                        make_dead_tile() // Cell dies
                    } else {
                        current_tile    // Cell lives
                    }
                } else {
                    // Cell is currently "dead" (e.g., open space)
                    if neighbor_count > rules.birth_limit {
                        make_live_tile() // Cell is born
                    } else {
                        current_tile    // Cell remains dead
                    }
                };

                // Write the new state to the back buffer (chunk.tiles)
                chunk.tiles[current_index] = new_tile;
            }
        }
    }

    Ok(chunk)
}

/// Checks the state (e.g., TileID) to determine if a tile is "live" (a wall/solid).
fn is_live(tile: TileData) -> bool {
    // Assumption: Tile ID > 0 is a solid wall tile
    tile.tile_id > 0
}

fn make_live_tile() -> TileData {
    // Placeholder for setting a 'wall' tile type
    TileData { tile_id: 1, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}

fn make_dead_tile() -> TileData {
    // Placeholder for setting an 'air' or 'floor' tile type
    TileData { tile_id: 0, atlas_coords: 0, rotation_flags: 0, custom_data: 0 }
}


/// Calculates the number of live neighbors in the 3x3 area around (cx, cy).
/// Uses simple bounds checking (no wrapping/toroidal logic for simplicity).
fn count_live_neighbors(tiles: &[TileData], size: usize, cx: i32, cy: i32) -> u8 {
    let mut count = 0;
    
    // Iterate over the 3x3 neighborhood grid
    for y in -1..=1 {
        for x in -1..=1 {
            if x == 0 && y == 0 {
                continue; // Skip the center cell
            }
            
            let nx = cx + x;
            let ny = cy + y;
            
            // Bounds check
            if nx >= 0 && nx < size as i32 && ny >= 0 && ny < size as i32 {
                let neighbor_index = (ny as usize) * size + (nx as usize);
                if is_live(tiles[neighbor_index]) {
                    count += 1;
                }
            }
        }
    }
    count
}
// --- END: rust/ssxl_ext/src\generate_ca.rs ---
        97 LOC | rust/ssxl_ext/src\generate_ca_simulation.rs
// --- START: rust/ssxl_ext/src\generate_ca_simulation.rs ---
// rust/SSXL-ext/src/generate_ca_simulation.rs

use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use crate::shared_config::CellularAutomataConfig;
use crate::cache::NoiseCache; // Required for boundary lookups
use crate::shared_error::SSXLCoreError;
// --- FIX: Correct module path from 'math' to 'shared_math' ---
use crate::shared_math::ChunkCoords;
// --- FIX: Import logging macro from the crate root ---
use crate::ssxl_info;

/// Runs the Cellular Automata simulation for the specified number of steps on the given chunk.
pub fn run_simulation_steps(
    mut chunk: Chunk,
    config: CellularAutomataConfig,
    // The Noise Cache is passed in so the CA can query neighbor chunks' initial states.
    noise_cache: &NoiseCache, 
    // The coordinates of the current chunk being processed.
    chunk_coords: ChunkCoords,
) -> Result<Chunk, SSXLCoreError> {
    
    // We need a secondary buffer to store the next state before applying it, 
    // ensuring all calculations use the data from the *start* of the step.
    let mut next_state_buffer = chunk.tiles.clone();
    
    ssxl_info!("CA Sim: Starting {} steps for chunk {:?}", config.steps, chunk_coords);

    for _step in 0..config.steps {
        
        for y in 0..chunk.size {
            for x in 0..chunk.size {
                
                // 1. Count Neighbors
                let live_neighbors = count_live_neighbors(
                    x as i32, 
                    y as i32, 
                    &chunk, 
                    chunk_coords, 
                    noise_cache
                );

                // 2. Apply Rules
                let current_tile = chunk.get_tile(x, y).unwrap();
                let next_state_tile = calculate_next_state(
                    current_tile, 
                    live_neighbors, 
                    &config
                );

                // 3. Stage Result in Buffer
                let index = chunk.get_index(x, y);
                next_state_buffer[index] = next_state_tile;
            }
        }
        
        // After iterating all tiles, swap the buffer to the current state for the next step.
        chunk.tiles.copy_from_slice(&next_state_buffer);
    }
    
    Ok(chunk)
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Counts the number of 'live' neighbors for a cell, handling cross-chunk boundary lookups.
fn count_live_neighbors(
    local_x: i32, 
    local_y: i32, 
    current_chunk: &Chunk,
    chunk_coords: ChunkCoords,
    noise_cache: &NoiseCache,
) -> u8 {
    let mut live_count = 0;
    let chunk_size = current_chunk.size as i32;
    
    // Iterates through a 3x3 grid centered on (local_x, local_y)
    for dy in -1..=1 {
        for dx in -1..=1 {
            if dx == 0 && dy == 0 { continue; } // Skip the center cell
            
            let neighbor_x = local_x + dx;
            let neighbor_y = local_y + dy;
            
            // --- Determine if the neighbor is INSIDE or OUTSIDE the current chunk ---
            if neighbor_x >= 0 && neighbor_x < chunk_size && neighbor_y >= 0 && neighbor_y < chunk_size {
                // INTERNAL NEIGHBOR (Fast lookup)
                if current_chunk.get_tile(neighbor_x as u32, neighbor_y as u32)
                    // The t in the closure is &TileData. We assume TileData implements Copy
                    // and is_live() takes self (by value) to force the dereference.
                    .map_or(false, |t| (*t).is_live()) 
                {
                    live_count += 1;
                }
            } else {
                // EXTERNAL NEIGHBOR (Requires a cache lookup, slower)
                // 1. Calculate the adjacent chunk coordinates
                let adjacent_chunk_coords = (
                    chunk_coords.0 + if neighbor_x < 0 { -1 } else if neighbor_x >= chunk_size { 1 } else { 0 },
                    chunk_coords.1 + if neighbor_y < 0 { -1 } else if neighbor_y >= chunk_size { 1 } else { 0 },
                );
                
                // 2. Calculate the local coordinates within the adjacent chunk
                let local_adj_x = neighbor_x.rem_euclid(chunk_size);
                let local_adj_y = neighbor_y.rem_euclid(chunk_size);

                // 3. Query the NoiseCache for the adjacent chunk's initial state
                if noise_cache.get_noise_data(adjacent_chunk_coords)
                    // FIX: Changed inner `map_or` to `map`. 
                    // and_then requires the closure to return Option<T>. 
                    // map returns Option<bool>, which satisfies and_then.
                    .and_then(|data| {
                        // Look up the tile's state in the cached noise data
                        let index = (local_adj_y * chunk_size + local_adj_x) as usize;
                        // Use map to convert Option<&NoiseValue> to Option<bool>
                        data.get(index).map(|&noise_val| noise_val > 0.5) 
                    })
                    .unwrap_or(false) 
                {
                    live_count += 1;
                }
            }
        }
    }
    live_count
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Applies the birth and death limits to determine the next state of a cell.
fn calculate_next_state(
    current_tile: &TileData,
    live_neighbors: u8,
    config: &CellularAutomataConfig,
) -> TileData {
    
    // Start with a copy of the current state
    let mut next_state = *current_tile;

    if current_tile.is_live() {
        // --- Live Cell (Survival/Death) ---
        // If live neighbors are LESS than the Death Limit, the cell dies (becomes 'dead').
        if live_neighbors < config.death_limit {
            next_state.set_live(false); // Method call will be found after implementing TileData::set_live
        }
    } else {
        // --- Dead Cell (Birth) ---
        // If live neighbors are GREATER than or equal to the Birth Limit, the cell is born (becomes 'live').
        if live_neighbors >= config.birth_limit {
            next_state.set_live(true); // Method call will be found after implementing TileData::set_live
        }
    }
    
    next_state
}
// --- END: rust/ssxl_ext/src\generate_ca_simulation.rs ---
       150 LOC | rust/ssxl_ext/src\generate_conductor.rs
// --- START: rust/ssxl_ext/src\generate_conductor.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::obj::InstanceId;

use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use flume::Receiver;
use crate::sync_pool::SyncPool;
use crate::config::GlobalConfig;
use crate::shared_message::GenerationDataMessage;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;
use crate::generate_conductor_state::{
    ConductorState, ConductorStateContainer, GenerationMetrics,
};

#[cfg(feature = "godot-binding")]
pub type InstanceType = InstanceId;
#[cfg(not(feature = "godot-binding"))]
pub type InstanceType = u64;

pub struct GenerateConductor {
    state_container: ConductorStateContainer,
    thread_pool: SyncPool,
    chunk_receiver: Receiver<GenerationDataMessage>,
    pub tilemap_target_id: InstanceType,
    signal_emitted: AtomicBool,
}

impl GenerateConductor {
    pub fn new(num_workers: u32, config: Arc<GlobalConfig>) -> Self {
        let (pool, chunk_receiver) = SyncPool::new(num_workers as usize, config);
        let state_container = ConductorStateContainer::new();
        eprintln!("INFO: GenerateConductor initialized.");
        Self {
            state_container,
            thread_pool: pool,
            chunk_receiver,
            tilemap_target_id: {
                #[cfg(feature = "godot-binding")]
                {
                    InstanceId::from_i64(1)
                }
                #[cfg(not(feature = "godot-binding"))]
                {
                    1u64
                }
            },
            signal_emitted: AtomicBool::new(false),
        }
    }

    pub fn set_ready_status(&mut self, status: bool) {
        if status {
            self.state_container.transition_to(ConductorState::Ready);
        } else {
            self.state_container.transition_to(ConductorState::Idle);
        }
    }

    pub fn start_generation(
        &mut self,
        tilemap_id: InstanceType,
        initial_jobs: Vec<GenerationJob>,
    ) -> Result<(), SSXLCoreError> {
        if self.state_container.get_state() != ConductorState::Ready {
            eprintln!("WARN: Conductor is not ready to start generation.");
            return Err(SSXLCoreError::ConductorBusy);
        }

        self.signal_emitted.store(false, Ordering::SeqCst);

        self.tilemap_target_id = tilemap_id;
        let total_chunks = initial_jobs.len() as u32;
        self.state_container.set_total_chunks(total_chunks);
        self.state_container.transition_to(ConductorState::Generating);

        let mut submitted_count = 0;
        for job in initial_jobs {
            match self.thread_pool.submit_job(job) {
                Ok(_) => submitted_count += 1,
                Err(e) => {
                    eprintln!("ERROR: Failed to submit job to worker pool: {:?}", e);
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }

        eprintln!("INFO: Generation started, submitted {} chunks.", submitted_count);
        Ok(())
    }

    pub fn poll_chunks_and_render(&self) -> (u32, bool) {
        let mut chunks_rendered = 0;

        while let Ok(message) = self.chunk_receiver.try_recv() {
            match message {
                GenerationDataMessage::CompletedChunk(chunk) => {
                    match crate::host_tilemap::render_chunk_direct(self.tilemap_target_id, chunk)
                    {
                        Ok(_) => {
                            chunks_rendered += 1;
                            self.state_container.increment_completed_chunks();
                        }
                        Err(e) => {
                            eprintln!("ERROR: Failed to directly render chunk: {:?}", e);
                        }
                    }
                }
                GenerationDataMessage::JobFailure(e) => {
                    eprintln!("ERROR: A worker job failed: {:?}", e);
                }
                GenerationDataMessage::Ack => {
                    eprintln!("WARN: Conductor received unexpected Ack message.");
                }
            }
        }

        let metrics = self.state_container.get_metrics();
        let is_finished =
            metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;

        if is_finished && self.state_container.get_state() == ConductorState::Generating {
            self.state_container
                .transition_to(ConductorState::Finished);
            eprintln!("INFO: All chunks rendered. Generation finished.");
        }

        (chunks_rendered, is_finished)
    }

    pub fn try_finalize_and_get_target_id(&self) -> Option<InstanceType> {
        if self.state_container.get_state() != ConductorState::Finished {
            return None;
        }

        match self.signal_emitted.swap(true, Ordering::SeqCst) {
            false => {
                let is_valid_id = {
                    #[cfg(feature = "godot-binding")]
                    {
                        self.tilemap_target_id.to_i64() != 0
                    }
                    #[cfg(not(feature = "godot-binding"))]
                    {
                        self.tilemap_target_id != 0
                    }
                };

                if is_valid_id {
                    Some(self.tilemap_target_id)
                } else {
                    eprintln!("ERROR: Conductor cannot finalize: TileMap ID is invalid.");
                    None
                }
            }
            true => None,
        }
    }

    pub fn shutdown(self) {
        eprintln!(
            "INFO: GenerateConductor initiating shutdown (pool cleanup deferred to HostCleanup)..."
        );
        eprintln!("INFO: GenerateConductor shut down successfully.");
    }

    pub fn get_state_container(&self) -> &ConductorStateContainer {
        &self.state_container
    }

    pub fn get_chunk_receiver(&self) -> &Receiver<GenerationDataMessage> {
        &self.chunk_receiver
    }

    pub fn get_metrics(&self) -> GenerationMetrics {
        self.state_container.get_metrics()
    }
}

// --- END: rust/ssxl_ext/src\generate_conductor.rs ---
        66 LOC | rust/ssxl_ext/src\generate_conductor_state.rs
// --- START: rust/ssxl_ext/src\generate_conductor_state.rs ---
// rust/SSXL-ext/src/generate_conductor_state.rs

use std::fmt;
use std::sync::Mutex;
// --- FIX: Import logging macros from the crate root ---
use crate::ssxl_info;

// --------------------------------------------------------------------------
// --- ConductorState Enum ---
// --------------------------------------------------------------------------

/// Defines the current operational status of the Generation Conductor.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConductorState {
    /// Initial state, awaiting a command to start. (Previously Idle)
	Idle,
    Ready, // <<< FIX: Renamed 'Idle' to 'Ready' to satisfy generate_conductor.rs
    /// The worker pool is actively generating chunks.
    Generating,
    /// Generation is complete, but the final cleanup/signals are pending.
    Finished,
    /// An unrecoverable error occurred (e.g., worker panic, channel failure).
    Error,
    /// Generation has been manually paused or terminated.
    Paused,
}

impl fmt::Display for ConductorState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

// --------------------------------------------------------------------------
// --- GenerationMetrics Struct ---
// --------------------------------------------------------------------------

/// Holds the volatile metrics of the current generation job.
#[derive(Debug, Clone, Copy)]
pub struct GenerationMetrics {
    /// The total number of chunks requested for generation.
    pub total_chunks: u32,
    /// The number of chunks successfully completed and rendered.
    pub completed_chunks: u32,
    /// The number of jobs that failed during processing.
    pub failed_jobs: u32,
    /// The instantaneous speed of processing (e.g., chunks per second).
    pub current_throughput: f32, 
}

impl Default for GenerationMetrics {
    fn default() -> Self {
        GenerationMetrics {
            total_chunks: 0,
            completed_chunks: 0,
            failed_jobs: 0,
            current_throughput: 0.0,
        }
    }
}

// --------------------------------------------------------------------------
// --- ConductorStateContainer Struct (Thread-Safe Wrapper) ---
// --------------------------------------------------------------------------

/// A thread-safe container holding the Conductor's current state and metrics.
/// This is typically wrapped in an Arc<T> for shared, concurrent access.
pub struct ConductorStateContainer {
    // The current state (requires Mutex protection).
    state: Mutex<ConductorState>,
    // The current metrics (requires Mutex protection).
    metrics: Mutex<GenerationMetrics>,
}

impl ConductorStateContainer {
    pub fn new() -> Self {
        ConductorStateContainer {
            // FIX: Initialize to the 'Ready' state
            state: Mutex::new(ConductorState::Idle),
            metrics: Mutex::new(GenerationMetrics::default()),
        }
    }

    /// Safely updates the state, logging the transition. (Main thread only)
    pub fn transition_to(&self, new_state: ConductorState) {
        let mut state = self.state.lock().unwrap();
        if *state != new_state {
            ssxl_info!("Conductor State Transition: {} -> {}", *state, new_state);
            *state = new_state;
        }
    }

    /// Safely reads the current state.
    pub fn get_state(&self) -> ConductorState {
        *self.state.lock().unwrap()
    }

    /// Safely reads the current metrics.
    pub fn get_metrics(&self) -> GenerationMetrics {
        *self.metrics.lock().unwrap()
    }

    /// Atomic update: Sets the total number of chunks to be generated.
    pub fn set_total_chunks(&self, count: u32) {
        self.metrics.lock().unwrap().total_chunks = count;
    }

    /// Atomic update: Increments the count of completed chunks.
    pub fn increment_completed_chunks(&self) {
        self.metrics.lock().unwrap().completed_chunks += 1;
        // Logic for throughput calculation would also be here
    }

    /// Atomic update: Increments the count of failed jobs.
    pub fn increment_failed_jobs(&self) {
        self.metrics.lock().unwrap().failed_jobs += 1;
    }
}
// --- END: rust/ssxl_ext/src\generate_conductor_state.rs ---
        43 LOC | rust/ssxl_ext/src\generate_conductor_sync.rs
// --- START: rust/ssxl_ext/src\generate_conductor_sync.rs ---
// rust/SSXL-ext/src/generate_conductor_sync.rs

use flume::Receiver;
use crate::shared_message::{GenerationDataMessage, GenerationControlMessage};
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState};
use crate::shared_chunk::Chunk;
use crate::tools::{ssxl_info, ssxl_error, Profiler};

// The maximum number of messages (completed chunks/errors) to process from the channel per frame.
// This is separate from the rendering budget but necessary to prevent channel backlog.
const MAX_MESSAGES_PER_FRAME: u32 = 32;

/// Polls the completed work channel, updates metrics, and stages chunks for rendering.
/// 
/// This is the synchronization point between the worker threads and the main thread state.
/// 
/// Returns: A vector of completed Chunks that are ready to be passed to the host_render.rs pacing layer.
pub fn poll_and_stage_completed_work(
    chunk_receiver: &Receiver<GenerationDataMessage>,
    state_container: &ConductorStateContainer,
) -> Vec<Chunk> {
    
    let mut completed_chunks_staged = Vec::new();
    let mut messages_processed = 0;
    
    // Use a profiler to track the time spent syncing channels
    let _p = Profiler::start("Conductor_Sync_Poll");

    // Loop until the channel is empty or the frame budget is hit
    while messages_processed < MAX_MESSAGES_PER_FRAME {
        
        match chunk_receiver.try_recv() {
            Ok(message) => {
                messages_processed += 1;
                
                match message {
                    GenerationDataMessage::CompletedChunk(chunk) => {
                        // 1. Update Metrics
                        state_container.increment_completed_chunks();
                        
                        // 2. Stage for Rendering
                        // The chunk is now safe on the main thread and ready for Godot API calls.
                        completed_chunks_staged.push(chunk);
                    },
                    
                    GenerationDataMessage::JobFailure(e) => {
                        // 1. Update Metrics (may or may not count as completed, depending on policy)
                        state_container.increment_failed_jobs();
                        
                        // 2. Transition State
                        state_container.transition_to(ConductorState::Error);
                        
                        ssxl_error!("Generation Worker Failed: {}", e);
                    },
                    
                    GenerationDataMessage::Ack => {
                        // Worker status acknowledgement (e.g., worker started)
                        // Ignore but count towards the budget.
                    }
                }
            },
            
            Err(flume::TryRecvError::Empty) => {
                // Channel is temporarily empty. Exit the loop.
                break;
            },
            
            Err(flume::TryRecvError::Disconnected) => {
                // Worker pool channel has been closed (workers shut down unexpectedly).
                ssxl_error!("Worker pool channel disconnected. Generation likely failed or was terminated.");
                state_container.transition_to(ConductorState::Error);
                break;
            }
        }
    }
    
    completed_chunks_staged
}
// --- END: rust/ssxl_ext/src\generate_conductor_sync.rs ---
        44 LOC | rust/ssxl_ext/src\generate_manager.rs
// --- START: rust/ssxl_ext/src\generate_manager.rs ---
// rust/SSXL-ext/src/generate_manager.rs

use crate::sync_pool::SyncPool;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_config::GenerationConfig;
use crate::shared_error::SSXLCoreError;
use crate::{ssxl_error, ssxl_info};
// FIX 1: Remove godot::prelude::* if it's not strictly necessary for the GenerationManager logic
// or keep it commented out to prevent accidental Godot-dependent calls in the CLI context.
// use godot::prelude::*; // Commented out to reduce surface area for Godot dependency checks

/// The functional engine that manages the submission of generation jobs
/// to the worker pool.
pub struct GenerationManager {
    // A reference to the thread pool implementation (held by the HostState)
    pool: SyncPool,
    // The current global generation configuration
    // âœ… FIX WARNING: Renamed to `_config` to silence the 'never read' warning.
    _config: GenerationConfig,
}

impl GenerationManager {
    /// Creates a new manager, typically called during host_init.rs.
    // Updated parameter name to match the struct field.
    pub fn new(pool: SyncPool, config: GenerationConfig) -> Self {
        GenerationManager { pool, _config: config }
    }

    /// Provides a high-level function to start processing a batch of tasks.
    /// This is called by the GenerateConductor when generation starts.
    pub fn submit_job_batch(&self, tasks: Vec<GenerationTask>) -> Result<usize, SSXLCoreError> {
        let mut jobs_submitted = 0;
        
        // --- 1. Map Tasks to Jobs and Submit ---
        for task in tasks {
            // Create the full, multi-stage GenerationJob structure
            let job = GenerationJob::new(task);
            
            // Extract the job ID before moving the job into submit_job.
            let job_id = job.id;

            // Submit the job to the worker pool's queue (job is moved here)
            match self.pool.submit_job(job) {
                Ok(_) => jobs_submitted += 1,
                Err(e) => {
                    // Uses the extracted job_id for the error log, preventing the borrow-after-move error.
                    ssxl_error!("Generation Manager: Failed to submit job {:?}. Pool likely disconnected or full: {}", job_id, e);
                    // On first error, we might stop and return the error
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }

        // --- 2. Update Conductor State ---
        
        ssxl_info!("Generation Manager: Submitted {} multi-stage jobs to the pool.", jobs_submitted);
        Ok(jobs_submitted)
    }

    /// Retrieves the current status of the worker pool (useful for debugging).
    pub fn get_pool_status(&self) -> (u32, usize) {
        let (worker_count, queue_size) = self.pool.get_status();
        (worker_count as u32, queue_size)
    }
}


// ============================================================================
// FFI EXPORTS (MOCKS required for ssxl_cli linking) - KEEP THESE HERE!
// These must use eprintln! instead of godot_print! when run from the CLI.
// ============================================================================

/// EXPORT 3/5: Called by CLI to stress the raw computation layer.
#[no_mangle]
pub extern "C" fn ssxl_ext_generate_noise_chunk(x: i32, y: i32, size: i32, seed: u64) {
    // ðŸ”¥ FIX 2: Replaced godot_print! with eprintln! to prevent Godot runtime panic.
    eprintln!("FFI_EXPORT: CLI triggered HEAVY NOISE GENERATION MOCK for chunk ({}, {}) size {} with seed {}",
                 x, y, size, seed);
}

/// EXPORT 4/5: Called by CLI to test the boundary matching data structure.
#[no_mangle]
pub extern "C" fn ssxl_ext_verify_chunk_boundary(chunk_x: i32, chunk_y: i32, neighbor_x: i32, neighbor_y: i32) -> bool {
    // ðŸ”¥ FIX 3: Replaced godot_print! with eprintln! to prevent Godot runtime panic.
    eprintln!("FFI_EXPORT: CLI checking boundary MOCK between chunk ({}, {}) and ({}, {})",
                 chunk_x, chunk_y, neighbor_x, neighbor_y);
    true
}
// --- END: rust/ssxl_ext/src\generate_manager.rs ---
        51 LOC | rust/ssxl_ext/src\generate_perlin.rs
// --- START: rust/ssxl_ext/src\generate_perlin.rs ---
// rust/SSXL-ext/src/generate_perlin.rs

use crate::shared_config::PerlinNoiseConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use noise::{Fbm, Perlin, NoiseFn, MultiFractal};

/// Holds the initialized noise generator and configuration.
pub struct NoiseGenerator {
    // Fbm (Fractal Brownian Motion) is typically used for complex terrain.
    fbm: Fbm<Perlin>,
    config: PerlinNoiseConfig,
}

impl NoiseGenerator {
    /// Creates a generator instance from configuration.
    pub fn new(config: PerlinNoiseConfig, seed: u64) -> Self {
        let fbm: Fbm<Perlin> = Fbm::<Perlin>::new(seed as u32)
            .set_octaves(config.octaves)
            .set_lacunarity(config.lacunarity)
            .set_persistence(config.persistence);

        NoiseGenerator { fbm, config }
    }
}

// rust/SSXL-ext/src/generate_perlin.rs

/// Generates the base noise map for a specific chunk.
/// This is one of the initial steps inside the ThreadPool's worker execution.
pub fn generate_noise_map(
    mut chunk: Chunk, 
    generator: &NoiseGenerator
) -> Result<Chunk, String> {
    
    let chunk_x = chunk.position.0;
    let chunk_y = chunk.position.1;
    let size = chunk.size as i32;
    let scale = generator.config.scale;
    let threshold = generator.config.threshold;

    // Use a dense Vec for speed, matching the TileData layout.
    chunk.tiles.resize( (size * size) as usize, TileData::default() );

    for local_y in 0..size {
        for local_x in 0..size {
            // 1. Calculate the World Coordinates (Crucial for continuity)
            // This translates local chunk coordinates into continuous world coordinates.
            let world_x = (chunk_x * size) + local_x;
            let world_y = (chunk_y * size) + local_y;
            
            // 2. Sample the Noise Function
            let noise_value = generator.fbm.get([
                world_x as f64 / scale, 
                world_y as f64 / scale
            ]);

            // 3. Map Value to Tile Data
            let tile_data = if noise_value > threshold {
                // Above threshold: Solid / Wall (the target for CA refinement)
                TileData {
                    tile_id: 1, // Wall tile ID
                    atlas_coords: 0,
                    rotation_flags: 0,
                    custom_data: (noise_value * 255.0).abs().round() as u8, // Store raw density
                }
            } else {
                // Below threshold: Air / Floor
                TileData::default() 
            };
            
            // 4. Write to Chunk Buffer
            let index = (local_y * size + local_x) as usize;
            chunk.tiles[index] = tile_data;
        }
    }

    Ok(chunk)
}
// --- END: rust/ssxl_ext/src\generate_perlin.rs ---
        47 LOC | rust/ssxl_ext/src\generate_runtime.rs
// --- START: rust/ssxl_ext/src\generate_runtime.rs ---
// rust/SSXL-ext/src/generate_runtime.rs

use crate::shared_job::{GenerationJob, JobStep};
use crate::shared_config::GenerationConfig;
use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;
use crate::generate_batch_processor;
use crate::tools::Profiler;

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_error}; 

/// The primary entry point for a worker thread to execute a multi-step generation job.
/// This function manages the entire runtime lifecycle for a single chunk's generation.
pub fn run_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<Chunk, SSXLCoreError> {
    
    // --- 1. Runtime Profiling Context ---
    // Start a profiler for the entire chunk's execution time (Perlin, CA, Post-process combined).
    let profiler_name = format!("Chunk_Gen_Runtime ({}, {})", job.id.0, job.id.1);
    // Note: Box::leak is used to convert the dynamically created string into a 'static str for Profiler.
    let _p = Profiler::start(Box::leak(profiler_name.into_boxed_str()));
    
    // Set the initial step correctly
    if job.current_step == JobStep::Queued {
        job.advance_step(); // Move to NoiseGeneration
    }
    
    // --- 2. The Multi-Step Execution Loop ---
    
    // Continue processing the job until it reaches a terminal state (Finished or Failed).
    while job.current_step != JobStep::Finished && job.current_step != JobStep::Failed {
        
        // FIX: Capture the necessary fields *before* moving the `job` into the processor.
        let job_id_for_logging = job.id;
        let job_step_for_logging = job.current_step; // Since JobStep is likely Copy or Clone, this works.

        let result = generate_batch_processor::process_generation_job(
            job, 
            config
        );

        match result {
            Ok(next_job) => {
                // Step succeeded and job was advanced by the processor. Continue the loop.
                job = next_job;
            }
            Err(e) => {
                // Step failed. Log the error, transition to Failed, and break the loop.
                // FIX: Use the captured variables for logging.
                ssxl_error!("Job {:?} failed at step {:?}: {:?}", job_id_for_logging, job_step_for_logging, e);
                // NOTE: The compiler still complains about using `job` here, so we must rely on
                // the `process_generation_job` function to have updated the job state inside
                // the thread pool before returning an error, or the `job` struct must implement `Copy`.
                
                // Since the original code attempted to access the moved value, and the intent was to update it,
                // we *must* rely on the captured step for logging and return immediately.
                // If `job` implemented Copy, we could just copy the job. We'll proceed with the assumption
                // that `job.id` and `job.current_step` are Copy/Clone.
                
                // We cannot use `job.current_step = JobStep::Failed;` here because `job` is moved.
                // The responsibility to mark the job as failed must fall to the `process_generation_job`
                // function before it returns the error, or the worker manager needs to handle it.
                // Given the existing structure, we remove the access to the moved value.
                // We remove the line `job.current_step = JobStep::Failed;` because it is unreachable.
                
                return Err(e);
            }
        }
    }
    
    // --- 3. Terminal State Handling ---
    
    match job.current_step {
        JobStep::Finished => {
            ssxl_info!("Job {:?} successfully completed runtime.", job.id);
            // The job is complete, return the final chunk data payload.
            // NOTE: Assuming the final chunk data is correctly stored in job.chunk_data by the processor.
            Ok(job.chunk_data)
        }
        JobStep::Failed => {
            // Should be handled above, but included for complete error coverage.
            ssxl_error!("Runtime ended in failed state for job {:?}", job.id);
            Err(SSXLCoreError::InvalidConductorState("Job loop finished but state is Failed.".to_string()))
        }
        _ => {
            // Should be unreachable if the batch processor is correct.
            Err(SSXLCoreError::InvalidConductorState(format!("Runtime finished in non-terminal state: {:?}", job.current_step)))
        }
    }
}
// --- END: rust/ssxl_ext/src\generate_runtime.rs ---
        17 LOC | rust/ssxl_ext/src\generate_task_queue.rs
// --- START: rust/ssxl_ext/src\generate_task_queue.rs ---
// rust/SSXL-ext/src/generate_task_queue.rs

use crate::shared_config::GenerationConfig;

/// The strict data structure representing one unit of work (one chunk) 
/// to be processed by a worker thread.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    pub chunk_pos: (i32, i32),
    pub chunk_size: u32,
    pub seed: u64,
    pub config: GenerationConfig, // Includes CA rules, Perlin settings, etc.
}

impl GenerationTask {
    pub fn new(chunk_pos: (i32, i32), chunk_size: u32) -> Self {
        // ... simple constructor ...
        Self { 
            chunk_pos, 
            chunk_size, 
            seed: 12345, // Example
            config: GenerationConfig::default(), // Example
        }
    }
}
// --- END: rust/ssxl_ext/src\generate_task_queue.rs ---
        67 LOC | rust/ssxl_ext/src\host_anim.rs
// --- START: rust/ssxl_ext/src\host_anim.rs ---
// rust/SSXL-ext/src/host_anim.rs

use godot::prelude::*;
use godot::classes::{TileMap, TileMapLayer}; // Added TileMapLayer for the mock
use crate::animate_events::AnimationEvent;
use crate::animate_conductor::AnimationConductor;
use crate::host_state::GodotError;
use crate::{ssxl_error, ssxl_warn, ssxl_info}; // ðŸ”¥ FIX 1: Import custom logger macros

// Define a safe maximum number of animation events to process per frame
const MAX_ANIM_EVENTS_PER_FRAME: u32 = 256; 

/// Polls the animation event channel and applies visual updates to the Godot world.
/// This must be called on the Godot main thread.
pub fn apply_animation_updates(conductor: &AnimationConductor, tilemap_id: InstanceId) -> u32 {
    let mut events_processed = 0;
    
    // Use a try_recv loop with a frame budget to ensure non-blocking execution
    while events_processed < MAX_ANIM_EVENTS_PER_FRAME {
        
        // 1. Receive the next completed event from the worker threads
        match conductor.event_receiver.try_recv() {
            Ok(event) => {
                // 2. Apply the visual change based on the event type
                if let Err(e) = handle_animation_event(tilemap_id, event) {
                    // ðŸ”¥ FIX 2: Replaced godot_error! with ssxl_error!
                    ssxl_error!("Host Anim: Failed to handle event: {:?}", e);
                }
                events_processed += 1;
            },
            Err(flume::TryRecvError::Empty) => {
                // No more events this frame
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                // ðŸ”¥ FIX 3: Replaced godot_warn! with ssxl_warn!
                ssxl_warn!("Host Anim: Conductor event channel disconnected.");
                break;
            }
        }
    }
    
    events_processed
}

/// Dispatches the event to the appropriate Godot TileMap or Node API call.
fn handle_animation_event(tilemap_id: InstanceId, event: AnimationEvent) -> Result<(), GodotError> {
    
    // We assume the tilemap_id can be safely resolved to a Gd<TileMap>
    let tilemap_node = InstanceId::get_object(tilemap_id)
        .ok_or(GodotError::InvalidInstance)?
        .cast::<TileMap>();

    // Temporarily handling the unwrap() if the cast fails. In production this should be handled.
    let mut tilemap = tilemap_node.unwrap(); 

    // Mock implementation of to_godot_vector() and set_cell_tiledata_value()
    trait MockTileMapMethods {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i;
        fn set_cell_tiledata_value(&mut self, layer: i32, coords: godot::builtin::Vector2i, data_id: TileMapLayer, value: Variant);
    }
    
    impl MockTileMapMethods for (i32, i32) {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i {
            godot::builtin::Vector2i::new(self.0, self.1)
        }
    }
    
    impl MockTileMapMethods for Gd<TileMap> {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i {
            // Not used, but required for trait completeness
            godot::builtin::Vector2i::new(0, 0)
        }
        fn set_cell_tiledata_value(&mut self, layer: i32, coords: godot::builtin::Vector2i, data_id: TileMapLayer, value: Variant) {
            // Placeholder: Call the actual Godot API here in a real build
        }
    }
    
    match event {
        AnimationEvent::SetTileAnimation { layer, coords, frame_index } => {
            // Update the tile's animated frame (lightweight API call)
            tilemap.set_cell_tiledata_value(
                layer,
                coords.to_godot_vector(), // Helper to convert Rust coords to Godot Vector2i
                TileMapLayer::ANIMATION_FRAME,
                frame_index.to_variant(),
            );
        }
        
        AnimationEvent::SetLightColor { light_id, color } => {
            // Example: update_light_node(light_id, color);
            // ðŸ”¥ FIX 4: Replaced godot_print! with ssxl_info!
            ssxl_info!("Applying color {:?} to light {}", color, light_id);
        }
        
        AnimationEvent::SpawnParticleEffect { effect_id, position } => {
            // Example: spawn_particle_at(effect_id, position);
            // ðŸ”¥ FIX 5: Replaced godot_print! with ssxl_info!
            ssxl_info!("Spawning particle {} at {:?}", effect_id, position);
        }
        // ... other event types
    }

    Ok(())
}
// --- END: rust/ssxl_ext/src\host_anim.rs ---
        30 LOC | rust/ssxl_ext/src\host_cleanup.rs
// --- START: rust/ssxl_ext/src\host_cleanup.rs ---
// rust/SSXL-ext/src/host_cleanup.rs (FIXED)


// ðŸŽ¯ FIX 1: Gate host_state imports (only used within the gated cleanup function)
#[cfg(feature = "godot-binding")]
use crate::host_state::{HostState, HOST_SINGLETON};
// ðŸŽ¯ FIX 2: Gate logging macro imports (only used within the gated cleanup function)

/// The primary cleanup function called by Godot when the GDExtension is unloaded.
/// This ensures a clean exit by shutting down all background workers and state.
// ðŸŽ¯ CRITICAL FIX: Gate the entire function implementation
#[cfg(feature = "godot-binding")]
pub fn cleanup_ssxl_core() {
    // ðŸŽ¯ FIX: Use feature-gated macro
    crate::ssxl_info!("SSXL-ext Core: Starting cleanup procedure.");

    // 1. Attempt to take ownership of the global state
    let taken_state = unsafe {
        // FIX 1: Provide explicit type annotation for the mutable raw pointer to resolve E0282.
        // We cast the immutable static reference to a mutable pointer of its known type.
        let host_singleton_mut: *mut once_cell::sync::OnceCell<Option<HostState>> = 
            &HOST_SINGLETON as *const _ as *mut _;
        
        // Dereference the mutable pointer and call take() on the mutable reference.
        (*host_singleton_mut).take()
    };
    
    // `HOST_SINGLETON.take()` returns Option<Option<HostState>> because of the definition in host_state.rs.
    match taken_state {
        Some(host_state_option) => {
            // FIX 2: Pattern match the inner Option to extract the HostState value.
            if let Some(host_state) = host_state_option {
                
                // 2. Safely dismantle the Conductor and its resources
                // FIX 3: Destructure HostState to take ownership of 'conductor' and ignore other non-Copy fields (Partial Move fix).
                let HostState { 
                    conductor, 
                    anim_conductor: _, // Take ownership but ignore the value if cleanup isn't done here
                    .. // Ignore all other fields
                } = host_state;

                // 3. Initiate Thread Pool Shutdown (The most critical step)
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_info!("Cleanup: Instructing Conductor to shut down worker threads...");
                conductor.shutdown(); // Assume a shutdown method exists on the Conductor

                // 4. Cleanup other Godot-related resources (e.g., cached InstanceIds, etc.)
                
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_info!("SSXL-ext Core: Cleanup complete. Resources released.");
            } else {
                // If the inner Option was None (i.e., someone already cleaned up the value)
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_warn!("Cleanup called but HostState was already cleaned up (Inner Option::None).");
            }
        }
        None => {
            // If the outer Option was None (i.e., OnceCell was never set)
            // ðŸŽ¯ FIX: Use feature-gated macro
            crate::ssxl_warn!("Cleanup called but SSXL-ext was not initialized or already cleaned up.");
        }
    }
}

// ðŸŽ¯ FALLBACK: Provide a mock function for the CLI build to satisfy cross-module calls
#[cfg(not(feature = "godot-binding"))]
pub fn cleanup_ssxl_core() {
    // No-op for the CLI build
}
// --- END: rust/ssxl_ext/src\host_cleanup.rs ---
        85 LOC | rust/ssxl_ext/src\host_commands.rs
// --- START: rust/ssxl_ext/src\host_commands.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use crate::host_state::HostState;
use crate::generate_conductor_state::ConductorState;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;

#[cfg(feature = "godot-binding")]
use once_cell::sync::Lazy;

#[cfg(feature = "godot-binding")]
use crate::{ssxl_info, ssxl_warn, ssxl_error};

#[cfg(feature = "godot-binding")]
static TEST_TILEMAP_ID: Lazy<InstanceId> = Lazy::new(|| InstanceId::from_i64(1337000));

#[cfg(not(feature = "godot-binding"))]
const TEST_TILEMAP_ID: u64 = 1337000;

pub fn handle_start_command(host_state: &mut HostState, tilemap_id_raw: u64) -> Result<(), SSXLCoreError> {
    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        crate::ssxl_warn!("Command: Attempted to start generation while already Running. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if tilemap_id_raw == 0 {
        crate::ssxl_error!("Command: Invalid TileMap InstanceId (0) provided. Cannot proceed. (FFI -5)");
        return Err(SSXLCoreError::InvalidTarget);
    }

    if !host_state.is_core_ready {
        crate::ssxl_warn!("Command: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready.".to_string()));
    }

    let map_extent = 1;
    let chunk_size = 32;

    let mut jobs = Vec::new();

    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new((chunk_x, chunk_y), chunk_size);
            let job = GenerationJob::new(task);
            jobs.push(job);
        }
    }

    let total_jobs = jobs.len();

    #[cfg(feature = "godot-binding")]
    let tilemap_id = InstanceId::from_i64(tilemap_id_raw as i64);

    #[cfg(not(feature = "godot-binding"))]
    let tilemap_id = tilemap_id_raw;

    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            crate::ssxl_info!("Command: Successfully initiated {} generation tasks.", total_jobs);
            Ok(())
        }
        Err(e) => {
            crate::ssxl_error!("Command: Conductor failed to start generation: {:?}", e);
            Err(e)
        }
    }
}

pub fn trigger_structural_test_job(host_state: &mut HostState) -> Result<(), SSXLCoreError> {
    crate::ssxl_info!("Structural Test: Initiating 1x1 conductor lifecycle test...");

    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        crate::ssxl_warn!("Structural Test: Conductor is already busy. Cannot run test. (FFI -6)");
        return Err(SSXLCoreError::ConductorBusy);
    }

    if !host_state.is_core_ready {
        crate::ssxl_warn!("Structural Test: Core not ready. Initialization failed or is pending.");
        return Err(SSXLCoreError::InitializationError("Core not ready for test.".to_string()));
    }

    let map_extent = 0;
    let chunk_size = 8;

    #[cfg(feature = "godot-binding")]
    let tilemap_id = *TEST_TILEMAP_ID;

    #[cfg(not(feature = "godot-binding"))]
    let tilemap_id = TEST_TILEMAP_ID;

    let mut jobs = Vec::new();

    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new((chunk_x, chunk_y), chunk_size);
            let job = GenerationJob::new(task);
            jobs.push(job);
        }
    }

    let total_jobs = jobs.len();

    match host_state.conductor.start_generation(tilemap_id, jobs) {
        Ok(_) => {
            crate::ssxl_info!(
                "Structural Test: Successfully started {} test task(s) with ID: {}. Result will be reported via FFI poll.",
                total_jobs,
                tilemap_id
            );
            Ok(())
        }
        Err(e) => {
            crate::ssxl_error!("Structural Test: Conductor failed to start: {:?}.", e);
            Err(e)
        }
    }
}

// --- END: rust/ssxl_ext/src\host_commands.rs ---
       108 LOC | rust/ssxl_ext/src\host_conductor.rs
// --- START: rust/ssxl_ext/src\host_conductor.rs ---
// rust/SSXL-ext/src/host_conductor.rs (UNIFIED AND FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate all Godot imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::classes::{Node, TileMap};

#[cfg(feature = "godot-binding")]
use godot::builtin::{GString, VarDictionary};

// --- Imports from host_tick.rs ---
// ðŸŽ¯ FIX 2: Gate core logic imports that are only used within the Godot-bound SSXLConductor implementation.
#[cfg(feature = "godot-binding")]
use crate::host_poller::poll_conductor_status;
#[cfg(feature = "godot-binding")]
use crate::host_state::{get_host_state, get_host_state_mut, HostState};
#[cfg(feature = "godot-binding")]
use crate::generate_conductor::GenerateConductor;
#[cfg(feature = "godot-binding")]
use crate::host_commands;
#[cfg(feature = "godot-binding")]
use crate::host_tilemap_status;
// ---------------------------------

// ----------------------------------------------------
// ðŸŽ¯ GDExtension Implementation
// ----------------------------------------------------

// ðŸŽ¯ CRITICAL FIX: Add a non-gated struct/impl block to satisfy dependencies 
// in other files when godot-binding is disabled.
#[cfg(not(feature = "godot-binding"))]
pub struct SSXLConductor {}
#[cfg(not(feature = "godot-binding"))]
impl SSXLConductor {}


#[cfg(feature = "godot-binding")]
#[derive(GodotClass)]
#[class(base = Node)]
pub struct SSXLConductor {
    // Fields from the old host_conductor.rs (API State)
    tilemap_target: Option<Gd<TileMap>>,
    signal_target: Option<Gd<Node>>,
    active_generator_id: String,

    #[base]
    base: Base<Node>,
}

#[cfg(feature = "godot-binding")]
#[godot_api]
impl INode for SSXLConductor { // INode implementation for the process loop
    // This manual fn init is now the *only* way the struct is initialized.
    fn init(base: Base<Node>) -> Self {
        // ðŸŽ¯ FIX: Use feature-gated macro
        crate::ssxl_info!("SSXLConductor initialized.");
        Self {
            tilemap_target: None,
            signal_target: None,
            active_generator_id: "none".to_owned(),
            base,
        }
    }
    
    fn ready(&mut self) {
        self.base_mut().set_process(true);
    }

    /// The Godot engine's main loop update function (from host_tick.rs).
    fn process(&mut self, _delta: f64) {
        let host_state: &HostState = match get_host_state() {
            Ok(state) => state,
            Err(e) => {
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_error!("SSXL Process Error: HostState not initialized in _process: {:?}", e);
                return; // Stop processing if state is unavailable
            }
        };
        
        if host_state.is_core_ready {
            let conductor: &GenerateConductor = &host_state.conductor;
            
            // Poll the status
            poll_conductor_status(conductor);
        }
    }
}


#[cfg(feature = "godot-binding")]
#[godot_api]
impl SSXLConductor {
    // --- API Functions from host_conductor.rs ---
    
    #[func]
    pub fn set_tilemap(&mut self, tilemap: Gd<TileMap>) {
        self.tilemap_target = Some(tilemap);
        // ðŸŽ¯ FIX: Use feature-gated macro
        crate::ssxl_info!(
            "TileMap target successfully registered: {:?}",
            self.tilemap_target.as_ref().unwrap().instance_id()
        );
    }

    #[func]
    pub fn initialize_runtime_shell(&mut self, signal_receiver: Gd<Node>) {
        self.signal_target = Some(signal_receiver);
        // ðŸŽ¯ FIX: Use feature-gated macro
        crate::ssxl_info!("Runtime shell initialization requested. Signal target registered.");
    }

    #[func]
    pub fn set_generator(&mut self, id: GString) {
        self.active_generator_id = id.to_string();
        // ðŸŽ¯ FIX: Use feature-gated macro
        crate::ssxl_info!("Generator set to: {}", self.active_generator_id);
    }

    #[func]
    pub fn build_map(&mut self, config: VarDictionary) -> bool {
        // ðŸŽ¯ FIX: Use feature-gated macro
        crate::ssxl_info!("Received request to build map with config: {:?}", config);

        if self.tilemap_target.is_none() {
            // ðŸŽ¯ FIX: Use feature-gated macro
            crate::ssxl_error!("FATAL: Cannot build map. TileMap target is missing.");
            return false;
        }
        true
    }

    #[func]
    pub fn get_status(&self) -> GString {
        "Running - Waiting for build_map".into()
    }

    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        (&self.active_generator_id).into() 
    }

    #[func]
    pub fn oracle_tick(&self, _delta: f32) {
        if let Some(_tilemap) = &self.tilemap_target {
            // Logic that was in the old oracle_tick
        }
    }

    #[func]
    pub fn get_metrics(&self) -> VarDictionary {
        VarDictionary::new()
    }

    // --- API Functions from host_tick.rs ---
    
    /// Public method called by GDScript to kick off generation.
    #[func]
    fn start_generation(&mut self, target_tilemap: Gd<Node>) -> bool {
        let host_state_mut = match get_host_state_mut() {
            Ok(state) => state,
            Err(e) => {
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_error!("HostState not ready for start_generation command: {:?}", e);
                return false;
            }
        };
        let tilemap_id = target_tilemap.instance_id();

        // ðŸŽ¯ FIX 4: Convert Godot's InstanceId to u64 using the public to_i64() method and casting.
        let tilemap_id_u64 = tilemap_id.to_i64() as u64;

        match host_commands::handle_start_command(host_state_mut, tilemap_id_u64) {
            Ok(_) => true,
            Err(e) => {
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_error!("Failed to start generation: {:?}", e);
                false
            }
        }
    }

    /// Public method called by GDScript to get the current generation status.
    #[func]
    fn get_status_report(&self) -> VarDictionary {
        match get_host_state() {
            Ok(state) => host_tilemap_status::get_status_report_dict(state),
            Err(e) => {
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_error!("Failed to get status report: {:?}", e);
                VarDictionary::new()
            }
        }
    }
}
// --- END: rust/ssxl_ext/src\host_conductor.rs ---
        46 LOC | rust/ssxl_ext/src\host_init.rs
// --- START: rust/ssxl_ext/src\host_init.rs ---
// ssxl_ext\src\host_init.rs (FIXED)

// Conditionally include Godot dependencies only when needed.
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use crate::host_state::init_host_state;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::config::GlobalConfig;
use std::sync::Arc;

// --- CORE LOGIC (Godot-independent and safe to call from CLI) ---

/// Internal function performing all core logic (Config loading, Conductor init, HostState init),
/// isolated from Godot-specific API calls.
fn _do_initialization() -> Result<(), String> {
    
    // 1. Load Global Configuration
    let config = match GlobalConfig::load_or_default() {
        Ok(c) => c,
        Err(e) => return Err(format!("Failed to load configuration: {}", e)),
    };
    let config = Arc::new(config);

    // 2. Initialize the Conductor
    let num_workers = config.threading.generation_worker_count;
    let conductor = GenerateConductor::new(
        num_workers,
        Arc::clone(&config),
    );

    // 3. Initialize the Animation Conductor
    let anim_conductor = AnimConductor::new();
    
    // 4. Initialize the Host State Singleton
    // FIX: Map the custom SSXLCoreError returned by init_host_state to a generic String.
    init_host_state(conductor, anim_conductor, Arc::clone(&config))
        .map_err(|e| format!("HostState initialization failed: {}", e))
}


// --- FFI ENTRY POINT (CLI-safe) ---

// ðŸŽ¯ CRITICAL FIX: Gate the C-exported function to ensure it is only compiled 
// for the CLI build, completely bypassing Godot FFI linkage.
#[cfg(not(feature = "godot-binding"))]
#[no_mangle]
pub extern "C" fn ssxl_boot_core_to_idle() -> i32 {
    match _do_initialization() { 
        Ok(_) => {
            // Use standard console output (eprintln!) for the CLI environment.
            eprintln!("âœ… SSXL-ext CLI Core: Initialization complete. Ready for FFI work.");
            0 // Success
        },
        Err(e) => {
            // Use standard console error output for the CLI environment.
            eprintln!("âŒ CLI FFI Boot Error: {}", e);
            1 // Generic error code for boot failure
        }
    }
}


// --- GODOT ENTRY POINT (Feature-gated for GDExtension hook) ---

/// The public function used by the Godot GDExtension lifecycle hook.
/// It wraps the core logic with Godot's logging API and is only compiled for the Godot target.
#[cfg(feature = "godot-binding")] // <-- CORRECTLY GATED
pub fn initialize_ssxl_core() -> Result<(), String> {
    
    godot_print!("SSXL-ext Core: Starting initialization (v9.1.seed).");
    
    match _do_initialization() { 
        Ok(_) => {
            godot_print!("SSXL-ext Core: Initialization complete. Ready for work.");
            Ok(())
        },
        Err(e) => {
            // Retain the original use of godot_print! for logging inside the Godot environment
            godot_print!("âŒ SSXL-ext Core FFI Error: {}", e);
            Err(e)
        }
    }
}

// NOTE: If your ssxl_cli::main.rs calls `ssxl_ext::host_init::initialize_ssxl_core()`, 
// you must change that call to `ssxl_ext::host_init::ssxl_boot_core_to_idle()` instead,
// to ensure the CLI uses the correct, gated entry point.
// --- END: rust/ssxl_ext/src\host_init.rs ---
        19 LOC | rust/ssxl_ext/src\host_poller.rs
// --- START: rust/ssxl_ext/src\host_poller.rs ---
// rust/SSXL-ext/src/host_poller.rs (FIXED)

use crate::generate_conductor::GenerateConductor;
use crate::bridge_signals;
use crate::ssxl_info;

/// The main polling routine, called once per Godot frame (typically from `host_tick.rs`).
/// Its primary responsibility is to pull completed work from the background thread,
/// render it, and emit the final completion signal.
pub fn poll_conductor_status(conductor: &GenerateConductor) {
    // 1. Process and Render Completed Chunks (The Direct Write)
    // The non-blocking channel polling and rendering are handled internally by the Conductor.
    let (chunks_rendered, generation_completed) = conductor.poll_chunks_and_render();

    if chunks_rendered > 0 {
        ssxl_info!("Poller: Rendered {} chunks this frame.", chunks_rendered);
        // Optional: Emit a progress update signal here if detailed GDScript tracking is needed.
        // bridge_signals::emit_progress_update(conductor.get_metrics());
    }

    // 2. State Transition Monitoring and Signal Broadcast (Lifecycle Guard)
    
    // `generation_completed` indicates the Conductor has internally flipped its state to Finished,
    // and all chunks are written. Now, we must emit the signal exactly once.
    if generation_completed {
        // This call implements the CRITICAL single-emission guard.
        if let Some(tilemap_id) = conductor.try_finalize_and_get_target_id() {
            
            // ðŸŽ¯ CRITICAL FIX 2: Restructured the block assignment using nested blocks. 
            // This forces the parser to see each feature-gated section as a single, 
            // self-contained expression, resolving the unexpected '#' token error.
            let id_for_logging: u64 = {
                #[cfg(feature = "godot-binding")]
                { tilemap_id.to_i64() as u64 }
                
                #[cfg(not(feature = "godot-binding"))]
                { tilemap_id }
            };

            ssxl_info!("Poller: All chunks rendered. Emitting final signal for ID: {}", id_for_logging);
            
            // Broadcast the signal back to GDScript, closing the loop.
            // Note: bridge_signals::emit_generation_finished expects the same InstanceType
            bridge_signals::emit_generation_finished(tilemap_id);
        }
        // If try_finalize_and_get_target_id() returns None, the signal was already sent 
        // or an internal error (logged by the Conductor) occurred.
    }
}
// --- END: rust/ssxl_ext/src\host_poller.rs ---
        49 LOC | rust/ssxl_ext/src\host_render.rs
// --- START: rust/ssxl_ext/src\host_render.rs ---
// rust/SSXL-ext/src/host_render.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate Godot imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use flume::Receiver;
use crate::shared_chunk::Chunk;
// Only ConductorStateContainer is used in the CLI fallback, so only ConductorState needs to be gated.
use crate::generate_conductor_state::ConductorStateContainer;
// ðŸŽ¯ FIX 1: Gate ConductorState import
#[cfg(feature = "godot-binding")]
use crate::generate_conductor_state::ConductorState;

// Note: The crate::host_tilemap::render_chunk_direct function must also be 
// feature-gated or stubbed in its own file.
#[cfg(feature = "godot-binding")]
use crate::host_tilemap::render_chunk_direct;

// ðŸŽ¯ FIX 3: Gate the constant definition, as it is only used within the gated render_available_chunks function.
#[cfg(feature = "godot-binding")]
// Define a safe maximum number of chunk writes per frame.
const MAX_CHUNKS_PER_FRAME: u32 = 16; 

/// Manages the rendering budget for completed chunks.
/// This function is called by the Host Poller on the Godot main thread.
// ðŸŽ¯ CRITICAL FIX: Gate the entire function implementation
#[cfg(feature = "godot-binding")]
pub fn render_available_chunks(
    tilemap_id: InstanceId,
    chunk_receiver: &Receiver<Chunk>,
    state_container: &ConductorStateContainer,
) -> (u32, bool) {
    
    let mut chunks_rendered_this_frame = 0;

    // Loop, but break if we hit the frame budget
    while chunks_rendered_this_frame < MAX_CHUNKS_PER_FRAME {
        
        // Non-blocking channel receive check
        match chunk_receiver.try_recv() {
            Ok(chunk) => {
                // 1. Execute the HIGH-PERFORMANCE DIRECT WRITE
                match render_chunk_direct(tilemap_id, chunk) {
                    Ok(_) => {
                        chunks_rendered_this_frame += 1;
                        state_container.increment_completed_chunks();
                    },
                    Err(e) => {
                        // ðŸŽ¯ FIX: Use feature-gated macro
                        crate::ssxl_error!("Render Pacing Layer: Direct write failed: {:?}", e);
                        // We continue, but might want to transition the state to Error
                    }
                }
            },
            Err(flume::TryRecvError::Empty) => {
                // No more chunks available in the channel. Exit loop.
                break;
            },
            Err(flume::TryRecvError::Disconnected) => {
                // Channel is closed (workers are shut down).
                // ðŸŽ¯ FIX: Use feature-gated macro
                crate::ssxl_warn!("Render Pacing Layer: Worker channel disconnected unexpectedly.");
                break;
            }
        }
    }
    
    // Check for overall generation completion
    let metrics = state_container.get_metrics();
    let is_finished = metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;
    
    if is_finished && state_container.get_state() == ConductorState::Generating {
        state_container.transition_to(ConductorState::Finished);
    }
    
    (chunks_rendered_this_frame, is_finished)
}

// ðŸŽ¯ FALLBACK: Provide a mock function for the CLI build to satisfy cross-module calls
#[cfg(not(feature = "godot-binding"))]
pub fn render_available_chunks(
    _tilemap_id: u64,
    _chunk_receiver: &Receiver<Chunk>,
    _state_container: &ConductorStateContainer,
) -> (u32, bool) {
    // No-op for the CLI build
    (0, false)
}
// --- END: rust/ssxl_ext/src\host_render.rs ---
        68 LOC | rust/ssxl_ext/src\host_state.rs
// --- START: rust/ssxl_ext/src\host_state.rs ---
// rust/SSXL-ext/src/host_state.rs (FIXED)

// --------------------------------------------------------------------------
// --- CONDITIONAL IMPORTS AND TYPE ALIASES (CRITICAL FIX) ---
// --------------------------------------------------------------------------

// 1. Only import Godot's InstanceId type when the feature is enabled.
#[cfg(feature = "godot-binding")]
use godot::prelude::InstanceId;
use once_cell::sync::OnceCell;
use std::sync::Arc;

use crate::config::GlobalConfig;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::rhythm_manager::RhythmManager;
use crate::shared_error::SSXLCoreError;
use crate::{ssxl_error, ssxl_info};

// 2. Define a type alias for the Instance ID based on the feature flag.
// This ensures that the HostState struct's field is either the Godot type or a primitive i64.
#[cfg(feature = "godot-binding")]
pub type InstanceType = InstanceId;
#[cfg(not(feature = "godot-binding"))]
pub type InstanceType = i64; // Use a standard integer for the CLI build

// --------------------------------------------------------------------------
// --- Conditional InstanceId Creation ---
// --------------------------------------------------------------------------

/// Helper function to safely create a null InstanceId without triggering FFI in the CLI.
fn create_null_instance_id() -> InstanceType {
    // === CLI MOCK IMPLEMENTATION (Safe) ===
    #[cfg(not(feature = "godot-binding"))]
    {
        // ðŸŽ¯ FIX: Simply return the i64 primitive value (type InstanceType = i64)
        1 
    }

    // === GDExtension IMPLEMENTATION ===
    #[cfg(feature = "godot-binding")]
    {
        // ðŸŽ¯ FIX: Return the Godot InstanceId type by calling its constructor
        InstanceId::from_i64(0) 
    }
}

// --------------------------------------------------------------------------
// --- Singleton & Access Functions ---
// --------------------------------------------------------------------------

/// The global, thread-safe singleton holding the core state of the system.
pub static HOST_SINGLETON: OnceCell<Option<HostState>> = OnceCell::new();

// ... (get_host_state and get_host_state_mut remain unchanged as they don't use InstanceId directly) ...

/// Attempts to retrieve a reference to the global `HostState`.
/// This function is safe to call from the main thread during runtime.
pub fn get_host_state() -> Result<&'static HostState, SSXLCoreError> {
    HOST_SINGLETON.get()
        .and_then(|host_option| host_option.as_ref())
        .ok_or_else(|| {
            ssxl_error!("Attempted to access HostState before it was initialized (immutable access).");
            SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
        })
}

/// Attempts to retrieve a MUTABLE reference to the global `HostState`.
/// This function is ONLY safe to call from the Godot Main Thread during runtime.
pub fn get_host_state_mut() -> Result<&'static mut HostState, SSXLCoreError> {
    // This block is unsafe because it bypasses Rust's static mutability checks,
    // relying on the caller (Godot main thread) to ensure exclusive access.
    let host_state_mut = unsafe {
        // 1. Get a mutable pointer to the static OnceCell<Option<HostState>> container.
        let host_singleton_mut_ptr =
            &HOST_SINGLETON as *const _ as *mut once_cell::sync::OnceCell<Option<HostState>>;

        // 2. Call get_mut() on the mutable container (requires dereferencing the pointer).
        // 3. Call as_mut() to get Option<&mut HostState>.
        (*host_singleton_mut_ptr)
            .get_mut()
            .and_then(|opt| opt.as_mut())
    };

    host_state_mut.ok_or_else(|| {
        ssxl_error!("Attempted to access HostState before it was initialized (mutable access).");
        SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
    })
}


/// Initializes the global `HostState` singleton.
pub fn init_host_state(
    conductor: GenerateConductor,
    anim_conductor: AnimConductor,
    config: Arc<GlobalConfig>
) -> Result<(), SSXLCoreError> {
    ssxl_info!("Initializing HostState...");

    let new_state = HostState {
        // Core components
        conductor,
        anim_conductor,
        config,
        rhythm_manager: RhythmManager::new(), // Initialize the rhythm manager

        // Volatile / Runtime fields
        is_core_ready: true, // Mark as ready immediately after init
        // CRITICAL FIX: Use the conditional helper function.
        tilemap_id: create_null_instance_id(),
    };

    // Try to set the static singleton instance to Some(new_state)
    HOST_SINGLETON.set(Some(new_state)).map_err(|_| {
        ssxl_error!("HostState initialization failed: Already initialized.");
        SSXLCoreError::InitializationError("HostState was already set.".to_string())
    })
}


// --------------------------------------------------------------------------
// --- HostState Structure ---
// --------------------------------------------------------------------------

/// The main structure containing all state required by the Rust core.
/// This struct is a main-thread singleton accessed via `get_host_state()` and `get_host_state_mut()`.
pub struct HostState {
    // --- Configuration & Conductor Components ---
    /// The global, immutable configuration settings.
    pub config: Arc<GlobalConfig>,
    /// The main procedural generation orchestrator.
    pub conductor: GenerateConductor,
    /// The manager for dynamic map/tile animations.
    pub anim_conductor: AnimConductor,
    /// The manager for low-frequency, synchronization-critical operations.
    pub rhythm_manager: RhythmManager,

    // --- Runtime Flags & Metadata ---
    /// Flag indicating if all core components are initialized and running.
    pub is_core_ready: bool,
    /// The Instance ID of the current target TileMap in Godot.
    /// Defaulted to 0 (null/unassigned) until a TileMap is provided by the Godot script.
    pub tilemap_id: InstanceType, // ðŸŽ¯ FIX: Use the conditional alias here
}
// --- END: rust/ssxl_ext/src\host_state.rs ---
        55 LOC | rust/ssxl_ext/src\host_tilemap.rs
// --- START: rust/ssxl_ext/src\host_tilemap.rs ---
// rust/SSXL-ext/src/host_tilemap.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate Godot imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::classes::TileMap;

// ðŸŽ¯ FIX 1: Gate TileData import (only used within the gated logic)
#[cfg(feature = "godot-binding")]
use crate::shared_tile::TileData;
use crate::shared_error::SSXLCoreError;
use crate::shared_chunk::Chunk;
// ðŸŽ¯ FIX 2: Gate bridge_ffi imports (only used within the gated logic)
#[cfg(feature = "godot-binding")]
use crate::bridge_ffi::{ssxl_get_tilemap_chunk_ptr, ssxl_notify_chunk_updated};
// ðŸŽ¯ FIX 3: Gate logging macro imports (only used within the gated logic)
#[cfg(feature = "godot-binding")]
use crate::{ssxl_info, ssxl_warn, ssxl_error}; 

// NOTE: The trait must be visible to the Godot compilation layer, but its implementation 
// only makes sense when Godot types are available.

#[cfg(feature = "godot-binding")]
pub trait TileMapDirectWriteExtension {
    fn get_raw_chunk_data_ptr(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) -> *mut TileData;
    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32);
}

// ðŸŽ¯ CRITICAL FIX: Gate the implementation block
#[cfg(feature = "godot-binding")]
impl TileMapDirectWriteExtension for Gd<TileMap> {
    
    fn get_raw_chunk_data_ptr(&mut self, _layer: i32, _chunk_x: i32, _chunk_y: i32) -> *mut TileData {
        let dummy_ptr = 0xDEADBEEF as *mut TileData;
        
        // ðŸ”¥ FIX 2: Use feature-gated macro
        crate::ssxl_warn!("Architectural WARNING: get_raw_chunk_data_ptr is placeholder (0xDEADBEEF). C++ TileMap binding required for runtime stability.");
        dummy_ptr
    }

    fn notify_chunk_data_changed(&mut self, layer: i32, chunk_x: i32, chunk_y: i32) {
        // ðŸ”¥ FIX 3: Use feature-gated macro
        crate::ssxl_info!("TILEMAP_WRITE_NOTIFY: Chunk ({}, {}) for layer {} marked dirty.", chunk_x, chunk_y, layer);
    }
}

/// The Finisher function responsible for the high-speed data delivery.
/// This must be called from the Godot main thread loop (e.g., host_render.rs).
// ðŸŽ¯ CRITICAL FIX: Gate the entire function implementation
#[cfg(feature = "godot-binding")]
pub fn render_chunk_direct(tilemap_id: InstanceId, chunk: Chunk) -> Result<(), SSXLCoreError> {
    
    let dest_ptr = unsafe {
        ssxl_get_tilemap_chunk_ptr(
            tilemap_id, 
            chunk.position.0, 
            chunk.position.1
        )
    };

    if dest_ptr.is_null() {
        // ðŸ”¥ FIX 4: Use feature-gated macro
        crate::ssxl_error!("ERROR: TileMap chunk pointer is NULL for chunk {:?}", chunk.position);
        return Err(SSXLCoreError::InvalidInstance(tilemap_id.to_i64() as u64)); 
    }
    
    let tile_count = chunk.tiles.len();
    
    // Perform the direct, non-overlapping memory copy (the O(1) core optimization).
    unsafe {
        std::ptr::copy_nonoverlapping(
            chunk.tiles.as_ptr() as *const _, // Source: Rust's generated Vector
            dest_ptr as *mut _,               // Destination: Godot's internal TileMap memory
            tile_count
        );
    
        // Notify Godot's renderer that the buffer has been changed manually.
        ssxl_notify_chunk_updated(tilemap_id, chunk.position.0, chunk.position.1);
    }

    Ok(())
}

// ðŸŽ¯ FALLBACK: Provide a mock function for the CLI build to satisfy cross-module calls
#[cfg(not(feature = "godot-binding"))]
pub fn render_chunk_direct(_tilemap_id: u64, _chunk: Chunk) -> Result<(), SSXLCoreError> {
    // No-op for the CLI build
    Ok(())
}


// ============================================================================
// FFI EXPORTS FOR ssxl_cli (TEST HARNESS)
// ============================================================================

/// EXPORT 1/2: Used by ssxl_cli to stress test single-cell FFI writing.
#[no_mangle]
// ðŸŽ¯ FIX: Explicitly gate the body to prevent conflict/warning when building for Godot
#[cfg(not(feature = "godot-binding"))] 
pub extern "C" fn ssxl_set_cell(x: i32, y: i32, tile_id: i32) {
    // ðŸ”¥ FIX 5: Use eprintln! for CLI FFI MOCK, ensuring it's only for the CLI build.
    eprintln!("FFI_EXPORT: CLI set cell ({}, {}) to Tile ID {}", x, y, tile_id);
}

// ðŸŽ¯ FALLBACK: Empty FFI export for Godot build to satisfy linker (though linker usually handles this)
#[cfg(feature = "godot-binding")]
pub extern "C" fn ssxl_set_cell(_x: i32, _y: i32, _tile_id: i32) {}


/// EXPORT 2/2: Used by ssxl_cli to signal the end of a writing batch.
#[no_mangle]
// ðŸŽ¯ FIX: Explicitly gate the body to prevent conflict/warning when building for Godot
#[cfg(not(feature = "godot-binding"))] 
pub extern "C" fn ssxl_notify_tilemap_update() {
    // ðŸ”¥ FIX 6: Use eprintln! for CLI FFI MOCK, ensuring it's only for the CLI build.
    eprintln!("FFI_EXPORT: CLI triggered global TileMap update notification.");
    // A real implementation might iterate over a list of dirty chunks and call ssxl_notify_chunk_updated.
}

// ðŸŽ¯ FALLBACK: Empty FFI export for Godot build to satisfy linker
#[cfg(feature = "godot-binding")]
pub extern "C" fn ssxl_notify_tilemap_update() {}
// --- END: rust/ssxl_ext/src\host_tilemap.rs ---
        32 LOC | rust/ssxl_ext/src\host_tilemap_status.rs
// --- START: rust/ssxl_ext/src\host_tilemap_status.rs ---
// rust/SSXL-ext/src/host_tilemap_status.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate Godot imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::builtin::VarDictionary;

use crate::host_state::HostState;
// ðŸŽ¯ FIX 1: Gate ssxl_error import (only used within the gated function)
#[cfg(feature = "godot-binding")]
use crate::ssxl_error;

// NOTE: ConductorState should be visible without gating.

/// Generates a `VarDictionary` containing the current status and metrics of the SSXL core.
// ðŸŽ¯ CRITICAL FIX: Gate the entire function implementation
#[cfg(feature = "godot-binding")]
pub fn get_status_report_dict(host_state: &HostState) -> VarDictionary {
    let mut dict = VarDictionary::new();

    if !host_state.is_core_ready {
        // ssxl_error! is already feature-gated and will work correctly.
        crate::ssxl_error!("Called get_status_report_dict before core was ready.");
        let _ = dict.insert("is_core_ready", false.to_variant());
        let _ = dict.insert("conductor_state", "Uninitialized".to_variant());
        let _ = dict.insert("total_chunks", 0.to_variant());
        let _ = dict.insert("completed_chunks", 0.to_variant());
        return dict;
    }

    // 1. Get the current state and metrics from the Conductor
    let conductor = &host_state.conductor;
    let metrics = conductor.get_metrics();
    let conductor_state = conductor.get_state_container().get_state();

    // 2. Map metrics into the Dictionary
    let _ = dict.insert("is_core_ready", host_state.is_core_ready.to_variant());
    let _ = dict.insert("conductor_state", conductor_state.to_string().to_variant());
    
    // Convert GenerationMetrics into Dictionary entries
    let _ = dict.insert("total_chunks", metrics.total_chunks.to_variant());
    let _ = dict.insert("completed_chunks", metrics.completed_chunks.to_variant());
    
    // Calculate progress as a float
    let progress = if metrics.total_chunks > 0 {
        metrics.completed_chunks as f64 / metrics.total_chunks as f64
    } else {
        0.0
    };
    let _ = dict.insert("progress", progress.to_variant());

    dict
}

// ðŸŽ¯ FALLBACK: Provide a mock function for the CLI build to satisfy cross-module calls
#[cfg(not(feature = "godot-binding"))]
// Define a placeholder type for VarDictionary in the CLI context if needed, or use a simpler return type.
// Since the caller (SSXLConductor) is also gated, we can use a simpler signature.
pub fn get_status_report_dict(_host_state: &HostState) -> () {
    // No-op for the CLI build
    ()
}
// --- END: rust/ssxl_ext/src\host_tilemap_status.rs ---
        59 LOC | rust/ssxl_ext/src\lib.rs
// --- START: rust/ssxl_ext/src\lib.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::init::{ExtensionLibrary, InitLevel};


pub mod tools;
pub mod math;
pub mod config;

pub mod cache;
pub mod sync_pool;
pub mod sync_rhythm;

pub mod shared_tile;
pub mod shared_chunk;
pub mod shared_config;
pub mod shared_error;
pub mod shared_math;
pub mod shared_message;
pub mod generate_task_queue;
pub mod shared_job;
pub mod generate_runtime;
pub mod generate_batch_processor;
pub mod generate_anim_conductor;
pub mod rhythm_manager;

pub mod generate_perlin;
pub mod generate_ca;
pub mod generate_ca_simulation;
pub mod generate_conductor;
pub mod generate_conductor_state;
pub mod generate_manager;

pub mod animate_events;
pub mod animate_worker;
pub mod animate_conductor;

pub mod bridge_ffi;
pub mod bridge_signals;
pub mod bridge_oracle;
pub mod host_conductor;
pub mod host_state;
pub mod host_init;
pub mod host_cleanup;
pub mod host_poller;
pub mod host_render;
pub mod host_commands;
pub mod host_tilemap;
pub mod host_tilemap_status;
pub mod tile_conversion;


#[cfg(feature = "godot-binding")]
struct SSXLExtension;

#[cfg(feature = "godot-binding")]
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    fn on_level_init(level: InitLevel) {
        if level == InitLevel::Scene {
            match host_init::initialize_ssxl_core() {
                Ok(_) => crate::ssxl_info!("Core resources successfully initialized and workers started."),
                Err(e) => crate::ssxl_error!("FATAL: SSXL Core failed to initialize. Reason: {}", e),
            }
        }
    }

    fn on_level_deinit(level: InitLevel) {
        if level == InitLevel::Scene {
            host_cleanup::cleanup_ssxl_core();
            crate::ssxl_info!("SSXL GDExtension terminated successfully.");
        }
    }
}

// --- END: rust/ssxl_ext/src\lib.rs ---
        40 LOC | rust/ssxl_ext/src\math.rs
// --- START: rust/ssxl_ext/src\math.rs ---
// rust/SSXL-ext/src/math.rs

use crate::shared_config::MapSettingsConfig; // To get chunk size

/// Converts continuous world coordinates (global tile coordinates) into 
/// discrete chunk coordinates.
/// 
/// This is crucial for determining which worker needs to process a given location.
pub fn world_to_chunk_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // Use floor division (integer division in Rust for positive numbers)
    // For proper handling of negative coordinates (common in large worlds), 
    // we use a correction for negative numbers.
    let chunk_x = (world_x as f32 / chunk_size as f32).floor() as i32;
    let chunk_y = (world_y as f32 / chunk_size as f32).floor() as i32;
    
    (chunk_x, chunk_y)
}

/// Converts discrete chunk coordinates and local chunk coordinates back into 
/// global world coordinates.
pub fn chunk_to_world_coords(chunk_x: i32, chunk_y: i32, local_x: i32, local_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    let world_x = (chunk_x * chunk_size) + local_x;
    let world_y = (chunk_y * chunk_size) + local_y;
    
    (world_x, world_y)
}

/// Calculates the local tile coordinate within a chunk from a global coordinate.
pub fn world_to_local_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // The modulo operation handles the wrap-around within the chunk boundary.
    // Ensure the result is non-negative for proper indexing.
    let local_x = world_x.rem_euclid(chunk_size);
    let local_y = world_y.rem_euclid(chunk_size);
    
    (local_x, local_y)
}

// rust/SSXL-ext/src/math.rs

/// Fast, safe 32-bit integer clamping. Useful for setting bounds on noise or CA values.
pub fn clamp_i32(val: i32, min: i32, max: i32) -> i32 {
    val.max(min).min(max)
}

/// Fast, safe float clamping. Used for normalizing noise output to a [0.0, 1.0] range.
pub fn clamp_f64(val: f64, min: f64, max: f64) -> f64 {
    val.max(min).min(max)
}

/// Linearly interpolates between 'a' and 'b' by the factor 't'.
/// Used in various generation algorithms for blending values.
pub fn lerp(a: f64, b: f64, t: f64) -> f64 {
    a + (b - a) * t.max(0.0).min(1.0) // Clamp t to [0.0, 1.0]
}

/// Calculates the distance squared between two points. 
/// Used for fast proximity checks without the overhead of a square root.
pub fn distance_squared_2d(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    dx * dx + dy * dy
}

// rust/SSXL-ext/src/math.rs

/// Generates a deterministic u64 seed from a pair of chunk coordinates.
/// Ensures that the same coordinates always produce the same seed, 
/// guaranteeing continuity across chunk borders.
pub fn hash_chunk_coords(chunk_x: i32, chunk_y: i32, world_seed: u64) -> u64 {
    // A simple, fast XOR-based hash mixing method:
    let mut hash: u64 = world_seed;
    hash = hash.wrapping_add(chunk_x as u64);
    hash = hash.wrapping_mul(31); // Simple prime multiplier
    hash ^= (chunk_y as u64).wrapping_shl(32);
    hash
}
// --- END: rust/ssxl_ext/src\math.rs ---
        19 LOC | rust/ssxl_ext/src\rhythm_manager.rs
// --- START: rust/ssxl_ext/src\rhythm_manager.rs ---
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq)]
#[allow(dead_code)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

pub struct RhythmManager {
    _last_check_time: Instant,
    _current_phase: RhythmPhase,
}

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            _last_check_time: Instant::now(),
            _current_phase: RhythmPhase::Idle,
        }
    }
}
// --- END: rust/ssxl_ext/src\rhythm_manager.rs ---
        30 LOC | rust/ssxl_ext/src\shared_chunk.rs
// --- START: rust/ssxl_ext/src\shared_chunk.rs ---
// rust/SSXL-ext/src/shared_chunk.rs

use crate::shared_math::ChunkCoords;
use crate::shared_tile::TileData;

/// Represents a single, self-contained, generated block of the world map.
/// This structure is the primary payload sent from worker threads to the conductor.
// FIX: Add #[derive(Default)] to satisfy the requirement for std::mem::take in generate_batch_processor.rs
#[derive(Debug, Clone, Default)] 
pub struct Chunk {
    /// The discrete coordinates (X, Y) identifying this chunk in the world grid.
    pub position: ChunkCoords,
    /// The edge length of the chunk (e.g., 32 for a 32x32 chunk).
    pub size: u32,
    /// The flat, contiguous array of tile data for the chunk.
    /// Storage is in Row-Major order (Y is outer loop, X is inner loop).
    pub tiles: Vec<TileData>,
    /// Metadata flag indicating if this chunk contains dynamic assets (entities, lights, etc.).
    pub contains_assets: bool,
}

// rust/SSXL-ext/src/shared_chunk.rs

impl Chunk {
    /// Initializes a new, empty chunk with the required size and position.
    pub fn new(position: ChunkCoords, size: u32) -> Self {
        // Pre-allocate the vector capacity immediately for performance.
        let capacity = (size * size) as usize;
        Self {
            position,
            size,
            // Initialize with the correct size (will be filled during generation).
            tiles: Vec::with_capacity(capacity), 
            contains_assets: false,
        }
    }

    /// Calculates the 1D index from 2D local coordinates (X, Y).
    /// This ensures consistent Row-Major ordering across all modules.
    /// Note: This does not perform bounds checking; it assumes inputs (x, y) are 0..size.
    pub fn get_index(&self, x: u32, y: u32) -> usize {
        // Index = Y * Size + X (Row-Major Ordering)
        (y * self.size + x) as usize
    }

    /// Gets an immutable reference to the TileData at the specified local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        let index = self.get_index(x, y);
        self.tiles.get(index)
    }

    /// Gets a mutable reference to the TileData for modification during generation.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        let index = self.get_index(x, y);
        self.tiles.get_mut(index)
    }
}
// --- END: rust/ssxl_ext/src\shared_chunk.rs ---
        87 LOC | rust/ssxl_ext/src\shared_config.rs
// --- START: rust/ssxl_ext/src\shared_config.rs ---
// rust/SSXL-ext/src/shared_config.rs

use serde::{Deserialize, Serialize};

/// Combines all settings relevant for the procedural generation workers.
/// This struct is passed via the GenerationTask to the sync_pool.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct GenerationConfig {
    pub perlin: PerlinNoiseConfig,
    pub ca: CellularAutomataConfig,
    pub world_seed: u64,
}

impl Default for GenerationConfig {
    fn default() -> Self {
        Self {
            perlin: PerlinNoiseConfig::default(),
            ca: CellularAutomataConfig::default(),
            world_seed: 5011993,
        }
    }
}

/// Configuration for the Fractal Brownian Motion (FBM) noise function.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct PerlinNoiseConfig {
    pub scale: f64,
    pub octaves: usize,
    pub persistence: f64,
    pub lacunarity: f64,
    pub threshold: f64,
}

impl Default for PerlinNoiseConfig {
    fn default() -> Self {
        Self {
            scale: 250.0,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            threshold: 0.0,
        }
    }
}

/// Configuration for the Cellular Automata simulation rules.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct CellularAutomataConfig {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl Default for CellularAutomataConfig {
    fn default() -> Self {
        Self {
            death_limit: 4,
            birth_limit: 5,
            steps: 5,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for all thread pools and concurrency limits.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct ThreadingConfig {
    // Number of dedicated workers for one-time generation (sync_pool.rs)
    pub generation_worker_count: u32,
    // Number of dedicated workers for continuous animation/simulation (animate_worker.rs)
    pub animation_worker_count: u32,
    // Max number of tasks/chunks allowed in the main generation queue
    pub task_channel_capacity: usize,
}

impl Default for ThreadingConfig {
    fn default() -> Self {
        Self {
            generation_worker_count: 4,
            animation_worker_count: 2,
            task_channel_capacity: 4096,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration defining the physical layout of the world chunks.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct MapSettingsConfig {
    // The size (edge length) of a single chunk (e.g., 32 -> 32x32 tiles)
    pub chunk_size: u32,
    // The initial number of chunks to generate from the center (0,0) outward (e.g., 8 -> 17x17 grid)
    pub map_extent_chunks: i32,
    pub tile_scale_factor: f32,
}

impl Default for MapSettingsConfig {
    fn default() -> Self {
        Self {
            chunk_size: 32,
            map_extent_chunks: 8,
            tile_scale_factor: 1.0,
        }
    }
}

// rust/SSXL-ext/src/shared_config.rs

/// Configuration for the continuous simulation and animation workers.
#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct AnimationConfig {
    // The desired speed of the simulation loop, decoupled from Godot's FPS.
    pub simulation_fps: u32,
    pub fluid_damping_factor: f32,
}

impl Default for AnimationConfig {
    fn default() -> Self {
        Self {
            simulation_fps: 30, // 30Hz simulation loop
            fluid_damping_factor: 0.95,
        }
    }
}
// --- END: rust/ssxl_ext/src\shared_config.rs ---
        30 LOC | rust/ssxl_ext/src\shared_error.rs
// --- START: rust/ssxl_ext/src\shared_error.rs ---
// ssxl_ext/src/shared_error.rs (FIXED)

use thiserror::Error;
// ðŸŽ¯ CRITICAL FIX: Removed the direct Godot import, which is unnecessary
// since we will use the crate's feature-gated macro (ssxl_warn!).
// use godot::prelude::godot_warn; 

#[derive(Debug, Error, Clone)]
pub enum SSXLCoreError {
    #[error("Core state uninitialized: HostState singleton is not yet set.")]
    UninitializedState,
    #[error("Core initialization failed: {0}")]
    InitializationError(String),
    #[error("Conductor lifecycle error: Conductor is currently busy and cannot accept new jobs.")]
    ConductorBusy,
    #[error("Conductor lifecycle error: System is currently in state '{0}'.")]
    InvalidConductorState(String),
    #[error("Configuration error: Invalid value for '{0}'.")]
    InvalidConfig(String),
    #[error("Channel sending failed: {0}")]
    ChannelSendError(String),
    #[error("Channel receiving failed: {0}")]
    ChannelRecvError(String),
    #[error("Thread management error: Worker thread join failed.")]
    ThreadJoinError,
    #[error("Generation data error: {0}")]
    GenerationDataError(String),
    #[error("Mathematical boundary error: {0}")]
    MathError(String),
    #[error("Godot instance error: Target TileMap InstanceId is invalid (0).")]
    InvalidTarget,
    #[error("Godot instance error: ID '{0}' is invalid or null.")]
    InvalidInstance(u64),
    #[error("FFI Bridge error: Direct memory write failed: {0}")]
    FFIWriteError(String),
    #[error("Godot API failure on '{0}': {1}")]
    GodotAPIFailure(String, String),
}

impl SSXLCoreError {
    pub fn to_ffi_code(&self) -> isize {
        match self {
            SSXLCoreError::UninitializedState => -2,
            SSXLCoreError::InvalidTarget => -5,
            SSXLCoreError::ConductorBusy => -6,
            _ => {
                // ðŸŽ¯ FIX: Use the feature-gated logging macro defined in tools.rs.
                crate::ssxl_warn!("Unhandled critical error in SSXLCoreError::to_ffi_code. Mapping to FFI -3 (ConductorStopped): {:?}", self);
                -3
            }
        }
    }
}
// --- END: rust/ssxl_ext/src\shared_error.rs ---
        37 LOC | rust/ssxl_ext/src\shared_job.rs
// --- START: rust/ssxl_ext/src\shared_job.rs ---
// rust/SSXL-ext/src/shared_job.rs

use crate::generate_task_queue::GenerationTask;

/// Defines the sequential steps required to fully process a single chunk.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum JobStep {
    /// Initial state: The task has been queued.
    Queued,
    /// Step 1: Raw Perlin noise generation is running.
    NoiseGeneration,
    /// Step 2: Cellular Automata refinement is running.
    CARefinement,
    /// Step 3: Post-processing and refinement (e.g., placing entities, blending).
    PostProcessing,
    /// Final state: The chunk data is ready to be sent to the Conductor's finisher queue.
    Finished,
    /// Error state: A worker encountered an unrecoverable error.
    Failed,
}

// rust/SSXL-ext/src/shared_job.rs

use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords;

/// Represents a complete, multi-stage task for generating a single world chunk.
#[derive(Debug, Clone)]
pub struct GenerationJob {
    /// The unique identifier for this job (e.g., the chunk's coordinates).
    pub id: ChunkCoords,
    /// The core data and parameters for the job.
    pub task: GenerationTask,
    /// The current stage of processing for this job.
    pub current_step: JobStep,
    /// The partially or fully completed chunk data.
    pub chunk_data: Chunk,
}

impl GenerationJob {
    /// Creates a new job, initializing its state.
    pub fn new(task: GenerationTask) -> Self {
        let chunk_data = Chunk::new(task.chunk_pos, task.chunk_size);
        
        GenerationJob {
            id: task.chunk_pos,
            task,
            current_step: JobStep::Queued,
            chunk_data,
        }
    }

    /// Advances the job to the next sequential step.
    pub fn advance_step(&mut self) {
        self.current_step = match self.current_step {
            JobStep::Queued => JobStep::NoiseGeneration,
            JobStep::NoiseGeneration => JobStep::CARefinement,
            JobStep::CARefinement => JobStep::PostProcessing,
            JobStep::PostProcessing => JobStep::Finished,
            // Finished and Failed are terminal states
            _ => self.current_step,
        };
    }
}
// --- END: rust/ssxl_ext/src\shared_job.rs ---
        12 LOC | rust/ssxl_ext/src\shared_math.rs
// --- START: rust/ssxl_ext/src\shared_math.rs ---
// rust/SSXL-ext/src/shared_math.rs

// --------------------------------------------------------------------------
// --- Type Aliases ---
// --------------------------------------------------------------------------

/// Type alias for 2D chunk coordinates (X, Y).
/// Used as the primary key for chunk addressing across the system (e.g., in cache.rs).
pub type ChunkCoords = (i32, i32);

/// Type alias for 2D coordinates used to identify a single tile within a chunk.
pub type LocalTileCoords = (i32, i32);

/// Type alias for 2D coordinates identifying a single tile in the entire world.
pub type WorldTileCoords = (i32, i32);


// --------------------------------------------------------------------------
// --- Constants ---
// --------------------------------------------------------------------------

/// The number of neighbors checked by the Cellular Automata algorithm (3x3 grid minus center).
pub const CA_NEIGHBOR_COUNT: u8 = 8;

/// A constant representing the world's gravity factor in the simulation, 
/// used by systems like animate_worker.rs.
pub const WORLD_GRAVITY_FACTOR: f32 = 9.81;

/// A small epsilon value used for floating-point comparisons to maintain precision.
pub const F32_EPSILON: f32 = 0.00001;


// --------------------------------------------------------------------------
// --- Shared Structures ---
// --------------------------------------------------------------------------

/// A simple structure to represent a position and a direction vector, 
/// used by animate_worker.rs for entities.
/// #[repr(C)] ensures FFI compatibility if this is passed directly to the Godot side.
#[derive(Debug, Clone, Copy, Default)]
#[repr(C)] 
pub struct EntityMovementState {
    pub position_x: f32,
    pub position_y: f32,
    pub velocity_x: f32,
    pub velocity_y: f32,
}
// --- END: rust/ssxl_ext/src\shared_math.rs ---
        23 LOC | rust/ssxl_ext/src\shared_message.rs
// --- START: rust/ssxl_ext/src\shared_message.rs ---
// rust/SSXL-ext/src/shared_message.rs

/// Control messages sent to the generation workers (sync_pool.rs).
#[derive(Debug, Clone, Copy)]
pub enum GenerationControlMessage {
    /// Instructs the workers to stop processing new tasks but finish current ones.
    Pause,
    /// Instructs the workers to stop immediately and shut down the thread.
    Stop,
    /// Forces a worker to reload its configuration from the global state.
    ReloadConfig,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;

/// Data messages sent from the generation workers back to the main thread Conductor.
#[derive(Debug)]
pub enum GenerationDataMessage {
    /// A completed chunk ready for direct writing to the TileMap.
    CompletedChunk(Chunk),
    /// A fatal error occurred during the processing of a specific chunk.
    JobFailure(SSXLCoreError),
    /// A simple acknowledgement that a worker is initialized or has cleared its state.
    Ack,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_config::AnimationConfig;

/// Control messages sent to the animation workers (animate_worker.rs).
#[derive(Debug, Clone, Copy)]
pub enum AnimationControlMessage {
    Pause,
    Stop,
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/shared_message.rs

use crate::animate_events::AnimationEvent;

/// Data messages sent from the animation workers back to the main thread Conductor.
#[derive(Debug, Clone)]
pub enum AnimationDataMessage {
    /// A single, ready-to-render visual event.
    Event(AnimationEvent),
    /// A worker encountered an unrecoverable error during simulation.
    WorkerPanic(SSXLCoreError),
}
// --- END: rust/ssxl_ext/src\shared_message.rs ---
        47 LOC | rust/ssxl_ext/src\shared_tile.rs
// --- START: rust/ssxl_ext/src\shared_tile.rs ---
// rust/SSXL-ext/src/shared_tile.rs

/// The minimal data required to represent a single tile in the Godot TileMap.
///
/// #[repr(C)] ensures FFI-compatibility for direct memory writing 
/// to Godot's C++ data structures, making the chunk rendering extremely fast.
/// 
/// Total size: 6 bytes.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TileData {
    pub tile_id: u16,        // ID corresponding to a tile in the Godot TileSet (source ID)
    pub atlas_coords: u16,   // Packed coords within the TileSet Atlas
    pub rotation_flags: u8,  // Rotation, flip, and custom flags
    pub custom_data: u8,     // Used for dynamic data (e.g., fluid level, density score)
}

// Add a default implementation for easy initialization (e.g., for empty chunks)
impl Default for TileData {
    fn default() -> Self {
        // Defaulting to an "Air" or "Empty" tile (ID 0)
        Self {
            tile_id: 0, 
            atlas_coords: 0, 
            rotation_flags: 0, 
            custom_data: 0,
        }
    }
}

// --- FIX: Implement the is_live and set_live methods for Cellular Automata logic ---
impl TileData {
    /// Checks if the tile is in a 'live' state. 
    /// In the context of a tile map, this usually means the tile is present (tile_id != 0).
    pub fn is_live(&self) -> bool {
        // A tile is 'live' if it has been assigned a valid tile_id (i.e., not the default 0).
        self.tile_id != 0
    }

    /// Sets the live/dead state of the tile.
    /// To set 'live' (true), we use a placeholder tile_id (1).
    /// To set 'dead' (false), we use the default 'empty' tile_id (0).
    pub fn set_live(&mut self, live: bool) {
        if live {
            // Set to a placeholder 'live' tile ID (assuming ID 1 is the default solid tile)
            if self.tile_id == 0 {
                self.tile_id = 1; 
            }
        } else {
            // Set to the 'dead' (empty) tile ID
            self.tile_id = 0;
            // Optionally clear other related fields for an empty tile
            self.atlas_coords = 0;
            self.rotation_flags = 0;
            self.custom_data = 0;
        }
    }
}
// --- END FIX ---


/// A structure to hold the generated data for a single TileMap chunk.
/// This is the payload delivered from the worker threads to the main thread.
#[derive(Debug, Clone)] // Clone is necessary for safe job/message passing
pub struct Chunk {
    pub position: (i32, i32), // Grid position of the chunk
    pub tiles: Vec<TileData>, // The raw tile data array
    pub size: u32,             // Edge length (e.g., 16x16 chunk -> size = 16)
}

// Default implementation for Chunk (e.g., for empty/uninitialized chunks)
impl Default for Chunk {
    fn default() -> Self {
        Self {
            position: (0, 0),
            tiles: Vec::new(),
            size: 0,
        }
    }
}
// --- END: rust/ssxl_ext/src\shared_tile.rs ---
        99 LOC | rust/ssxl_ext/src\sync_pool.rs
// --- START: rust/ssxl_ext/src\sync_pool.rs ---
// rust/SSXL-ext/src/sync_pool.rs

use std::thread;
use std::sync::Arc;
use flume::{Receiver, Sender};

// Shared types used for concurrent operations
use crate::shared_job::GenerationJob; 
use crate::shared_message::GenerationDataMessage;
use crate::config::GlobalConfig;
use crate::generate_runtime;

// --- FIX: Removed the import for Godot-dependent logging macros
// use crate::{ssxl_info, ssxl_error};

// --------------------------------------------------------------------------
// --- Worker Structures ---
// --------------------------------------------------------------------------

/// A wrapper around a dedicated worker thread handle.
struct Worker {
    id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl Worker {
    /// Spawns a new thread and starts the worker's execution loop.
    fn new(
        id: usize, 
        task_receiver: Arc<Receiver<GenerationJob>>, 
        chunk_sender: Sender<GenerationDataMessage>,
        // The worker needs a reference to the global configuration
        config: Arc<GlobalConfig>,
    ) -> Worker {
        // Clone the necessary handles for the new thread
        let sender_clone = chunk_sender.clone();
        
        let handle = thread::spawn(move || {
            // Loop until the channel is disconnected (which signals shutdown)
            while let Ok(job) = task_receiver.recv() {
                
                // --- EXECUTE FULL GENERATION RUNTIME ---
                let final_result = generate_runtime::run_generation_job(job, &config.generation);

                // --- FINISHER DELIVERY ---
                // Send the final result (Completed Chunk or Failure Message) back to the Conductor.
                let message = match final_result {
                    Ok(completed_chunk) => {
                        // Using eprintln! for standard thread logging
                        eprintln!("INFO: Worker {} completed job {:?}", id, completed_chunk.position);
                        GenerationDataMessage::CompletedChunk(completed_chunk)
                    },
                    Err(e) => {
                        // Using eprintln! for standard thread logging
                        eprintln!("ERROR: Worker {} failed job: {:?}", id, e);
                        GenerationDataMessage::JobFailure(e)
                    }
                };

                // Non-blocking delivery of the result back to the Conductor's main thread poller.
                if let Err(e) = sender_clone.send(message) {
                    // The main thread is no longer listening; break the loop and shut down.
                    // Using eprintln! for standard thread logging
                    eprintln!("ERROR: Worker {} failed to send result: {}. Conductor likely shut down.", id, e);
                    break; 
                }
            }
            // Using eprintln! for standard thread logging
            eprintln!("INFO: Worker {} shutting down.", id);
        });

        Worker { id, handle: Some(handle) }
    }
}


// --------------------------------------------------------------------------
// --- ThreadPool Structure ---
// --------------------------------------------------------------------------

/// Manages the pool of worker threads dedicated to procedural generation.
pub struct SyncPool {
    workers: Vec<Worker>,
    // The pool holds the sender end of the channel for task submission
    task_sender: Sender<GenerationJob>,
    // The pool sends completed messages back to the Conductor
    chunk_sender: Sender<GenerationDataMessage>,
    // This handle ensures the Receiver stays alive while the workers are running.
    _task_receiver_final_handle: Receiver<GenerationJob>,
}

impl SyncPool {
    /// Creates a new SyncPool and spawns the specified number of workers.
    /// Returns the Conductor's receiving channel for completed work.
    /// 
    /// Returns: (SyncPool instance, Receiver for completed chunks)
    pub fn new(num_workers: usize, config: Arc<GlobalConfig>) -> (Self, Receiver<GenerationDataMessage>) {
        
        // --- 1. Setup Channels ---
        let (task_sender, task_receiver_final_handle) = flume::unbounded();
        let task_receiver_arc = Arc::new(task_receiver_final_handle.clone());
        let (chunk_sender, chunk_receiver) = flume::unbounded();

        // --- 2. Spawn Workers ---
        let mut workers = Vec::with_capacity(num_workers);
        for id in 0..num_workers {
            workers.push(Worker::new(
                id,
                Arc::clone(&task_receiver_arc),
                chunk_sender.clone(),
                Arc::clone(&config),
            ));
        }

        eprintln!("INFO: Started SyncPool with {} dedicated workers.", num_workers);
        
        let pool = SyncPool { 
            workers, 
            task_sender, 
            chunk_sender,
            _task_receiver_final_handle: task_receiver_final_handle,
        };
        
        (pool, chunk_receiver)
    }
    
    /// Submits a new generation job to the worker pool.
    pub fn submit_job(&self, job: GenerationJob) -> Result<(), flume::SendError<GenerationJob>> {
        self.task_sender.send(job)
    }
    
    // âœ… FIX E0599: Implemented the method required by GenerationManager.
    /// Retrieves the current status of the worker pool (worker count and queue size).
    pub fn get_status(&self) -> (usize, usize) {
        let worker_count = self.workers.len();
        // flume::Sender::len() reports the number of messages currently waiting in the queue.
        let queue_size = self.task_sender.len();
        (worker_count, queue_size)
    }

    // âŒ REMOVED: The shutdown method that takes `self` (ownership) is removed here 
    // to resolve E0507 in GenerationManager. Cleanup will be done by the owner 
    // when the struct is dropped, or via a public, static cleanup method.
    /*
    pub fn shutdown(self) {
        // ... shutdown logic ...
    }
    */
}

// NOTE: To ensure threads are properly joined upon cleanup (which is essential
// for clean shutdown), we re-introduce the shutdown logic using a static method 
// or implement the Drop trait. Since `GenerationManager` is fixed to no longer 
// call `shutdown(&self)`, we defer the joining/cleanup to the host layer 
// responsible for owning and dropping the SyncPool instance.
// However, since the original code contained the join logic, we will define a 
// static `cleanup` function that takes ownership for the host to call.

impl SyncPool {
    /// Signals workers to stop and waits for all threads to finish (clean shutdown).
    /// This method takes ownership and is intended to be called when the pool is 
    /// no longer needed by the owning structure.
    pub fn cleanup(self) {
        // Drop all senders and the receiver handle. This signals to workers to exit their loops.
        drop(self.task_sender);
        drop(self._task_receiver_final_handle);
        drop(self.chunk_sender);
        
        // Wait for all worker threads to finish.
        for mut worker in self.workers.into_iter() {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    eprintln!("ERROR: Worker {} thread join failed: {:?}", worker.id, e);
                }
            }
        }
        eprintln!("INFO: SyncPool shut down successfully.");
    }
}
// --- END: rust/ssxl_ext/src\sync_pool.rs ---
        58 LOC | rust/ssxl_ext/src\sync_rhythm.rs
// --- START: rust/ssxl_ext/src\sync_rhythm.rs ---
// rust/SSXL-ext/src/sync_rhythm.rs

use std::time::{Instant, Duration};
use crate::generate_conductor_state::ConductorState;
use crate::host_state::get_host_state;
// --- FIX: Import logging macro from the crate root ---
use crate::{ssxl_info, ssxl_error};

// Define the interval at which the complex rhythm checks run (e.g., 4 times per second)
const RHYTHM_CHECK_INTERVAL: Duration = Duration::from_millis(250);

/// Manages the timing and synchronization points between the generation and simulation layers.
pub struct RhythmManager {
    last_check_time: Instant,
    // The current phase of the synchronization loop (if staggered)
    current_phase: RhythmPhase, 
}

/// Defines the stages in a multi-step synchronization cycle.
#[derive(Debug, Clone, Copy, PartialEq)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

// rust/SSXL-ext/src/sync_rhythm.rs

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            last_check_time: Instant::now(),
            current_phase: RhythmPhase::Idle,
        }
    }

    /// Checks if it's time to run a complex synchronization check.
    pub fn poll_rhythm(&mut self) {
        if self.last_check_time.elapsed() >= RHYTHM_CHECK_INTERVAL {
            self.last_check_time = Instant::now();
            self.execute_rhythm_check();
        }
    }

    /// Executes the staged synchronization logic.
    fn execute_rhythm_check(&mut self) {
        // Access the global state, where the conductors and caches reside
        let host_state = match get_host_state() {
            Ok(state) => state,
            Err(_) => {
                // If HostState isn't initialized, we can't run the rhythm check.
                ssxl_error!("RhythmManager tried to poll but HostState is uninitialized.");
                return;
            }
        };

        // Get the state container safely
        let generation_state = host_state.conductor.get_state_container();
        
        match self.current_phase {
            RhythmPhase::Idle => {
                // Check if any system needs attention
                if generation_state.get_state() == ConductorState::Finished {
                    self.current_phase = RhythmPhase::CheckGenerationStatus;
                } else {
                    // Nothing urgent, remain idle
                }
            },
            
            RhythmPhase::CheckGenerationStatus => {
                // Action: Generation is FINISHED. This is a synchronization point.
                ssxl_info!("Rhythm Check: Generation finished. Starting post-gen cleanup.");

                // 1. Flush caches that depend on generation tasks
                // NOTE: Assumes host_state has a public `noise_cache` field and it has a `clear` method.
                // host_state.noise_cache.clear(); 
                
                self.current_phase = RhythmPhase::SyncAnimationStarts;
            },
            
            RhythmPhase::SyncAnimationStarts => {
                // Action: Start the Animation workers now that the world is ready.
                ssxl_info!("Rhythm Check: Starting animation workers...");
                // host_state.anim_conductor.start_workers(); 

                self.current_phase = RhythmPhase::CleanUpStaleCaches;
            },

            RhythmPhase::CleanUpStaleCaches => {
                // Action: Run garbage collection/stale data cleanup
                // host_state.chunk_cache.prune_distant_chunks(host_state.player_position); 

                self.current_phase = RhythmPhase::Idle; // Cycle complete
            }
        }
    }
}
// --- END: rust/ssxl_ext/src\sync_rhythm.rs ---
         7 LOC | rust/ssxl_ext/src\tile_conversion.rs
// --- START: rust/ssxl_ext/src\tile_conversion.rs ---
// ssxl_ext/src/tile_conversion.rs

/// Pure Rust implementation of bitmask â†’ tile ID conversion.
/// This is what the CLI should call directly.
pub fn bitmask_to_id(bitmask: u8) -> i32 {
    // Real implementation would use a LUT.
    (bitmask % 48) as i32
}

/// FFI wrapper for Godot.
/// This is what the DLL exports.
#[no_mangle]
pub extern "C" fn ssxl_ext_bitmask_to_id(bitmask: u8) -> i32 {
    // Optional: debug print for Godot-side calls
    eprintln!("FFI_EXPORT: converting bitmask {} via FFI wrapper", bitmask);

    bitmask_to_id(bitmask)
}

// --- END: rust/ssxl_ext/src\tile_conversion.rs ---
        56 LOC | rust/ssxl_ext/src\tools.rs
// --- START: rust/ssxl_ext/src\tools.rs ---
// rust/SSXL-ext/src/tools.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate all Godot-related imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use std::time::Instant;

// ----------------------------------------------------
// 1. CUSTOM LOGGING MACROS (CONDITIONALLY COMPILED)
// ----------------------------------------------------

// NOTE: These macros are already correctly feature-gated internally.

/// Prints a standard information message.
#[macro_export]
macro_rules! ssxl_info {
    ($($arg:tt)*) => ({
        // === GDExtension IMPLEMENTATION ===
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_print!("INFO [SSXL]: {}", format!($($arg)*));
        
        // === CLI/STANDARD IMPLEMENTATION (Fallback) ===
        #[cfg(not(feature = "godot-binding"))]
        println!("INFO [SSXL]: {}", format!($($arg)*));
    });
}

/// Prints a warning message.
#[macro_export]
macro_rules! ssxl_warn {
    ($($arg:tt)*) => ({
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_warn!("WARN [SSXL]: {}", format!($($arg)*));
        
        #[cfg(not(feature = "godot-binding"))]
        eprintln!("WARN [SSXL]: {}", format!($($arg)*));
    });
}

/// Prints an error message.
#[macro_export]
macro_rules! ssxl_error {
    ($($arg:tt)*) => ({
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_error!("ERROR [SSXL]: {}", format!($($arg)*));
        
        #[cfg(not(feature = "godot-binding"))]
        eprintln!("ERROR [SSXL]: {}", format!($($arg)*));
    });
}

// ----------------------------------------------------
// 2. COORDINATE UTILITIES
// ----------------------------------------------------

// ðŸŽ¯ CRITICAL FIX: Define a mock type for the CLI build (where Vector2i is missing).
// This is necessary because 'ToGodotVector' is not gated.
#[cfg(not(feature = "godot-binding"))]
pub type Vector2i = (i32, i32);


/// Trait for converting Rust coordinate types to Godot Vector2i.
// NOTE: Since this trait is used across the crate (impls are below) but its function 
// only makes sense in Godot, we keep the trait declaration ungated but the implementation gated.
pub trait ToGodotVector {
    fn to_godot_vector(&self) -> Vector2i;
}

// ðŸŽ¯ CRITICAL FIX: Gate the implementation, as it uses Godot's Vector2i::new.
// If this is not gated, the compiler gets E0433: use of undeclared type `Vector2i`.
#[cfg(feature = "godot-binding")]
impl ToGodotVector for (i32, i32) {
    /// Converts a (x, y) tuple into a Godot Vector2i.
    fn to_godot_vector(&self) -> Vector2i {
        Vector2i::new(self.0, self.1)
    }
}

// ----------------------------------------------------
// 3. PROFILER UTILITY
// ----------------------------------------------------

/// A simple struct for timing code execution blocks.
pub struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    /// Starts a new profiler instance if profiling is globally enabled.
    pub fn start(name: &'static str) -> Self {
        // NOTE: In a real project, 'is_profiling_enabled' would be read from config.rs
        const IS_PROFILING_ENABLED: bool = true;
        
        Profiler {
            start: Instant::now(),
            name,
            enabled: IS_PROFILING_ENABLED,
        }
    }
}

/// The Drop implementation automatically logs the duration when the scope is exited.
impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            // This already correctly uses eprintln! and does not require macro conditionalization.
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms",
                self.name,
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}
// --- END: rust/ssxl_ext/src\tools.rs ---
        95 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
pub mod ssxl_menu;
pub mod ssxl_source_scan;
pub mod ssxl_api_scan;
pub mod ssxl_testing;
pub mod ssxl_godot;

pub use ssxl_godot::launch_godot_project;
pub use ssxl_testing::run_grand_unified_test;

use std::{fs, io, process::Command};
use tracing::{error, info};
use tracing_subscriber::{filter::LevelFilter, prelude::*};

extern "C" {
    fn ssxl_boot_core_to_idle() -> i32;
}

// -----------------------------------------------------------------------------
// NEW PIPELINE CONSTANTS
// -----------------------------------------------------------------------------

// Build output (always release for Godot)
const DLL_SRC: &str = "C:/zv9/zv9.SSXL-ext/rust/target/release/ssxl_ext.dll";

// Dual deployment targets
const DLL_DST_TESTER2: &str = "C:/zv9/zv9.SSXL-ext/SSXLtester2/ssxl_ext.dll";
const DLL_DST_ENGINE: &str = "C:/zv9/zv9.SSXL-ext/SSXL_engine_tester/ssxl_ext.dll";

// -----------------------------------------------------------------------------
// PIPELINE HELPERS
// -----------------------------------------------------------------------------

fn kill_stale_godot() {
    let _ = Command::new("taskkill")
        .args(&["/IM", "godot.exe", "/F"])
        .status();
}

fn build_extension() {
    info!("Building ssxl_ext (release, godot-binding)...");

    let status = Command::new("cargo")
        .args([
            "build",
            "-p",
            "ssxl_ext",
            "--release",
            "--features",
            "godot-binding",
        ])
        .status()
        .expect("Failed to run cargo build");

    if !status.success() {
        error!("ssxl_ext build failed.");
        std::process::exit(1);
    }
}

fn deploy_dll() {
    info!("Deploying DLL to both Godot projects...");

    if let Err(e) = fs::copy(DLL_SRC, DLL_DST_TESTER2) {
        error!("Failed to copy to SSXLtester2: {}", e);
    }

    if let Err(e) = fs::copy(DLL_SRC, DLL_DST_ENGINE) {
        error!("Failed to copy to SSXL_engine_tester: {}", e);
    }

    info!("âœ… DLL deployed to SSXLtester2 and SSXL_engine_tester");
}

fn ensure_extension_fresh() {
    // NEW: Always rebuild on CLI start.
    // No timestamp logic. No stale detection.
    // The pipeline is authoritative.
    kill_stale_godot();
    build_extension();
    deploy_dll();
}

// -----------------------------------------------------------------------------
// ENGINE RUNTIME
// -----------------------------------------------------------------------------

pub fn start_runtime() -> bool {
    unsafe {
        match ssxl_boot_core_to_idle() {
            0 => {
                info!("Engine runtime initialized.");
                true
            }
            code => {
                error!("Engine failed to boot. Code {}", code);
                false
            }
        }
    }
}

// -----------------------------------------------------------------------------
// INIT + MAIN
// -----------------------------------------------------------------------------

fn init() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXL CLI initializing...");

    // NEW: Always rebuild + deploy DLL before any FFI call.
    ensure_extension_fresh();
}

fn main() {
    init();

    ssxl_source_scan::scan_and_report_loc();

    println!(
        r#"
            (__)  
            (oo)
      /------\/
     / |    ||
    * ||----||
      ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    ssxl_menu::run_interactive_loop(ssxl_menu::build_menu());
}

// --- END: rust/ssxl_cli/src\main.rs ---
        21 LOC | rust/ssxl_cli/src\pipeline.rs
// --- START: rust/ssxl_cli/src\pipeline.rs ---
use std::fs;
use std::process::Command;
use std::path::PathBuf;

pub fn run_pipeline() -> anyhow::Result<()> {
    // 1. Kill stale Godot processes
    let _ = Command::new("taskkill")
        .args(&["/IM", "godot.exe", "/F"])
        .status();

    // 2. Build DLL
    Command::new("cargo")
        .args(&["build", "-p", "ssxl_ext", "--release", "--features", "godot-binding"])
        .status()?;

    // 3. Locate DLL
    let dll_src = PathBuf::from("rust/target/release/ssxl_ext.dll");

    // 4. Copy into both Godot project roots
    let tester2 = PathBuf::from("SSXLtester2/SSXL_ext.dll");
    let engine_tester = PathBuf::from("SSXL_engine_tester/SSXL_ext.dll");

    fs::copy(&dll_src, &tester2)?;
    fs::copy(&dll_src, &engine_tester)?;

    println!("âœ… DLL deployed to both Godot projects");

    // 5. Optionally launch Godot (example: SSXLtester2)
    Command::new("godot")
        .current_dir("SSXLtester2")
        .status()?;

    Ok(())
}

// --- END: rust/ssxl_cli/src\pipeline.rs ---
         6 LOC | rust/ssxl_cli/src\ssxl_api_scan.rs
// --- START: rust/ssxl_cli/src\ssxl_api_scan.rs ---
// ssxl_api_scan.rs
use tracing::info;

/// Action stub: Prints an inspection of the Godot API Surface exposed via the GDExtension.
pub fn print_godot_api_surface() { 
    info!("MOCK ACTION: Inspecting Godot API surface...");
    println!("API Scan: Currently using placeholder FFI stubs (`ssxl_set_cell`, `ssxl_notify_tilemap_update`).");
    println!("API Scan: Real implementation will reflect the final Godot<->Rust API defined by the 'finisher' component.");
}
// --- END: rust/ssxl_cli/src\ssxl_api_scan.rs ---
        32 LOC | rust/ssxl_cli/src\ssxl_godot.rs
// --- START: rust/ssxl_cli/src\ssxl_godot.rs ---
use std::{path::PathBuf, process::Command};
use tracing::{error, info};

const GODOT_EXE: &str = "../SSXLtester2/Godot_v4.5.1-stable_win64.exe";
const GODOT_PROJECT: &str = "../SSXLtester2/project.godot";

pub fn launch_godot_project() {
    let project_path = PathBuf::from(GODOT_PROJECT);

    // âœ… FIX: Avoid returning a reference to a temporary PathBuf
    let project_dir_buf = project_path
        .parent()
        .map(|p| p.to_path_buf())
        .unwrap_or_else(|| PathBuf::from(".."));

    let project_dir = project_dir_buf.as_path();

    if !project_path.exists() {
        error!("Godot project not found at {}.", GODOT_PROJECT);
        return;
    }

    info!("Launching Godot editor...");

    match Command::new(GODOT_EXE)
        .arg("--editor")
        .arg(project_dir)
        .spawn()
    {
        Ok(mut child) => {
            info!("Godot launched. Waiting for editor to close...");
            if let Err(e) = child.wait() {
                error!("Error waiting for Godot: {}", e);
            }
        }
        Err(e) => {
            error!("Failed to launch Godot: {}", e);
        }
    }
}

// --- END: rust/ssxl_cli/src\ssxl_godot.rs ---
        88 LOC | rust/ssxl_cli/src\ssxl_menu.rs
// --- START: rust/ssxl_cli/src\ssxl_menu.rs ---
use std::collections::HashSet;
use std::io::{self, Write};
use std::time::Duration;
use std::thread;
use crossterm::event::{self, Event, KeyCode};
use tracing::info;

// Import actions from crate root (main.rs re-exports them)
use crate::{
    run_grand_unified_test,
    launch_godot_project,
};

// âœ… Import start_runtime so L can load the engine on demand
use crate::start_runtime;

/// Structure representing a single menu item and its action.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn()>,
}

pub fn build_menu() -> Vec<CliAction> {
    vec![
        // âœ… L now starts the runtime AND launches Godot
        CliAction {
            key: 'L',
            label: "ðŸš€ press L: Launch Godot Project (Full Integration Test)",
            id: "launch_godot",
            action: Box::new(|| {
                // âœ… Runtime loads ONLY here â€” never at startup
                if start_runtime() {
                    launch_godot_project();
                } else {
                    println!("âŒ Runtime failed to start. Cannot launch Godot.");
                }
            }),
        },

        // âœ… Grand Unified Test
        CliAction {
            key: 'G',
            label: "âœ… press G: Run Grand Unified Test (GUT)",
            id: "grand_unified_test",
            action: Box::new(run_grand_unified_test),
        },

        // âœ… Exit
        CliAction {
            key: 'U',
            label: "âœ… press U: EXIT Console",
            id: "exit",
            action: Box::new(|| {}),
        },
    ]
}

fn print_menu(menu: &[CliAction]) {
    println!("\n--- SSXL-ext Main Menu ---");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
}

fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

pub fn run_interactive_loop(menu: Vec<CliAction>) {
    let mut last_keys = HashSet::new();

    loop {
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            // Debounced input poll
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);

                                (item.action)(); // Execute the action closure

                                if c == 'U' {
                                    return;
                                }

                                wait_for_enter();
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}

// --- END: rust/ssxl_cli/src\ssxl_menu.rs ---
       107 LOC | rust/ssxl_cli/src\ssxl_source_scan.rs
// --- START: rust/ssxl_cli/src\ssxl_source_scan.rs ---
// ssxl_source_scan.rs
use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// --- CONSTANTS ---
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";
// Note: Relative paths are assumed to be run from the 'rust' directory.

// --- LOC COUNTING LOGIC ---

/// Counts non-empty, non-comment lines of code.
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        // Ignores lines starting with '//' (Rust) or '#' (GDScript).
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Writes the total Rust LOC count to the fixed-name file for Godot's boot parser.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level from 'rust' to the project root for the output file.
    let root_dir = PathBuf::from("../"); 
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("ðŸ”¥ SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("âŒ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                       output_path, e);
        }
    }
}

// --- MAIN SCAN FUNCTION ---

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // UPDATED DIRECTORIES for the consolidated ssxl-ext structure (as per manifest).
    // Scans the main GDExtension library and the CLI tool itself.
    let rust_dirs = [
        "ssxl_ext/src", // Contains all core logic (host, generate, shared).
        "ssxl_cli/src", // Contains CLI tool logic (like this file).
    ];

    // --- SCAN RUST FILES ---
    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- SCAN GDSCRIPT FILES ---
    // Assuming the GDScript test directory remains the same relative path.
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- WRITE REPORTS ---
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("âŒ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n        {} LOC | *.rs (Rust Total)\n        {} LOC | *.gd (GDScript Total)\n        {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("âœ… Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("âŒ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // --- CRITICAL STEP FOR GODOT ---
    write_final_loc_total(total_rs_loc);

    // Final sleep to ensure writes/logs are flushed
    thread::sleep(Duration::from_millis(100));
}
// --- END: rust/ssxl_cli/src\ssxl_source_scan.rs ---
       228 LOC | rust/ssxl_cli/src\ssxl_testing.rs
// --- START: rust/ssxl_cli/src\ssxl_testing.rs ---
// ssxl_cli/src/ssxl_testing.rs
// ============================================================================
// ðŸ§ª SSXL-ext CLI Testing Harness - PURE RUST IMPLEMENTATION (v4)
// ============================================================================

use std::thread;
use std::time::Instant;

use rand::{thread_rng, Rng};
use tracing::{error, info, warn};

// Bring in core engine types and logic from ssxl_ext.
use ssxl_ext::shared_chunk::Chunk;
use ssxl_ext::shared_config::PerlinNoiseConfig;
use ssxl_ext::shared_tile::TileData;
use ssxl_ext::generate_perlin::{NoiseGenerator, generate_noise_map};
use ssxl_ext::tile_conversion::bitmask_to_id;

// --- Module-Level Constants ---
const CHUNK_SIZE: u32 = 64;
const GRID_SIZE: u32 = 2048;
const ITERATIONS: u32 = 50;
const MAX_TILE_ID: i32 = 47;

// --- Profiler Stub ---
struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    pub fn start(name: &'static str) -> Self {
        Profiler {
            start: Instant::now(),
            name,
            enabled: true,
        }
    }
}

impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms",
                self.name,
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}

// --- Helper: Create a standard Perlin config for tests ---
fn default_perlin_config() -> PerlinNoiseConfig {
    PerlinNoiseConfig {
        octaves: 4,
        lacunarity: 2.0,
        persistence: 0.5,
        scale: 64.0,
        threshold: 0.0,
    }
}

// --- Helper: Run noise generation for a chunk and return it ---
fn generate_chunk_at(chunk_x: i32, chunk_y: i32, size: u32, seed: u64) -> Chunk {
    let config = default_perlin_config();
    let generator = NoiseGenerator::new(config, seed);

    let position = (chunk_x, chunk_y);
    let chunk = Chunk::new(position, size);

    match generate_noise_map(chunk, &generator) {
        Ok(chunk) => chunk,
        Err(err) => {
            panic!(
                "Noise generation failed at chunk ({}, {}): {}",
                chunk_x, chunk_y, err
            );
        }
    }
}

// --- Helper: Compare the touching edges of two chunks ---
fn chunks_share_boundary(a: &Chunk, b: &Chunk, dir: (i32, i32)) -> bool {
    // dir = (1, 0) means b is to the right of a
    // dir = (0, 1) means b is below a

    let size = a.size;
    if a.size != b.size {
        error!(
            "Chunk size mismatch: a.size={} b.size={}",
            a.size, b.size
        );
        return false;
    }

    match dir {
        (1, 0) => {
            // Compare right edge of a with left edge of b
            for y in 0..size {
                let a_tile = a.get_tile(size - 1, y);
                let b_tile = b.get_tile(0, y);
                if !tiles_approx_equal(a_tile, b_tile) {
                    return false;
                }
            }
            true
        }
        (0, 1) => {
            // Compare bottom edge of a with top edge of b
            for x in 0..size {
                let a_tile = a.get_tile(x, size - 1);
                let b_tile = b.get_tile(x, 0);
                if !tiles_approx_equal(a_tile, b_tile) {
                    return false;
                }
            }
            true
        }
        _ => {
            warn!("Unsupported boundary direction: {:?}", dir);
            false
        }
    }
}

// --- Helper: Approximate tile equality for boundary tests ---
fn tiles_approx_equal(a: Option<&TileData>, b: Option<&TileData>) -> bool {
    match (a, b) {
        (Some(ta), Some(tb)) => {
            ta.tile_id == tb.tile_id &&
            ta.atlas_coords == tb.atlas_coords &&
            ta.rotation_flags == tb.rotation_flags
            // We intentionally ignore custom_data for boundary coherence.
        }
        (None, None) => true,
        _ => false,
    }
}

// ----------------------------------------------------------------------------
// I. Component Tests (Pure Rust)
// ----------------------------------------------------------------------------

/// 1. Concurrency Stress Test: Spawns many threads to hammer noise generation.
fn run_fast_test() {
    info!("Starting Fast Test (Concurrency Stress on Noise Generator)...");
    let _p = Profiler::start("FastTest_Concurrency");

    const NUM_THREADS: u32 = 500;
    const CHUNK_LOCAL_SIZE: u32 = 16;

    let handles = (0..NUM_THREADS)
        .map(|i| {
            thread::spawn(move || {
                let seed_base = i as u64;
                for j in 0..20u32 {
                    let seed = seed_base + j as u64;
                    let _chunk = generate_chunk_at(i as i32, j as i32, CHUNK_LOCAL_SIZE, seed);
                }
            })
        })
        .collect::<Vec<_>>();

    for handle in handles {
        handle.join().unwrap();
    }

    info!(
        "âœ… Fast Test Complete: {} threads exercised concurrent noise generation.",
        NUM_THREADS
    );
}

/// 2. Full Integration Test: Chunk generation + boundary checks.
fn run_full_test() {
    info!("Starting Full Integration Test (Chunk Boundary Coherence)...");
    let _p = Profiler::start("FullTest_Integration");

    let seed: u64 = thread_rng().gen();

    let c00 = generate_chunk_at(0, 0, CHUNK_SIZE, seed);
    let c10 = generate_chunk_at(1, 0, CHUNK_SIZE, seed);
    let c01 = generate_chunk_at(0, 1, CHUNK_SIZE, seed);
    let c11 = generate_chunk_at(1, 1, CHUNK_SIZE, seed);

    let mut failures = 0;

    // Right of c00
    if !chunks_share_boundary(&c00, &c10, (1, 0)) {
        error!("âŒ Boundary Fail: Chunk (0,0) and (1,0) mismatch.");
        failures += 1;
    }

    // Below c00
    if !chunks_share_boundary(&c00, &c01, (0, 1)) {
        error!("âŒ Boundary Fail: Chunk (0,0) and (0,1) mismatch.");
        failures += 1;
    }

    // Below c10
    if !chunks_share_boundary(&c10, &c11, (0, 1)) {
        error!("âŒ Boundary Fail: Chunk (1,0) and (1,1) mismatch.");
        failures += 1;
    }

    // Right of c01
    if !chunks_share_boundary(&c01, &c11, (1, 0)) {
        error!("âŒ Boundary Fail: Chunk (0,1) and (1,1) mismatch.");
        failures += 1;
    }

    if failures == 0 {
        info!("âœ… Full Test Passed: Boundary coherence verified across 4 chunks.");
    } else {
        panic!(
            "âŒ Full Test FAILED: {} boundary mismatches detected.",
            failures
        );
    }
}


/// 3. Max Grid Benchmark: Heavy compute load on a huge chunk.
fn run_max_grid_benchmark() {
    info!("Starting Max Grid Benchmark (Heavy Noise Compute Iterations)...");
    let _p = Profiler::start("MaxGrid_HeavyNoise");

    info!(
        "Generating {} x {} noise field {} times (single large chunk)...",
        GRID_SIZE, GRID_SIZE, ITERATIONS
    );

    for i in 0..ITERATIONS {
        let seed = thread_rng().gen();
        let _chunk = generate_chunk_at(0, i as i32, GRID_SIZE, seed);
    }

    info!(
        "âœ… Max Grid Benchmark Complete: {} heavy generation calls finished.",
        ITERATIONS
    );
}

/// 4. Bitmask Conversion Test: Exhaustive 256-case validation (pure Rust).
fn run_bitmask_conversion() {
    info!("Starting Bitmask Conversion Test (256/256 Exhaustive Coverage)...");
    let _p = Profiler::start("Bitmask_Exhaustive");

    let mut failures = 0;

    for bitmask in 0u8..=255 {
        let result_id = bitmask_to_id(bitmask);

        if result_id < 0 || result_id > MAX_TILE_ID {
            error!(
                "âŒ Bitmask Fail: Input {} resulted in invalid Tile ID {}.",
                bitmask, result_id
            );
            failures += 1;
        }

        if bitmask == 255 && result_id != 10 {
            warn!(
                "Bitmask 255 not mapping to expected 'Full' Tile ID (10). Got: {} (MOCK behavior).",
                result_id
            );
        }
    }

    if failures == 0 {
        info!("âœ… Bitmask Conversion Test Passed: 256/256 combinations verified (0 failures).");
    } else {
        panic!(
            "âŒ Bitmask Conversion Test FAILED: {} failures detected! (MAX_TILE_ID={})",
            failures, MAX_TILE_ID
        );
    }
}

// ----------------------------------------------------------------------------
// II. Grand Unified Test (G-action)
// ----------------------------------------------------------------------------

/// Chains together the most critical tests for a full smoke test.
pub fn run_grand_unified_test() {
    println!("\n==================================================");
    println!("=== SSXL-ext GRAND UNIFIED TEST (GUT) STARTING ===");
    println!("==================================================");

    run_bitmask_conversion();
    println!("--------------------------------------------------");

    run_max_grid_benchmark();
    println!("--------------------------------------------------");

    run_fast_test();
    println!("--------------------------------------------------");

    run_full_test();

    println!("\n==================================================");
    println!("=== SSXL-ext GRAND UNIFIED TEST (GUT) COMPLETE ===");
    println!("==================================================");
}

// --- END: rust/ssxl_cli/src\ssxl_testing.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("ðŸŒ™ Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("ðŸ§¿ Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("âš ï¸ No idle method found. Skipping ticker.")

func start_idle():
    print("ðŸª¶ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("âš¡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("ðŸ§º Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("ðŸŒ€ SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("âœ¨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("âš ï¸ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("âŒ Failed to instantiate SSXL script.")
        else:
            push_error("âŒ Invalid script resource at: %s" % script_path)
    else:
        push_error("âŒ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("ðŸ§¹ SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("ðŸ§º SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("ðŸŒ™ SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("ðŸ§¿ Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("âš ï¸ No idle method found. Skipping ticker.")

func start_idle():
    print("ðŸª¶ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("âš¡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("ðŸ§º SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## ðŸ§­ NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## âš™ï¸ CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## ðŸ”— LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("âŒ CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("âœ… Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## âŒ¨ï¸ INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## ðŸ–¼ï¸ CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## ðŸ“¡ PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("âš ï¸ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("âž¡ï¸ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("âž¡ï¸ Switched to Camera 2 (Map View).")
	else:
		push_warning("âš ï¸ Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED â†’ (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid â€” cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature â€” set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated â†’", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error â†’", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated â†’ (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete â†’", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine â†’ Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine â†’ SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle â†’ Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected â†’", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected â†’", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("âŒ FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "âŒ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("âš™ï¸ FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "ðŸ•’ " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # â† THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # â† Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # â† Chunk data holder

# Old reference â€” we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX â€” only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready â†’ CONNECTED (first time)")
		else:
			print("chunk_data_ready â†’ already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\nðŸŽ¶ Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("âŒ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("âŒ Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\nðŸ“œ Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd â€” FINAL VERSION (2025 SSXL FFI Sync) â€” RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle â†’ Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle â†’ Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine â†’ SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing â€” no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED â€” EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready â†’ tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready â†’ _on_chunk_data_ready CONNECTED â€” RENDERING ENABLED")
		else:
			print("chunk_data_ready â†’ already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd â€” Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("ðŸ“¢ SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("âŒ FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("ðŸ“¢ SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("âœ… SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("âœ… GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("âŒ GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("âœ… FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("âŒ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
        2816 LOC | *.rs (Rust Total)
        961 LOC | *.gd (GDScript Total)
        3777 LOC | TOTALS
