SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1765094517
Root Directories: rust, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       130 LOC | rust/ssxl_cache/src\lib.rs
// --- START: rust/ssxl_cache/src\lib.rs ---
// ============================================================================
// üóÑÔ∏è Chunk Cache System (`ssxl_cache`)
// ----------------------------------------------------------------------------
// This module implements a thread-safe, region-aware cache for chunk data in
// the SSXL engine. It combines an LRU (Least Recently Used) eviction policy
// with region indexing to balance performance, memory usage, and spatial
// organization.
//
// Key Concepts:
//   ‚Ä¢ ChunkCache:
//       - Stores chunks in an LRU cache, automatically evicting the least
//         recently used entries when capacity is exceeded.
//       - Provides methods to load, save, and remove chunks safely.
//       - Tracks cache metrics (hits, misses, evictions) for performance tuning.
//   ‚Ä¢ RegionIndex:
//       - Maps regions (groups of chunks) to sets of chunk keys.
//       - Regions are defined by dividing world coordinates by REGION_SIZE.
//       - Supports insertion and removal of chunk keys, automatically cleaning
//         up empty regions.
//   ‚Ä¢ CacheMetrics:
//       - Atomic counters for hits, misses, and evictions.
//       - Provides lightweight tracking of cache performance without locking.
//   ‚Ä¢ REGION_SIZE:
//       - Defines the granularity of regions (here, 64 units).
//       - Used to group chunks spatially for efficient lookup.
//
// Workflow:
//   1. Initialization (`ChunkCache::new`):
//      - Creates an LRU cache with a non-zero capacity.
//      - Initializes region index and metrics tracker.
//   2. Loading (`load_chunk`):
//      - Attempts to retrieve a chunk by key.
//      - Increments hit/miss counters accordingly.
//   3. Saving (`save_chunk`):
//      - Inserts a chunk into the cache and updates the region index.
//      - If capacity is exceeded, evicts the least recently used chunk.
//      - Tracks eviction metrics and cleans up region index.
//   4. Removal (`remove_chunk`):
//      - Manually removes a chunk and updates the region index.
//   5. Inspection (`len`, `capacity`):
//      - Provides current cache size and maximum capacity.
//
// Design Choices:
//   ‚Ä¢ `parking_lot::Mutex` and `RwLock` provide high-performance locking
//     primitives for concurrent access.
//   ‚Ä¢ `Arc` ensures safe shared ownership of chunks and metrics across threads.
//   ‚Ä¢ `AtomicResource` wraps the region index for ergonomic thread-safe access.
//   ‚Ä¢ `lru::LruCache` provides a proven eviction strategy for bounded memory.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a layered caching strategy:
//       - LRU eviction ensures memory bounds.
//       - Region indexing provides spatial organization.
//       - Metrics tracking enables runtime tuning.
//   ‚Ä¢ By combining these techniques, the engine achieves efficient chunk
//     management in large, procedurally generated worlds.
// ============================================================================


use ssxl_math::coordinate_system::ChunkKey;
use ssxl_shared::ChunkData;
use ssxl_sync::AtomicResource;

use std::collections::{HashMap, HashSet};
use std::sync::{
    Arc,
    atomic::{AtomicUsize, Ordering}
};
use std::io;
use std::num::NonZeroUsize;

use parking_lot::{Mutex, RwLock};
use tracing::info;
use glam::I64Vec3;
use lru::LruCache;

const REGION_SIZE: i64 = 64;
type RegionKey = ChunkKey;
type RegionList = RwLock<HashSet<ChunkKey>>;

#[derive(Debug, Default)]
pub struct CacheMetrics {
    pub hits: AtomicUsize,
    pub misses: AtomicUsize,
    pub evictions: AtomicUsize,
}

impl CacheMetrics {
    #[inline(always)]
    pub fn hit(&self) { self.hits.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn miss(&self) { self.misses.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn evict(&self) { self.evictions.fetch_add(1, Ordering::Relaxed); }
}

#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<HashMap<RegionKey, Arc<RegionList>>>,
}

impl RegionIndex {
    pub fn new() -> Self {
        Self {
            storage: AtomicResource::new(HashMap::new()),
        }
    }

    #[inline(always)]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let p = chunk_key.0;
        let rx = p.x / REGION_SIZE;
        let ry = p.y / REGION_SIZE;
        let rz = p.z / REGION_SIZE;
        ChunkKey(I64Vec3::new(rx, ry, rz))
    }

    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = {
            let mut map = self.storage.write();
            map.entry(region_key)
                .or_insert_with(|| Arc::new(RwLock::new(HashSet::new())))
                .clone()
        };
        let mut list = list_arc.write();
        list.insert(chunk_key);
    }

    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = self.storage.read().get(&region_key).cloned();

        if let Some(list_arc) = list_arc {
            let mut list = list_arc.write();
            if list.remove(&chunk_key) {
                if list.is_empty() {
                    drop(list);
                    self.storage.write().remove(&region_key);
                    info!("Removed empty region from index: {:?}", region_key);
                }
                return true;
            }
        }
        false
    }
}

#[derive(Debug)]
pub struct ChunkCache {
    storage: Mutex<LruCache<ChunkKey, Arc<ChunkData>>>,
    region_index: RegionIndex,
    capacity: NonZeroUsize,
    pub metrics: Arc<CacheMetrics>,
}

impl ChunkCache {
    pub fn new(max_chunks: usize) -> io::Result<Self> {
        let capacity = NonZeroUsize::new(max_chunks.max(1))
            .unwrap_or(NonZeroUsize::new(1024).unwrap());
        
        info!("ChunkCache initialized with LRU eviction (capacity: {})", capacity);

        Ok(Self {
            storage: Mutex::new(LruCache::new(capacity)),
            region_index: RegionIndex::new(),
            capacity,
            metrics: Arc::new(CacheMetrics::default()),
        })
    }

    pub fn load_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let mut guard = self.storage.lock();
        let result = guard.get(key).map(Arc::clone);
        
        if result.is_some() {
            self.metrics.hit();
        } else {
            self.metrics.miss();
        }

        result
    }

    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> io::Result<()> {
        let key = *key;
        let mut guard = self.storage.lock();

        self.region_index.insert_key(key);

        let _old_data = guard.put(key, data);
        
        if let Some((evicted_key, _)) = guard.pop_lru() {
            self.metrics.evict();
            self.region_index.remove_key(evicted_key);
            info!(
                "LRU evicted chunk: {:?} (cache size: {})",
                evicted_key,
                guard.len()
            );
        }

        Ok(())
    }

    pub fn remove_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let removed = self.storage.lock().pop(key);
        if removed.is_some() {
            self.region_index.remove_key(*key);
            info!("Manually removed chunk from cache: {:?}", key);
        }
        removed
    }

    pub fn len(&self) -> usize {
        self.storage.lock().len()
    }

    pub fn capacity(&self) -> usize {
        self.capacity.get()
    }
}

// --- END: rust/ssxl_cache/src\lib.rs ---
       139 LOC | rust/ssxl_engine_ffi/src\lib.rs
// --- START: rust/ssxl_engine_ffi/src\lib.rs ---
// ============================================================================
// üéÆ SSXL Engine Godot Extension (`ssxl_godot::engine`)
// ----------------------------------------------------------------------------
// This module defines the `SSXLEngine` Godot node, which acts as the bridge
// between the Rust-based SSXL engine and the Godot game engine via GDExtension.
//
// Purpose:
//   ‚Ä¢ Provide a Godot-facing node that orchestrates procedural generation tasks.
//   ‚Ä¢ Manage communication channels between Rust async tasks and Godot runtime.
//   ‚Ä¢ Render generated chunks into a Godot `TileMap`.
//   ‚Ä¢ Expose methods and signals for Godot scripts to interact with the engine.
//
// Key Components:
//   ‚Ä¢ Feature Flag
//       - `#![feature(int_roundings)]` enables nightly integer division helpers
//         like `div_ceil`, used for chunk calculations.
//
//   ‚Ä¢ Imports
//       - Godot prelude, Node, TileMap, INode trait for GDExtension integration.
//       - Tokio channels for async task communication.
//       - `tracing` for structured logging.
//       - SSXL subsystems: `Conductor`, `ConductorState`, `GenerationTask`,
//         `GenerationMessage`, math utilities, and shared constants.
//
//   ‚Ä¢ create_dummy_engine_state
//       - Provides a fallback engine state if the Conductor fails to start.
//       - Ensures the node remains valid even without generation capability.
//
//   ‚Ä¢ SSXLEngine Struct
//       - Annotated with `#[derive(GodotClass)]` to register as a Godot node.
//       - Fields:
//           ‚Ä¢ base: underlying Godot Node.
//           ‚Ä¢ conductor: orchestrates generation tasks.
//           ‚Ä¢ request_sender: channel for sending tasks.
//           ‚Ä¢ progress_rx: channel for receiving updates.
//           ‚Ä¢ tilemap: optional Godot TileMap reference.
//           ‚Ä¢ state: conductor state tracking activity.
//
//   ‚Ä¢ INode Implementation
//       - `init`: initializes shared data, starts conductor, or falls back.
//       - `process`: runs every frame, consumes progress messages, applies
//         generated chunks to the TileMap, and emits signals.
//       - `exit_tree`: gracefully shuts down conductor when node is removed.
//
//   ‚Ä¢ Public Methods
//       - `set_tilemap`: assigns a Godot TileMap for rendering.
//       - `build_map`: schedules generation tasks for a given width/height,
//         dividing into chunks using `div_ceil`.
//       - `is_active`: checks conductor activity state.
//       - `chunk_applied`: signal emitted when a chunk is rendered.
//
//   ‚Ä¢ Extension Entry Point
//       - `SSXLExtension` struct implements `ExtensionLibrary` to register
//         the engine node with Godot.
//
// Workflow:
//   1. Godot instantiates `SSXLEngine` as a node.
//   2. Rust initializes conductor and shared resources.
//   3. Godot requests map generation via `build_map`.
//   4. Rust sends tasks, processes updates, and applies chunks to TileMap.
//   5. Signals notify Godot scripts when chunks are applied.
//   6. Node shuts down gracefully when removed.
//
// Design Choices:
//   ‚Ä¢ Async channels decouple generation tasks from rendering loop.
//   ‚Ä¢ Arc ensures safe sharing of chunk data across threads.
//   ‚Ä¢ Signals provide a clean Godot-side API for reacting to generation events.
//   ‚Ä¢ Fallback dummy state prevents crashes if conductor initialization fails.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can extend Godot with high-performance
//     procedural generation, while maintaining safe concurrency and ergonomic
//     scripting interfaces.
//   ‚Ä¢ By combining async task orchestration with Godot signals, developers gain
//     a powerful workflow for integrating complex systems into game engines.
// ============================================================================


#![feature(int_roundings)]

use godot::{
    prelude::*,
    classes::{Node, TileMap, INode},
    obj::{Base, Gd},
};

use std::sync::Arc;
use tokio::sync::mpsc::{
    channel,
    Receiver,
    UnboundedSender,
    unbounded_channel,
    error::TryRecvError
};
use tracing::{info, error, Level, span};

use ssxl_generate::Conductor;
use ssxl_generate::conductor::ConductorState;
use ssxl_generate::task::task_queue::{GenerationMessage, GenerationTask};

use ssxl_math::prelude::Vec2i;
use ssxl_shared::{initialize_shared_data, CHUNK_SIZE};

fn create_dummy_engine_state(base: Base<Node>) -> SSXLEngine {
    let (dummy_tx, _) = unbounded_channel();
    let (_, dummy_rx) = channel(1);

    SSXLEngine {
        base,
        conductor: None,
        state: ConductorState::new(String::new()),
        request_sender: dummy_tx,
        progress_rx: dummy_rx,
        tilemap: None,
    }
}

#[derive(GodotClass)]
#[class(base = Node)]
pub struct SSXLEngine {
    base: Base<Node>,
    conductor: Option<Conductor>,
    request_sender: UnboundedSender<GenerationTask>,
    progress_rx: Receiver<GenerationMessage>,
    tilemap: Option<Gd<TileMap>>,
    state: ConductorState,
}

#[godot_api]
impl INode for SSXLEngine {
    fn init(base: Base<Node>) -> Self {
        let _span = span!(Level::INFO, "SSXLEngine::init").entered();

        initialize_shared_data();

        match Conductor::new(None) {
            Ok((conductor, state, request_sender, progress_rx)) => {
                info!("SSXLEngine ‚Üí Conductor ONLINE");
                Self {
                    base,
                    conductor: Some(conductor),
                    state,
                    request_sender,
                    progress_rx,
                    tilemap: None,
                }
            }
            Err(e) => {
                error!("Failed to start Conductor: {:?}", e);
                create_dummy_engine_state(base)
            }
        }
    }

    fn process(&mut self, _delta: f64) {
        loop {
            let message = match self.progress_rx.try_recv() {
                Ok(msg) => msg,
                Err(TryRecvError::Empty) => break,
                Err(e) => {
                    error!("Progress channel error: {:?}", e);
                    break;
                }
            };

            match message {
                GenerationMessage::Generated(key, chunk_data) => {
                    let Some(tilemap) = self.tilemap.as_mut() else { continue; };

                    let origin_x = (key.x as i32) * CHUNK_SIZE as i32;
                    let origin_y = (key.y as i32) * CHUNK_SIZE as i32;
                    let layer = 0;

                    let tiles = Arc::try_unwrap(chunk_data)
                        .unwrap_or_else(|arc| (*arc).clone())
                        .tiles;

                    for (idx, _tile) in tiles.iter().enumerate() {
                        let local_x = (idx as u32 % CHUNK_SIZE) as i32;
                        let local_y = (idx as u32 / CHUNK_SIZE) as i32;

                        let world_x = origin_x + local_x;
                        let world_y = origin_y + local_y;

                        tilemap.set_cell(
                            layer,
                            Vector2i::new(world_x, world_y),
                        );
                    }

                    self.base_mut().emit_signal(
                        "chunk_applied",
                        &[key.x.to_variant(), key.y.to_variant()],
                    );
                }

                GenerationMessage::GenerationComplete => {
                    info!("Generation Task Queue signaled completion.");
                }

                GenerationMessage::StatusUpdate(status) => {
                    info!("Generation status update: {}", status);
                }
            }
        }
    }

    fn exit_tree(&mut self) {
        if let Some(conductor) = self.conductor.take() {
            conductor.signal_shutdown_graceful();
        }
    }
}

#[godot_api]
impl SSXLEngine {
    #[func]
    pub fn set_tilemap(&mut self, tilemap: Gd<TileMap>) {
        self.tilemap = Some(tilemap);
    }

    #[func]
    pub fn build_map(&self, width: i32, height: i32, generator_id: GString) {
        if self.request_sender.is_closed() {
            error!("Conductor is shut down. Cannot request map.");
            return;
        }

        let chunks_x = width.div_ceil(CHUNK_SIZE as i32);
        let chunks_y = height.div_ceil(CHUNK_SIZE as i32);

        for x in 0..chunks_x {
            for y in 0..chunks_y {
                let task = GenerationTask {
                    chunk_coords: Vec2i::new(x as i64, y as i64),
                    generator_id: generator_id.to_string(),
                };
                let _ = self.request_sender.send(task);
            }
        }

        info!("Sent {} generation tasks.", chunks_x * chunks_y);
    }

    #[func]
    pub fn is_active(&self) -> bool {
        self.state.is_active()
    }

    #[signal]
    fn chunk_applied(key_x: i64, key_y: i64);
}

struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {}

// --- END: rust/ssxl_engine_ffi/src\lib.rs ---
       123 LOC | rust/ssxl_generate/src\ca\cellular_automata_generator.rs
// --- START: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
// ============================================================================
// üß© SSXL Cellular Automata Generator (`ssxl_generate::ca_generator`)
// ----------------------------------------------------------------------------
// This module implements a procedural generation algorithm based on Cellular
// Automata (CA). It is responsible for producing chunk data (tile grids) that
// simulate cave-like, maze-like, or static patterns depending on the ruleset.
//
// Purpose:
//   ‚Ä¢ Provide a flexible generator that can evolve tile states using CA rules.
//   ‚Ä¢ Support both iterative simulations and static pattern generation.
//   ‚Ä¢ Ensure deterministic results by seeding a PRNG with chunk coordinates.
//
// Key Components:
//   ‚Ä¢ Constants
//       - CA_ITERATIONS: number of iterations to stabilize the CA pattern.
//       - INITIAL_FILL_PERCENT: percentage of tiles initially seeded as Rock.
//
//   ‚Ä¢ CellularAutomataGenerator
//       - Struct holding a numeric ruleset ID.
//       - Provides `new` constructor for initialization.
//       - Implements the `Generator` trait for integration with the engine.
//
//   ‚Ä¢ generate_static_pattern
//       - Produces non-iterative static patterns (Solid fill, Checkerboard).
//       - Bypasses CA simulation for efficiency.
//       - Builds chunk data directly from ruleset logic.
//
//   ‚Ä¢ run_ca_simulation
//       - Executes iterative CA simulation using double-buffering.
//       - For each tile, counts live neighbors and applies ruleset logic.
//       - Swaps buffers after each iteration to evolve the state.
//       - Logs progress after each iteration.
//
//   ‚Ä¢ Generator Trait Implementation
//       - `id`: returns a string identifier for the generator based on ruleset.
//       - `generate_chunk`: orchestrates chunk generation workflow:
//           1. Logs start of generation.
//           2. Handles static rulesets directly.
//           3. Seeds PRNG deterministically from chunk coordinates.
//           4. Builds initial randomized tile state.
//           5. Runs CA simulation to evolve state.
//           6. Returns final chunk data.
//
// Workflow:
//   1. A chunk coordinate is passed to `generate_chunk`.
//   2. If ruleset is static, generate a direct pattern.
//   3. Otherwise, seed PRNG and build randomized initial state.
//   4. Run CA iterations to evolve tile states.
//   5. Return final `ChunkData` for rendering or further processing.
//
// Design Choices:
//   ‚Ä¢ Deterministic seeding ensures reproducible worlds across runs.
//   ‚Ä¢ Double-buffering avoids in-place mutation errors during CA iteration.
//   ‚Ä¢ Static patterns allow efficient bypass for simple rulesets.
//   ‚Ä¢ Logging (`tracing`) provides visibility into generation steps.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata are widely used in procedural generation for caves,
//     dungeons, and organic structures.
//   ‚Ä¢ This implementation demonstrates how Rust can combine deterministic PRNG,
//     efficient memory handling, and modular design to produce complex,
//     reproducible terrain patterns.
// ============================================================================


use crate::Generator;
use ssxl_math::prelude::Vec2i;
use fastrand;
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

const CA_ITERATIONS: u8 = 4;
const INITIAL_FILL_PERCENT: u8 = 45;

pub struct CellularAutomataGenerator {
    ruleset: u8,
}

impl CellularAutomataGenerator {
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;

    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;

    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );

    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };

    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    if (x + y) % 2 == 0 { TileType::Rock } else { TileType::Void }
                }
                _ => TileType::Void,
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    let mut target_tiles = chunk_data.tiles.clone();

    for i in 0..CA_ITERATIONS {
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;

                let current_tile = &chunk_data.tiles[index];

                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }

        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        info!("CA Generator: Iteration {} complete.", i + 1);
    }

    chunk_data
}

impl Generator for CellularAutomataGenerator {
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);

        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;
            let tile_type = if is_rock { TileType::Rock } else { TileType::Void };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles_vec);

        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}

// --- END: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
         3 LOC | rust/ssxl_generate/src\ca\mod.rs
// --- START: rust/ssxl_generate/src\ca\mod.rs ---
// ============================================================================
// üß© Cellular Automata Module (`crate::ca`)
// ----------------------------------------------------------------------------
// This module serves as the entry point for the Cellular Automata (CA) system
// within the SSXL engine. It organizes and exposes submodules that implement
// different aspects of CA-based procedural generation.
//
// Purpose:
//   ‚Ä¢ Provide a modular, extensible framework for CA-driven terrain and structure generation.
//   ‚Ä¢ Separate concerns into distinct submodules for clarity and maintainability.
//   ‚Ä¢ Expose a clean public API surface so other parts of the engine can access
//     CA functionality via `crate::ca::<submodule>`.
//
// Submodules:
//   ‚Ä¢ cellular_automata_generator
//       - Contains the `CellularAutomataGenerator` struct.
//       - Implements the `Generator` trait for CA-based chunk generation.
//       - Responsible for seeding chunks, running CA iterations, and producing
//         final `ChunkData`.
//
//   ‚Ä¢ rule_set
//       - Defines specific CA rulesets (e.g., Solid fill, Checkerboard, Basic Cave, Maze).
//       - Encapsulates logic for determining the next tile type based on current
//         state and neighbor counts.
//       - Enables experimentation and swapping of rule sets without changing
//         generator logic.
//
//   ‚Ä¢ neighbor_check
//       - Provides low-level functions for inspecting tile neighbors.
//       - Example: `count_live_neighbors` counts adjacent Rock tiles.
//       - Supplies local state information to the `rule_set` logic.
//       - Keeps neighborhood definitions modular (e.g., Moore vs. Von Neumann).
//
// Workflow:
//   1. The generator seeds a chunk with initial tile states.
//   2. Neighbor checks provide local context for each tile.
//   3. Rule sets apply CA logic to evolve tile states.
//   4. The generator produces final chunk data for rendering or simulation.
//
// Design Choices:
//   ‚Ä¢ Modular submodules improve readability and allow independent evolution.
//   ‚Ä¢ Clear separation of generator, rules, and neighbor logic supports reuse
//     and experimentation.
//   ‚Ä¢ Public module declarations (`pub mod`) ensure external access to CA
//     components while maintaining internal organization.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata are a powerful tool for procedural generation,
//     producing organic, cave-like, or maze-like structures.
//   ‚Ä¢ This module demonstrates how Rust‚Äôs module system can be leveraged to
//     build a clean, extensible architecture for complex algorithms.
// ============================================================================


pub mod cellular_automata_generator;
pub mod rule_set;
pub mod neighbor_check;

// --- END: rust/ssxl_generate/src\ca\mod.rs ---
        25 LOC | rust/ssxl_generate/src\ca\neighbor_check.rs
// --- START: rust/ssxl_generate/src\ca\neighbor_check.rs ---
// ============================================================================
// üß© Cellular Automata Utility: Neighbor Check (`count_live_neighbors`)
// ----------------------------------------------------------------------------
// This module provides a helper function for the Cellular Automata (CA)
// subsystem of the SSXL engine. It inspects the local neighborhood of a tile
// within a chunk and counts how many surrounding tiles are "live" (defined as
// `TileType::Rock`). This information is critical for applying CA rulesets
// that evolve terrain patterns.
//
// Purpose:
//   ‚Ä¢ Support CA simulation by providing local neighbor counts.
//   ‚Ä¢ Implement a 3x3 Moore neighborhood (8 surrounding cells).
//   ‚Ä¢ Handle boundary conditions safely to avoid out-of-bounds indexing.
//
// Function: count_live_neighbors
//   ‚Ä¢ Arguments:
//       - `chunk_data`: reference to the chunk‚Äôs tile data.
//       - `cx`: X coordinate of the center cell (0..CHUNK_SIZE-1).
//       - `cy`: Y coordinate of the center cell (0..CHUNK_SIZE-1).
//   ‚Ä¢ Returns:
//       - `u8` count of live neighbors (0‚Äì8).
//
// Workflow:
//   1. Convert center coordinates to signed integers for arithmetic.
//   2. Iterate over relative offsets (dx, dy) in the range -1..=1.
//   3. Skip the center cell itself.
//   4. Compute neighbor coordinates and check boundaries.
//   5. If inside bounds, compute linear index into the tile array.
//   6. Increment count if neighbor tile is `TileType::Rock`.
//   7. Return total count.
//
// Design Choices:
//   ‚Ä¢ Uses signed arithmetic (`i32`) for safe offset calculations.
//   ‚Ä¢ Boundary checks prevent invalid indexing at chunk edges.
//   ‚Ä¢ Linear indexing formula (`y * CHUNK_SIZE + x`) ensures efficient lookup.
//   ‚Ä¢ Returns `u8` since maximum neighbor count is 8.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how to implement neighborhood checks in
//     Cellular Automata systems.
//   ‚Ä¢ By separating neighbor counting from rule application, the design remains
//     modular and extensible (e.g., supporting different neighborhood types).
// ============================================================================


use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;

    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    for dx in -1..=1 {
        for dy in -1..=1 {
            if dx == 0 && dy == 0 {
                continue;
            }

            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;

                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }

    count
}

// --- END: rust/ssxl_generate/src\ca\neighbor_check.rs ---
        28 LOC | rust/ssxl_generate/src\ca\rule_set.rs
// --- START: rust/ssxl_generate/src\ca\rule_set.rs ---
// ============================================================================
// üß© Cellular Automata Rule Set (`crate::ca::rule_set`)
// ----------------------------------------------------------------------------
// This module defines the rulesets and transition logic for the Cellular
// Automata (CA) subsystem of the SSXL engine. It determines how tiles evolve
// from one generation to the next based on their current state and the number
// of live neighbors.
//
// Purpose:
//   ‚Ä¢ Provide reusable constants for identifying different CA rulesets.
//   ‚Ä¢ Implement the core transition function (`get_next_tile_type`) that applies
//     Birth/Survival rules to evolve tile states.
//   ‚Ä¢ Support multiple terrain generation styles (caves, mazes, static fills).
//
// Rule Set Identifiers:
//   ‚Ä¢ RULE_BASIC_CAVE (0)
//       - Birth: 4‚Äì5 neighbors
//       - Survival: 1‚Äì7 neighbors
//       - Produces large, open cave-like structures.
//   ‚Ä¢ RULE_MAZE (1)
//       - Birth: exactly 3 neighbors
//       - Survival: 1‚Äì4 neighbors
//       - Produces thin, winding maze-like corridors.
//   ‚Ä¢ RULE_SOLID (2)
//       - Static rule: fills all tiles with Rock.
//   ‚Ä¢ RULE_CHECKERBOARD (3)
//       - Static rule: alternates Rock/Void in a checkerboard pattern.
//
// Function: get_next_tile_type
//   ‚Ä¢ Arguments:
//       - current_type: current tile state (`TileType`).
//       - live_neighbors: number of Rock neighbors (0‚Äì8).
//       - ruleset: identifier for which ruleset to apply.
//   ‚Ä¢ Returns:
//       - Next tile state (`TileType`).
//
// Workflow:
//   1. Select Birth/Survival ranges based on ruleset.
//   2. If tile is Rock (alive):
//        - Survives if neighbor count is within survival range.
//        - Otherwise becomes Void.
//   3. If tile is Void (dead):
//        - Becomes Rock if neighbor count is within birth range.
//        - Otherwise remains Void.
//   4. Other tile types (e.g., Water, Ore) remain unchanged.
//
// Design Choices:
//   ‚Ä¢ Encapsulates ruleset logic in a single function for clarity.
//   ‚Ä¢ Uses pattern matching to separate Rock/Void cases.
//   ‚Ä¢ Birth/Survival ranges are defined per ruleset for flexibility.
//   ‚Ä¢ Supports extensibility: new rulesets can be added easily.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata rulesets are often expressed in "B/S notation"
//     (e.g., B3/S1-4 for Maze, B4-5/S1-7 for Cave).
//   ‚Ä¢ This function demonstrates how to translate those rules into Rust logic,
//     enabling reproducible terrain generation across chunks.
// ============================================================================


use ssxl_shared::TileType;

pub const RULE_BASIC_CAVE: u8 = 0;
pub const RULE_MAZE: u8 = 1;
pub const RULE_SOLID: u8 = 2;
pub const RULE_CHECKERBOARD: u8 = 3;

pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7),
    };

    match current_type {
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        _ => current_type,
    }
}

// --- END: rust/ssxl_generate/src\ca\rule_set.rs ---
        76 LOC | rust/ssxl_generate/src\conductor\builder.rs
// --- START: rust/ssxl_generate/src\conductor\builder.rs ---
// ============================================================================
// üéº Conductor Setup and Spawn (`crate::conductor::setup`)
// ----------------------------------------------------------------------------
// This module provides the initialization and spawning logic for the SSXL
// Conductor, the central orchestrator of procedural generation tasks. It
// prepares channels, managers, and state, then launches the asynchronous
// request loop that drives chunk generation.
//
// Purpose:
//   ‚Ä¢ Bundle together configuration, managers, channels, and initial state.
//   ‚Ä¢ Provide a clean entry point for starting the Conductor runtime.
//   ‚Ä¢ Ensure safe, modular setup of async communication and caching systems.
//
// Key Components:
//   ‚Ä¢ PROGRESS_CHANNEL_BOUND
//       - Defines bounded capacity for the progress channel.
//       - Prevents unbounded queuing of progress messages, applying backpressure.
//
//   ‚Ä¢ setup_channels_and_state
//       - Loads configuration from a file path (or defaults).
//       - Initializes the GeneratorManager, which tracks available generators.
//       - Creates bounded progress channel for updates and unbounded request
//         channel for chunk generation tasks.
//       - Determines initial generator ID from config.
//       - Creates initial ConductorState with that ID.
//       - Returns a `ConductorInternalSetup` bundle containing all components.
//
//   ‚Ä¢ spawn
//       - Consumes `ConductorInternalSetup` and spawns the async request loop.
//       - Initializes a RuntimeManager (Tokio runtime wrapper).
//       - Clones generator map and creates a chunk cache (LRU, capacity 4096).
//       - Marks conductor state as running.
//       - Starts the async request loop with runtime handle, channels, generators,
//         cache, and state.
//       - Constructs a `Conductor` instance with runtime, managers, state, cache,
//         and channels.
//       - Returns tuple: (Conductor, ConductorState, request sender, progress receiver).
//
// Workflow:
//   1. `setup_channels_and_state` prepares configuration, managers, channels, and state.
//   2. `spawn` consumes setup bundle and starts async request loop.
//   3. Conductor instance is returned, ready to manage generation tasks.
//   4. Progress updates flow through bounded channel; requests flow through unbounded channel.
//   5. Chunk cache ensures efficient reuse of generated chunks.
//
// Design Choices:
//   ‚Ä¢ Separation of setup and spawn improves modularity and testability.
//   ‚Ä¢ Bounded progress channel prevents overload; unbounded request channel ensures flexibility.
//   ‚Ä¢ Arc-based sharing allows safe concurrent access to generators, cache, and state.
//   ‚Ä¢ Logging provides visibility into initialization and runtime events.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to structure async orchestration in Rust,
//     combining configuration, state management, channels, and runtime spawning.
//   ‚Ä¢ By encapsulating setup and spawn logic, the Conductor remains extensible
//     and maintainable, supporting complex procedural generation workflows.
// ============================================================================


use super::{conductor_state, Conductor};
use super::internal_setup::ConductorInternalSetup; 

use crate::manager::{GeneratorManager, RuntimeManager};
use crate::task::{start_request_loop, GenerationMessage, GenerationTask as ChunkRequest};
use ssxl_cache::ChunkCache;
use ssxl_shared::config::config::get_config_from_path;
use tokio::sync::mpsc::{self, Receiver, UnboundedSender};
use tracing::info;
use std::io;
use std::sync::Arc;

const PROGRESS_CHANNEL_BOUND: usize = 1024;

pub(crate) fn setup_channels_and_state(
    config_path: Option<&str>,
) -> Result<ConductorInternalSetup, io::Error> {
    let config = get_config_from_path(config_path);

    let generator_manager = GeneratorManager::new().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
    })?;

    let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
    let (request_sender_api, request_receiver) = mpsc::unbounded_channel();

    let initial_id = generator_manager.get_initial_id(&config.default_generator_id());
    let initial_state = conductor_state::ConductorState::new(initial_id.clone());

    info!("Conductor initialized. Active generator: {}", initial_id);

    Ok(ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    })
}

pub(crate) fn spawn(
    internal_setup: ConductorInternalSetup,
) -> Result<
    (
        Conductor,
        conductor_state::ConductorState,
        UnboundedSender<ChunkRequest>,
        Receiver<GenerationMessage>,
    ),
    io::Error,
> {
    let ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    } = internal_setup;

    let runtime_manager = RuntimeManager::new()?;
    let handle = runtime_manager.get_handle();

    let generators_for_loop = Arc::new(generator_manager.get_map_clone());
    let chunk_cache = Arc::new(ChunkCache::new(4096)?);
    let chunk_cache_for_loop = chunk_cache.clone();

    initial_state.set_status(conductor_state::ConductorStatus::Running);
    let state_for_loop = initial_state.clone();

    start_request_loop(
        handle,
        request_receiver,
        progress_sender.clone(),
        generators_for_loop,
        chunk_cache_for_loop,
        Arc::new(state_for_loop),
    );

    let conductor = Conductor {
        runtime_manager,
        generator_manager,
        internal_state: initial_state.clone(),
        chunk_cache,
        progress_sender,
        _request_sender: request_sender_api.clone(),
    };

    Ok((conductor, initial_state, request_sender_api, progress_receiver))
}

// --- END: rust/ssxl_generate/src\conductor\builder.rs ---
        79 LOC | rust/ssxl_generate/src\conductor\conductor.rs
// --- START: rust/ssxl_generate/src\conductor\conductor.rs ---
// ============================================================================
// üéº Conductor Module (`crate::conductor`)
// ----------------------------------------------------------------------------
// The Conductor is the central orchestrator of the SSXL engine‚Äôs procedural
// generation system. It manages runtime execution, generator selection,
// communication channels, and caching of generated chunks.
//
// Purpose:
//   ‚Ä¢ Provide a unified interface for starting, controlling, and shutting down
//     the generation system.
//   ‚Ä¢ Manage async communication between generation tasks and the engine.
//   ‚Ä¢ Track conductor state (active generator, lifecycle status).
//   ‚Ä¢ Expose constructors for both internal use and FFI integration.
//
// Key Components:
//   ‚Ä¢ Conductor Struct
//       - Holds references to:
//           ‚Ä¢ RuntimeManager: manages the async runtime.
//           ‚Ä¢ GeneratorManager: manages available generator instances.
//           ‚Ä¢ ConductorState: tracks active generator and lifecycle status.
//           ‚Ä¢ ChunkCache: shared cache for generated chunks.
//           ‚Ä¢ progress_sender: channel for sending progress updates.
//           ‚Ä¢ _request_sender: channel for sending chunk generation requests.
//
//   ‚Ä¢ Constructors
//       - `new`
//           ‚Ä¢ Initializes conductor with channels and state.
//           ‚Ä¢ Returns tuple: (Conductor, ConductorState, request sender, progress receiver).
//       - `new_for_ffi`
//           ‚Ä¢ Specialized for external bindings (FFI).
//           ‚Ä¢ Returns tuple: (Conductor, ConductorState, command sender, response receiver, progress receiver).
//
//   ‚Ä¢ Control Methods
//       - `get_active_generator_id`: returns ID of currently active generator.
//       - `set_generator`: switches active generator and logs the change.
//       - `stop_generation`: signals conductor to stop generation tasks.
//       - `graceful_teardown`: consumes conductor, shuts down runtime gracefully.
//       - `signal_shutdown_graceful`: signals shutdown without consuming conductor.
//       - `request_shutdown`: signals shutdown and stops runtime.
//
// Workflow:
//   1. Conductor is created via `new` or `new_for_ffi`.
//   2. Async request loop is spawned, handling chunk generation tasks.
//   3. Progress updates flow through bounded channels; requests flow through unbounded channels.
//   4. Conductor methods allow switching generators, stopping tasks, or shutting down gracefully.
//
// Design Choices:
//   ‚Ä¢ Separation of constructors for internal vs. FFI use improves flexibility.
//   ‚Ä¢ Arc-based cache ensures safe concurrent access to generated chunks.
//   ‚Ä¢ Logging provides visibility into generator changes and lifecycle events.
//   ‚Ä¢ Explicit shutdown methods prevent resource leaks and ensure graceful teardown.
//
// Educational Note:
//   ‚Ä¢ The Conductor demonstrates how to structure a central orchestrator in Rust,
//     combining async runtime management, modular generators, and safe concurrency.
//   ‚Ä¢ By exposing clear constructors and lifecycle controls, it provides a robust
//     foundation for procedural generation workflows in game engines or simulations.
// ============================================================================


use crate::conductor::builder::{setup_channels_and_state, spawn};

use ssxl_cache::ChunkCache;
use ssxl_shared::message::{GenerationCommand, GenerationResponse};

use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver};

use tracing::info;
use std::error::Error;
use std::io;
use std::sync::Arc;

use crate::manager::runtime_manager::RuntimeManager;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};

use crate::conductor::conductor_state::{self, ConductorState};

pub struct Conductor {
    pub(crate) runtime_manager: RuntimeManager,
    pub(crate) generator_manager: GeneratorManager,
    pub(crate) internal_state: conductor_state::ConductorState,
    pub(crate) chunk_cache: Arc<ChunkCache>,
    pub progress_sender: tokio::sync::mpsc::Sender<GenerationMessage>,
    #[allow(dead_code)]
    pub(crate) _request_sender: UnboundedSender<ChunkRequest>,
}

impl Conductor {
    pub fn new(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<ChunkRequest>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        spawn(setup)
    }

    pub fn new_for_ffi(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<GenerationCommand>,
            UnboundedReceiver<GenerationResponse>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        let (conductor, state, _req_tx, progress_rx) = spawn(setup)?;
        let (cmd_tx, _) = tokio::sync::mpsc::unbounded_channel();
        let (_, resp_rx) = tokio::sync::mpsc::unbounded_channel();
        Ok((conductor, state, cmd_tx, resp_rx, progress_rx))
    }

    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    pub fn set_generator(&mut self, id: &str) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_active_generator_id(id);
        info!("Active generator switched to: {}", id);
        Ok(())
    }

    pub fn stop_generation(&self) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Global stop requested.");
        Ok(())
    }

    pub fn graceful_teardown(self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
        self.runtime_manager.shutdown_graceful();
        info!("Conductor gracefully shut down.");
    }

    pub fn signal_shutdown_graceful(&self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor.rs ---
        58 LOC | rust/ssxl_generate/src\conductor\conductor_state.rs
// --- START: rust/ssxl_generate/src\conductor\conductor_state.rs ---
// ============================================================================
// üéº Conductor State Management (`crate::conductor::conductor_state`)
// ----------------------------------------------------------------------------
// This module defines the lifecycle state and shared state container for the
// Conductor, the central orchestrator of SSXL‚Äôs procedural generation system.
// It provides thread-safe, atomic access to conductor status, queue depth,
// active generator ID, and tile counters.
//
// Purpose:
//   ‚Ä¢ Represent the lifecycle phases of the Conductor (initializing, running,
//     generating, stopping, shutting down, error).
//   ‚Ä¢ Maintain shared state across async tasks and threads safely.
//   ‚Ä¢ Provide atomic counters and resources for concurrent mutation.
//   ‚Ä¢ Expose getters and mutators for monitoring and controlling conductor state.
//
// Key Components:
//   ‚Ä¢ ConductorStatus (enum)
//       - Represents lifecycle phases:
//           ‚Ä¢ Initializing: conductor is starting up.
//           ‚Ä¢ Running: actively processing tasks.
//           ‚Ä¢ Paused: temporarily halted.
//           ‚Ä¢ Generating: actively generating chunks.
//           ‚Ä¢ Stopping: graceful stop requested.
//           ‚Ä¢ ShuttingDown: final shutdown in progress.
//           ‚Ä¢ Error: fault state encountered.
//
//   ‚Ä¢ ConductorState (struct)
//       - Holds shared state with atomic safety:
//           ‚Ä¢ status: current lifecycle status.
//           ‚Ä¢ queue_depth: number of pending tasks.
//           ‚Ä¢ active_generator_id: ID of currently active generator.
//           ‚Ä¢ tile_counter: total number of tiles placed/generated.
//       - Designed for concurrent access across async tasks and threads.
//
//   ‚Ä¢ Implementation Methods
//       - new: constructs initial state with defaults.
//       - get_status: returns current lifecycle status.
//       - is_active: checks if conductor is in an active state (Running/Generating).
//       - get_queue_depth: returns number of tasks in queue.
//       - get_tiles_placed: returns total tiles placed/generated.
//       - get_active_generator_id: returns active generator ID.
//       - increment_queue_depth / decrement_queue_depth: adjust queue depth atomically.
//       - increment_tile_count: increase tile counter by specified amount.
//       - set_status: update lifecycle status.
//       - set_active_generator_id: update active generator ID.
//
// Workflow:
//   1. ConductorState is created with initial generator ID.
//   2. Async tasks increment/decrement queue depth as tasks are added/completed.
//   3. Tile counter tracks total tiles generated across tasks.
//   4. Status transitions reflect conductor lifecycle (e.g., Running ‚Üí Stopping).
//   5. Active generator ID can be switched dynamically.
//
// Design Choices:
//   ‚Ä¢ AtomicResource provides safe concurrent read/write for complex types.
//   ‚Ä¢ Arc + AtomicUsize/AtomicU64 ensure thread-safe counters.
//   ‚Ä¢ Relaxed ordering is used for performance where strict ordering isn‚Äôt required.
//   ‚Ä¢ Clear separation of getters and mutators improves readability and control.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to design thread-safe state containers in Rust,
//     combining atomic primitives with Arc for shared ownership.
//   ‚Ä¢ By encapsulating lifecycle and counters, it provides a robust foundation
//     for orchestrating async procedural generation workflows.
// ============================================================================


use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,
    Running,
    Paused,
    Generating,
    Stopping,
    ShuttingDown,
    Error,
}

#[derive(Clone)]
pub struct ConductorState {
    status: AtomicResource<ConductorStatus>,
    queue_depth: Arc<AtomicUsize>,
    active_generator_id: AtomicResource<String>,
    tile_counter: Arc<AtomicU64>,
}

impl ConductorState {
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: AtomicResource::new(ConductorStatus::Initializing),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: AtomicResource::new(initial_generator_id),
            tile_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
    }
    
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    pub fn get_active_generator_id(&self) -> String {
        self.active_generator_id.read().clone()
    }

    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    pub fn decrement_queue_depth(&self) {
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
    }

    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor_state.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\internal_setup.rs
// --- START: rust/ssxl_generate/src\conductor\internal_setup.rs ---
// ============================================================================
// üéº Conductor Internal Setup (`crate::conductor::internal_setup`)
// ----------------------------------------------------------------------------
// This module defines the `ConductorInternalSetup` struct, a bundle of all
// internal components required to initialize and run the Conductor. It acts
// as a "setup package" that can be passed between modules to ensure consistent
// initialization of channels, state, and managers.
//
// Purpose:
//   ‚Ä¢ Encapsulate all dependencies needed to start the Conductor runtime.
//   ‚Ä¢ Provide a clean, modular way to prepare async channels and state.
//   ‚Ä¢ Simplify spawning of the Conductor by bundling setup into one struct.
//
// Key Components:
//   ‚Ä¢ request_receiver
//       - UnboundedReceiver for incoming chunk generation requests.
//       - Consumed by the async request loop to process tasks.
//
//   ‚Ä¢ progress_sender
//       - Bounded Sender for progress updates.
//       - Ensures backpressure when too many updates are queued.
//
//   ‚Ä¢ request_sender_api
//       - UnboundedSender exposed to external modules.
//       - Allows API or other systems to submit chunk generation requests.
//
//   ‚Ä¢ progress_receiver
//       - Bounded Receiver for progress updates.
//       - Enables monitoring or reporting of generation progress.
//
//   ‚Ä¢ initial_state
//       - ConductorState tracking lifecycle status, queue depth,
//         active generator ID, and tile counters.
//       - Provides thread-safe, atomic access for concurrent tasks.
//
//   ‚Ä¢ generator_manager
//       - Manages available generator instances and their configurations.
//       - Provides access to generator logic during request loop execution.
//
// Workflow:
//   1. `setup_channels_and_state` constructs a `ConductorInternalSetup` bundle.
//   2. The bundle is passed into `spawn`, which consumes it to start the async
//      request loop and build a Conductor instance.
//   3. Channels handle communication between tasks and progress reporting.
//   4. State and managers ensure consistent orchestration of generation logic.
//
// Design Choices:
//   ‚Ä¢ Bundling setup into a single struct improves clarity and reduces boilerplate.
//   ‚Ä¢ Separation of bounded vs. unbounded channels balances flexibility with safety.
//   ‚Ä¢ Explicit inclusion of state and managers ensures all dependencies are tracked.
//
// Educational Note:
//   ‚Ä¢ This struct demonstrates how Rust can encapsulate complex initialization
//     logic into a single, reusable package.
//   ‚Ä¢ By centralizing setup, the Conductor remains modular, testable, and easy
//     to extend with new components or channels.
// ============================================================================


use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver, Sender};

pub(crate) struct ConductorInternalSetup {
    pub request_receiver: UnboundedReceiver<ChunkRequest>,
    pub progress_sender: Sender<GenerationMessage>,
    pub request_sender_api: UnboundedSender<ChunkRequest>,
    pub progress_receiver: Receiver<GenerationMessage>,
    pub initial_state: ConductorState,
    pub generator_manager: GeneratorManager,
}

// --- END: rust/ssxl_generate/src\conductor\internal_setup.rs ---
         9 LOC | rust/ssxl_generate/src\conductor\mod.rs
// --- START: rust/ssxl_generate/src\conductor\mod.rs ---
// ============================================================================
// üéº Conductor Module Declaration (`crate::conductor`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the
// Conductor system. It organizes submodules and re-exports key items so that
// other parts of the crate can easily access them without needing to know the
// internal layout.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for the Conductor system.
//   ‚Ä¢ Expose submodules that implement conductor logic, state management,
//     synchronization, setup, and internal utilities.
//   ‚Ä¢ Re-export commonly used items to simplify external imports.
//
// Submodules:
//   ‚Ä¢ conductor
//       - Core Conductor struct and its implementation.
//       - Provides constructors, lifecycle controls, and FFI integration.
//   ‚Ä¢ conductor_state
//       - Defines lifecycle states (Running, Stopping, etc.).
//       - Provides thread-safe state container for queue depth, generator ID,
//         and tile counters.
//   ‚Ä¢ sync
//       - Synchronization utilities for atomic resource sharing.
//       - Ensures safe concurrent access across async tasks.
//   ‚Ä¢ builder
//       - Setup and spawn logic for initializing conductor internals.
//       - Prepares channels, managers, and state before runtime starts.
//   ‚Ä¢ sync_get
//       - Helper functions for safely retrieving synchronized values.
//       - Improves ergonomics when working with atomic resources.
//   ‚Ä¢ internal_setup
//       - Defines `ConductorInternalSetup`, a bundle of channels, state, and
//         managers used during initialization.
//
// Re-exports:
//   ‚Ä¢ Conductor
//       - The main struct orchestrating chunk generation and lifecycle control.
//   ‚Ä¢ conductor_state::*
//       - Re-exports all items from `conductor_state` (status enum, state struct).
//   ‚Ä¢ sync::*
//       - Re-exports synchronization utilities for convenience.
//
// Workflow:
//   1. External code imports from `crate::conductor`.
//   2. Submodules provide specialized functionality (state, sync, setup).
//   3. Re-exports simplify usage by exposing key items directly.
//   4. Conductor orchestrates runtime, generators, and communication channels.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex subsystems into clear, modular components.
//   ‚Ä¢ By re-exporting key items, the public API remains clean and ergonomic,
//     while internal organization stays modular and maintainable.
// ============================================================================


pub mod conductor;
pub mod conductor_state;
pub mod sync;
pub mod builder;
pub mod sync_get;
pub mod internal_setup;

pub use conductor::Conductor;
pub use conductor_state::*;
pub use sync::*;

// --- END: rust/ssxl_generate/src\conductor\mod.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\sync.rs
// --- START: rust/ssxl_generate/src\conductor\sync.rs ---
// ============================================================================
// üéº Conductor Channel Types (`crate::conductor::sync_get`)
// ----------------------------------------------------------------------------
// This module defines domain-specific wrappers and aliases for the async
// communication channels used by the Conductor system. By introducing clear,
// descriptive names, it improves readability and makes the intent of each
// channel explicit.
//
// Purpose:
//   ‚Ä¢ Provide a type alias for request-sending channels to simplify usage.
//   ‚Ä¢ Wrap progress-receiving channels in a dedicated struct for clarity.
//   ‚Ä¢ Ensure that communication between tasks and the Conductor is both
//     ergonomic and domain-specific.
//
// Key Components:
//   ‚Ä¢ ConductorRequestSender (type alias)
//       - Alias for `UnboundedSender<GenerationTask>`.
//       - Represents the channel through which new chunk generation requests
//         are submitted into the Conductor system.
//       - Improves readability by avoiding repetitive generic type signatures.
//
//   ‚Ä¢ ConductorProgressReceiver (struct)
//       - Wraps a bounded `Receiver<GenerationMessage>`.
//       - Explicitly represents the channel for receiving progress updates
//         from generation tasks.
//       - Provides a constructor (`new`) for ergonomic initialization.
//
// Workflow:
//   1. External modules submit chunk generation requests via `ConductorRequestSender`.
//   2. The Conductor processes tasks asynchronously.
//   3. Progress updates are sent back through bounded channels.
//   4. `ConductorProgressReceiver` wraps the receiver, clarifying its purpose
//      as a conduit for progress messages.
//
// Design Choices:
//   ‚Ä¢ Separation of request and progress channels improves clarity.
//   ‚Ä¢ Use of type alias reduces boilerplate and emphasizes domain semantics.
//   ‚Ä¢ Wrapping the progress receiver in a struct makes its role explicit,
//     aiding maintainability and readability.
//   ‚Ä¢ Bounded vs. unbounded channels balance flexibility (requests) with
//     safety (progress updates).
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust‚Äôs type system can be leveraged to
//     create domain-specific abstractions over generic async channels.
//   ‚Ä¢ By naming and wrapping channels, developers can more easily understand
//     their purpose and avoid misuse in complex async systems.
// ============================================================================


use tokio::sync::mpsc::{Receiver, UnboundedSender};

use crate::task::task_queue::GenerationMessage;
use crate::task::task_queue::GenerationTask;

pub type ConductorRequestSender = UnboundedSender<GenerationTask>;

pub struct ConductorProgressReceiver {
    pub rx: Receiver<GenerationMessage>,
}

impl ConductorProgressReceiver {
    pub fn new(rx: Receiver<GenerationMessage>) -> Self {
        ConductorProgressReceiver { rx }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync.rs ---
        35 LOC | rust/ssxl_generate/src\conductor\sync_get.rs
// --- START: rust/ssxl_generate/src\conductor\sync_get.rs ---
// ============================================================================
// üéº Conductor Synchronous Chunk Retrieval (`Conductor::get_chunk_data`)
// ----------------------------------------------------------------------------
// This extension to the Conductor provides synchronous access to chunk data.
// While most of the Conductor system is designed around asynchronous task
// execution and streaming updates, there are scenarios where a caller needs
// immediate access to a chunk‚Äôs tile data. This method bridges that gap.
//
// Purpose:
//   ‚Ä¢ Allow synchronous retrieval of chunk data for given coordinates.
//   ‚Ä¢ Internally trigger chunk generation if data is not cached.
//   ‚Ä¢ Block until a `GenerationMessage::Generated` is received.
//   ‚Ä¢ Provide a fallback in case of channel errors.
//
// Key Components:
//   ‚Ä¢ active_generator_id
//       - Retrieved from conductor state.
//       - Determines which generator to use for chunk creation.
//
//   ‚Ä¢ temp_sender / temp_receiver
//       - Temporary bounded channel (capacity = 1).
//       - Used to send and receive the generated chunk synchronously.
//
//   ‚Ä¢ state_arc
//       - Arc-wrapped conductor state for safe sharing across tasks.
//
//   ‚Ä¢ handle_chunk_unit
//       - Core function that checks cache, generates chunk if missing,
//         and sends back a `GenerationMessage`.
//
// Workflow:
//   1. Retrieve active generator ID from conductor state.
//   2. Create a temporary bounded channel for synchronous communication.
//   3. Wrap conductor state in Arc for safe sharing.
//   4. Log the synchronous chunk request.
//   5. Call `handle_chunk_unit` to generate or fetch chunk data.
//   6. Enter blocking loop waiting for a `GenerationMessage`:
//        ‚Ä¢ If `Generated`: unwrap Arc<ChunkData> into owned ChunkData.
//        ‚Ä¢ If other message: ignore and continue waiting.
//        ‚Ä¢ If channel closed: log error and return fallback empty chunk.
//
// Design Choices:
//   ‚Ä¢ Blocking loop ensures synchronous semantics, even in async environment.
//   ‚Ä¢ Arc::try_unwrap optimizes ownership transfer; fallback clone ensures safety.
//   ‚Ä¢ Temporary channel isolates synchronous requests from async streams.
//   ‚Ä¢ Logging provides visibility into synchronous requests and errors.
//
// Educational Note:
//   ‚Ä¢ This method demonstrates how synchronous access can be layered on top of
//     an asynchronous system in Rust.
//   ‚Ä¢ By carefully using bounded channels and blocking receives, it provides
//     deterministic behavior without disrupting async workflows.
// ============================================================================


use super::Conductor;
use crate::task::{handle_chunk_unit, GenerationMessage};
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;
use std::sync::Arc;
use tokio::sync::mpsc;
use tracing::{info, error};

impl Conductor {
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();

        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        let state_arc = Arc::new(self.internal_state.clone());

        info!("Sync chunk request: {:?}", chunk_coords);

        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        loop {
            match temp_receiver.blocking_recv() {
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
                }
                Some(_) => continue,
                None => {
                    error!("Sync channel closed for {:?}", chunk_coords);
                    return ChunkData::new_at_coords(*chunk_coords);
                }
            }
        }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync_get.rs ---
        33 LOC | rust/ssxl_generate/src\lib.rs
// --- START: rust/ssxl_generate/src\lib.rs ---
// ============================================================================
// üéº SSXL Engine Crate Root (`lib.rs`)
// ----------------------------------------------------------------------------
// This file defines the core structure of the SSXL engine crate. It organizes
// all subsystems (generators, conductor, manager, tasks) and exposes a clean,
// unified public API for external use.
//
// Purpose:
//   ‚Ä¢ Serve as the entry point for the SSXL engine library.
//   ‚Ä¢ Define the `Generator` trait, the contract for all procedural generators.
//   ‚Ä¢ Organize submodules for different generation strategies and orchestration.
//   ‚Ä¢ Re-export key components to simplify external imports.
//   ‚Ä¢ Provide a placeholder runtime entry point for testing initialization.
//
// Submodules:
//   ‚Ä¢ ca
//       - Implements cellular automata generators.
//       - Provides rule-based cave/maze generation algorithms.
//   ‚Ä¢ conductor
//       - Orchestrates generator execution, task queue, and runtime lifecycle.
//       - Tracks conductor state and manages async task flow.
//   ‚Ä¢ manager
//       - Validates generator configuration (map dimensions, chunk limits).
//       - Maintains registry of available generators.
//   ‚Ä¢ perlin
//       - Implements Perlin noise generator for smooth terrain generation.
//   ‚Ä¢ task
//       - Provides task queue, batch processor, and benchmarking utilities.
//
// Trait:
//   ‚Ä¢ Generator
//       - Contract for all procedural generation algorithms.
//       - Methods:
//           ‚Ä¢ id(): returns unique identifier string.
//           ‚Ä¢ generate_chunk(): generates a chunk of terrain at given coordinates.
//
// Re-exports:
//   ‚Ä¢ CellularAutomataGenerator, PerlinGenerator
//       - Concrete generator implementations exposed at crate root.
//   ‚Ä¢ Conductor
//       - Orchestrator for runtime and task execution.
//   ‚Ä¢ GeneratorConfig
//       - Configuration validator for generator settings.
//   ‚Ä¢ ConductorProgressReceiver, ConductorRequestSender
//       - Sync interfaces for conductor communication.
//   ‚Ä¢ GenerationTask
//       - Represents a single chunk generation request.
//   ‚Ä¢ benchmark_generation_workload
//       - Utility for simulating heavy workloads.
//
// Function:
//   ‚Ä¢ start_runtime_placeholder
//       - Demonstrates runtime initialization and immediate teardown.
//       - Workflow:
//           1. Attempt to create a new Conductor with no configuration.
//           2. If successful:
//                ‚Ä¢ Log runtime creation.
//                ‚Ä¢ Forget progress_receiver to avoid drop side effects.
//                ‚Ä¢ Call graceful_teardown() on Conductor.
//           3. If failed:
//                ‚Ä¢ Log error with failure details.
//
// Design Choices:
//   ‚Ä¢ Modular organization ensures separation of concerns.
//   ‚Ä¢ Re-exports flatten hierarchy for ergonomic external use.
//   ‚Ä¢ Placeholder runtime provides a safe test harness for initialization logic.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust crates can be structured to balance
//     modularity and usability. By centralizing traits, modules, and re-exports,
//     SSXL provides a clean API surface while maintaining internal organization.
// ============================================================================


use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;
use tracing::{info, error};
use std::mem;

pub mod ca;
pub mod conductor;
pub mod manager;
pub mod perlin;
pub mod task;

pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

pub use conductor::conductor::Conductor;
pub use manager::config_validator::GeneratorConfig;

pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;

pub use task::task_queue::GenerationTask;
pub use task::benchmark_logic::benchmark_generation_workload;

pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _request_sender, progress_receiver)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            mem::forget(progress_receiver);
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}

// --- END: rust/ssxl_generate/src\lib.rs ---
        58 LOC | rust/ssxl_generate/src\manager\config_validator.rs
// --- START: rust/ssxl_generate/src\manager\config_validator.rs ---
// ============================================================================
// üéº Generator Configuration and Validation (`crate::manager::generator_config`)
// ----------------------------------------------------------------------------
// This module defines the configuration parameters for a generator run and
// provides validation logic to ensure map dimensions are safe and reasonable.
// It is a critical part of the SSXL engine‚Äôs setup pipeline, ensuring that
// generation requests do not exceed system limits.
//
// Purpose:
//   ‚Ä¢ Encapsulate generator metadata (map size, seed, generator type, overrides).
//   ‚Ä¢ Provide human-readable logging for configuration state.
//   ‚Ä¢ Validate map dimensions in terms of chunk counts before generation begins.
//
// Key Components:
//   ‚Ä¢ GeneratorConfig (struct)
//       - Holds configuration parameters for a generator run:
//           ‚Ä¢ width: map width in tiles.
//           ‚Ä¢ height: map height in tiles.
//           ‚Ä¢ seed: string used for deterministic random generation.
//           ‚Ä¢ generator_name: identifier for which generator to use.
//           ‚Ä¢ tile_overrides: optional overrides for specific tiles.
//       - Implements `Display` for human-readable logging.
//
//   ‚Ä¢ ConfigValidator (struct)
//       - Provides validation logic for `GeneratorConfig`.
//       - Ensures map dimensions are within safe bounds.
//       - Prevents runaway generation requests that could exhaust resources.
//
// Constants:
//   ‚Ä¢ MAX_ACTIVE_CHUNKS
//       - Defines the maximum number of active chunks allowed in memory.
//       - Protects against excessive generation requests.
//
// Workflow:
//   1. A `GeneratorConfig` is created with map dimensions, seed, generator name,
//      and optional tile overrides.
//   2. `ConfigValidator::validate_map_dimensions` is called before generation.
//   3. Validation steps:
//        ‚Ä¢ Convert dimensions and chunk size to i64 for safe arithmetic.
//        ‚Ä¢ Compute width and height in chunks using ceiling division.
//        ‚Ä¢ Calculate total number of chunks.
//        ‚Ä¢ Ensure total chunks > 0.
//        ‚Ä¢ Ensure total chunks ‚â§ MAX_ACTIVE_CHUNKS.
//   4. Log success or failure with structured messages.
//   5. Return `Ok(())` if valid, or `Err(String)` with error message if invalid.
//
// Design Choices:
//   ‚Ä¢ Ceiling division ensures partial chunks are counted as full.
//   ‚Ä¢ Logging provides traceability for both success and failure cases.
//   ‚Ä¢ Separation of configuration and validation improves modularity.
//   ‚Ä¢ Using `Display` for `GeneratorConfig` makes logs concise and readable.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can enforce safety at the configuration
//     level, preventing invalid or excessive workloads before they reach runtime.
//   ‚Ä¢ By combining strong typing, validation, and logging, it ensures reliability
//     and transparency in procedural generation workflows.
// ============================================================================


use tracing::{error, info};
use std::fmt;
use std::collections::HashMap;
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width,
            self.height,
            self.seed,
            self.generator_name,
            self.tile_overrides.len()
        )
    }
}

pub struct ConfigValidator;

impl ConfigValidator {
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}

// --- END: rust/ssxl_generate/src\manager\config_validator.rs ---
         6 LOC | rust/ssxl_generate/src\manager\generator.rs
// --- START: rust/ssxl_generate/src\manager\generator.rs ---
// ============================================================================
// üéº Generator Trait (`crate::generator::generator`)
// ----------------------------------------------------------------------------
// This module defines the `Generator` trait, the core contract for all
// procedural generation algorithms in the SSXL engine. By enforcing a common
// interface, the engine can treat all generators uniformly, swap them
// dynamically, and maintain modularity and extensibility.
//
// Purpose:
//   ‚Ä¢ Provide a unified interface for chunk generation algorithms.
//   ‚Ä¢ Ensure deterministic, self-contained generation logic.
//   ‚Ä¢ Enable the Conductor to manage multiple generator types seamlessly.
//
// Key Components:
//   ‚Ä¢ id (method)
//       - Returns a unique, static string identifier for the generator.
//       - Used by the Conductor to distinguish between generator types.
//       - Useful for logging, debugging, and configuration.
//       - Examples: "cellular_automata_basic", "perlin_noise".
//
//   ‚Ä¢ generate_chunk (method)
//       - Executes the generator‚Äôs algorithm to produce a single chunk of world data.
//       - Arguments:
//           ‚Ä¢ chunk_coords: Vec2i representing the global coordinates of the chunk.
//       - Returns:
//           ‚Ä¢ ChunkData: the fully generated chunk, ready for caching and use.
//       - Requirements:
//           ‚Ä¢ Must be deterministic: same coordinates and seed ‚Üí identical output.
//           ‚Ä¢ Must be self-contained: should not rely on external mutable state.
//       - Examples:
//           ‚Ä¢ Cave generator: runs a cellular automata simulation.
//           ‚Ä¢ Noise generator: samples Perlin/Simplex noise fields.
//
// Workflow:
//   1. Conductor requests chunk generation by calling `generate_chunk`.
//   2. Generator implementation produces deterministic tile data for the chunk.
//   3. Resulting `ChunkData` is cached and returned for use in the world grid.
//   4. Generator ID is logged and tracked for debugging and configuration.
//
// Design Choices:
//   ‚Ä¢ Trait-based design enforces consistency across all generator implementations.
//   ‚Ä¢ Separation of ID and generation logic improves clarity and modularity.
//   ‚Ä¢ Deterministic output ensures reproducibility across runs and seeds.
//
// Educational Note:
//   ‚Ä¢ This trait demonstrates how Rust traits can define contracts for modular,
//     pluggable systems.
//   ‚Ä¢ By requiring both identification and generation methods, it ensures that
//     all generators are discoverable, traceable, and interchangeable.
// ============================================================================


use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;

#[allow(dead_code)]
pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

// --- END: rust/ssxl_generate/src\manager\generator.rs ---
        54 LOC | rust/ssxl_generate/src\manager\generator_manager.rs
// --- START: rust/ssxl_generate/src\manager\generator_manager.rs ---
// ============================================================================
// üéº Generator Manager (`crate::manager::generator_manager`)
// ----------------------------------------------------------------------------
// This module defines the `GeneratorManager`, the central registry and access
// point for all procedural generation algorithms in the SSXL engine. It ensures
// that multiple generator types (e.g., Perlin noise, cellular automata) can be
// initialized, stored, and retrieved in a uniform way.
//
// Purpose:
//   ‚Ä¢ Maintain a registry of all available generator implementations.
//   ‚Ä¢ Provide safe, shared access to generators across async tasks.
//   ‚Ä¢ Allow dynamic lookup of generators by ID.
//   ‚Ä¢ Execute chunk generation requests using the active generator.
//
// Key Components:
//   ‚Ä¢ DynGenerator (type alias)
//       - Represents a dynamically dispatched generator trait object.
//       - Box<dyn Generator + Send + Sync> ensures uniform storage and thread safety.
//       - Wrapped in Arc for shared ownership across tasks.
//
//   ‚Ä¢ GeneratorManager (struct)
//       - Holds:
//           ‚Ä¢ generators: HashMap mapping generator IDs ‚Üí Arc<DynGenerator>.
//           ‚Ä¢ default_perlin_id: fallback ID for Perlin generator.
//       - Acts as the registry and dispatcher for all generators.
//
// Implementation Methods:
//   ‚Ä¢ new
//       - Initializes registry with:
//           ‚Ä¢ Perlin generator (base noise layer).
//           ‚Ä¢ Multiple cellular automata generators (different rule sets).
//       - Logs how many generators were registered.
//       - Returns a fully constructed `GeneratorManager`.
//
//   ‚Ä¢ get_map_ref
//       - Returns a reference to the internal generator map.
//       - Useful for quick lookups without cloning.
//
//   ‚Ä¢ get_map_clone
//       - Returns a cloned copy of the generator map.
//       - Useful for background tasks requiring ownership.
//
//   ‚Ä¢ generate_single_chunk
//       - Executes chunk generation for given coordinates using specified generator ID.
//       - Panics if ID is invalid (should be validated earlier).
//       - Returns fully generated `ChunkData`.
//
//   ‚Ä¢ get_initial_id
//       - Determines initial active generator ID based on configuration.
//       - If config ID exists ‚Üí return it.
//       - If not ‚Üí log warning and return default Perlin ID.
//
// Workflow:
//   1. Registry is initialized with Perlin + CA generators.
//   2. Conductor queries `GeneratorManager` for active generator ID.
//   3. Chunk generation requests are dispatched to the correct generator.
//   4. Fallback logic ensures system stability if config ID is invalid.
//
// Design Choices:
//   ‚Ä¢ Arc + Box<dyn Generator> ensures safe concurrent access and polymorphism.
//   ‚Ä¢ HashMap provides O(1) lookup for generator IDs.
//   ‚Ä¢ Logging improves visibility into registration and fallback events.
//   ‚Ä¢ Default Perlin fallback ensures system always has a valid generator.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can combine trait objects, smart pointers,
//     and collections to build a flexible plugin-like architecture.
//   ‚Ä¢ By centralizing generator management, the engine remains modular, extensible,
//     and resilient to configuration errors.
// ============================================================================


use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;
use crate::Generator;
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;
use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

pub type DynGenerator = Box<dyn Generator + Send + Sync>;

pub struct GeneratorManager {
    generators: HashMap<String, Arc<DynGenerator>>,
    default_perlin_id: String,
}

impl GeneratorManager {
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        generator_arc.generate_chunk(chunk_coords)
    }

    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!(
                "Config default generator ID '{}' not found. Falling back to Perlin: {}",
                config_id, self.default_perlin_id
            );
            self.default_perlin_id.clone()
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\generator_manager.rs ---
         8 LOC | rust/ssxl_generate/src\manager\mod.rs
// --- START: rust/ssxl_generate/src\manager\mod.rs ---
// ============================================================================
// üéº Manager Module Declaration (`crate::manager`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the
// Manager system. It organizes submodules related to configuration validation,
// generator logic, generator registry, and runtime management. By re-exporting
// key items, it simplifies usage for external code.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for all management-related functionality.
//   ‚Ä¢ Expose submodules that implement configuration checks, generator contracts,
//     generator registry, and runtime orchestration.
//   ‚Ä¢ Re-export commonly used items to provide a clean, ergonomic public API.
//
// Submodules:
//   ‚Ä¢ config_validator
//       - Provides validation logic for generator configurations.
//       - Ensures map dimensions and chunk limits are safe before generation.
//   ‚Ä¢ generator
//       - Defines the `Generator` trait, the contract for all generation algorithms.
//       - Enforces modularity and extensibility across procedural generators.
//   ‚Ä¢ generator_manager
//       - Acts as a registry for all available generators (Perlin, Cellular Automata, etc.).
//       - Provides lookup, fallback, and chunk generation execution.
//   ‚Ä¢ runtime_manager
//       - Manages the async runtime environment for executing generation tasks.
//       - Handles graceful shutdown and lifecycle control.
//
// Re-exports:
//   ‚Ä¢ config_validator::*
//       - Exposes `ConfigValidator` and related validation utilities.
//   ‚Ä¢ generator::*
//       - Exposes the `Generator` trait and related items.
//   ‚Ä¢ generator_manager::*
//       - Exposes `GeneratorManager` and type aliases for dynamic generators.
//   ‚Ä¢ runtime_manager::*
//       - Exposes `RuntimeManager` and runtime utilities.
//
// Workflow:
//   1. External code imports from `crate::manager`.
//   2. Submodules provide specialized functionality (validation, generator logic, registry, runtime).
//   3. Re-exports simplify usage by exposing key items directly.
//   4. Manager orchestrates configuration, generator selection, and runtime execution.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex subsystems into clear, modular components.
//   ‚Ä¢ By re-exporting key items, the public API remains clean and ergonomic,
//     while internal organization stays modular and maintainable.
// ============================================================================


pub mod config_validator;
pub mod generator;
pub mod generator_manager;
pub mod runtime_manager;

pub use config_validator::*;
pub use generator::*;
pub use generator_manager::*;
pub use runtime_manager::*;

// --- END: rust/ssxl_generate/src\manager\mod.rs ---
        34 LOC | rust/ssxl_generate/src\manager\runtime_manager.rs
// --- START: rust/ssxl_generate/src\manager\runtime_manager.rs ---
// ============================================================================
// üéº Runtime Manager (`crate::manager::runtime_manager`)
// ----------------------------------------------------------------------------
// This module defines the `RuntimeManager`, a wrapper around the Tokio runtime
// that manages its lifecycle. It ensures that asynchronous tasks in the SSXL
// engine are executed efficiently and that the runtime is properly initialized
// and shut down.
//
// Purpose:
//   ‚Ä¢ Provide a centralized manager for the Tokio runtime.
//   ‚Ä¢ Configure runtime with optimal worker threads based on available CPU cores.
//   ‚Ä¢ Expose a safe handle for spawning tasks without owning the runtime directly.
//   ‚Ä¢ Ensure graceful shutdown when the manager is dropped.
//
// Key Components:
//   ‚Ä¢ RuntimeManager (struct)
//       - Wraps an `Option<Runtime>` to allow safe ownership transfer during Drop.
//       - Encapsulates initialization, access, and shutdown logic.
//
// Implementation Methods:
//   ‚Ä¢ new
//       - Creates a new multi-threaded Tokio runtime.
//       - Configures worker threads equal to the number of CPU cores.
//       - Enables all Tokio features (I/O, time, etc.).
//       - Logs initialization details.
//       - Returns `Ok(RuntimeManager)` or `Err(io::Error)` if runtime fails to build.
//
//   ‚Ä¢ get_handle
//       - Provides a clone of the runtime handle.
//       - Allows spawning tasks without owning the runtime itself.
//       - Panics if runtime is unexpectedly None.
//
//   ‚Ä¢ shutdown_graceful
//       - Logs a graceful shutdown request.
//       - Actual shutdown is deferred to the Drop implementation.
//
// Drop Implementation:
//   ‚Ä¢ Ensures runtime is properly shut down when `RuntimeManager` goes out of scope.
//   ‚Ä¢ Steps:
//       1. Take ownership of runtime from Option (leaving None behind).
//       2. Log shutdown message.
//       3. Call `shutdown_background()` to stop runtime without blocking current thread.
//
// Workflow:
//   1. RuntimeManager is created via `new`, initializing a multi-threaded runtime.
//   2. Tasks are spawned using `get_handle`.
//   3. When shutdown is requested, `shutdown_graceful` logs the intent.
//   4. On drop, runtime is safely shut down in the background.
//
// Design Choices:
//   ‚Ä¢ Wrapping runtime in `Option` allows safe transfer of ownership during Drop.
//   ‚Ä¢ Using `num_cpus` ensures runtime scales with hardware capabilities.
//   ‚Ä¢ Logging provides visibility into initialization and shutdown events.
//   ‚Ä¢ Background shutdown prevents blocking the main thread during cleanup.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can manage async runtimes safely,
//     ensuring deterministic lifecycle control.
//   ‚Ä¢ By combining smart pointers, logging, and Drop semantics, it provides
//     a robust foundation for concurrent task execution in the SSXL engine.
// ============================================================================


use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

impl RuntimeManager {
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?;

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped ‚Äî shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\runtime_manager.rs ---
         2 LOC | rust/ssxl_generate/src\perlin\mod.rs
// --- START: rust/ssxl_generate/src\perlin\mod.rs ---
// ============================================================================
// üéº Perlin Module Declaration (`crate::perlin`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the Perlin
// noise subsystem in the SSXL engine. It organizes submodules related to Perlin
// noise generation and re-exports their contents for easier access.
//
// Purpose:
//   ‚Ä¢ Serve as the "entry point" for all Perlin-related functionality.
//   ‚Ä¢ Expose the `perlin_generator` submodule, which implements the Perlin noise algorithm.
//   ‚Ä¢ Re-export items so external code can import directly from `crate::perlin`
//     without drilling down into internal paths.
//
// Submodules:
//   ‚Ä¢ perlin_generator
//       - Contains the actual implementation of the Perlin noise generator.
//       - Conforms to the `Generator` trait, ensuring compatibility with the
//         Conductor and GeneratorManager systems.
//       - Provides deterministic chunk generation based on Perlin noise fields.
//
// Re-exports:
//   ‚Ä¢ pub use perlin_generator::*
//       - Exposes all items from the `perlin_generator` submodule.
//       - Simplifies external imports by flattening the module hierarchy.
//       - Example:
//           ‚Ä¢ Without re-export ‚Üí `use crate::perlin::perlin_generator::PerlinGenerator;`
//           ‚Ä¢ With re-export    ‚Üí `use crate::perlin::PerlinGenerator;`
//
// Workflow:
//   1. External code imports from `crate::perlin`.
//   2. The `perlin_generator` submodule provides Perlin noise generation logic.
//   3. Re-export ensures ergonomic access to `PerlinGenerator` and related items.
//   4. GeneratorManager registers Perlin as one of the available algorithms.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     specialized subsystems (like Perlin noise) while keeping the public API clean.
//   ‚Ä¢ By re-exporting, developers gain ergonomic access without sacrificing
//     modularity or maintainability.
// ============================================================================


pub mod perlin_generator;

pub use perlin_generator::*;

// --- END: rust/ssxl_generate/src\perlin\mod.rs ---
        68 LOC | rust/ssxl_generate/src\perlin\perlin_generator.rs
// --- START: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
// ============================================================================
// üéº Perlin Noise Generator (`crate::perlin::perlin_generator`)
// ----------------------------------------------------------------------------
// This module implements a procedural terrain generator based on Perlin noise.
// It conforms to the `Generator` trait, making it interchangeable with other
// generation algorithms in the SSXL engine.
//
// Purpose:
//   ‚Ä¢ Provide deterministic terrain generation using Perlin noise fields.
//   ‚Ä¢ Translate continuous noise values into discrete tile types (Water, Grass, Mountain).
//   ‚Ä¢ Ensure reproducibility by seeding the noise function.
//   ‚Ä¢ Integrate seamlessly with the Conductor and GeneratorManager systems.
//
// Key Components:
//   ‚Ä¢ PerlinGenerator (struct)
//       - Fields:
//           ‚Ä¢ perlin: Perlin noise object seeded for deterministic output.
//           ‚Ä¢ scale: scaling factor applied to coordinates before sampling noise.
//       - Larger scale ‚Üí smoother, larger terrain features.
//       - Smaller scale ‚Üí finer detail and variation.
//
//   ‚Ä¢ new (constructor)
//       - Creates a new PerlinGenerator with a given scale.
//       - Uses a hardcoded DEFAULT_SEED for reproducibility.
//       - Ensures consistent terrain generation across runs.
//
//   ‚Ä¢ id (trait method)
//       - Returns a unique identifier string ("perlin_basic_2d").
//       - Used by Conductor and GeneratorManager to select this generator.
//
//   ‚Ä¢ generate_chunk (trait method)
//       - Generates a single chunk of terrain using Perlin noise.
//       - Steps:
//           1. Compute chunk size in tiles.
//           2. Calculate world coordinates for chunk origin.
//           3. Create unique chunk ID by packing coordinates into u64.
//           4. Define spatial bounds for the chunk.
//           5. Initialize ChunkData container.
//           6. Pre-allocate vector for TileData entries.
//           7. Iterate over each tile in the chunk:
//                a. Compute world coordinates.
//                b. Sample Perlin noise at scaled coordinates.
//                c. Normalize noise value from [-1, 1] ‚Üí [0, 1].
//                d. Threshold into TileType (Water, Grass, Mountain).
//                e. Create TileData with type + raw noise metadata.
//                f. Push into tile vector.
//           8. Insert generated tiles into ChunkData.
//           9. Log completion message with chunk coordinates and tile count.
//          10. Return fully populated ChunkData.
//
// Workflow:
//   1. Conductor requests chunk generation via GeneratorManager.
//   2. PerlinGenerator samples noise field at scaled coordinates.
//   3. Noise values are normalized and mapped to discrete tile types.
//   4. ChunkData is populated with TileData entries.
//   5. Completed chunk is cached and returned for use in the world grid.
//
// Design Choices:
//   ‚Ä¢ Deterministic seed ensures reproducibility across runs.
//   ‚Ä¢ Scaling factor allows tuning of terrain smoothness vs. detail.
//   ‚Ä¢ Thresholds map continuous noise into meaningful terrain categories.
//   ‚Ä¢ Logging provides visibility into generation process.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how continuous mathematical noise functions
//     can be transformed into discrete, game-ready terrain data.
//   ‚Ä¢ By combining Perlin noise with clear thresholds, it produces varied yet
//     deterministic landscapes suitable for procedural world generation.
// ============================================================================


use crate::Generator;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use noise::{NoiseFn, Perlin};
use tracing::info;

pub struct PerlinGenerator {
    perlin: Perlin,
    scale: f64,
}

impl PerlinGenerator {
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

impl Generator for PerlinGenerator {
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                let normalized_value = (noise_value + 1.0) / 2.0;

                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                let tile = TileData::new(tile_type, normalized_value as f32);

                tiles.push(tile);
            }
        }

        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}

// --- END: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
        53 LOC | rust/ssxl_generate/src\task\batch_processor.rs
// --- START: rust/ssxl_generate/src\task\batch_processor.rs ---
// ============================================================================
// üéº Batch Generation Task Spawner (`crate::task::batch_generation`)
// ----------------------------------------------------------------------------
// This module defines the `spawn_batch_generation_task` function, which is
// responsible for orchestrating sequential batch generation of chunks in the
// SSXL engine. It leverages the Tokio runtime to spawn a blocking task that
// processes all chunks in a map configuration.
//
// Purpose:
//   ‚Ä¢ Execute full map generation in a controlled, sequential manner.
//   ‚Ä¢ Ensure stability when working with non-thread-safe generators and caches.
//   ‚Ä¢ Provide progress and completion signals back to the Conductor.
//   ‚Ä¢ Track queue depth to monitor active generation tasks.
//
// Key Components:
//   ‚Ä¢ runtime_handle
//       - A handle to the Tokio runtime.
//       - Used to spawn the blocking batch generation task.
//
//   ‚Ä¢ generators_clone
//       - Cloned registry of available generators.
//       - Provides access to generator implementations by ID.
//
//   ‚Ä¢ chunk_cache_clone
//       - Shared cache for storing/retrieving generated chunks.
//       - Prevents redundant computation.
//
//   ‚Ä¢ active_generator_id
//       - ID of the generator to use for this batch.
//       - Ensures deterministic selection of algorithm.
//
//   ‚Ä¢ progress_sender_clone
//       - Channel sender for progress/completion messages.
//       - Allows Conductor to track task lifecycle.
//
//   ‚Ä¢ internal_state_clone
//       - Tracks conductor lifecycle state and queue depth.
//       - Ensures proper accounting of active tasks.
//
//   ‚Ä¢ config_clone
//       - Generator configuration (map dimensions, seed, etc.).
//       - Defines the scope of the batch generation.
//
// Workflow:
//   1. Log the start of batch generation with configuration details.
//   2. Spawn a blocking task on the runtime to process chunks sequentially.
//   3. Increment queue depth to track active task.
//   4. Calculate map dimensions in terms of chunk counts using ceiling division.
//   5. Build a list of all chunk coordinates to be generated.
//   6. Iterate sequentially over each chunk coordinate:
//        ‚Ä¢ Call `handle_chunk_unit` to generate and cache chunk data.
//   7. Send a completion message via channel when finished.
//   8. Decrement queue depth to reflect task completion.
//   9. Log completion message with configuration details.
//
// Design Choices:
//   ‚Ä¢ Sequential processing ensures stability with non-thread-safe components.
//   ‚Ä¢ Ceiling division guarantees partial chunks are included in generation.
//   ‚Ä¢ Logging provides visibility into task lifecycle and edge cases.
//   ‚Ä¢ Queue depth tracking prevents runaway task spawning.
//   ‚Ä¢ Completion signaling integrates with Conductor‚Äôs orchestration layer.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust + Tokio can coordinate blocking,
//     sequential workloads within an async runtime.
//   ‚Ä¢ By combining concurrency primitives (channels, Arc) with structured logging,
//     it ensures deterministic, traceable, and safe batch generation.
// ============================================================================


use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_cache::ChunkCache;
use crate::manager::config_validator::GeneratorConfig;
use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::DynGenerator;
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};
use ssxl_shared::CHUNK_SIZE;

pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<ChunkCache>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: Arc<ConductorState>,
    config_clone: GeneratorConfig,
) {
    info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

    runtime_handle.spawn_blocking(move || {
        internal_state_clone.increment_queue_depth();

        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        if all_chunk_coords.is_empty() {
            info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
        }

        let active_generator_id_ref = &active_generator_id;
        
        for &chunk_coords in all_chunk_coords.iter() {
            handle_chunk_unit(
                chunk_coords,
                active_generator_id_ref,
                &generators_clone,
                &chunk_cache_clone,
                &progress_sender_clone,
                &internal_state_clone,
            );
        }

        if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
            warn!("Batch completion signal dropped (Channel full).");
        }

        internal_state_clone.decrement_queue_depth();

        info!("Batch generation task finished processing command: {}", config_clone);
    });
}

// --- END: rust/ssxl_generate/src\task\batch_processor.rs ---
        21 LOC | rust/ssxl_generate/src\task\benchmark_logic.rs
// --- START: rust/ssxl_generate/src\task\benchmark_logic.rs ---
// ============================================================================
// üéº Benchmark Generation Workload (`crate::benchmark::generation_workload`)
// ----------------------------------------------------------------------------
// This module defines the `benchmark_generation_workload` function, which
// simulates a heavy tile-processing workload. It is primarily used for stress
// testing, benchmarking, and validating progress-tracking mechanisms in the
// SSXL engine.
//
// Purpose:
//   ‚Ä¢ Mimic the computational cost of large-scale chunk/tile generation.
//   ‚Ä¢ Provide a controlled workload for performance benchmarking.
//   ‚Ä¢ Update a shared atomic counter to report progress periodically.
//   ‚Ä¢ Log start and completion events for visibility.
//
// Key Components:
//   ‚Ä¢ workload_tiles
//       - Total number of tiles to simulate processing.
//       - Defines the scale of the benchmark workload.
//
//   ‚Ä¢ processed_tiles_counter
//       - Shared atomic counter (Arc<AtomicU64>).
//       - Updated periodically to reflect progress.
//       - Allows external systems (e.g., Conductor) to monitor task advancement.
//
// Workflow:
//   1. Log the start of workload execution with tile count.
//   2. Define update interval (every 10 million tiles).
//   3. Initialize result accumulator for dummy computation.
//   4. Iterate over all tiles:
//        ‚Ä¢ Perform dummy computation (checksum-like addition).
//        ‚Ä¢ Update atomic counter at each interval.
//   5. Handle final remainder update if workload size is not a multiple of interval.
//   6. Log completion message with final checksum value.
//
// Design Choices:
//   ‚Ä¢ Wrapping addition prevents overflow panics during dummy computation.
//   ‚Ä¢ Relaxed memory ordering provides fast atomic updates without synchronization overhead.
//   ‚Ä¢ Large update interval reduces contention on atomic counter.
//   ‚Ä¢ Logging ensures visibility into workload lifecycle.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how to simulate heavy workloads in Rust
//     while safely tracking progress across threads.
//   ‚Ä¢ By combining atomic counters, logging, and dummy computation, it provides
//     a reproducible benchmark for testing runtime performance and monitoring.
// ============================================================================


use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64>
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}

// --- END: rust/ssxl_generate/src\task\benchmark_logic.rs ---
         6 LOC | rust/ssxl_generate/src\task\mod.rs
// --- START: rust/ssxl_generate/src\task\mod.rs ---
// ============================================================================
// üéº Task Module Declaration (`crate::task`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the Task
// system in the SSXL engine. It organizes all task-related functionality,
// including batch generation, benchmarking, and task queue management.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for task-related subsystems.
//   ‚Ä¢ Expose submodules that implement chunk batch processing, benchmarking,
//     and queue orchestration.
//   ‚Ä¢ Re-export commonly used items to simplify external imports.
//
// Submodules:
//   ‚Ä¢ batch_processor
//       - Handles sequential batch generation of chunks.
//       - Ensures stability with non-thread-safe generators and caches.
//   ‚Ä¢ benchmark_logic
//       - Provides benchmarking utilities for workload simulation.
//       - Useful for stress testing and performance validation.
//   ‚Ä¢ task_queue
//       - Manages the queue of chunk generation tasks.
//       - Supports both async and sync execution flows.
//
// Re-exports:
//   ‚Ä¢ pub use batch_processor::*
//       - Exposes batch generation functions directly from `crate::task`.
//   ‚Ä¢ pub use benchmark_logic::*
//       - Exposes benchmarking utilities directly from `crate::task`.
//   ‚Ä¢ pub use task_queue::*
//       - Exposes task queue management functions directly from `crate::task`.
//
// Workflow:
//   1. External code imports from `crate::task`.
//   2. Submodules provide specialized functionality (batch, benchmark, queue).
//   3. Re-exports flatten the hierarchy for ergonomic access.
//   4. Conductor orchestrates tasks using these utilities.
//
// Design Choices:
//   ‚Ä¢ Modular organization keeps batch, benchmark, and queue logic isolated.
//   ‚Ä¢ Re-exports simplify the public API, reducing boilerplate in external code.
//   ‚Ä¢ Clear separation of concerns ensures maintainability and scalability.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex task orchestration into clean, modular components.
//   ‚Ä¢ By re-exporting, developers gain ergonomic access while preserving
//     internal modularity and clarity.
// ============================================================================


pub mod batch_processor;
pub mod benchmark_logic;
pub mod task_queue;

pub use batch_processor::*;
pub use benchmark_logic::*;
pub use task_queue::*;

// --- END: rust/ssxl_generate/src\task\mod.rs ---
        97 LOC | rust/ssxl_generate/src\task\task_queue.rs
// --- START: rust/ssxl_generate/src\task\task_queue.rs ---
// ============================================================================
// üéº Task Queue System (`crate::task::task_queue`)
// ----------------------------------------------------------------------------
// This module defines the core task queue logic for the SSXL engine. It manages
// chunk generation requests, integrates with caching, and ensures that tasks
// are processed safely and efficiently within the Tokio runtime.
//
// Purpose:
//   ‚Ä¢ Provide an asynchronous task queue for chunk generation.
//   ‚Ä¢ Handle cache lookups and generation logic in a unified flow.
//   ‚Ä¢ Track conductor state (tile counts, lifecycle, active status).
//   ‚Ä¢ Ensure clean startup and shutdown of generation tasks.
//
// Key Components:
//   ‚Ä¢ DynGenerator (type alias)
//       - Dynamically dispatched `Generator` trait object.
//       - Send + Sync for concurrency safety.
//   ‚Ä¢ CHUNK_SIZE (constant)
//       - Local i64 constant derived from shared crate.
//       - Defines chunk dimensions for generation and caching.
//
// Functions:
//   ‚Ä¢ handle_chunk_unit
//       - Handles a single chunk request end-to-end.
//       - Workflow:
//           1. Build a unique `ChunkKey` from coordinates.
//           2. Check cache for existing chunk.
//           3. If cache hit ‚Üí send cached chunk via channel.
//           4. If cache miss ‚Üí generate new chunk using selected generator.
//           5. Update conductor state with tile count.
//           6. Save generated chunk to cache.
//           7. Send generated chunk via progress channel.
//       - Provides structured logging for cache hits/misses, errors, and results.
//
//   ‚Ä¢ start_request_loop
//       - Main async loop for processing incoming generation tasks.
//       - Workflow:
//           1. Spawn async loop on runtime.
//           2. Log start of task queue.
//           3. Maintain list of active blocking tasks.
//           4. For each incoming task:
//                a. Check conductor active state.
//                b. Clone necessary resources.
//                c. Spawn blocking task to handle chunk via `handle_chunk_unit`.
//                d. Track task handle.
//           5. When channel closes, drain all active tasks.
//           6. Send `GenerationComplete` message.
//           7. Log clean shutdown.
//       - Ensures graceful lifecycle management of generation tasks.
//
// Design Choices:
//   ‚Ä¢ Separation of concerns: `handle_chunk_unit` focuses on single chunk logic,
//     while `start_request_loop` orchestrates task queue lifecycle.
//   ‚Ä¢ Arc + HashMap ensures safe concurrent access to generators and cache.
//   ‚Ä¢ Structured logging (info, warn, debug, error) provides visibility into
//     task execution, cache behavior, and error handling.
//   ‚Ä¢ Blocking tasks are spawned for generation to isolate heavy workloads
//     while preserving async responsiveness.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust + Tokio can integrate async orchestration
//     with blocking workloads, ensuring both performance and safety.
//   ‚Ä¢ By combining caching, atomic state tracking, and structured logging,
//     it provides a robust foundation for procedural generation pipelines.
// ============================================================================


use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{info, error, warn, debug};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_math::coordinate_system::ChunkKey;
use glam::I64Vec3;
use ssxl_cache::ChunkCache;
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE;
use crate::Generator;
use crate::conductor::conductor_state;
pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask};

type DynGenerator = Box<dyn Generator + Send + Sync>;
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;

pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
    conductor_state: &Arc<conductor_state::ConductorState>,
) {
    let chunk_key = ChunkKey(I64Vec3 {
        x: chunk_coords.x,
        y: chunk_coords.y,
        z: 0,
    });

    if let Some(chunk_data_arc) = chunk_cache.load_chunk(&chunk_key) {
        debug!(?chunk_coords, "Cache HIT");

        let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
        if progress_sender.try_send(msg).is_err() {
            warn!(?chunk_coords, "Failed to send cached chunk (channel full/closed)");
        }
        return;
    }

    debug!(?chunk_coords, generator = %generator_name, "Cache MISS ‚Üí generating");

    let generator = generators
        .get(generator_name)
        .expect("Generator must exist in map");

    let chunk_data = generator.generate_chunk(chunk_coords);

    let tile_count = chunk_data.tiles.len() as u64;
    conductor_state.increment_tile_count(tile_count);

    let chunk_data_arc = Arc::new(chunk_data);

    if chunk_cache.save_chunk(&chunk_key, chunk_data_arc.clone()).is_err() {
        error!(?chunk_coords, "Failed to save generated chunk to cache");
    }

    let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
    if progress_sender.try_send(msg).is_err() {
        warn!(?chunk_coords, "Failed to send generated chunk (channel full/closed)");
    } else {
        debug!(?chunk_coords, "Sent newly generated chunk");
    }
}

pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<conductor_state::ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue started");

        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();

        while let Some(task) = request_rx.recv().await {
            if !conductor_state.as_ref().is_active() {
                warn!(?task.chunk_coords, "Dropping task ‚Äî Conductor not active");
                continue;
            }

            let progress_tx = progress_tx.clone();
            let generators = generators.clone();
            let cache = chunk_cache.clone();
            let state = conductor_state.clone();

            let handle = tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators,
                    &cache,
                    &progress_tx,
                    &state,
                );
            });

            active_tasks.push(handle);
        }

        info!("Request channel closed. Draining {} active tasks...", active_tasks.len());

        for handle in active_tasks {
            if let Err(e) = handle.await {
                error!("Generation task panicked: {:?}", e);
            }
        }

        let _ = progress_tx.send(GenerationMessage::GenerationComplete).await;

        info!("Generation Task Queue shut down cleanly");
    });
}

// --- END: rust/ssxl_generate/src\task\task_queue.rs ---
        19 LOC | rust/ssxl_godot/src\anim\animation_api.rs
// --- START: rust/ssxl_godot/src\anim\animation_api.rs ---
// ============================================================================
// üéº Animation API (`crate::animation_api`)
// ----------------------------------------------------------------------------
// This module defines the `AnimationAPI` struct, which serves as an abstraction
// layer for animation-related orchestration in the SSXL engine. It bridges the
// animation conductor subsystem with the core generation conductor, enabling
// coordinated lifecycle management across threads.
//
// Purpose:
//   ‚Ä¢ Provide a unified interface for animation orchestration.
//   ‚Ä¢ Hold references to conductor handles for lifecycle and communication.
//   ‚Ä¢ Support flexible initialization with optional components.
//   ‚Ä¢ Serve as a foundation for future animation-specific extensions.
//
// Key Components:
//   ‚Ä¢ AnimationAPI (struct)
//       - Attributes:
//           ‚Ä¢ animation_conductor
//               - Optional reference to `AnimationConductorHandle`.
//               - Drives animation-specific orchestration.
//               - Stored as `Option<&>` to allow absence when not needed.
//           ‚Ä¢ _conductor
//               - Optional reference to core `Conductor` wrapped in `Arc<Mutex>`.
//               - Arc ensures shared ownership across threads.
//               - Mutex ensures safe concurrent access.
//               - Leading underscore indicates this field may be unused directly,
//                 but retained for lifecycle management or future use.
//
//   ‚Ä¢ new (constructor)
//       - Creates a new `AnimationAPI` instance.
//       - Accepts optional references to both animation conductor and core conductor.
//       - Returns a fully initialized struct with provided references stored.
//       - Flexible design allows initialization depending on orchestration needs.
//
// Workflow:
//   1. External systems create an `AnimationAPI` instance via `new`.
//   2. Optionally provide references to animation conductor and/or core conductor.
//   3. The struct stores these references for lifecycle management.
//   4. Future extensions may add orchestration methods leveraging these handles.
//
// Design Choices:
//   ‚Ä¢ Use of `Option<&>` allows safe absence of conductor references.
//   ‚Ä¢ Arc + Mutex ensures thread-safe access to the core conductor.
//   ‚Ä¢ Default + dead_code attributes provide flexibility for unused fields
//     while retaining compatibility with FFI or future expansion.
//   ‚Ä¢ Separation of animation conductor from core conductor maintains modularity.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can structure orchestration APIs
//     with optional, thread-safe references. By combining `Arc`, `Mutex`,
//     and `Option`, it provides a flexible yet safe foundation for managing
//     concurrent animation and generation lifecycles.
// ============================================================================


use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};
use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}

// --- END: rust/ssxl_godot/src\anim\animation_api.rs ---
        30 LOC | rust/ssxl_godot/src\engine\api.rs
// --- START: rust/ssxl_godot/src\engine\api.rs ---
// ============================================================================
// üéº Engine Initialization and API Layer (`crate::engine::initializer`)
// ----------------------------------------------------------------------------
// This module provides the glue between the SSXL engine core and the Godot
// game engine. It defines initialization routines and public-facing APIs that
// allow Godot scripts to interact with the procedural generation system.
//
// Purpose:
//   ‚Ä¢ Bootstrap the SSXL engine inside Godot.
//   ‚Ä¢ Set up conductor state, communication channels, and runtime orchestration.
//   ‚Ä¢ Provide a safe, thread-aware interface for spawning and managing the Conductor.
//   ‚Ä¢ Expose a public API for chunk data retrieval compatible with Godot.
//
// Key Components:
//   ‚Ä¢ EngineInitializer (struct)
//       - Acts as a bootstrapper for the engine.
//       - Provides methods to:
//           ‚Ä¢ Create a new initializer (`new`).
//           ‚Ä¢ Execute channel and state setup (`execute_channel_and_state_setup`).
//           ‚Ä¢ Wrap and spawn the conductor (`execute_conductor_setup_and_spawn`).
//       - Ensures conductor is safely shared across threads using `Arc<Mutex>`.
//       - Extracts and clones `AnimationConductorHandle` for animation orchestration.
//
//   ‚Ä¢ GenerationAPI (struct)
//       - Provides a public-facing API for chunk data retrieval.
//       - Intended to be called from Godot scripts.
//       - Currently a stub implementation returning an empty `Dictionary`.
//       - Future extension point for exposing generated chunk data to Godot.
//
// Workflow:
//   1. Godot calls `EngineInitializer::new()` to create an initializer.
//   2. `execute_channel_and_state_setup` wires channels and conductor state.
//   3. `execute_conductor_setup_and_spawn` wraps conductor in `Arc<Mutex>`
//      and provides an animation handle.
//   4. Godot scripts can call `GenerationAPI::fetch_chunk_data` to retrieve
//      chunk data (stubbed for now).
//
// Design Choices:
//   ‚Ä¢ Separation of initialization (EngineInitializer) from data access (GenerationAPI).
//   ‚Ä¢ Use of `Arc<Mutex>` ensures safe concurrent access to conductor across threads.
//   ‚Ä¢ Returning `Dictionary` aligns with Godot‚Äôs native data structures for FFI.
//   ‚Ä¢ Stubbed `fetch_chunk_data` provides a placeholder for future expansion.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can integrate with external engines
//     (like Godot) via FFI. By combining safe concurrency primitives, modular
//     initialization, and Godot-compatible data types, it creates a bridge
//     between procedural generation logic and game engine scripting.
// ============================================================================


use godot::builtin::Dictionary;
use std::error::Error;
use std::sync::{Arc, Mutex};
use ssxl_generate::Conductor;
use ssxl_shared::AnimationConductorHandle;
use crate::engine::api_initializers::{execute_channel_and_state_setup, GenesisHandles};

#[derive(Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    pub fn new() -> Self { Self::default() }

    pub fn execute_channel_and_state_setup(
        &self,
        config_path: Option<&str>,
    ) -> Result<GenesisHandles, Box<dyn Error>> {
        execute_channel_and_state_setup(config_path)
    }

    pub fn execute_conductor_setup_and_spawn(
        &self,
        handles: GenesisHandles,
    ) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        let conductor_arc = Arc::new(Mutex::new(handles._gen_conductor));
        let anim_handle: AnimationConductorHandle = handles.anim_command_tx.clone();
        (Some(conductor_arc), anim_handle)
    }
}

#[derive(Default)]
pub struct GenerationAPI {}

impl GenerationAPI {
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }
}

// --- END: rust/ssxl_godot/src\engine\api.rs ---
        64 LOC | rust/ssxl_godot/src\engine\api_initializers\mod.rs
// --- START: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
// ============================================================================
// üéº Genesis Channel and State Setup (`crate::genesis`)
// ----------------------------------------------------------------------------
// This module wires together the foundational communication channels and state
// objects required to initialize the SSXL engine. It bundles conductor and
// animation subsystems into a unified "genesis kit" for orchestration.
//
// Purpose:
//   ‚Ä¢ Establish all channels for generation and animation communication.
//   ‚Ä¢ Initialize conductor and animation state objects.
//   ‚Ä¢ Provide a single struct (`GenesisHandles`) that encapsulates all handles.
//   ‚Ä¢ Simplify engine startup by returning a fully wired configuration.
//
// Key Components:
//   ‚Ä¢ Type Aliases
//       - AnimationUpdateReceiver: channel receiver for animation updates.
//       - GenerationCommandTx: channel sender for generation commands.
//       - GenerationResponseRx: channel receiver for generation responses.
//       - These aliases improve readability of channel signatures.
//
//   ‚Ä¢ GenesisHandles (struct)
//       - Bundles all handles, channels, and state objects created during setup.
//       - Fields:
//           ‚Ä¢ gen_state: snapshot of conductor state.
//           ‚Ä¢ anim_state: snapshot of animation state.
//           ‚Ä¢ gen_progress_rx: receiver for generation progress updates.
//           ‚Ä¢ anim_update_rx: receiver for animation updates.
//           ‚Ä¢ anim_command_tx: sender for animation commands.
//           ‚Ä¢ gen_command_tx: sender for generation commands.
//           ‚Ä¢ gen_response_rx: receiver for generation responses.
//           ‚Ä¢ _gen_conductor: internal conductor instance (not exposed).
//           ‚Ä¢ _anim_rx: internal receiver for animation commands.
//           ‚Ä¢ _anim_update_tx: internal sender for animation updates.
//           ‚Ä¢ _gen_resp_tx: internal sender for generation responses.
//
//   ‚Ä¢ execute_channel_and_state_setup (function)
//       - Initializes all channels and state objects required for the engine.
//       - Arguments:
//           ‚Ä¢ config_path: optional path to configuration file.
//       - Workflow:
//           1. Load configuration from path.
//           2. Create generation command + response channels.
//           3. Initialize conductor via `Conductor::new_for_ffi`.
//           4. Create animation command + update channels.
//           5. Initialize animation state.
//           6. Log successful initialization.
//           7. Return `GenesisHandles` with all handles and channels wired.
//
// Design Choices:
//   ‚Ä¢ Separation of conductor and animation subsystems ensures modularity.
//   ‚Ä¢ Internal fields (`_gen_conductor`, `_anim_rx`, etc.) are retained for
//     lifecycle management but hidden from external API.
//   ‚Ä¢ Logging provides visibility into initialization success.
//   ‚Ä¢ Returning a single struct simplifies downstream orchestration.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can bundle complex initialization
//     logic into a clean, ergonomic API. By combining channels, state objects,
//     and conductor instances into `GenesisHandles`, it provides a reproducible
//     and maintainable foundation for engine startup.
// ============================================================================


use tokio::sync::mpsc;
use ssxl_shared::config::config::get_config_from_path;
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    conductor::ConductorState,
};
use ssxl_shared::AnimationConductorHandle;
use ssxl_shared::message::{
    AnimationCommand,
    AnimationState,
    GenerationCommand,
    GenerationResponse,
    AnimationUpdate,
};
use std::error::Error;
use tracing::info;

pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;
pub type GenerationCommandTx = mpsc::UnboundedSender<GenerationCommand>;
pub type GenerationResponseRx = mpsc::UnboundedReceiver<GenerationResponse>;

pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    pub gen_command_tx: GenerationCommandTx,
    pub gen_response_rx: GenerationResponseRx,
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>,
    pub(crate) _gen_resp_tx: mpsc::UnboundedSender<GenerationResponse>,
}

pub fn execute_channel_and_state_setup(
    config_path: Option<&str>,
) -> Result<GenesisHandles, Box<dyn Error>> {
    let _config = get_config_from_path(config_path);

    let (gen_command_tx, _gen_cmd_rx) = mpsc::unbounded_channel::<GenerationCommand>();
    let (_gen_resp_tx, gen_response_rx) = mpsc::unbounded_channel::<GenerationResponse>();

    let (
        gen_conductor,
        gen_state,
        _internal_gen_cmd_tx,
        _internal_gen_resp_rx,
        gen_progress_rx_inner,
    ) = Conductor::new_for_ffi(config_path)?;

    let (anim_command_tx_inner, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
    let (anim_update_tx, anim_update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();

    let anim_state = AnimationState::default();

    info!("Genesis engine initialized: Conductor + Animation systems ready.");

    Ok(GenesisHandles {
        gen_state,
        anim_state,
        gen_progress_rx: ConductorProgressReceiver::new(gen_progress_rx_inner),
        anim_update_rx,
        anim_command_tx: anim_command_tx_inner,

        gen_command_tx,
        gen_response_rx,
        _gen_conductor: gen_conductor,
        _anim_rx: anim_rx,
        _anim_update_tx: anim_update_tx,
        _gen_resp_tx,
    })
}
// --- END: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
        21 LOC | rust/ssxl_godot/src\engine\cleanup.rs
// --- START: rust/ssxl_godot/src\engine\cleanup.rs ---
// ============================================================================
// üéº Engine Shutdown Logic (`crate::engine::shutdown`)
// ----------------------------------------------------------------------------
// This module defines the `shutdown_logic` function, which provides a clean,
// public-facing API for Godot to explicitly shut down the SSXL engine. It ensures
// that all resources, background threads, and subsystems are gracefully released.
//
// Purpose:
//   ‚Ä¢ Allow Godot scripts to trigger a controlled shutdown of the SSXL engine.
//   ‚Ä¢ Safely tear down the Conductor and related subsystems.
//   ‚Ä¢ Clear references to Godot nodes to prevent dangling pointers.
//   ‚Ä¢ Return a confirmation message compatible with Godot (`GString`).
//
// Key Components:
//   ‚Ä¢ SSXLEngine
//       - Represents the engine state exposed to Godot.
//       - Holds references to conductor, animation subsystems, and Godot nodes.
//   ‚Ä¢ state! macro
//       - Provides safe access to the internal state of `SSXLEngine`.
//   ‚Ä¢ Arc + Mutex
//       - Used to manage shared ownership of the Conductor across threads.
//       - `Arc::try_unwrap` ensures teardown only occurs if the Conductor is
//         uniquely owned, preventing unsafe shutdowns.
//
// Workflow:
//   1. Access the engine‚Äôs internal state via the `state!` macro.
//   2. If a Conductor exists:
//        ‚Ä¢ Attempt to unwrap the `Arc<Mutex<Conductor>>`.
//        ‚Ä¢ If successful, call `graceful_teardown()` on the Conductor.
//        ‚Ä¢ If not unique or poisoned, skip teardown safely.
//   3. Clear other subsystems:
//        ‚Ä¢ conductor_state
//        ‚Ä¢ animation_conductor
//        ‚Ä¢ animation_state
//   4. Clear Godot node references:
//        ‚Ä¢ signals_node
//        ‚Ä¢ tilemap_node
//   5. Return a Godot-compatible confirmation message (`GString`).
//
// Design Choices:
//   ‚Ä¢ Graceful teardown ensures background tasks and channels are closed cleanly.
//   ‚Ä¢ Clearing subsystems prevents memory leaks and dangling references.
//   ‚Ä¢ Returning a `GString` integrates seamlessly with Godot‚Äôs scripting layer.
//   ‚Ä¢ Defensive use of `Arc::try_unwrap` avoids unsafe shutdown in multi-threaded contexts.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust can safely manage engine lifecycle
//     when integrated with external systems like Godot. By combining concurrency
//     primitives, structured teardown, and Godot-compatible types, it ensures
//     stability and reliability during engine shutdown.
// ============================================================================


use godot::prelude::*;
use std::sync::Arc;

use crate::engine::state as state_module;
use state_module::{SSXLEngine, state};

pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    let state = state!(engine);
    
    if let Some(conductor_arc) = state.conductor.take() {
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok()
            .and_then(|m| m.into_inner().ok())
        {
            conductor.graceful_teardown();
        }
    }
    
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    state.signals_node.take();
    state.tilemap_node.take();

    "SSXLEngine resources shut down and released.".into()
}

// --- END: rust/ssxl_godot/src\engine\cleanup.rs ---
        26 LOC | rust/ssxl_godot/src\engine\commands.rs
// --- START: rust/ssxl_godot/src\engine\commands.rs ---
// ============================================================================
// üéº Engine Control Logic (`crate::engine::control_logic`)
// ----------------------------------------------------------------------------
// This module defines public-facing functions that allow Godot scripts to
// control the SSXL engine at runtime. These functions provide safe access to
// the engine‚Äôs internal state and expose key orchestration commands.
//
// Purpose:
//   ‚Ä¢ Allow Godot to stop terrain generation gracefully.
//   ‚Ä¢ Enable or disable animation subsystems dynamically.
//   ‚Ä¢ Switch active terrain generators mid-session.
//   ‚Ä¢ Provide a clean, script-friendly API surface for engine control.
//
// Key Components:
//   ‚Ä¢ SSXLEngine
//       - Represents the engine state exposed to Godot.
//       - Holds references to conductor, animation subsystems, and channels.
//   ‚Ä¢ state! macro
//       - Provides safe access to the internal state of `SSXLEngine`.
//   ‚Ä¢ AnimationCommand
//       - Enum representing commands sent to the animation conductor.
//       - Includes variants like `SetEnabled` for toggling animation systems.
//
// Functions:
//   ‚Ä¢ stop_generation_logic
//       - Gracefully halts the current generation process.
//       - Workflow:
//           1. Access engine state via `state!`.
//           2. If a conductor exists, acquire its lock.
//           3. Call `stop_generation()` on the conductor.
//           4. Errors (e.g., lock poisoning) are ignored silently.
//
//   ‚Ä¢ set_animation_enabled_logic
//       - Toggles the animation conductor (flow fields, particle systems, etc.).
//       - Workflow:
//           1. Access engine state via `state!`.
//           2. If an animation conductor channel exists, send `SetEnabled` command.
//           3. Errors (e.g., channel closed) are ignored silently.
//
//   ‚Ä¢ set_generator_logic
//       - Switches the active generator mid-session.
//       - Useful for dynamic biome switching or experimentation.
//       - Workflow:
//           1. Access engine state via `state!`.
//           2. If a conductor exists, acquire its lock.
//           3. Call `set_generator()` with the new generator name.
//           4. Convert Godot‚Äôs `GString` into a Rust `String` before passing.
//           5. Errors are ignored silently.
//
// Design Choices:
//   ‚Ä¢ Defensive programming: all functions ignore errors silently to prevent
//     runtime crashes in Godot scripts.
//   ‚Ä¢ Use of `Arc<Mutex>` ensures safe concurrent access to conductor state.
//   ‚Ä¢ Godot-compatible types (`GString`) allow seamless FFI integration.
//   ‚Ä¢ Separation of control logic into standalone functions keeps API surface clean.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can expose safe, script-friendly
//     orchestration commands to external engines like Godot. By combining
//     concurrency primitives, enums for structured commands, and FFI-compatible
//     types, it creates a robust bridge between procedural generation logic
//     and game engine scripting.
// ============================================================================


use godot::prelude::*;
use ssxl_shared::AnimationCommand;
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            let _ = c.set_generator(&name.to_string());
        }
    }
}

// --- END: rust/ssxl_godot/src\engine\commands.rs ---
       110 LOC | rust/ssxl_godot/src\engine\init.rs
// --- START: rust/ssxl_godot/src\engine\init.rs ---
// ============================================================================
// üéº SSXL Engine Godot API (`crate::engine::ssxl_engine`)
// ----------------------------------------------------------------------------
// This module exposes the SSXL engine‚Äôs functionality to the Godot game engine
// via the `#[godot_api]` and `#[func]` attributes. It bridges Rust‚Äôs procedural
// generation system with Godot‚Äôs scripting layer, enabling game developers to
// control and query the engine directly from GDScript.
//
// Purpose:
//   ‚Ä¢ Provide a public-facing API for initializing, controlling, and querying
//     the SSXL engine from Godot.
//   ‚Ä¢ Wire conductor, animation, and generation subsystems into Godot‚Äôs runtime.
//   ‚Ä¢ Ensure safe lifecycle management with graceful startup and shutdown.
//   ‚Ä¢ Expose ergonomic methods for terrain generation, animation toggling,
//     and engine state queries.
//
// Key Components:
//   ‚Ä¢ SSXLEngine (struct)
//       - Core engine state exposed to Godot.
//       - Holds conductor, animation handles, and runtime state.
//   ‚Ä¢ initialize_runtime_shell
//       - Public entry point for initializing the engine runtime.
//       - Wires channels, conductor, and animation subsystems.
//       - Returns success/failure as a boolean to Godot.
//   ‚Ä¢ initialize_runtime_shell_logic (private)
//       - Internal setup logic separated from public API.
//       - Creates channels, spawns conductor threads, and stores handles.
//   ‚Ä¢ shutdown
//       - Gracefully tears down engine resources via `cleanup::shutdown_logic`.
//   ‚Ä¢ build_map
//       - Stubbed method for starting a new generation run.
//   ‚Ä¢ stop_generation
//       - Halts current generation tasks via `commands::stop_generation_logic`.
//   ‚Ä¢ set_animation_enabled
//       - Toggles animation conductor (flow fields, particles) on/off.
//   ‚Ä¢ set_generator
//       - Switches active generator mid-session (biome switching).
//   ‚Ä¢ get_current_tile_count
//       - Returns total number of tiles generated so far.
//   ‚Ä¢ get_status
//       - Returns human-readable engine status string.
//   ‚Ä¢ get_active_generator_id
//       - Returns the ID of the currently active generator.
//   ‚Ä¢ fetch_chunk_data
//       - Stubbed method returning an empty `Dictionary` for chunk data.
//   ‚Ä¢ process_engine_tick
//       - Must be called every frame to update engine state.
//       - Increments tick counter and processes async messages.
//
// Design Choices:
//   ‚Ä¢ Separation of public API (`#[func]`) from internal logic ensures clarity.
//   ‚Ä¢ Defensive error handling prevents runtime crashes in Godot scripts.
//   ‚Ä¢ Logging (`info`, `error`) provides visibility into lifecycle events.
//   ‚Ä¢ Godot-compatible types (`GString`, `Dictionary`, `Node`) ensure seamless FFI.
//   ‚Ä¢ Stubbed methods (`build_map`, `fetch_chunk_data`) provide placeholders
//     for future expansion.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can integrate deeply with Godot via
//     FFI. By exposing structured APIs with safe concurrency and lifecycle
//     management, SSXL enables developers to harness procedural generation
//     directly in their game scripts while maintaining reliability and clarity.
// ============================================================================


use godot::prelude::*;
use tokio::sync::mpsc::UnboundedSender;
use godot::classes::{Node, TileMap}; 
use godot::builtin::Dictionary;
use std::error::Error;
use tracing::{info, error};
use crate::engine::__godot_SSXLEngine_Funcs;
use super::state::SSXLEngine;
use crate::engine::tick::process_engine_tick;
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};
use crate::engine::cleanup::shutdown_logic;
use ssxl_shared::AnimationConductorHandle;
use ssxl_shared::message::{AnimationCommand, GenerationCommand};
// --- ASSUMED IMPORTS FOR BUILD_MAP_BY_SIZE LOGIC ---
use ssxl_shared::{CHUNK_SIZE, TileCoord}; // Added TileCoord import
use ssxl_math::prelude::Vec2i; 
use ssxl_generate::task::task_queue::GenerationTask; 
// ---------------------------------------------------

#[godot_api]
impl SSXLEngine {
    #[func]
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                self.shutdown();
                false
            }
        }
    }

    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // Clone the necessary senders before moving 'handles'.
        let anim_command_tx_for_internal_state: AnimationConductorHandle = handles.anim_command_tx.clone();
        let gen_command_tx_clone = handles.gen_command_tx.clone();

        // 'handles' is moved into this function
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);
        
        internal_state.request_sender = gen_command_tx_clone; 

        info!("SSXL Channels successfully wired to AsyncPoller.");

        Ok(())
    }

    #[func]
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    #[func]
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        // GDExt stub that takes a Dictionary.
        true
    }
    
    // -------------------------------------------------
    // PUBLIC API FUNCTIONS
    // -------------------------------------------------

    /// Exposes the TileMap reference setter. (API: set_tilemap)
    #[func]
    pub fn set_tilemap(&mut self, tilemap: Gd<TileMap>) {
        let internal_state = unsafe { &mut *self._internal_state.get() };
        internal_state.tilemap_node = Some(tilemap);
        info!("TileMap reference set in GDExtension.");
    }
    
    /// Exposes the FFI-style map build based on size. (API: build_map)
    #[func]
    pub fn build_map_by_size(&mut self, width: i32, height: i32, generator_id: GString) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        if internal_state.request_sender.is_closed() {
            error!("Conductor is shut down. Cannot request map.");
            return;
        }

        let chunks_x = width.div_ceil(CHUNK_SIZE as i32);
        let chunks_y = height.div_ceil(CHUNK_SIZE as i32);
        
        // NOTE: The generator_id parameter is being ignored here because
        // we can only send one command type: GenerateChunk. 
        // A proper fix would involve updating GenerationCommand in ssxl_shared/src/message/messages.rs
        // to have a variant like GenerationCommand::StartTask(GenerationTask).

        for x in 0..chunks_x {
            for y in 0..chunks_y {
                // FIX E0599: Instead of wrapping a GenerationTask, we create the command 
                // using the existing GenerationCommand::GenerateChunk variant.
                let command = GenerationCommand::GenerateChunk { 
                    coords: TileCoord::from(Vec2i::new(x as i64, y as i64)), // Assuming TileCoord::from(Vec2i) exists
                };
                
                let _ = internal_state.request_sender.send(command);
            }
        }

        info!("Sent {} generation tasks.", chunks_x * chunks_y);
    }
    
    // -------------------------------------------------

    #[func]
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }

    #[func]
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    #[func]
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }

    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    #[func]
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    #[func]
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }

    #[func]
    pub fn process_engine_tick(&mut self) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}
// --- END: rust/ssxl_godot/src\engine\init.rs ---
        18 LOC | rust/ssxl_godot/src\engine\mod.rs
// --- START: rust/ssxl_godot/src\engine\mod.rs ---
// ============================================================================
// üéº Engine Module Root (`crate::engine::mod.rs`)
// ----------------------------------------------------------------------------
// This file defines the structure of the `engine` module in the SSXL Godot
// integration. It acts as the central hub, organizing all submodules and
// re-exporting key items so external code can access them easily.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for the engine layer.
//   ‚Ä¢ Organize submodules into clear responsibilities (init, API, tick, commands, etc.).
//   ‚Ä¢ Re-export important functions and types for ergonomic external use.
//   ‚Ä¢ Provide a single entry point for accessing the `SSXLEngine` Godot class.
//
// Key Components:
//   ‚Ä¢ #[macro_use] state
//       - Imports macros defined in the `state` module (e.g., `state!`).
//       - Ensures macros are available throughout the engine without explicit imports.
//   ‚Ä¢ Submodules
//       - init: Runtime initialization logic (channels, conductor setup).
//       - api: Public-facing API for Godot to interact with the engine.
//       - tick: Game loop integration, processes engine state each frame.
//       - commands: Lightweight runtime commands (stop generation, toggle animation, switch generator).
//       - query: Read-only queries for engine state (tile count, status, active generator).
//       - cleanup: Graceful shutdown and resource release logic.
//       - render_batch: Rendering-related batch operations (integration with Godot visuals).
//       - query_data: Data access layer for chunk/tile queries.
//       - api_initializers: Helper functions for setting up channels and conductor state.
//   ‚Ä¢ Re-exports
//       - Flatten the API surface so external code can import directly from `engine`
//         without drilling down into submodules.
//       - Example:
//           Without re-export ‚Üí `use crate::engine::commands::stop_generation_logic;`
//           With re-export    ‚Üí `use crate::engine::stop_generation_logic;`
//   ‚Ä¢ SSXLEngine
//       - The Godot-exposed class representing the engine state.
//       - Re-exported here for clean external access, so consumers only need
//         `use crate::engine::SSXLEngine;`.
//
// Design Choices:
//   ‚Ä¢ Centralized organization improves discoverability and maintainability.
//   ‚Ä¢ Re-exports flatten hierarchy for ergonomic usage in external crates.
//   ‚Ä¢ Macro import ensures consistent access to state management utilities.
//   ‚Ä¢ Modular separation of concerns keeps each file focused and testable.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust projects can use `mod.rs` files as
//     organizational hubs. By combining submodule declarations, macro imports,
//     and re-exports, SSXL provides a clean, ergonomic API surface while
//     maintaining internal modularity.
// ============================================================================


#[macro_use] 
pub mod state;

pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
pub mod api_initializers; 

pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

pub use state::SSXLEngine;

// --- END: rust/ssxl_godot/src\engine\mod.rs ---
        60 LOC | rust/ssxl_godot/src\engine\poller.rs
// --- START: rust/ssxl_godot/src\engine\poller.rs ---
// ============================================================================
// üéº AsyncPoller (`crate::engine::async_poller`)
// ----------------------------------------------------------------------------
// This module defines the `AsyncPoller` struct, which is responsible for
// non-blocking draining of asynchronous channels in the SSXL engine. It
// provides a unified interface for collecting both generation results and
// animation updates without stalling the runtime.
//
// Purpose:
//   ‚Ä¢ Manage asynchronous communication between engine subsystems.
//   ‚Ä¢ Provide non-blocking polling for generation messages and animation updates.
//   ‚Ä¢ Handle channel disconnections gracefully by disabling receivers.
//   ‚Ä¢ Collect messages into `VecDeque` for batch processing.
//
// Key Components:
//   ‚Ä¢ AsyncPoller (struct)
//       - Holds two optional channel receivers:
//           ‚Ä¢ gen_rx: receives heavy generation results (chunks, progress).
//           ‚Ä¢ anim_rx: receives lightweight animation updates (flow fields, particles).
//       - Both receivers are wrapped in `Option<T>` to allow flexible initialization
//         and safe disabling when channels disconnect.
//
//   ‚Ä¢ Default Implementation
//       - Provides an empty `AsyncPoller` with no channels set.
//       - Useful for initializing before wiring channels during runtime setup.
//
//   ‚Ä¢ Methods
//       - set_generation_receiver
//           ‚Ä¢ Assigns the receiver for generation messages.
//           ‚Ä¢ Called during initialization when channels are created.
//       - set_animation_receiver
//           ‚Ä¢ Assigns the receiver for animation updates.
//           ‚Ä¢ Called during initialization when channels are created.
//       - poll_generation_messages
//           ‚Ä¢ Drains all available generation messages using `try_recv()`.
//           ‚Ä¢ Collects messages into a `VecDeque` for batch processing.
//           ‚Ä¢ If channel disconnects, logs a warning and disables receiver.
//       - poll_animations
//           ‚Ä¢ Drains all available animation updates using `try_recv()`.
//           ‚Ä¢ Collects updates into a `VecDeque` for batch processing.
//           ‚Ä¢ If channel disconnects, logs a warning and disables receiver.
//
// Design Choices:
//   ‚Ä¢ Non-blocking polling ensures the engine remains responsive.
//   ‚Ä¢ `VecDeque` provides efficient push/pop operations for batch collection.
//   ‚Ä¢ Logging (`warn!`) provides visibility into unexpected channel disconnections.
//   ‚Ä¢ Optional receivers (`Option<T>`) allow safe handling of missing or disconnected channels.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust‚Äôs async channels can be integrated into
//     a polling system that avoids blocking the runtime. By combining `try_recv()`,
//     structured logging, and safe handling of disconnections, `AsyncPoller` provides
//     a robust foundation for managing asynchronous communication in game engines.
// ============================================================================


use tokio::sync::mpsc::Receiver as TokioReceiver;
use ssxl_generate::task_queue::GenerationMessage; 
use ssxl_shared::message::messages::AnimationUpdate; 
use std::collections::VecDeque;
use tracing::warn; 
use tokio::sync::mpsc::error::TryRecvError;

pub struct AsyncPoller {
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

impl AsyncPoller {
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        if let Some(rx) = &mut self.gen_rx {
            loop {
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None;
                        break;
                    }
                }
            }
        }
        messages
    }

    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None;
                        break;
                    }
                }
            }
        }
        updates
    }
}

// --- END: rust/ssxl_godot/src\engine\poller.rs ---
        24 LOC | rust/ssxl_godot/src\engine\query.rs
// --- START: rust/ssxl_godot/src\engine\query.rs ---
// ============================================================================
// üéº Engine Query Logic (`crate::engine::query`)
// ----------------------------------------------------------------------------
// This module defines read-only query functions that expose engine state to
// Godot scripts. These functions provide safe, side-effect-free access to
// information about the SSXL engine‚Äôs current status, tile counts, and active
// generator identity.
//
// Purpose:
//   ‚Ä¢ Allow Godot scripts to query engine state without mutating it.
//   ‚Ä¢ Provide human-readable status reports and numeric summaries.
//   ‚Ä¢ Safely handle concurrency when accessing conductor state.
//   ‚Ä¢ Return Godot-compatible types (`GString`, `u64`) for seamless FFI.
//
// Key Components:
//   ‚Ä¢ get_current_tile_count_logic
//       - Returns the total number of tiles generated so far.
//       - Workflow:
//           1. Access engine state via `state!` macro.
//           2. Call `StatusReporter::get_current_tile_count_value` with conductor state.
//           3. Return tile count as `u64`.
//
//   ‚Ä¢ get_status_logic
//       - Returns a human-readable engine status string.
//       - Example: "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
//       - Workflow:
//           1. Access engine state via `state!` macro.
//           2. Call `StatusReporter::get_status_report` with conductor and animation state.
//           3. Return result as `GString`.
//
//   ‚Ä¢ get_active_generator_id_logic
//       - Returns the name of the currently active generator.
//       - Examples: "perlin", "cellular", "simplex", "custom_my_gen".
//       - Workflow:
//           1. Access engine state via `state!` macro.
//           2. Check if conductor exists (`Option<Arc<Mutex<Conductor>>>`).
//           3. If None ‚Üí return `"Not Initialized"`.
//           4. If Some ‚Üí attempt to acquire lock on conductor.
//           5. On success ‚Üí call `get_active_generator_id()` and convert to `GString`.
//           6. On failure (mutex poisoned) ‚Üí return `"Mutex Poisoned"`.
//
// Design Choices:
//   ‚Ä¢ Queries are side-effect-free, ensuring safe read-only access.
//   ‚Ä¢ Defensive handling of `Option` and `Mutex` prevents runtime crashes.
//   ‚Ä¢ Integration with `StatusReporter` centralizes reporting logic.
//   ‚Ä¢ Returning Godot-native types ensures compatibility with GDScript.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can expose safe, read-only queries
//     to external engines like Godot. By combining concurrency primitives,
//     defensive programming, and FFI-compatible types, it provides a robust
//     interface for monitoring engine state without risking mutation.
// ============================================================================


use godot::prelude::*;
use crate::tilemap::status_reporter::StatusReporter;
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}

// --- END: rust/ssxl_godot/src\engine\query.rs ---
         6 LOC | rust/ssxl_godot/src\engine\query_data.rs
// --- START: rust/ssxl_godot/src\engine\query_data.rs ---
// ============================================================================
// üéº Chunk Data Query Logic (`crate::engine::query_data`)
// ----------------------------------------------------------------------------
// This module defines the `fetch_chunk_data_logic` function, which provides
// Godot scripts with read-only access to specific chunk data generated by the
// SSXL engine. It acts as a bridge between Rust‚Äôs generation API and Godot‚Äôs
// scripting layer.
//
// Purpose:
//   ‚Ä¢ Allow Godot to request structured chunk data by coordinates (x, y).
//   ‚Ä¢ Provide a safe, side-effect-free query into the engine‚Äôs generation API.
//   ‚Ä¢ Return results in Godot‚Äôs native `Dictionary` type for seamless FFI.
//
// Key Components:
//   ‚Ä¢ SSXLEngine
//       - Core engine struct exposed to Godot.
//       - Holds references to subsystems including the generation API.
//   ‚Ä¢ state! macro
//       - Provides scoped access to the internal state of `SSXLEngine`.
//       - Expands to code that dereferences the internal state pointer safely.
//   ‚Ä¢ Dictionary
//       - Godot‚Äôs built-in key-value container type.
//       - Used here to return chunk data in a format that Godot scripts can consume.
//
// Function: fetch_chunk_data_logic
//   ‚Ä¢ Arguments:
//       - engine: mutable reference to `SSXLEngine`.
//         (mutable required because `state!` macro dereferences internal state,
//         even though this function itself does not mutate).
//       - x, y: integer coordinates of the chunk being requested.
//   ‚Ä¢ Workflow:
//       1. Access engine‚Äôs internal state via `state!` macro.
//       2. Call `generation_api.fetch_chunk_data(x, y)`.
//       3. Return the resulting `Dictionary` to Godot.
//   ‚Ä¢ Returns:
//       - Dictionary containing chunk data (tiles, metadata, etc.).
//       - The exact contents depend on the implementation of `generation_api`.
//
// Design Choices:
//   ‚Ä¢ Query-only function ensures no mutation or side effects.
//   ‚Ä¢ Returning `Dictionary` aligns with Godot‚Äôs native data structures.
//   ‚Ä¢ Encapsulation via `generation_api` centralizes data retrieval logic.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust can expose safe, read-only queries
//     to external engines like Godot. By combining macro-based state access,
//     structured data containers, and FFI integration, it provides a clean,
//     ergonomic interface for retrieving chunk data in game scripts.
// ============================================================================


use godot::builtin::Dictionary; 
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    state!(engine).generation_api.fetch_chunk_data(x, y)
}

// --- END: rust/ssxl_godot/src\engine\query_data.rs ---
        42 LOC | rust/ssxl_godot/src\engine\render_batch.rs
// --- START: rust/ssxl_godot/src\engine\render_batch.rs ---
// ============================================================================
// üé® Render Batch Dictionary (`crate::engine::render_batch`)
// ----------------------------------------------------------------------------
// This module defines the `create_render_batch_dictionary` function, which
// translates raw `ChunkData` from the SSXL engine into a Godot-compatible
// `Dictionary`. The dictionary is structured specifically for Godot‚Äôs TileMap
// API, enabling efficient rendering of terrain chunks.
//
// Purpose:
//   ‚Ä¢ Convert engine-generated tile data into Godot-native structures.
//   ‚Ä¢ Provide arrays of positions, source IDs, atlas coordinates, and alt tiles.
//   ‚Ä¢ Act as the bridge between Rust‚Äôs generation system and Godot‚Äôs rendering layer.
//
// Key Components:
//   ‚Ä¢ CHUNK_SIZE
//       - Fixed dimension of a chunk (32x32 tiles).
//   ‚Ä¢ DEFAULT_SOURCE_ID
//       - Default identifier for the tile source in Godot‚Äôs TileMap.
//   ‚Ä¢ Dictionary
//       - Godot‚Äôs built-in key-value container used to return structured data.
//   ‚Ä¢ PackedInt32Array
//       - Efficient array type for storing integer sequences (positions, IDs, coords).
//   ‚Ä¢ TileType
//       - Enum describing tile types (grass, water, empty, etc.).
//       - Provides helpers like `is_empty()` and atlas coordinate lookup.
//
// Function: create_render_batch_dictionary
//   ‚Ä¢ Arguments:
//       - chunk_data: reference to `ChunkData` containing tile information.
//       - chunk_x, chunk_y: coordinates of the chunk in world space.
//   ‚Ä¢ Workflow:
//       1. Initialize output dictionary and arrays for rendering data.
//       2. Iterate over every tile in the chunk grid (32x32).
//       3. Skip empty tiles (no rendering needed).
//       4. Compute world-space coordinates for each tile.
//       5. Push positions, source IDs, atlas coordinates, and alt tile indices.
//       6. Store arrays into dictionary (converted to Godot Variants).
//       7. Log debug message if any tiles were prepared.
//       8. Return the fully constructed dictionary.
//   ‚Ä¢ Returns:
//       - Dictionary formatted for Godot‚Äôs TileMap API, e.g.:
//         {
//            "layer": 0,
//            "positions": PackedInt32Array [x1, y1, x2, y2, ...],
//            "source_ids": PackedInt32Array [id, id, ...],
//            "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
//            "alt_tiles": PackedInt32Array [0, 0, ...]
//         }
//
// Design Choices:
//   ‚Ä¢ Non-empty tiles only ‚Üí avoids unnecessary rendering overhead.
//   ‚Ä¢ Default source ID simplifies integration with Godot TileSets.
//   ‚Ä¢ Atlas coordinates provide flexible mapping to visual assets.
//   ‚Ä¢ Logging ensures visibility into rendering pipeline performance.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust can act as a translation layer
//     between procedural generation systems and external rendering engines.
//     By structuring data into Godot-native containers, it ensures seamless
//     integration while maintaining efficiency and clarity.
// ============================================================================


use godot::builtin::*;
use ssxl_shared::{ChunkData, TileType};
use godot::prelude::ToGodot; 

pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    let mut dict = Dictionary::new();

    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    dict.set("layer", 0i64);

    let mut tile_count = 0usize;

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let idx = (y * CHUNK_SIZE + x) as usize;

            if let Some(tile) = chunk_data.tiles.get(idx) {
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                positions.push(world_x);
                positions.push(world_y);

                source_ids.push(DEFAULT_SOURCE_ID);

                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                alt_tiles.push(0);

                tile_count += 1;
            }
        }
    }

    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    dict
}

// --- END: rust/ssxl_godot/src\engine\render_batch.rs ---
        55 LOC | rust/ssxl_godot/src\engine\state.rs
// --- START: rust/ssxl_godot/src\engine\state.rs ---
// ============================================================================
// üéº SSXL Engine State & Godot Integration (`crate::engine::state`)
// ----------------------------------------------------------------------------
// This module defines the internal state management and Godot-facing class
// for the SSXL engine. It provides the bridge between Rust‚Äôs procedural
// generation system and Godot‚Äôs scripting layer.
//
// Purpose:
//   ‚Ä¢ Encapsulate all runtime state of the SSXL engine in `InternalState`.
//   ‚Ä¢ Provide safe access to internal state via the `state!` macro.
//   ‚Ä¢ Expose `SSXLEngine` as a Godot class, enabling direct interaction
//     from GDScript while maintaining Rust‚Äôs safety guarantees.
//
// Key Components:
//   ‚Ä¢ state! macro
//       - Provides safe access to the `_internal_state` field inside `SSXLEngine`.
//       - Two forms:
//           ‚Ä¢ Expression form: `state!(self)` ‚Üí returns mutable reference.
//           ‚Ä¢ Statement form: `state!(self, name)` ‚Üí binds reference to local variable.
//       - Required because `_internal_state` is wrapped in `UnsafeCell`.
//       - Ensures interior mutability while respecting Godot‚Äôs object ownership.
//
//   ‚Ä¢ InternalState (struct)
//       - Holds all non-FFI-safe runtime state for the engine.
//       - Fields:
//           ‚Ä¢ conductor: shared `Conductor` instance (Arc<Mutex<Conductor>>).
//           ‚Ä¢ conductor_state: snapshot of conductor status.
//           ‚Ä¢ animation_conductor: handle for animation commands.
//           ‚Ä¢ animation_state: snapshot of animation status.
//           ‚Ä¢ signals_node: Godot Node for emitting signals.
//           ‚Ä¢ tilemap_node: Godot TileMap for rendering.
//           ‚Ä¢ initializer: bootstraps conductor threads and channels.
//           ‚Ä¢ poller: drains async channels (generation + animation).
//           ‚Ä¢ genesis_handles: optional initialization handles.
//           ‚Ä¢ generation_api: API for chunk data queries.
//           ‚Ä¢ tick_count: frame counter for engine ticks.
//       - Implements `Default` to provide an empty, safe initial state.
//
//   ‚Ä¢ SSXLEngine (struct)
//       - The Godot-facing class exposed to GDScript.
//       - Attributes:
//           ‚Ä¢ #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//             - Marks SSXLEngine as a Godot class.
//             - `tool`: usable in Godot editor.
//             - `base = Node`: inherits from Godot‚Äôs Node.
//             - `init`: ensures proper initialization.
//       - Fields:
//           ‚Ä¢ base: Godot Node base.
//           ‚Ä¢ _internal_state: UnsafeCell<InternalState>, hidden from Godot.
//       - Wraps `InternalState` inside `UnsafeCell` to allow interior mutability,
//         since Godot owns object lifetime and Rust must adapt.
//
// Design Choices:
//   ‚Ä¢ Separation of `InternalState` from `SSXLEngine` keeps FFI-safe and
//     non-FFI-safe concerns distinct.
//   ‚Ä¢ Use of `Arc<Mutex>` ensures safe concurrent access to conductor state.
//   ‚Ä¢ `UnsafeCell` provides controlled interior mutability required by Godot.
//   ‚Ä¢ Macro-based access (`state!`) ensures consistent and safe state handling.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can integrate deeply with Godot by
//     exposing classes via `GodotClass` while maintaining strong safety
//     guarantees. By combining concurrency primitives, interior mutability,
//     and macro-based access, it creates a robust foundation for bridging
//     procedural generation logic with Godot‚Äôs scripting environment.
// ============================================================================


use godot::prelude::*;
use godot::classes::{TileMap, Node};
use std::cell::UnsafeCell;
use std::sync::{Arc, Mutex};
use ssxl_shared::AnimationConductorHandle;
use ssxl_generate::{Conductor, conductor::ConductorState}; 
use ssxl_shared::AnimationState;
use ssxl_shared::message::GenerationCommand;
use crate::tilemap::async_poll::AsyncPoller; 
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 
use crate::engine::api::{GenerationAPI, EngineInitializer};
// FIX: ADDED IMPORTS FOR SENDER
use tokio::sync::mpsc::{unbounded_channel, UnboundedSender};
use ssxl_generate::task::task_queue::GenerationTask;

#[macro_export]
macro_rules! state {
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

pub use state; 

pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    // FIX: ADDED MISSING FIELD for map generation requests
    pub request_sender: UnboundedSender<GenerationCommand>, 

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    pub tick_count: u64,
}

impl Default for InternalState {
    fn default() -> Self {
        // FIX: Initialize the sender (unconnected at this stage)
        let (request_sender, _redundant_gen_rx) = unbounded_channel(); 
        
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            // FIX: Assign the initialized sender
            request_sender,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            tick_count: 0,
        }
    }
}

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}
// --- END: rust/ssxl_godot/src\engine\state.rs ---
        65 LOC | rust/ssxl_godot/src\engine\tick.rs
// --- START: rust/ssxl_godot/src\engine\tick.rs ---
// ============================================================================
// üéº Engine Tick Processing (`crate::engine::tick`)
// ----------------------------------------------------------------------------
// This module defines the `process_engine_tick` function, which is called once
// per frame by Godot. It serves as the heartbeat of the SSXL engine, ensuring
// that generation and animation messages are processed, signals are emitted,
// and the engine state advances consistently.
//
// Purpose:
//   ‚Ä¢ Poll asynchronous channels for generation and animation updates.
//   ‚Ä¢ Translate raw engine messages into Godot-compatible signals.
//   ‚Ä¢ Drive rendering updates (chunks, tile flips) and status reporting.
//   ‚Ä¢ Emit a tick completion signal to mark the end of each frame.
//
// Key Components:
//   ‚Ä¢ SSXLEngine
//       - The Godot-facing engine struct wrapping `InternalState`.
//       - Provides access to conductor, poller, and signals node.
//   ‚Ä¢ SSXLSignals
//       - Godot signal interface used to emit events back to GDScript.
//       - Bridges Rust engine events with Godot script callbacks.
//   ‚Ä¢ GenerationMessage
//       - Enum representing messages from the generation system.
//       - Variants include `Generated(chunk)`, `StatusUpdate(string)`,
//         and `GenerationComplete`.
//   ‚Ä¢ create_render_batch_dictionary
//       - Utility function that converts `ChunkData` into a Godot `Dictionary`
//         formatted for TileMap rendering.
//   ‚Ä¢ AnimationPayload
//       - Represents animation updates (e.g., frame flips).
//
// Function: process_engine_tick
//   ‚Ä¢ Arguments:
//       - engine: mutable reference to `SSXLEngine`.
//       - tick: current tick counter (frame number).
//   ‚Ä¢ Workflow:
//       1. Access internal state via `UnsafeCell`.
//       2. Ensure conductor and signals node exist; return early if missing.
//       3. Cast signals node to `SSXLSignals` for emitting signals.
//       4. Poll generation messages:
//           ‚Ä¢ On `Generated`: convert chunk to render batch and emit signal.
//           ‚Ä¢ On `StatusUpdate`: emit engine status update signal.
//           ‚Ä¢ On `GenerationComplete`: emit build completion signal.
//       5. Poll animation messages:
//           ‚Ä¢ On `FrameUpdate`: emit tile flip update signals.
//       6. Emit `tick_complete` signal with current tick number.
//   ‚Ä¢ Returns:
//       - No return value; side effects are emitted signals to Godot.
//
// Design Choices:
//   ‚Ä¢ Defensive programming: early returns if conductor or signals node missing.
//   ‚Ä¢ Non-blocking polling ensures responsiveness each frame.
//   ‚Ä¢ Logging (`debug!`) provides visibility into tick activity.
//   ‚Ä¢ Signals provide a clean, script-friendly interface for Godot integration.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust can orchestrate real-time engine
//     updates while integrating seamlessly with Godot‚Äôs signal system. By
//     translating internal messages into Godot-native events, it ensures
//     that procedural generation and animation remain synchronized with
//     the game loop.
// ============================================================================


use godot::prelude::*;
use super::state::SSXLEngine;
use super::render_batch::create_render_batch_dictionary;
use crate::ffi::signals::*; 
use godot::builtin::GString; 
use tracing::debug;
use ssxl_shared::message::generation_message::GenerationMessage; 

pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    let state = unsafe { &mut *engine._internal_state.get() };
    
    let Some(_conductor) = &state.conductor else { return };
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    let messages = state.poller.poll_generation();
    for msg in messages {
        match msg {
            GenerationMessage::Generated(_, chunk) => {
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
        }
    }

    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(),
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}

// --- END: rust/ssxl_godot/src\engine\tick.rs ---
        17 LOC | rust/ssxl_godot/src\ffi\gde_api_defs.rs
// --- START: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
// ============================================================================
// üéº SSXL Godot Extension Entry (`lib.rs` or equivalent)
// ----------------------------------------------------------------------------
// This module defines the entry point and lifecycle bindings for integrating
// the SSXL engine with Godot via GDExtension. It ensures that the Rust-based
// `SSXLEngine` struct is properly registered as a Godot class and participates
// in the engine‚Äôs scene graph lifecycle.
//
// Purpose:
//   ‚Ä¢ Register `SSXLEngine` as a Godot class so it can be instantiated in GDScript.
//   ‚Ä¢ Bind Rust implementations of lifecycle methods (_init, _process, _ready)
//     to Godot‚Äôs Node lifecycle.
//   ‚Ä¢ Provide the mandatory extension entry point (`ssxl_godot_init`) for Godot.
//
// Key Components:
//   ‚Ä¢ #[gdextension] ssxl_godot_init
//       - Mandatory entry point for Godot‚Äôs GDExtension system.
//       - Called automatically when the dynamic library is loaded.
//       - Registers `SSXLEngine` with Godot via `builder.add_class::<SSXLEngine>()`.
//       - Declared `unsafe` because it interacts directly with Godot‚Äôs C/C++ runtime.
//
//   ‚Ä¢ ExtensionLibrary Implementation for SSXLEngine
//       - Maps Godot‚Äôs virtual methods to Rust implementations:
//           ‚Ä¢ _init: Constructor, runs when SSXLEngine is instantiated.
//             Delegates to `SSXLEngine::init`.
//           ‚Ä¢ _process: Called every frame, passes delta time to engine tick.
//             Delegates to `SSXLEngine::tick`, casting delta to `u64`.
//           ‚Ä¢ _ready: Called once when the node enters the scene tree.
//             Delegates to `SSXLEngine::on_ready` for startup logic.
//       - Ensures SSXLEngine participates fully in Godot‚Äôs scene lifecycle.
//
// Design Choices:
//   ‚Ä¢ Using `#[gdextension]` provides seamless integration with Godot‚Äôs extension system.
//   ‚Ä¢ Delegating lifecycle hooks to SSXLEngine methods keeps responsibilities clear:
//       - Initialization ‚Üí `init`
//       - Frame updates ‚Üí `tick`
//       - Scene setup ‚Üí `on_ready`
//   ‚Ä¢ Unsafe block is minimized to the extension entry point, isolating FFI concerns.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can extend Godot by exposing custom
//     classes via GDExtension. By binding lifecycle methods, it ensures that
//     Rust logic runs in sync with Godot‚Äôs scene graph, enabling powerful
//     procedural generation and engine orchestration directly from GDScript.
// ============================================================================


use godot::prelude::*;
use godot::classes::Node;
use crate::ssxl_engine::SSXLEngine;

#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    builder.add_class::<SSXLEngine>();
}

impl ExtensionLibrary for SSXLEngine {
    fn _init(base: Base<Node>) -> Self {
        SSXLEngine::init(base)
    }

    fn _process(&mut self, delta: f64) {
        self.tick(delta as u64);
    }

    fn _ready(&mut self) {
        self.on_ready();
    }
}

// --- END: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
         4 LOC | rust/ssxl_godot/src\ffi\mod.rs
// --- START: rust/ssxl_godot/src\ffi\mod.rs ---
// ============================================================================
// üéº FFI Module (`crate::ffi`)
// ----------------------------------------------------------------------------
// This module defines the Foreign Function Interface (FFI) layer for the SSXL
// engine. It organizes submodules that handle communication between Rust and
// Godot, and re-exports key types for ergonomic access.
//
// Purpose:
//   ‚Ä¢ Provide a namespace (`ffi`) for all Rust ‚Üî Godot bridging logic.
//   ‚Ä¢ Encapsulate signal definitions and oracle utilities in dedicated submodules.
//   ‚Ä¢ Re-export commonly used types so external code can import them directly
//     from `ffi` without drilling down into submodules.
//
// Key Components:
//   ‚Ä¢ Submodules
//       - oracle.rs
//           ‚Ä¢ Defines the `SSXLOracle` struct.
//           ‚Ä¢ Encapsulates logic for predictive or query-based FFI operations.
//       - signals.rs
//           ‚Ä¢ Defines the `SSXLSignals` struct.
//           ‚Ä¢ Contains signal definitions emitted from Rust to Godot.
//           ‚Ä¢ Provides the bridge between engine events and Godot script callbacks.
//
//   ‚Ä¢ Re-exports
//       - `pub use oracle::SSXLOracle;`
//           ‚Ä¢ Makes `SSXLOracle` available directly via `crate::ffi::SSXLOracle`.
//       - `pub use signals::SSXLSignals;`
//           ‚Ä¢ Makes `SSXLSignals` available directly via `crate::ffi::SSXLSignals`.
//       - This improves ergonomics and keeps external imports clean.
//
// Example Usage:
//   ‚Ä¢ Instead of writing:
//       use crate::ffi::oracle::SSXLOracle;
//       use crate::ffi::signals::SSXLSignals;
//     You can simply write:
//       use crate::ffi::{SSXLOracle, SSXLSignals};
//
// Design Choices:
//   ‚Ä¢ Modular separation ensures clarity: oracle logic and signal definitions
//     remain independent but accessible under a unified namespace.
//   ‚Ä¢ Re-exports flatten the API surface, reducing verbosity in external code.
//   ‚Ä¢ Clear FFI boundaries make it easier to maintain Rust ‚Üî Godot integration.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust projects can use submodules and
//     re-exports to create clean, ergonomic APIs. By centralizing FFI-related
//     logic under `ffi`, SSXL ensures that external consumers have a simple,
//     intuitive interface for interacting with engine signals and oracle logic.
// ============================================================================


pub mod oracle;
pub mod signals;

pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;

// --- END: rust/ssxl_godot/src\ffi\mod.rs ---
        54 LOC | rust/ssxl_godot/src\ffi\oracle.rs
// --- START: rust/ssxl_godot/src\ffi\oracle.rs ---
// ============================================================================
// üîÆ SSXL Oracle (`crate::ffi::oracle`)
// ----------------------------------------------------------------------------
// This module defines the `SSXLOracle` class, a Godot-facing node that acts
// as a lightweight interface to the SSXL engine. It provides query and control
// methods that can be called directly from GDScript, serving as an "oracle"
// for engine status, ticks, and tile counts.
//
// Purpose:
//   ‚Ä¢ Expose a simple Godot node (`SSXLOracle`) that delegates work to `SSXLEngine`.
//   ‚Ä¢ Provide lifecycle hooks and query methods accessible from GDScript.
//   ‚Ä¢ Track tick progression and allow external scripts to reset or monitor it.
//   ‚Ä¢ Offer a clean bridge between Rust engine logic and Godot‚Äôs scripting layer.
//
// Key Components:
//   ‚Ä¢ SSXLOracle (struct)
//       - Attributes:
//           ‚Ä¢ #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//             - Marks SSXLOracle as a Godot class.
//             - `tool`: usable in the Godot editor.
//             - `base = Node`: inherits from Godot‚Äôs Node.
//             - `init`: ensures proper initialization.
//       - Fields:
//           ‚Ä¢ base: underlying Godot Node.
//           ‚Ä¢ engine: optional reference to `SSXLEngine`.
//           ‚Ä¢ tick_count: counter for processed ticks.
//
//   ‚Ä¢ init (method)
//       - Constructor for SSXLOracle.
//       - Initializes with no engine bound and tick_count = 0.
//
//   ‚Ä¢ Godot API Methods (#[godot_api])
//       - _ready
//           ‚Ä¢ Lifecycle hook called when node enters the scene tree.
//           ‚Ä¢ Enables per-frame processing.
//       - set_engine
//           ‚Ä¢ Binds an `SSXLEngine` instance to this oracle.
//           ‚Ä¢ Allows delegation of tick and query methods.
//       - tick
//           ‚Ä¢ Advances the engine by one tick via `process_engine_tick`.
//           ‚Ä¢ Increments tick_count.
//       - get_current_tile_count
//           ‚Ä¢ Queries engine for total tiles generated.
//           ‚Ä¢ Returns 0 if engine not bound.
//       - get_status
//           ‚Ä¢ Queries engine for human-readable status string.
//           ‚Ä¢ Returns "Engine not bound." if no engine attached.
//       - ping
//           ‚Ä¢ Simple test function; placeholder for connectivity checks.
//       - reset
//           ‚Ä¢ Resets tick_count to 0.
//       - get_tick
//           ‚Ä¢ Returns current tick_count.
//
// Design Choices:
//   ‚Ä¢ Oracle pattern provides a lightweight fa√ßade over the engine.
//   ‚Ä¢ Optional engine reference allows flexible binding/unbinding at runtime.
//   ‚Ä¢ Tick counter enables monitoring of engine progression from scripts.
//   ‚Ä¢ Minimal methods keep the API surface simple and script-friendly.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can expose custom Godot nodes that
//     act as fa√ßades over complex engine logic. By delegating to `SSXLEngine`,
//     `SSXLOracle` provides a clean, script-accessible interface for queries
//     and ticks, while maintaining Rust‚Äôs safety and Godot‚Äôs usability.
// ============================================================================


use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use crate::engine::SSXLEngine;

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

impl SSXLOracle {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0,
        }
    }
}

#[godot_api]
impl SSXLOracle {
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {}
        }
    }

    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => engine.bind().get_current_tile_count(),
            None => 0,
        }
    }

    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => engine.bind().get_status(),
            None => GString::from("Engine not bound."),
        }
    }

    #[func]
    pub fn ping(&self) {}

    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}

// --- END: rust/ssxl_godot/src\ffi\oracle.rs ---
        24 LOC | rust/ssxl_godot/src\ffi\signals.rs
// --- START: rust/ssxl_godot/src\ffi\signals.rs ---
// ============================================================================
// üì° SSXL Signals (`crate::ffi::signals`)
// ----------------------------------------------------------------------------
// This module defines the `SSXLSignals` class, a Godot-facing broadcaster node
// that emits signals from the Rust-based SSXL engine into the Godot scene graph.
// Signals are the primary communication bridge between Rust logic and Godot
// scripts, enabling real-time updates, event handling, and synchronization.
//
// Purpose:
//   ‚Ä¢ Provide a dedicated Godot node (`SSXLSignals`) for emitting engine signals.
//   ‚Ä¢ Allow GDScript or C# scripts to connect to engine events without directly
//     accessing Rust internals.
//   ‚Ä¢ Broadcast generation lifecycle events, animation updates, and engine status.
//
// Key Components:
//   ‚Ä¢ SSXLSignals (struct)
//       - Attributes:
//           ‚Ä¢ #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//             - Marks SSXLSignals as a Godot class.
//             - `tool`: usable in the Godot editor.
//             - `base = Node`: inherits from Godot‚Äôs Node.
//             - `init`: ensures proper initialization.
//       - Fields:
//           ‚Ä¢ base: underlying Godot Node wrapped by this broadcaster.
//
//   ‚Ä¢ init (method)
//       - Constructor for SSXLSignals.
//       - Wraps the provided Node base inside the struct.
//
//   ‚Ä¢ Godot API Implementation (#[godot_api])
//       - Defines all signals exposed to Godot via #[signal] attributes.
//       - These signals can be connected to GDScript or C# methods in the editor.
//
// Signals Overview:
//   ‚Ä¢ Generation Lifecycle
//       - build_map_start: emitted when map generation begins.
//       - chunk_data_updated(x, y): emitted when chunk data is updated.
//       - chunk_generated_batch(batch): emitted when a chunk is fully generated
//         and converted into a render batch.
//       - build_map_complete: emitted when map generation completes successfully.
//       - build_map_stopped: emitted when generation is stopped prematurely.
//       - generation_error(error_message): emitted when a generation error occurs.
//       - chunk_data_ready(x, y): emitted when chunk data is ready for use.
//       - tick_complete(current_tick): emitted at the end of each tick (frame).
//
//   ‚Ä¢ Animation & Utility
//       - tile_flip_updated(tile_id, flip_frame): emitted when a tile‚Äôs flip frame updates.
//       - animation_update(percent_done, new_atlas_coords): emitted during animation updates.
//       - animation_state_changed(enabled): emitted when animation state changes.
//       - engine_status_updated(status_message): emitted when engine status changes.
//
// Design Choices:
//   ‚Ä¢ Separation of concerns: SSXLSignals contains no engine state, only broadcasts.
//   ‚Ä¢ Signal-based communication ensures loose coupling between Rust and Godot scripts.
//   ‚Ä¢ Rich set of signals provides granular visibility into engine lifecycle and animation.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can expose event-driven communication
//     to Godot via signals. By centralizing all engine broadcasts in `SSXLSignals`,
//     the design ensures that external scripts can react to engine events in a
//     clean, idiomatic Godot way, while Rust maintains control of core logic.
// ============================================================================


use godot::prelude::*;
use godot::classes::Node; 

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

impl SSXLSignals {
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

#[godot_api]
impl SSXLSignals {
    #[signal]
    fn build_map_start();

    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    #[signal]
    fn build_map_complete();

    #[signal]
    fn build_map_stopped();

    #[signal]
    fn generation_error(error_message: GString);

    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    #[signal]
    fn tick_complete(current_tick: u64);

    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    #[signal]
    fn animation_state_changed(enabled: bool);

    #[signal]
    fn engine_status_updated(status_message: GString);
}

// --- END: rust/ssxl_godot/src\ffi\signals.rs ---
         9 LOC | rust/ssxl_godot/src\lib.rs
// --- START: rust/ssxl_godot/src\lib.rs ---
// ============================================================================
// üöÄ SSXL Godot Crate Root (`lib.rs`)
// ----------------------------------------------------------------------------
// This file serves as the entry point for the `ssxl_godot` crate. It defines
// the top-level module structure and provides the GDExtension boilerplate
// required for Godot to load this Rust library.
//
// Purpose:
//   ‚Ä¢ Declare the public modules that make up the SSXL engine integration.
//   ‚Ä¢ Provide the mandatory `ExtensionLibrary` implementation for Godot.
//   ‚Ä¢ Act as the root manifest tying together engine, FFI, and tilemap logic.
//
// Module Structure:
//   ‚Ä¢ engine
//       - Core engine logic (SSXLEngine, conductor, tick loop, APIs).
//   ‚Ä¢ ffi
//       - Godot-facing FFI adapter nodes (SSXLOracle, SSXLSignals).
//       - Bridges Rust logic with Godot signals and scripting.
//   ‚Ä¢ tilemap
//       - TileMap integration (SSXLTilemap, async_poll, status_reporter).
//       - Handles rendering, async updates, and status reporting.
//
// Godot Integration:
//   ‚Ä¢ Uses `godot::prelude::*` for macros, traits, and types that enable
//     Rust ‚Üî Godot interoperability (e.g., #[gdextension], Gd<T>, GodotClass).
//   ‚Ä¢ Imports `ExtensionLibrary` and `InitLevel` to define the extension‚Äôs
//     lifecycle behavior.
//
// SSXLExtension (struct):
//   ‚Ä¢ Placeholder struct representing the extension library itself.
//   ‚Ä¢ Contains no fields because all logic is delegated to modules.
//
// ExtensionLibrary Implementation:
//   ‚Ä¢ #[gdextension] marks this as the entrypoint for Godot‚Äôs GDExtension system.
//   ‚Ä¢ unsafe impl ExtensionLibrary for SSXLExtension:
//       - Required by godot-rust to hook into Godot‚Äôs lifecycle.
//       - on_level_init(_level): called when Godot reaches a new initialization
//         stage (Core, Scene, Editor, etc.).
//       - Currently does nothing, but can be extended to register classes,
//         initialize resources, or set up global state.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust crates integrate with Godot via
//     GDExtension. By separating engine, FFI, and tilemap into modules,
//     the design remains modular and maintainable, while the extension
//     entrypoint ensures Godot can load and interact with the library.
// ============================================================================

#![feature(int_roundings)]
pub mod engine;
pub mod ffi;
pub mod tilemap; 

use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    fn on_level_init(_level: InitLevel) {}
}

// --- END: rust/ssxl_godot/src\lib.rs ---
        72 LOC | rust/ssxl_godot/src\tilemap\async_poll.rs
// --- START: rust/ssxl_godot/src\tilemap\async_poll.rs ---
// ============================================================================
// ‚ö° AsyncPoller (`crate::tilemap::async_poll`)
// ----------------------------------------------------------------------------
// This module defines the `AsyncPoller` struct, which acts as the bridge
// between Tokio asynchronous channels and Godot‚Äôs main thread. It provides
// non-blocking polling methods to safely drain generation and animation
// message channels each frame.
//
// Purpose:
//   ‚Ä¢ Integrate Tokio async channels with Godot‚Äôs synchronous game loop.
//   ‚Ä¢ Provide safe, non-blocking polling of generation and animation updates.
//   ‚Ä¢ Prevent runaway loops by enforcing maximum message limits.
//   ‚Ä¢ Centralize channel management for clarity and maintainability.
//
// Key Components:
//   ‚Ä¢ Constants
//       - MAX_GEN_MSGS (64): maximum generation messages processed per poll.
//         Prevents runaway loops if channel is flooded.
//       - MAX_ANIM_MSGS (2048): maximum animation messages processed per poll.
//         Higher limit since animation updates are more frequent.
//
//   ‚Ä¢ Type Aliases
//       - AnimationReceiver: unbounded channel receiver for `AnimationUpdate`.
//         Animation updates are frequent, so unbounded channels are used.
//       - GenerationReceiver: bounded channel receiver for `GenerationMessage`.
//         Generation messages are controlled by the conductor, so bounded channels are used.
//
//   ‚Ä¢ AsyncPoller (struct)
//       - Fields:
//           ‚Ä¢ generation_rx: optional bounded receiver for generation messages.
//           ‚Ä¢ animation_rx: optional unbounded receiver for animation updates.
//       - Implements `Default` for easy initialization.
//
//   ‚Ä¢ Methods
//       - new()
//           ‚Ä¢ Creates a new AsyncPoller with no receivers.
//       - set_animation_rx(rx)
//           ‚Ä¢ Assigns an animation receiver.
//       - set_generation_rx(rx)
//           ‚Ä¢ Assigns a generation receiver.
//       - clear_receivers()
//           ‚Ä¢ Clears both receivers, useful for resetting or shutting down.
//       - poll_generation()
//           ‚Ä¢ Non-blocking poll of generation messages.
//           ‚Ä¢ Drains up to MAX_GEN_MSGS messages.
//           ‚Ä¢ Handles Empty (no messages) and Disconnected (channel closed).
//           ‚Ä¢ Returns a vector of `GenerationMessage`.
//       - poll_animations()
//           ‚Ä¢ Non-blocking poll of animation updates.
//           ‚Ä¢ Drains up to MAX_ANIM_MSGS messages.
//           ‚Ä¢ Uses smaller initial capacity (min(256)) for efficiency.
//           ‚Ä¢ Returns a vector of `AnimationUpdate`.
//
// Design Choices:
//   ‚Ä¢ Non-blocking polling ensures responsiveness in Godot‚Äôs frame loop.
//   ‚Ä¢ Bounded vs. unbounded channels reflect expected message frequency.
//   ‚Ä¢ Temporary ownership of receivers avoids borrow checker conflicts,
//     then receivers are restored for subsequent polls.
//   ‚Ä¢ Logging errors (e.g., channel disconnection) aids debugging.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can integrate asynchronous systems
//     (Tokio channels) into synchronous environments like Godot. By enforcing
//     message limits and restoring receivers after polling, `AsyncPoller`
//     ensures safe, efficient communication between concurrent generation/
//     animation tasks and the main game loop.
// ============================================================================


use tokio::sync::mpsc::{
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};

use ssxl_shared::AnimationUpdate; 
use ssxl_shared::message::generation_message::GenerationMessage; 

const MAX_GEN_MSGS: usize = 64;
const MAX_ANIM_MSGS: usize = 2048;

pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

#[derive(Default)]
pub struct AsyncPoller {
    generation_rx: Option<GenerationReceiver>,
    animation_rx: Option<AnimationReceiver>,
}

impl AsyncPoller {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        self.animation_rx = rx;
    }

    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        self.generation_rx = rx;
    }

    pub fn clear_receivers(&mut self) {
        self.generation_rx = None;
        self.animation_rx = None;
    }

    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        self.generation_rx = Some(rx);
        updates
    }

    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        self.animation_rx = Some(rx);
        updates
    }
}

// --- END: rust/ssxl_godot/src\tilemap\async_poll.rs ---
         3 LOC | rust/ssxl_godot/src\tilemap\mod.rs
// --- START: rust/ssxl_godot/src\tilemap\mod.rs ---
// ============================================================================
// üß© Tilemap Module (`crate::tilemap`)
// ----------------------------------------------------------------------------
// This module serves as the parent namespace for all tilemap-related components
// in the SSXL engine. It organizes submodules that handle tilemap logic,
// asynchronous channel polling, and status reporting, and re-exports them for
// clean access throughout the engine.
//
// Purpose:
//   ‚Ä¢ Provide a central entry point for tilemap functionality.
//   ‚Ä¢ Encapsulate core tilemap logic, async communication, and status utilities
//     in dedicated submodules.
//   ‚Ä¢ Simplify imports by exposing submodules directly under `crate::tilemap`.
//
// Submodules:
//   ‚Ä¢ ssxl_tilemap
//       - Contains the main `SSXLTilemap` implementation.
//       - Responsible for managing tile placement, rendering, and integration
//         with Godot‚Äôs `TileMap` node.
//       - Provides APIs for interacting with chunks and tiles.
//
//   ‚Ä¢ async_poll
//       - Defines the `AsyncPoller` struct.
//       - Bridges Tokio async channels with Godot‚Äôs synchronous frame loop.
//       - Safely polls generation and animation channels each tick.
//       - Ensures non-blocking, panic-free message handling.
//
//   ‚Ä¢ status_reporter
//       - Provides utilities for reporting tilemap status back to Godot.
//       - Emits human-readable summaries of engine/tilemap state.
//       - Helps external scripts monitor lifecycle and debug tilemap behavior.
//
// Design Choices:
//   ‚Ä¢ Modular separation keeps responsibilities clear: rendering, async polling,
//     and status reporting are independent but unified under `tilemap`.
//   ‚Ä¢ Re-exporting submodules improves ergonomics, allowing external code to
//     import directly from `crate::tilemap` without deep paths.
//   ‚Ä¢ This structure mirrors Godot‚Äôs scene graph philosophy: small, focused
//     components that work together to form a cohesive system.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust projects can use submodules and
//     re-exports to create clean, maintainable APIs. By centralizing tilemap
//     functionality under `tilemap`, SSXL ensures that engine code and Godot
//     scripts have a simple, intuitive interface for managing tile-based worlds.
// ============================================================================


pub mod ssxl_tilemap;
pub mod async_poll;
pub mod status_reporter;

// --- END: rust/ssxl_godot/src\tilemap\mod.rs ---
       108 LOC | rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs
// --- START: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
// ============================================================================
// üß© SSXLTilemap (`crate::tilemap::ssxl_tilemap`)
// ----------------------------------------------------------------------------
// This module defines the `SSXLTilemap` class, a custom Godot `TileMap` node
// that integrates Rust-based rendering logic with Godot‚Äôs scene graph. It
// supports both signal-driven batch rendering and FFI-driven buffered updates,
// ensuring tiles can be placed efficiently from multiple sources.
//
// Purpose:
//   ‚Ä¢ Provide a Godot-facing `TileMap` implementation controlled by the SSXL engine.
//   ‚Ä¢ Support bulk tile placement via signals or GDScript (`batch_set_tiles`).
//   ‚Ä¢ Enable external C-style FFI callbacks to queue and flush tile updates.
//   ‚Ä¢ Maintain a buffer of pending updates for safe, batched rendering.
//
// Key Components:
//   ‚Ä¢ Global State
//       - TILEMAP_INSTANCE_ID: stores the Godot instance ID of the active tilemap.
//         Allows external FFI functions to safely access the tilemap.
//       - DEFAULT_LAYER: default layer index used when placing tiles via FFI.
//
//   ‚Ä¢ SSXLTilemap (struct)
//       - Attributes:
//           ‚Ä¢ #[derive(GodotClass)] + #[class(base = TileMap)]
//             - Marks SSXLTilemap as a Godot class inheriting from TileMap.
//       - Fields:
//           ‚Ä¢ base: underlying Godot TileMap node.
//           ‚Ä¢ tile_source_id: ID of the tile source used when setting cells.
//           ‚Ä¢ pending_updates: buffer of cell updates queued via FFI calls.
//
//   ‚Ä¢ ITileMap Implementation
//       - init(base): called when the TileMap node is created.
//       - Stores instance ID globally for FFI access.
//       - Initializes with default tile source and empty update buffer.
//
//   ‚Ä¢ Godot API Methods
//       - batch_set_tiles(batch):
//           ‚Ä¢ Primary entrypoint for rendering tiles in bulk.
//           ‚Ä¢ Expects a Dictionary with keys: "layer", "positions",
//             "atlas_coords", "alt_tiles".
//           ‚Ä¢ Places tiles on the specified layer using provided coordinates.
//       - get_instance():
//           ‚Ä¢ Retrieves the current SSXLTilemap instance using its global ID.
//           ‚Ä¢ Enables safe access for FFI functions.
//       - flush_updates():
//           ‚Ä¢ Applies all pending updates queued via FFI calls.
//           ‚Ä¢ Renders them on the default layer in bulk.
//
//   ‚Ä¢ FFI Host Functions
//       - ssxl_set_cell(x, y, tile_id):
//           ‚Ä¢ Queues a single cell update into `pending_updates`.
//           ‚Ä¢ Called from external FFI code.
//       - ssxl_notify_tilemap_update():
//           ‚Ä¢ Flushes all queued updates to the TileMap.
//           ‚Ä¢ Called from external FFI code.
//
// Design Choices:
//   ‚Ä¢ Separation of batch rendering (signals) and buffered updates (FFI)
//     ensures flexibility in how tiles are placed.
//   ‚Ä¢ Global instance ID allows external systems to interact with the tilemap
//     without unsafe global state manipulation.
//   ‚Ä¢ Buffered updates prevent unsafe concurrent modifications by batching
//     tile placement into a controlled flush.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can extend Godot‚Äôs TileMap with
//     custom rendering logic, while also exposing safe FFI hooks for external
//     systems. By combining signal-driven updates with FFI callbacks,
//     `SSXLTilemap` provides a robust, dual-path rendering pipeline that
//     integrates seamlessly into Godot‚Äôs scene graph.
// ============================================================================


use godot::prelude::*;
use godot::classes::{TileMap, ITileMap};
use godot::obj::Base;
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};
use once_cell::sync::OnceCell;

pub static TILEMAP_INSTANCE_ID: OnceCell<InstanceId> = OnceCell::new(); 
const DEFAULT_LAYER: i32 = 0;

#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    pub tile_source_id: i32,
    pub pending_updates: Vec<(i32, i32, i32)>,
}

#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        let id = base.to_init_gd().instance_id();
        let _ = TILEMAP_INSTANCE_ID.set(id);

        Self {
            base,
            tile_source_id: 1,
            pending_updates: Vec::new(),
        }
    }
}

#[godot_api]
impl SSXLTilemap {
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        for i in 0..len {
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }

    fn get_instance() -> Option<Gd<Self>> {
        let id = TILEMAP_INSTANCE_ID.get()?;
        godot::prelude::Gd::try_from_instance_id(*id).ok()
    }

    pub fn flush_updates(&mut self) {
        let updates = std::mem::take(&mut self.pending_updates);
        let len = updates.len();

        if len == 0 {
            return;
        }

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();
        
        tilemap.set_layer_enabled(DEFAULT_LAYER, true);

        for (world_x, world_y, tile_id) in updates {
            let cell = Vector2i::new(world_x, world_y);
            let atlas = Vector2i::new(0, tile_id); 
            
            tilemap
                .set_cell_ex(DEFAULT_LAYER, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(0)
                .done();
        }

        godot_print!("FFI Host: Batch rendered {len} tiles via FFI callback.");
    }
}

#[no_mangle]
pub extern "C" fn ssxl_set_cell(x: i32, y: i32, tile_id: i32) {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().pending_updates.push((x, y, tile_id));
    } else {
        godot_warn!("ssxl_set_cell: Tilemap instance not available. Update lost.");
    }
}

#[no_mangle]
pub extern "C" fn ssxl_notify_tilemap_update() {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().flush_updates();
    }
}

// --- END: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
        36 LOC | rust/ssxl_godot/src\tilemap\status_reporter.rs
// --- START: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
// ============================================================================
// üìä StatusReporter (`crate::tilemap::status_reporter`)
// ----------------------------------------------------------------------------
// This module defines the `StatusReporter` utility, a stateless helper for
// compiling human-readable status reports from the SSXL engine. It separates
// reporting logic from the core engine, keeping `SSXLEngine` focused on
// orchestration while providing clean, script-friendly summaries.
//
// Purpose:
//   ‚Ä¢ Generate formatted status strings combining generation and animation states.
//   ‚Ä¢ Provide helper methods for querying tile counts from the conductor.
//   ‚Ä¢ Return results as Godot-native types (`GString`) for direct use in GDScript.
//
// Key Components:
//   ‚Ä¢ StatusReporter (struct)
//       - Stateless utility; contains no fields.
//       - Provides static-style methods for reporting.
//
//   ‚Ä¢ get_status_report(gen_state, anim_state)
//       - Constructs a formatted status string.
//       - Generation State:
//           ‚Ä¢ If present, calls `get_status()` on `ConductorState`.
//           ‚Ä¢ If absent, defaults to "Uninitialized".
//       - Animation State:
//           ‚Ä¢ If present, derives status from `time_scale`:
//               - > 0.0 ‚Üí "Running (Scale: Xx)"
//               - == 0.0 ‚Üí "Stopped"
//               - < 0.0 ‚Üí "Error/Invalid Scale"
//           ‚Ä¢ If absent, defaults to "Uninitialized".
//       - Returns a `GString` formatted as:
//           "STATUS: Generation: <gen_status> | Animation: <anim_status>"
//
//   ‚Ä¢ get_current_tile_count_value(gen_state)
//       - Queries the total number of tiles placed by the generation conductor.
//       - If `gen_state` is present, calls `get_tiles_placed()`.
//       - If absent, defaults to 0.
//       - Returns a `u64` count.
//
// Design Choices:
//   ‚Ä¢ Stateless design ensures reporting logic is reusable and independent.
//   ‚Ä¢ Returning `GString` guarantees compatibility with Godot‚Äôs scripting layer.
//   ‚Ä¢ Clear formatting makes status reports easy to parse in logs or UI.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust utilities can provide clean,
//     script-friendly reporting interfaces for Godot. By separating reporting
//     from orchestration, `StatusReporter` keeps the engine modular and
//     maintainable, while ensuring external scripts can easily monitor
//     generation and animation progress.
// ============================================================================


use godot::prelude::GString;
use ssxl_generate::conductor::ConductorState;
use ssxl_shared::AnimationState;

pub struct StatusReporter;

impl StatusReporter {
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        let gen_status = gen_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let anim_status = anim_state
            .map(|state| {
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        GString::from(status.as_str())
    }

    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            .unwrap_or(0)
    }
}

// --- END: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
        58 LOC | rust/ssxl_math/src\coordinate_system.rs
// --- START: rust/ssxl_math/src\coordinate_system.rs ---
// ============================================================================
// üåç Coordinate System (`crate::coordinates`)
// ----------------------------------------------------------------------------
// This module defines the fundamental coordinate types used by the SSXL engine.
// It provides a robust system for mapping between global world positions,
// chunk indices, and local tile offsets, ensuring consistency across infinite
// 3D space.
//
// Purpose:
//   ‚Ä¢ Represent positions in an infinite 3D world using 64-bit integer vectors.
//   ‚Ä¢ Split global coordinates into chunk-local coordinates for efficient storage.
//   ‚Ä¢ Reconstruct global positions from chunk indices and tile offsets.
//   ‚Ä¢ Handle both positive and negative coordinates correctly using Euclidean division.
//
// Key Types:
//   ‚Ä¢ WorldPos
//       - Wraps an `I64Vec3` representing a specific point in the world.
//       - Supports extremely large coordinates beyond i32 limits.
//       - Provides `to_chunk_coords()` for splitting into chunk + tile offset.
//
//   ‚Ä¢ ChunkKey
//       - Wraps an `I64Vec3` representing the index of a chunk in world space.
//       - Each chunk is a cubic volume of size `CHUNK_SIZE_I64`.
//       - Provides `to_world_pos()` for reconstructing global positions.
//
//   ‚Ä¢ TileOffset
//       - Wraps an `I64Vec3` representing the local position of a tile inside
//         its parent chunk.
//       - Always non-negative, ranging from 0 to `CHUNK_SIZE_I64 - 1`.
//
// Conversion Logic:
//   ‚Ä¢ WorldPos ‚Üí (ChunkKey, TileOffset)
//       - Uses `rem_euclid` to ensure non-negative offsets even for negative coordinates.
//       - ChunkKey is computed by subtracting the offset and dividing by chunk size.
//   ‚Ä¢ ChunkKey + TileOffset ‚Üí WorldPos
//       - Formula: World = (Chunk Index * Chunk Size) + Tile Offset.
//       - Ensures round-trip consistency with `WorldPos::to_chunk_coords`.
//
// Tests:
//   ‚Ä¢ Validates correctness for large positive coordinates (well beyond i32::MAX).
//   ‚Ä¢ Validates correctness for negative coordinates, ensuring offsets remain non-negative.
//   ‚Ä¢ Round-trip tests confirm idempotency: converting WorldPos ‚Üí ChunkKey/TileOffset ‚Üí WorldPos
//     yields the original position.
//
// Design Choices:
//   ‚Ä¢ 64-bit vectors (`I64Vec3`) allow for virtually infinite coordinate ranges.
//   ‚Ä¢ Euclidean division ensures offsets are always valid within chunk boundaries.
//   ‚Ä¢ Separation of WorldPos, ChunkKey, and TileOffset provides semantic clarity
//     and prevents misuse of raw vectors.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to design a coordinate system for infinite
//     voxel or tile-based worlds. By splitting global positions into chunk-local
//     coordinates, the engine can efficiently manage memory, rendering, and
//     procedural generation across vast spaces.
// ============================================================================


use serde::{Serialize, Deserialize};
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);

impl WorldPos {
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        let chunk_size = CHUNK_SIZE_I64;

        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

impl ChunkKey {
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    #[test]
    fn test_world_to_chunk_positive() {
        let huge_coord = 5_000_000_000i64;
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64;
        let expected_offset = huge_coord % CHUNK_SIZE_I64;

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();
        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}

// --- END: rust/ssxl_math/src\coordinate_system.rs ---
        14 LOC | rust/ssxl_math/src\generation_utils.rs
// --- START: rust/ssxl_math/src\generation_utils.rs ---
// ============================================================================
// üé≤ Utility Functions (`crate::utils::probability`)
// ----------------------------------------------------------------------------
// This module provides lightweight utility functions for probabilistic rolls
// and generic data processing. These helpers are designed to support procedural
// generation and quick uniqueness checks in the SSXL engine.
//
// Purpose:
//   ‚Ä¢ `generate_percent_roll`: perform probabilistic chance rolls for events.
//   ‚Ä¢ `process_data`: derive a simple aggregate identifier from SSXLData objects.
//
// Key Functions:
//   ‚Ä¢ generate_percent_roll(target_percent: u8) -> u32
//       - Performs a probabilistic roll against a given percentage chance.
//       - Arguments:
//           ‚Ä¢ target_percent: u8 (0‚Äì100), representing the probability of success.
//       - Behavior:
//           ‚Ä¢ Generates a random integer between 0 and 99 inclusive.
//           ‚Ä¢ Compares it against target_percent.
//           ‚Ä¢ Returns 0 if success (random < target_percent).
//           ‚Ä¢ Returns 1 if failure (random >= target_percent).
//       - Example:
//           ‚Ä¢ generate_percent_roll(25) ‚Üí 25% chance of returning 0 (success).
//
//   ‚Ä¢ process_data(data: &impl SSXLData) -> u64
//       - Processes an object implementing the `SSXLData` trait.
//       - Arguments:
//           ‚Ä¢ data: reference to any object implementing SSXLData.
//       - Behavior:
//           ‚Ä¢ Calls `get_id()` to retrieve the object‚Äôs unique identifier.
//           ‚Ä¢ Calls `get_value_len()` to retrieve the length of its payload.
//           ‚Ä¢ Adds them together to produce a u64 aggregate value.
//       - Returns:
//           ‚Ä¢ u64 representing the combined identifier + payload length.
//       - Use Cases:
//           ‚Ä¢ Lightweight hashing.
//           ‚Ä¢ Quick uniqueness checks.
//           ‚Ä¢ Simple aggregate identifiers.
//
// Design Choices:
//   ‚Ä¢ Using `rand::Rng` ensures efficient and flexible random number generation.
//   ‚Ä¢ Returning `u32` for rolls keeps results lightweight and script-friendly.
//   ‚Ä¢ Trait-based `process_data` allows generic handling of any SSXLData object.
//   ‚Ä¢ Separation of probability and data utilities keeps the module cohesive.
//
// Educational Note:
//   ‚Ä¢ These functions demonstrate how small, focused utilities can support
//     larger systems. By abstracting probability rolls and data aggregation,
//     the engine gains reusable building blocks for procedural generation,
//     resource spawning, and uniqueness validation.
// ============================================================================


use crate::primitives::SSXLData;
use rand::Rng;

pub fn generate_percent_roll(target_percent: u8) -> u32 {
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    if rand_val < target_percent {
        0
    } else {
        1
    }
}

pub fn process_data(data: &impl SSXLData) -> u64 {
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}

// --- END: rust/ssxl_math/src\generation_utils.rs ---
        42 LOC | rust/ssxl_math/src\hashing.rs
// --- START: rust/ssxl_math/src\hashing.rs ---
// ============================================================================
// üîê Hashing Utilities (`crate::utils::hashing`)
// ----------------------------------------------------------------------------
// This module defines utility functions for generating deterministic,
// collision-resistant SHA-256 hashes for chunk coordinates and content data.
// These hashes serve as unique identifiers in caching, procedural generation,
// and content management systems.
//
// Purpose:
//   ‚Ä¢ Provide a reliable way to uniquely identify chunks in infinite world space.
//   ‚Ä¢ Generate consistent hashes for content keys used in caching or asset lookup.
//   ‚Ä¢ Ensure determinism: identical inputs always yield identical hashes.
//   ‚Ä¢ Ensure uniqueness: adjacent or different inputs yield distinct hashes.
//
// Key Functions:
//   ‚Ä¢ hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String>
//       - Arguments:
//           ‚Ä¢ coords: 3D chunk coordinates in world space (I64Vec3).
//       - Behavior:
//           ‚Ä¢ Serializes coordinates into canonical string format: "x:y:z".
//           ‚Ä¢ Feeds the string into a SHA-256 hasher.
//           ‚Ä¢ Produces a 64-character lowercase hexadecimal string.
//       - Returns:
//           ‚Ä¢ SSXLResult<String> containing the hash.
//       - Use Cases:
//           ‚Ä¢ Unique identifiers for chunks in procedural generation.
//           ‚Ä¢ Cache keys for chunk data.
//
//   ‚Ä¢ hash_content_data(data_key: u64) -> SSXLResult<String>
//       - Arguments:
//           ‚Ä¢ data_key: numeric identifier for content (e.g., asset ID, seed).
//       - Behavior:
//           ‚Ä¢ Converts the key into a string.
//           ‚Ä¢ Feeds the string into a SHA-256 hasher.
//           ‚Ä¢ Produces a 64-character lowercase hexadecimal string.
//           ‚Ä¢ Prefixes the result with "content_" for easy identification.
//       - Returns:
//           ‚Ä¢ SSXLResult<String> containing the prefixed hash.
//       - Use Cases:
//           ‚Ä¢ Content caching and lookup.
//           ‚Ä¢ Asset or configuration uniqueness checks.
//
// Tests:
//   ‚Ä¢ test_chunk_coords_determinism
//       - Verifies identical coordinates always yield identical hashes.
//   ‚Ä¢ test_chunk_coords_uniqueness_and_format
//       - Verifies adjacent coordinates yield different hashes.
//       - Ensures hash length is exactly 64 characters.
//   ‚Ä¢ test_content_data_determinism_and_format
//       - Verifies identical content keys yield identical hashes.
//       - Ensures prefix "content_" is present.
//       - Ensures total length is 72 characters (8 prefix + 64 hash).
//
// Design Choices:
//   ‚Ä¢ SHA-256 chosen for collision resistance and deterministic output.
//   ‚Ä¢ Hexadecimal encoding ensures compact, human-readable identifiers.
//   ‚Ä¢ Prefixing content hashes improves clarity in cache systems.
//   ‚Ä¢ Wrapping results in SSXLResult maintains consistency with engine-wide error handling.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how cryptographic hashing can be applied to
//     procedural generation and content management. By using SHA-256, the
//     engine guarantees both determinism and uniqueness, critical for large-scale
//     worlds and distributed caching systems.
// ============================================================================


use crate::primitives::SSXLResult;
use glam::I64Vec3;
use sha2::{Digest, Sha256};

pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    Ok(format!("{:x}", result))
}

pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    let key_string = data_key.to_string();

    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    Ok(format!("content_{:x}", result))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chunk_coords_determinism() {
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2);
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}

// --- END: rust/ssxl_math/src\hashing.rs ---
        30 LOC | rust/ssxl_math/src\lib.rs
// --- START: rust/ssxl_math/src\lib.rs ---
// ============================================================================
// üßÆ SSXL Math Module (`crate::ssxl_math`)
// ----------------------------------------------------------------------------
// This module defines the mathematical foundation of the SSXL engine. It
// provides core coordinate types, generation utilities, hashing functions,
// and primitive constants, along with specialized math routines for fast
// vector operations.
//
// Purpose:
//   ‚Ä¢ Organize math-related functionality into cohesive submodules.
//   ‚Ä¢ Provide efficient algorithms for vector normalization and hashing.
//   ‚Ä¢ Offer a prelude for convenient re-exports of essential math utilities.
//
// Module Structure:
//   ‚Ä¢ coordinate_system
//       - Defines core coordinate types (WorldPos, ChunkKey, TileOffset).
//       - Handles conversion between global world positions and chunk-local offsets.
//   ‚Ä¢ generation_utils
//       - Provides utility functions for procedural generation.
//       - Includes randomness utilities (percent rolls) and data processing helpers.
//   ‚Ä¢ hashing
//       - Provides deterministic SHA-256 hashing functions.
//       - Used for chunk IDs, cache keys, and ensuring stable procedural generation.
//   ‚Ä¢ primitives
//       - Defines core mathematical constants, types, and result/error handling.
//       - Acts as the foundation for other modules.
//
// Special Functions:
//   ‚Ä¢ q_rsqrt(number: f32) -> f32
//       - Fast inverse square root approximation.
//       - Famous algorithm from Quake III Arena, adapted here for safe use.
//       - Returns an approximation of 1/sqrt(number).
//       - Uses bit-level manipulation and one Newton-Raphson refinement.
//       - Safety guard: returns 0.0 if input <= 0.0.
//
//   ‚Ä¢ normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32)
//       - Computes the unit vector (normalized vector) of a 3D vector.
//       - Uses q_rsqrt for fast inverse square root approximation.
//       - Returns a tuple representing the normalized vector.
//
// Prelude Module:
//   ‚Ä¢ Provides a convenience re-export of all essential types and functions.
//   ‚Ä¢ Allows other crates to import `ssxl_math::prelude::*` for quick access.
//   ‚Ä¢ Re-exports coordinate_system, generation_utils, hashing, primitives,
//     along with q_rsqrt and normalize_vector_3d.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to combine classical math algorithms
//     (like fast inverse square root) with modern Rust abstractions.
//   ‚Ä¢ By organizing math utilities into submodules and exposing a prelude,
//     SSXL ensures both clarity and convenience for developers working on
//     large-scale procedural generation and simulation systems.
// ============================================================================


pub mod coordinate_system;
pub mod generation_utils;
pub mod hashing;
pub mod primitives;

#[inline(always)]
pub fn q_rsqrt(number: f32) -> f32 {
    if number <= 0.0 { 
        return 0.0;
    }

    const THREEHALFS: f32 = 1.5;

    let x2 = number * 0.5;
    let y = number;
    
    let i = y.to_bits();
    let j_bits = 0x5f3759df_u32.wrapping_sub(i >> 1);

    let mut y = f32::from_bits(j_bits);
    
    y = y * (THREEHALFS - (x2 * y * y));
    y
}

pub fn normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32) {
    let mag_sq = x * x + y * y + z * z;
    let inv_mag = q_rsqrt(mag_sq); 
    
    (x * inv_mag, y * inv_mag, z * inv_mag)
}

pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
    
    pub use super::q_rsqrt;
    pub use super::normalize_vector_3d;
}

// --- END: rust/ssxl_math/src\lib.rs ---
        19 LOC | rust/ssxl_math/src\primitives.rs
// --- START: rust/ssxl_math/src\primitives.rs ---
// ============================================================================
// üîß Primitives Module (`crate::primitives`)
// ----------------------------------------------------------------------------
// This module defines the low-level building blocks of the SSXL engine.
// It provides core types, traits, and constants that form the mathematical
// and structural foundation for higher-level systems like coordinate handling,
// generation utilities, and hashing.
//
// Purpose:
//   ‚Ä¢ Define canonical vector types for consistent coordinate representation.
//   ‚Ä¢ Provide semantic type aliases for clarity in APIs.
//   ‚Ä¢ Establish a lightweight, project-wide result type for error handling.
//   ‚Ä¢ Define a minimal trait (`SSXLData`) for generic data management.
//   ‚Ä¢ Expose global constants for chunk sizing and floating-point tolerance.
//
// Key Components:
//   ‚Ä¢ Vec2i
//       - A 2D integer vector using i64 components.
//       - Represents tile or chunk coordinates in 2D space.
//       - Aligns with the engine‚Äôs 64-bit world math (I64Vec3).
//       - Prevents overflow when combined with large-scale coordinates.
//       - Provides a constructor `new(x, y)` for explicit initialization.
//
//   ‚Ä¢ Type Aliases
//       - TileCoord: semantic alias for a tile‚Äôs coordinate in 2D space.
//       - ChunkId: semantic alias for a chunk‚Äôs identifier in a world grid.
//       - SSXLResult<T>: project-wide result type using `Result<T, String>`,
//         favoring human-readable error messages over custom enums.
//
//   ‚Ä¢ Trait: SSXLData
//       - Minimal contract for data managed by the engine (task queues, caches).
//       - Requires `Send + Sync` for safe concurrency across threads.
//       - Methods:
//           ‚Ä¢ get_id() -> u64: stable identifier for indexing and deduplication.
//           ‚Ä¢ get_value_len() -> usize: size of payload, useful for diagnostics.
//
//   ‚Ä¢ Constants
//       - CHUNK_SIZE_I64: canonical cubic side length for procedural chunks (32).
//         Uses i64 to align with engine math and avoid casting pitfalls.
//       - F32_EPSILON: small tolerance (1e-6) for floating-point comparisons,
//         used in math-heavy routines like normalization or interpolation.
//
// Design Choices:
//   ‚Ä¢ Using i64 for coordinates ensures compatibility with infinite world math.
//   ‚Ä¢ Semantic type aliases improve readability without runtime overhead.
//   ‚Ä¢ SSXLResult standardizes error handling across modules.
//   ‚Ä¢ SSXLData provides a minimal, flexible trait for generic data processing.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to establish a clean foundation for an engine.
//     By defining primitives here, higher-level systems can build on consistent,
//     reusable abstractions, ensuring clarity, safety, and scalability across
//     the entire codebase.
// ============================================================================


use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    pub x: i64,
    pub y: i64,
}

impl Vec2i {
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

pub type TileCoord = Vec2i; 
pub type ChunkId = Vec2i; 
pub type SSXLResult<T> = Result<T, String>;

pub trait SSXLData: Send + Sync {
    fn get_id(&self) -> u64;
    fn get_value_len(&self) -> usize;
}

pub const CHUNK_SIZE_I64: i64 = 32;
pub const F32_EPSILON: f32 = 1.0e-6;

// --- END: rust/ssxl_math/src\primitives.rs ---
       133 LOC | rust/ssxl_shared/src\chunk\chunk_data.rs
// --- START: rust/ssxl_shared/src\chunk\chunk_data.rs ---
// ============================================================================
// üß± Chunk Data Module (`ssxl_shared::chunk::chunk_data`)
// ----------------------------------------------------------------------------
// This module defines the core structures and utilities for handling chunks,
// which are fixed-size grids of tiles (32x32 by default) in the SSXL engine.
// Chunks are the atomic unit of world generation, caching, and rendering.
//
// Key Concepts:
//   ‚Ä¢ ChunkCoords: Identifies a chunk‚Äôs position in chunk-space (grid coordinates).
//   ‚Ä¢ ChunkData: Holds all data for a chunk, including:
//       - Unique ID (hashed from coordinates)
//       - Bounds in world-space
//       - Tile array (1024 TileData entries)
//       - Dimension tag (e.g., "Overworld", "Default")
//       - Generation timestamp (serialized deterministically)
//
// Design Choices:
//   ‚Ä¢ Fixed size (CHUNK_SIZE = 32) ensures predictable memory layout.
//   ‚Ä¢ Tiles stored in a flat array for cache-friendly access.
//   ‚Ä¢ `serde_big_array` used to serialize large fixed arrays.
//   ‚Ä¢ `system_time_serde` ensures timestamps are cross-platform and deterministic.
//   ‚Ä¢ Zigzag encoding + bit-packing used to generate unique chunk IDs.
//
// Core Methods:
//   ‚Ä¢ new / new_at_coords: Constructors for creating chunks either by explicit
//     parameters or by grid coordinates.
//   ‚Ä¢ zigzag_encode / hash_coords_2d: Utilities for encoding signed coordinates
//     into compact, unique u64 identifiers.
//   ‚Ä¢ coord_to_index_checked / coord_to_index_unchecked: Convert (x,y) tile
//     coordinates into array indices, with or without bounds checking.
//   ‚Ä¢ get_tile / get_tile_mut: Safe accessors for tiles.
//   ‚Ä¢ get_tile_unchecked / get_tile_mut_unchecked: Unsafe, faster accessors
//     when bounds are guaranteed externally.
//   ‚Ä¢ insert_tiles: Bulk replacement of the tile array, with validation.
//
// Testing:
//   ‚Ä¢ Unit tests validate index conversion, zigzag encoding, and hashing logic.
//   ‚Ä¢ Ensures correctness for edge cases (negative coords, large values).
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how game engines balance safety and performance:
//     - Safe methods for general use.
//     - Unsafe methods for hot paths where performance is critical.
//   ‚Ä¢ Hashing and encoding strategies ensure chunks can be uniquely identified
//     across infinite coordinate ranges.
// ============================================================================


use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto;
use std::ptr; 

use super::grid_bounds::GridBounds;
use crate::tile::tile_data::TileData; 
use crate::math::math_primitives;
use ssxl_math::prelude::Vec2i;
use serde_big_array::BigArray;

pub const CHUNK_SIZE: u32 = 32;
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    pub id: u64,
    pub bounds: GridBounds,
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    pub dimension_tag: String,
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}

impl ChunkData {
    pub const SIZE: u32 = CHUNK_SIZE;

    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    #[inline(always)]
    pub const fn zigzag_encode(n: i64) -> u64 {
        ((n << 1) ^ (n >> 63)) as u64
    }

    #[inline(always)]
    pub const fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);
        ux | (uy << 32)
    }
    
    #[inline(always)]
    fn coord_to_index_checked(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    #[inline(always)]
    pub const fn coord_to_index_unchecked(x: u32, y: u32) -> usize {
        (y * Self::SIZE + x) as usize
    }

    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    #[inline(always)]
    pub unsafe fn get_tile_unchecked(&self, x: u32, y: u32) -> &TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &self.tiles[index]
    }
    
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        match tiles_vec.try_into() {
            Ok(arr) => {
                unsafe { ptr::write(&mut self.tiles, arr) };
            }
            Err(vec) => {
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }

    #[inline(always)]
    pub unsafe fn get_tile_mut_unchecked(&mut self, x: u32, y: u32) -> &mut TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &mut self.tiles[index]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_coord_to_index() {
        assert_eq!(ChunkData::coord_to_index_checked(0, 0), Some(0));
        assert_eq!(ChunkData::coord_to_index_checked(16, 16), Some(528));
        assert_eq!(ChunkData::coord_to_index_checked(31, 31), Some(1023));
        assert_eq!(ChunkData::coord_to_index_checked(32, 0), None);
        assert_eq!(ChunkData::coord_to_index_checked(0, 32), None);
        assert_eq!(ChunkData::coord_to_index_checked(33, 33), None);
        
        assert_eq!(ChunkData::coord_to_index_unchecked(0, 0), 0);
        assert_eq!(ChunkData::coord_to_index_unchecked(31, 31), 1023);
    }
    
    #[test]
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    fn test_hash_coords_2d() {
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        let big_x = i64::MAX / 2;
        let big_y = i64::MIN / 2;
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0);
    }
}

// --- END: rust/ssxl_shared/src\chunk\chunk_data.rs ---
        36 LOC | rust/ssxl_shared/src\chunk\grid_bounds.rs
// --- START: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
use crate::Serialize;
use crate::Deserialize;
// -----------------------------------------------------------------------------
// Grid Bounds Module Overview
// -----------------------------------------------------------------------------
// This module defines the fundamental 2D coordinate and bounding box structures
// used throughout the SSXL engine. These are essential for representing world-space
// positions and rectangular regions (chunks, tiles, or arbitrary areas).
//
// Key Components:
// - Coord2D: A single point in 2D world space.
// - GridBounds: A rectangular bounding box defined by min and max coordinates.
// -----------------------------------------------------------------------------
//
// Coord2D
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a single 2D coordinate in world space.
//   - Uses i64 to support extremely large coordinate ranges (beyond i32 limits).
// Derives:
//   - Debug, Clone, Copy: for easy inspection and duplication.
//   - PartialEq, Eq, PartialOrd, Ord, Hash: for comparisons and use in collections.
//   - Serialize, Deserialize: for persistence and networking.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    pub x: i64, // X component of the coordinate
    pub y: i64, // Y component of the coordinate
}

// -----------------------------------------------------------------------------
// GridBounds
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a rectangular region in 2D world space.
//   - Defined by inclusive minimum (min) and exclusive maximum (max) coordinates.
// Convention:
//   - Half-open range: [min, max)
//     * min is inclusive
//     * max is exclusive
//   - This ensures correct size calculation and avoids off-by-one errors.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    pub min: Coord2D, // Inclusive minimum coordinate (bottom-left corner)
    pub max: Coord2D, // Exclusive maximum coordinate (one past top-right corner)
}

impl GridBounds {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new GridBounds from explicit min and max coordinates.
    // Arguments:
    //   - min_x, min_y: inclusive minimum coordinates
    //   - max_x, max_y: exclusive maximum coordinates
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    // -------------------------------------------------------------------------
    // Method: size
    // -------------------------------------------------------------------------
    // Calculates the width and height of the bounds.
    // Formula:
    //   size.x = max.x - min.x
    //   size.y = max.y - min.y
    // Works correctly with half-open ranges, yielding the number of integer
    // coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    // -------------------------------------------------------------------------
    // Method: contains
    // -------------------------------------------------------------------------
    // Checks if a given coordinate lies within the bounds.
    // Follows half-open range convention:
    //   - min.x <= coord.x < max.x
    //   - min.y <= coord.y < max.y
    // Returns:
    //   - true if inside bounds
    //   - false otherwise
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default GridBounds instance.
//   - min = (0,0)
//   - max = (0,0)
// Represents a zero-sized bounds at the origin.
impl Default for GridBounds {
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}

// --- END: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
         2 LOC | rust/ssxl_shared/src\chunk\mod.rs
// --- START: rust/ssxl_shared/src\chunk\mod.rs ---
// -----------------------------------------------------------------------------
// Chunk Module Overview
// -----------------------------------------------------------------------------
// This file serves as the **module root** for all chunk-related functionality
// in the `ssxl_shared` crate. It organizes and exposes submodules that define
// the data structures and utilities for handling chunks in the SSXL engine.
//
// Why this matters:
//   - Rust modules are hierarchical. Declaring `pub mod ...` here tells the compiler
//     to look for corresponding files (or directories) and include them as part of
//     the `chunk` namespace.
//   - By centralizing these declarations, we ensure that all chunk-related logic
//     is grouped together and can be accessed via `ssxl_shared::chunk::...`.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Submodule: chunk_data
// -----------------------------------------------------------------------------
// Contains the **ChunkData** struct, which represents a single chunk of the world.
// Responsibilities:
//   - Stores chunk ID, bounds, tiles, dimension tag, and timestamp.
//   - Provides methods for tile access, insertion, and coordinate hashing.
//   - Acts as the atomic unit of procedural generation and caching.
// Usage:
//   - Accessed via `ssxl_shared::chunk::chunk_data::ChunkData`.
pub mod chunk_data;

// -----------------------------------------------------------------------------
// Submodule: grid_bounds
// -----------------------------------------------------------------------------
// Contains the **GridBounds** struct and supporting types (Coord2D).
// Responsibilities:
//   - Defines rectangular bounding boxes in world space.
//   - Provides utilities for size calculation and containment checks.
//   - Used by ChunkData to represent the spatial extent of a chunk.
// Usage:
//   - Accessed via `ssxl_shared::chunk::grid_bounds::GridBounds`.
pub mod grid_bounds;

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------
// Together, `chunk_data` and `grid_bounds` form the foundation of chunk management:
//   - `chunk_data` handles the contents and metadata of a chunk.
//   - `grid_bounds` defines the spatial boundaries of a chunk.
// This modular design keeps responsibilities clear and makes the engine easier
// to maintain, extend, and test.
// -----------------------------------------------------------------------------

// --- END: rust/ssxl_shared/src\chunk\mod.rs ---
        41 LOC | rust/ssxl_shared/src\config\config.rs
// --- START: rust/ssxl_shared/src\config\config.rs ---
// -----------------------------------------------------------------------------
// Global Configuration Module Overview
// -----------------------------------------------------------------------------
// This module defines the configuration structure and constants that govern
// the SSXL engine‚Äôs behavior. It ensures consistent values across crates
// (math, generate, cache, godot) and provides safe defaults when loading fails.
//
// Key Components:
// - SSXLConfig: Struct holding runtime configuration settings.
// - CHUNK_SIZE / TILE_ARRAY_SIZE: Constants defining chunk geometry.
// - DEFAULT_CONFIG_PATH: Default path for configuration file.
// - new_with_defaults: Provides safe fallback values.
// - load_from_path: Attempts to load configuration (placeholder implementation).
// - default_generator_id: Accessor for generator ID.
// - get_config_from_path: Public function to load configuration safely.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// tracing::{info, warn}
//   - Logging macros for runtime diagnostics (info-level success, warn-level failure).
// std::error::Error
//   - Trait object used for error handling in load_from_path.
// serde::{Deserialize, Serialize}
//   - Enables serialization/deserialization of SSXLConfig for persistence and loading.
use tracing::{info, warn};
use std::error::Error;
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Struct: SSXLConfig
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds runtime configuration settings for the SSXL engine.
// Fields:
//   - ca_default_ruleset: Default ruleset ID for cellular automata generation.
//   - default_generator_id: Identifier for the default generator used in world creation.
// Derives:
//   - Debug, Clone: For inspection and duplication.
//   - Serialize, Deserialize: For persistence and loading from config files.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSXLConfig {
    pub ca_default_ruleset: u8,
    pub default_generator_id: String,
}

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE
//   - Canonical side length of a chunk in tiles (32).
// TILE_ARRAY_SIZE
//   - Total number of tiles in a chunk (32 * 32 = 1024).
// DEFAULT_CONFIG_PATH
//   - Default file path for configuration JSON.
pub const CHUNK_SIZE: u32 = 32;
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
const DEFAULT_CONFIG_PATH: &str = "res://ssxl_config.json";

// -----------------------------------------------------------------------------
// Implementation: SSXLConfig
// -----------------------------------------------------------------------------
impl SSXLConfig {
    // -------------------------------------------------------------------------
    // Method: new_with_defaults
    // -------------------------------------------------------------------------
    // Provides a safe, hardcoded default configuration.
    // Ensures engine can initialize even if config file is missing or invalid.
    pub fn new_with_defaults() -> Self {
        SSXLConfig {
            ca_default_ruleset: 1,
            default_generator_id: "default_noise_gen".to_string(),
        }
    }

    // -------------------------------------------------------------------------
    // Method: load_from_path
    // -------------------------------------------------------------------------
    // Attempts to load configuration from a file path.
    // Currently a placeholder: always returns defaults.
    // Returns:
    //   - Ok(Self) on success
    //   - Err(Box<dyn Error>) on failure
    pub fn load_from_path(_path: &str) -> Result<Self, Box<dyn Error>> {
        Ok(SSXLConfig::new_with_defaults())
    }
    
    // -------------------------------------------------------------------------
    // Method: default_generator_id
    // -------------------------------------------------------------------------
    // Accessor for the default generator ID.
    // Returns a clone of the string to avoid ownership issues.
    pub fn default_generator_id(&self) -> String {
        self.default_generator_id.clone()
    }
}

// -----------------------------------------------------------------------------
// Function: get_config_from_path
// -----------------------------------------------------------------------------
// Purpose:
//   - Public entry point for loading configuration.
//   - Attempts to load from provided path or falls back to DEFAULT_CONFIG_PATH.
// Behavior:
//   - On success: logs info and returns loaded config.
//   - On failure: logs warning and returns safe defaults.
// Ensures engine always initializes with valid configuration.
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            warn!(
                "Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.",
                path_to_load,
                e
            );
            SSXLConfig::new_with_defaults()
        }
    }
}

// --- END: rust/ssxl_shared/src\config\config.rs ---
         1 LOC | rust/ssxl_shared/src\config\mod.rs
// --- START: rust/ssxl_shared/src\config\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/config/mod.rs
// -----------------------------------------------------------------------------
// Purpose:
//   - This file acts as the *module root* for configuration logic in the
//     `ssxl_shared` crate.
//   - By declaring `pub mod config;`, it exposes the `config.rs` file as a
//     public submodule, making its types and functions available under
//     `ssxl_shared::config::...`.
//
// Why it matters:
//   - Keeps the crate organized: all configuration constants and structs live
//     in one place.
//   - Provides a clean namespace boundary, so other crates can import
//     `SSXLConfig` or constants without digging into file paths.
// -----------------------------------------------------------------------------
pub mod config;

// --- END: rust/ssxl_shared/src\config\mod.rs ---
        21 LOC | rust/ssxl_shared/src\error\errors.rs
// --- START: rust/ssxl_shared/src\error\errors.rs ---
use thiserror::Error;

// -----------------------------------------------------------------------------
// SSXLResult
// -----------------------------------------------------------------------------
// A project-wide Result type that standardizes error handling.
// All fallible functions in the SSXL engine should return this type.
pub type SSXLResult<T> = Result<T, SSXLError>;

// -----------------------------------------------------------------------------
// SSXLError
// -----------------------------------------------------------------------------
// Central error enumeration for the SSXL engine.
// Each variant represents a distinct failure category, ensuring consistent
// reporting across subsystems and FFI boundaries.
#[derive(Error, Debug)]
pub enum SSXLError {
    // I/O failures such as file system or network errors.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    // Serialization or deserialization problems (e.g., Bincode, Serde).
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    // Invalid or inconsistent data states (e.g., wrong tile array size).
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    // Failures in the procedural generation pipeline.
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    // Errors in the Godot bridge or FFI layer.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    // Critical, unexpected bug in core logic.
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    // Wrapper for errors from external crates not covered elsewhere.
    #[error("External Crate Error: {0}")]
    External(String),
}

// -----------------------------------------------------------------------------
// Error Conversions
// -----------------------------------------------------------------------------
// Provides convenient conversions from common external error types into SSXLError.
// Ensures external libraries integrate smoothly with the SSXL error system.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}

// --- END: rust/ssxl_shared/src\error\errors.rs ---
         1 LOC | rust/ssxl_shared/src\error\mod.rs
// --- START: rust/ssxl_shared/src\error\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/error/mod.rs
// -----------------------------------------------------------------------------
// This file is the entry point for the `error` namespace in the `ssxl_shared` crate.
// By declaring `pub mod errors;`, it exposes the `errors.rs` submodule, which
// contains the canonical `SSXLError` enum and `SSXLResult` type alias.
// Purpose:
//   - Centralizes error handling for the engine.
//   - Provides a clean namespace so other crates can import errors via
//     `ssxl_shared::error::SSXLError` or `ssxl_shared::error::SSXLResult`.
// -----------------------------------------------------------------------------
pub mod errors;

// --- END: rust/ssxl_shared/src\error\mod.rs ---
        22 LOC | rust/ssxl_shared/src\job\mod.rs
// --- START: rust/ssxl_shared/src\job\mod.rs ---
// ============================================================================
// ‚ö° SSXL Job Module ‚ö°
// File: ssxl_shared/src/job/mod.rs
// ----------------------------------------------------------------------------
// This module is the **command center** of the SSXL engine.
// It defines the packets of intent (jobs) and the packets of outcome (results)
// that flow between the engine core and its generation pipeline.
// Think of it as the **messenger guild**: jobs go in, results come out.
// ============================================================================

use crate::ChunkData; // üéØ Core chunk payload imported from lib.rs

// -----------------------------------------------------------------------------
// üöÄ Instruction Packet: SSXLJob
// -----------------------------------------------------------------------------
// Represents the set of commands the engine can receive.
// Each variant is a ritual order, telling the generator what to do next.
pub enum SSXLJob {
    // üó∫Ô∏è BuildMap: Spin up a new world grid with given dimensions and seed.
    BuildMap {
        width: u32,
        height: u32,
        seed: u64,
        generator_id: String, // üîë Which generator to invoke
    },

    // üîß SetGenerator: Swap out the active generator configuration mid-flight.
    SetGenerator {
        generator_id: String,
    },

    // üõë StopGeneration: Halt all jobs, both running and queued.
    StopGeneration,

    // ... Future expansion: more job types can be added here.
}

// -----------------------------------------------------------------------------
// üéØ Result Packet: JobResult
// -----------------------------------------------------------------------------
// Represents the outcomes returned back to the engine tick loop.
// Each variant is a signal of success, completion, or failure.
pub enum JobResult {
    // üåü ChunkGenerated: A new chunk is ready for integration into world state.
    ChunkGenerated {
        x: i32,          // Explicit coordinates for clarity
        y: i32,
        data: ChunkData, // üì¶ The freshly minted chunk payload
    },

    // ‚úÖ MapBuildComplete: The BuildMap job has finished successfully.
    MapBuildComplete,

    // üí• Error: Something went wrong during job execution.
    Error(String),
}

// --- END: rust/ssxl_shared/src\job\mod.rs ---
        53 LOC | rust/ssxl_shared/src\lib.rs
// --- START: rust/ssxl_shared/src\lib.rs ---
// ============================================================================
// üì¶ SSXL Shared Crate Root
// File: ssxl_shared/src/lib.rs (or equivalent entry point)
// ----------------------------------------------------------------------------
// This file defines the top-level structure of the `ssxl_shared` crate.
// It organizes submodules, re-exports key types, and provides FFI entry points
// for external runtimes (CLI, Godot, etc.).
//
// Educational notes:
//   - In Rust, the crate root (`lib.rs` or `main.rs`) is the starting point
//     for module resolution. Declaring `pub mod ...` here makes submodules
//     available to the rest of the crate.
//   - Re-exports (`pub use ...`) provide a curated public API, so downstream
//     code doesn‚Äôt need to know the internal file layout.
//   - FFI functions (`#[no_mangle] extern "C" fn ...`) allow this crate to be
//     called from non-Rust environments (e.g., C, Godot).
// ============================================================================

use serde::{Deserialize, Serialize}; // Serialization traits for data persistence and networking
use tracing;                         // Structured logging for runtime diagnostics

// -----------------------------------------------------------------------------
// üìÇ Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` corresponds to a directory or file under `src/`.
// Declaring them here makes their contents available throughout the crate.
// -----------------------------------------------------------------------------
pub mod chunk;    // Chunk-related data structures (ChunkData, GridBounds, etc.)
pub mod tile;     // Tile-related data structures (TileData, TileType, etc.)
pub mod error;    // Error handling utilities (SSXLError, SSXLResult)
pub mod config;   // Configuration loading and parsing (SSXLConfig)
pub mod message;  // Messaging system for animation/generation commands
pub mod math;     // Math primitives and helpers (serialization, vectors, etc.)
pub mod job;      // Job definitions for generation tasks

// -----------------------------------------------------------------------------
// üîó Public Re-exports
// -----------------------------------------------------------------------------
// These re-exports expose commonly used types at the crate root.
// This simplifies imports for downstream crates (e.g., `ssxl_godot`).
// -----------------------------------------------------------------------------
pub use config::config::{get_config_from_path, SSXLConfig}; // Config loader + struct
pub use ssxl_math::primitives::{ChunkId, TileCoord};        // Core math identifiers

pub use chunk::chunk_data::{ChunkData, CHUNK_SIZE};         // Chunk struct + size constant
pub use tile::tile_data::TileData;                          // Tile struct
pub use chunk::grid_bounds::GridBounds;                     // Chunk boundary struct
pub use tile::tile_type::TileType;                          // Tile type enum

pub use message::messages::{
    AnimationCommand,           // Commands sent to animation subsystem
    AnimationType,              // Types of animations (flip, tween, etc.)
    AnimationPayload,           // Payload data for animation updates
    UpdateSender,               // Channel type for sending updates
    AnimationConductorHandle,   // Channel type for sending commands
    AnimationState,             // Global animation state struct
    CommandResult,              // Standardized command result type
    AnimationUpdate,            // Struct for animation update messages
};

pub use error::errors::{SSXLError, SSXLResult}; // Error type + result alias
pub use anyhow;                                // General-purpose error handling crate

// -----------------------------------------------------------------------------
// üåê FFI Export Function
// -----------------------------------------------------------------------------
// Provides an entry point for external runtimes (e.g., CLI).
// `#[no_mangle]` ensures the function name is preserved for linking.
// `extern "C"` makes it callable from C or other languages.
// -----------------------------------------------------------------------------
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    initialize_shared_data();
    tracing::info!("FFI Function `ssxl_start_runtime` called and shared initialization completed.");
    true 
}

// -----------------------------------------------------------------------------
// üìä Shared Data Structures
// -----------------------------------------------------------------------------
// Defines simple data primitives used across the engine.
// These can be serialized for persistence or transmitted across FFI boundaries.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,        // Unique identifier
    pub timestamp: u64, // Timestamp for creation/update
    pub value: String,  // Arbitrary string payload
}

pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

// -----------------------------------------------------------------------------
// üì¶ Prelude Module
// -----------------------------------------------------------------------------
// The `prelude` re-exports commonly used types so that downstream code can
// import them with a single `use ssxl_shared::prelude::*;`.
// This is a Rust convention for convenience and readability.
// -----------------------------------------------------------------------------
pub mod prelude {
    pub use super::chunk::chunk_data::{ChunkData, CHUNK_SIZE};
    pub use super::tile::tile_data::TileData;
    pub use super::chunk::grid_bounds::GridBounds;
    pub use super::tile::tile_type::TileType;
    
    pub use super::{ChunkId, TileCoord};
    
    pub use super::error::errors::{SSXLError, SSXLResult};
    
    // Animation-related types
    pub use super::message::messages::{AnimationCommand, AnimationType, AnimationState};
    pub use super::message::messages::AnimationUpdate;

    // Config access
    pub use super::config::config::SSXLConfig;
}

// -----------------------------------------------------------------------------
// üìà Global Atomic Counter
// -----------------------------------------------------------------------------
// Tracks the number of chunks completed during generation.
// `AtomicUsize` allows safe concurrent updates across threads.
// -----------------------------------------------------------------------------
use std::sync::atomic::AtomicUsize;

pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);

// --- END: rust/ssxl_shared/src\lib.rs ---
        20 LOC | rust/ssxl_shared/src\math\math_primitives.rs
// --- START: rust/ssxl_shared/src\math\math_primitives.rs ---
// ============================================================================
// üßÆ Math Primitives & Serde Helpers
// File: ssxl_shared/src/math_primitives.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Provides custom serialization/deserialization logic for mathematical and
//     standard library types that require deterministic formatting.
//   - Ensures cross-platform compatibility and stable persistence when caching
//     or transmitting data across the SSXL engine ecosystem.
//
// Why it matters:
//   - Default Serde behavior for certain types (like SystemTime) can vary
//     depending on platform or implementation.
//   - By enforcing a canonical format (milliseconds since UNIX epoch), we
//     guarantee consistency across all crates (math, generate, cache, godot).
// ============================================================================

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};

// -----------------------------------------------------------------------------
// ‚è±Ô∏è Module: system_time_serde
// -----------------------------------------------------------------------------
// Custom Serde helpers for `std::time::SystemTime`.
// Converts SystemTime <-> u64 (milliseconds since epoch).
// This ensures:
//   - Deterministic representation (always the same format).
//   - Platform independence (no OS-specific quirks).
//   - Stable caching and networking (safe to persist and reload).
// -----------------------------------------------------------------------------
pub mod system_time_serde {
    use super::*;

    // -------------------------------------------------------------------------
    // Function: serialize
    // -------------------------------------------------------------------------
    // Converts a SystemTime into a u64 millisecond count since UNIX_EPOCH.
    // Steps:
    //   1. Compute duration since epoch.
    //   2. Convert duration to milliseconds.
    //   3. Serialize as u64.
    // Usage:
    //   - Called automatically by Serde when writing data structures containing
    //     SystemTime (e.g., saving ChunkData to disk or sending over network).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Duration since epoch; errors if time < UNIX_EPOCH.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert to milliseconds (u64).
        let ms = duration.as_millis() as u64;
        // Serialize the millisecond count.
        serializer.serialize_u64(ms)
    }

    // -------------------------------------------------------------------------
    // Function: deserialize
    // -------------------------------------------------------------------------
    // Converts a u64 millisecond count back into a SystemTime.
    // Steps:
    //   1. Deserialize u64 from input.
    //   2. Create Duration from milliseconds.
    //   3. Add Duration to UNIX_EPOCH to reconstruct SystemTime.
    // Usage:
    //   - Called automatically by Serde when reading data structures containing
    //     SystemTime (e.g., loading ChunkData from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Read the millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert back into SystemTime.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}

// --- END: rust/ssxl_shared/src\math\math_primitives.rs ---
         1 LOC | rust/ssxl_shared/src\math\mod.rs
// --- START: rust/ssxl_shared/src\math\mod.rs ---
// ============================================================================
// üßÆ Math Module Index
// File: src/math/mod.rs
// ----------------------------------------------------------------------------
// In Rust, a `mod.rs` file serves as the "table of contents" for a directory.
// This file declares which submodules belong to the `math/` namespace.
//
// Purpose of the `math` module:
//   ‚Ä¢ Organize math-related helpers and primitives in one place.
//   ‚Ä¢ Provide deterministic serialization utilities for types like `SystemTime`.
//   ‚Ä¢ Keep the crate structure clean by grouping math logic separately from
//     chunks, tiles, and messaging.
//
// Why this matters:
//   ‚Ä¢ Other parts of the engine (e.g., chunk generation, caching) rely on
//     math primitives for consistent behavior.
//   ‚Ä¢ Declaring `pub mod math_primitives;` here makes the file
//     `src/math/math_primitives.rs` available as `crate::math::math_primitives`.
//   ‚Ä¢ This ensures imports like `use crate::math::math_primitives;` compile
//     correctly without unresolved path errors.
// ============================================================================

// Declare the `math_primitives` submodule.
// This corresponds to the file: src/math/math_primitives.rs
pub mod math_primitives;

// --- END: rust/ssxl_shared/src\math\mod.rs ---
        13 LOC | rust/ssxl_shared/src\message\generation_message.rs
// --- START: rust/ssxl_shared/src\message\generation_message.rs ---
// ============================================================================
// üì° Generation Messaging
// File: ssxl_shared/src/message/generation_message.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Defines the communication protocol between the Conductor (main thread)
//     and worker threads in the SSXL engine.
//   - Provides structures for sending generation tasks into the pipeline and
//     receiving results or status updates back.
//   - Ensures messages are serializable for persistence, networking, or debugging.
// ============================================================================

use crate::chunk::chunk_data::ChunkData;   // Core chunk payload type
use ssxl_math::prelude::Vec2i;             // 2D integer vector for chunk coordinates
use std::sync::Arc;                        // Atomic reference-counted pointer for safe sharing
use serde::{Serialize, Deserialize};       // Serialization traits for message passing

// -----------------------------------------------------------------------------
// üõ†Ô∏è Work Request Structure: GenerationTask
// -----------------------------------------------------------------------------
// Represents a single unit of work to be performed by a worker thread.
// Inserted into the engine‚Äôs TaskQueue by the Conductor.
// Fields:
//   - chunk_coords: identifies which chunk in chunk-space should be generated.
//   - generator_id: specifies which generator algorithm to use (e.g. "cellular_automata").
// Derives:
//   - Debug, Clone: for inspection and duplication.
//   - Serialize, Deserialize: for persistence and cross-thread communication.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationTask {
    pub chunk_coords: Vec2i,     // Target chunk coordinates in grid space
    pub generator_id: String,    // Generator identifier string
}

// -----------------------------------------------------------------------------
// üì¨ Communication Message Enumeration: GenerationMessage
// -----------------------------------------------------------------------------
// Represents messages sent back from worker threads to the Conductor.
// Each variant signals a different type of pipeline outcome.
// Variants:
//   - Generated: A chunk has been successfully produced.
//   - StatusUpdate: Informational message about progress or internal state.
//   - GenerationComplete: Signals that all tasks in a batch are finished.
// -----------------------------------------------------------------------------
#[derive(Debug, Serialize, Deserialize)]
pub enum GenerationMessage {
    // üåü Generated: A new chunk is ready.
    // Payload:
    //   - Vec2i: coordinates of the chunk.
    //   - Arc<ChunkData>: reference-counted chunk data for safe sharing.
    Generated(Vec2i, Arc<ChunkData>),

    // üìä StatusUpdate: Provides progress or state information.
    // Example: "50% complete" or "Switching generator mode".
    StatusUpdate(String),

    // ‚úÖ GenerationComplete: Marks the end of a batch of tasks.
    // Used by the Conductor to update global generation state.
    GenerationComplete,
}

// --- END: rust/ssxl_shared/src\message\generation_message.rs ---
        52 LOC | rust/ssxl_shared/src\message\messages.rs
// --- START: rust/ssxl_shared/src\message\messages.rs ---
// ============================================================================
// üì° Messaging System
// File: ssxl_shared/src/message/messages.rs
// ----------------------------------------------------------------------------
// This module defines the communication layer for the SSXL engine.
// It provides the data structures used to send instructions (commands)
// and receive feedback (updates/responses) between subsystems such as
// the Conductor, worker threads, and animation pipeline.
//
// Key goals:
//   - Standardize how tasks and updates are represented.
//   - Ensure all messages can be serialized (for persistence, networking, or debugging).
//   - Separate animation-related communication from generation-related communication.
// ============================================================================

use tokio::sync::mpsc::UnboundedSender; // Asynchronous channel for message passing
use crate::{ChunkId, TileCoord};        // Identifiers for chunks and tiles
use serde::{Deserialize, Serialize};    // Traits for serialization and deserialization

// -----------------------------------------------------------------------------
// üé® AnimationType
// -----------------------------------------------------------------------------
// Describes the *kind* of animation to apply.
// Each variant represents a different animation strategy:
//   - TileFlip: toggles a tile‚Äôs visual state.
//   - TweenMove: smoothly interpolates movement.
//   - PulseFade(f32): fades in/out with a given intensity.
//   - CustomScripted(String): allows user-defined scripted animations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

// -----------------------------------------------------------------------------
// üé® AnimationPayload
// -----------------------------------------------------------------------------
// Encapsulates the *data* needed for an animation update.
//   - FrameUpdate: specifies which frame to display.
//   - TweenValue: provides a key/value pair for a tweened property
//     (e.g., "opacity" -> 0.5).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

// -----------------------------------------------------------------------------
// üé® AnimationUpdate
// -----------------------------------------------------------------------------
// Represents a single animation update message.
// Fields:
//   - coord: the tile coordinate being animated.
//   - payload: the animation data to apply at that coordinate.
// This is what worker threads send back to the Conductor to indicate
// progress or changes in animation state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

// -----------------------------------------------------------------------------
// üé® AnimationCommand
// -----------------------------------------------------------------------------
// Commands sent *to* the animation subsystem.
// These instruct the system to start, modify, or stop animations.
// Variants:
//   - AnimateChunkSet: apply a chosen animation type to multiple chunks.
//   - StartTestAnimation: run a test/demo animation.
//   - SetTimeScale(f32): adjust global animation speed.
//   - SetEnabled(bool): enable/disable animations globally.
//   - Shutdown: terminate the animation subsystem.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationCommand {
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    StartTestAnimation,
    SetTimeScale(f32),
    SetEnabled(bool),
    Shutdown,
}

// Type alias for sending animation updates through an async channel.
// This makes it easier to reference the sender type consistently.
pub type UpdateSender = UnboundedSender<AnimationUpdate>;

// -----------------------------------------------------------------------------
// ‚öôÔ∏è GenerationCommand
// -----------------------------------------------------------------------------
// Commands sent to the *generation subsystem*.
// Variants:
//   - GenerateChunk: request generation of a specific chunk at given coordinates.
//   - SetGenerator: change which generator algorithm is active.
//   - Shutdown: stop the generation subsystem entirely.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GenerationCommand {
    GenerateChunk { coords: TileCoord },
    SetGenerator { id: String },
    Shutdown,
}

// -----------------------------------------------------------------------------
// ‚öôÔ∏è GenerationResponse
// -----------------------------------------------------------------------------
// Feedback returned after executing a generation command.
// Fields:
//   - success: true if the command succeeded, false otherwise.
//   - message: human-readable explanation of the outcome.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationResponse {
    pub success: bool,
    pub message: String,
}

// Type alias for sending animation commands to the conductor.
// Simplifies references to the channel type.
pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

// Type alias for generic command results.
// Standardizes return values across subsystems.
pub type CommandResult = Result<(), String>;

// -----------------------------------------------------------------------------
// üéõÔ∏è AnimationState
// -----------------------------------------------------------------------------
// Holds the *current global state* of the animation subsystem.
// Fields:
//   - time_scale: multiplier for animation speed (e.g., 2.0 = double speed).
//   - is_enabled: whether animations are globally active.
// Includes helper methods to update these values.
#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
pub struct AnimationState {
    pub time_scale: f32,
    pub is_enabled: bool,
}

impl AnimationState {
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}

// -----------------------------------------------------------------------------
// üîó Re-export
// -----------------------------------------------------------------------------
// Re-exports GenerationMessage from generation_message.rs as ChunkMessage.
// This allows other modules to import generation-related messages
// directly from `messages.rs`, keeping the API surface consistent.
pub use super::generation_message::GenerationMessage as ChunkMessage;

// --- END: rust/ssxl_shared/src\message\messages.rs ---
         9 LOC | rust/ssxl_shared/src\message\mod.rs
// --- START: rust/ssxl_shared/src\message\mod.rs ---
// ============================================================================
// üì° Message Module Index
// File: ssxl_shared/src/message/mod.rs
// ----------------------------------------------------------------------------
// This file serves as the *entry point* for all messaging-related code in the
// `ssxl_shared` crate. It organizes submodules and re-exports key types so that
// other parts of the engine (and external crates like `ssxl_godot`) can access
// messaging functionality through a clean, consistent API surface.
//
// Why this matters:
//   - Keeps the crate structure organized: `generation_message.rs` handles
//     worker-to-conductor communication, while `messages.rs` defines animation
//     and generation command types.
//   - Provides a single place to re-export commonly used types, avoiding deep
//     import paths in downstream code.
//   - Ensures that external modules can compile without unresolved import errors
//     (e.g., E0432 in `ssxl_godot/api_initializers.rs`).
// ============================================================================

pub mod generation_message; // Defines messages returned from generation workers
pub mod messages;           // Defines animation and generation command structures

// -----------------------------------------------------------------------------
// üîó Public Re-exports
// -----------------------------------------------------------------------------
// The following types are re-exported from `messages.rs` so that other crates
// can import them directly from `ssxl_shared::message`.
//
// Benefits:
//   - Simplifies usage: external code can write `use ssxl_shared::message::AnimationCommand;`
//     instead of navigating into `messages::AnimationCommand`.
//   - Provides a stable, curated API surface for messaging-related types.
// -----------------------------------------------------------------------------
pub use messages::{
    // Newly added re-exports to resolve current import errors
    AnimationCommand,
    AnimationState,
    
    // Existing re-exports for generation and animation updates
    AnimationUpdate,
    GenerationCommand, 
    GenerationResponse,
};

// --- END: rust/ssxl_shared/src\message\mod.rs ---
         2 LOC | rust/ssxl_shared/src\tile\mod.rs
// --- START: rust/ssxl_shared/src\tile\mod.rs ---
// ============================================================================
// üß© Tile Module Index
// File: ssxl_shared/src/tile/mod.rs
// ----------------------------------------------------------------------------
// This file acts as the *entry point* for all tile-related code in the
// `ssxl_shared` crate. In Rust, a `mod.rs` file inside a directory serves as
// the "table of contents" for that directory, declaring which submodules
// belong to it.
//
// Why this matters:
//   - Keeps the crate organized: all tile logic is grouped under `tile/`.
//   - Provides a clean namespace boundary: external code can import
//     `ssxl_shared::tile::TileData` or `ssxl_shared::tile::TileType` without
//     needing to know the internal file layout.
//   - Makes it easier to extend: new tile-related modules can be added here
//     and automatically become part of the `tile` namespace.
// ============================================================================

// -----------------------------------------------------------------------------
// üì¶ Submodule: tile_data
// -----------------------------------------------------------------------------
// Contains the definition of `TileData`, the core struct representing the
// state of a single tile in a chunk. This typically includes information
// such as:
//   - Tile type (floor, wall, water, etc.)
//   - Metadata (flags, properties, animation state)
//   - Serialization logic for saving/loading tile state.
//
// Usage example:
//   use ssxl_shared::tile::tile_data::TileData;
// -----------------------------------------------------------------------------
pub mod tile_data;

// -----------------------------------------------------------------------------
// üì¶ Submodule: tile_type
// -----------------------------------------------------------------------------
// Defines the `TileType` enumeration, which categorizes tiles by their role
// in the world (e.g., Grass, Stone, Water, Empty). This provides a strongly
// typed way to reason about tiles instead of relying on raw integers or
// strings.
//
// Usage example:
//   use ssxl_shared::tile::tile_type::TileType;
// -----------------------------------------------------------------------------
pub mod tile_type;

// --- END: rust/ssxl_shared/src\tile\mod.rs ---
        51 LOC | rust/ssxl_shared/src\tile\tile_data.rs
// --- START: rust/ssxl_shared/src\tile\tile_data.rs ---
//! ============================================================================
//! üß© Tile Data Structures (`ssxl_shared::tile::tile_data`)
//! ----------------------------------------------------------------------------
//! This module defines the core representation of a single tile in the SSXL
//! procedural world. Tiles are the smallest unit of world data, and their
//! design emphasizes efficiency, clarity, and compatibility with both Rust
//! and external systems (like Godot).
//!
//! Key responsibilities:
//!   - Provide a lightweight `TileData` struct for representing tile state.
//!   - Support serialization/deserialization for persistence and networking.
//!   - Use bitflags (`u8`) to store multiple boolean properties compactly.
//!   - Define FFI-friendly structures (`AnimationUpdate`) for communication
//!     with external runtimes such as Godot.
//!
//! Design choices:
//!   - `Copy` trait: allows tiles to be duplicated cheaply in tight loops.
//!   - `u8` flags: packs up to 8 booleans into one byte for memory efficiency.
//!   - Noise values: store raw procedural noise for debugging and neighbor checks.
//! ============================================================================

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};
use ssxl_math::prelude::Vec2i; // Used for coordinate-based updates in animations

// -----------------------------------------------------------------------------
// üì¶ Core Data Structure: TileData
// -----------------------------------------------------------------------------
// Represents the minimal payload for a single tile in a chunk.
// Fields:
//   - tile_type: categorizes the tile (e.g., grass, rock, void).
//   - noise_value: raw procedural noise used to determine type.
//   - flags: compact bitfield for boolean properties (see tile_flags).
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    pub tile_type: TileType,
    pub noise_value: f32,
    pub flags: u8,
}

impl Default for TileData {
    /// Provides a default tile: "empty" type, zero noise, no flags.
    /// This ensures predictable initialization when creating new chunks.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}

// -----------------------------------------------------------------------------
// üîó Godot FFI Message Structure: AnimationUpdate
// -----------------------------------------------------------------------------
// Used for communication between the Rust engine and the Godot runtime.
// Encapsulates tile animation updates in a format that can be serialized
// and passed across the FFI boundary.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub struct AnimationUpdate {
    pub layer: i32,             // Layer or dimension the tile belongs to
    pub source_id: i32,         // Source ID of the tilemap/animation system
    pub tile_coords: Vec2i,     // World coordinates of the tile to update
    pub new_atlas_coords: Vec2i // New texture atlas coordinates for animation frame
}

// -----------------------------------------------------------------------------
// ‚öôÔ∏è Bitwise Flag Constants
// -----------------------------------------------------------------------------
// Flags provide a compact way to store multiple boolean properties in one byte.
// Each constant represents a bitmask that can be set, cleared, or checked.
// -----------------------------------------------------------------------------
pub mod tile_flags {
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001; // Entities can move through this tile
    pub const IS_RENDERED:    u8 = 0b0000_0010; // Tile is visible to the client
    pub const IS_MODIFIED:    u8 = 0b0000_0100; // Tile was changed after generation
    pub const HAS_RESOURCE:   u8 = 0b0000_1000; // Tile contains a resource/item
    // Bits 4‚Äì7 reserved for future expansion
}

// -----------------------------------------------------------------------------
// üîß TileData Methods
// -----------------------------------------------------------------------------
// Utility functions for creating, inspecting, and modifying tile state.
// -----------------------------------------------------------------------------
impl TileData {
    /// Creates a new tile with a given type and noise value.
    /// Flags are initialized to zero (no properties set).
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0,
        }
    }

    /// Determines if the tile is "solid" (non-empty), typically used for collision.
    #[inline(always)]
    pub const fn is_solid(&self) -> bool {
        !self.tile_type.is_empty()
    }
    
    /// Sets or clears a flag property using a bitmask (e.g., `tile_flags::IS_TRAVERSABLE`).
    #[inline(always)]
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            self.flags |= flag_mask;   // Set bit(s)
        } else {
            self.flags &= !flag_mask;  // Clear bit(s)
        }
    }

    /// Checks whether a flag property is set.
    #[inline(always)]
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        (self.flags & flag_mask) != 0
    }
}

// --- END: rust/ssxl_shared/src\tile\tile_data.rs ---
        55 LOC | rust/ssxl_shared/src\tile\tile_type.rs
// --- START: rust/ssxl_shared/src\tile\tile_type.rs ---
//! ============================================================================
//! üß© Tile Type Enumeration (`ssxl_shared::tile::tile_type`)
//! ----------------------------------------------------------------------------
//! This module defines the `TileType` enum, which categorizes the material or
//! nature of a single tile in the SSXL engine. It is one of the most fundamental
//! data structures, used everywhere from chunk generation to rendering.
//!
//! Key design choices:
//!   - `#[repr(u8)]`: Forces the enum to be stored as a single byte. This is a
//!     critical memory optimization because each chunk contains thousands of tiles.
//!     Using one byte per tile type keeps memory usage predictable and efficient.
//!   - Serialization derives: Enables saving/loading tile data across FFI boundaries
//!     and persistent caches.
//!
//! Educational note:
//!   - Enums with `#[repr(u8)]` are often used in game engines to pack large grids
//!     of state into memory without wasting space.
//!   - Conversion helpers (`to_u8`, `from_u8`) make it easy to move between raw
//!     byte values and strongly typed variants.
//! ============================================================================

use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// üì¶ Core Enum: TileType
// -----------------------------------------------------------------------------
// Represents all canonical tile categories in the procedural world.
// Each variant corresponds to a material or terrain type.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    Void = 0,       // Empty space (air/background)
    Water = 1,      // Fluid terrain (rivers, oceans)
    Grass = 2,      // Base terrain, flat and walkable
    Mountain = 3,   // Elevated terrain, harder to traverse
    Boundary = 4,   // Artificial boundary (chunk edges, isolation zones)
    Structure = 5,  // Engineered/placed structures (walls, ruins, roads)
    Rock = 6,       // Solid rocky terrain
    Custom1 = 7,    // Reserved for generator-specific customization
    Custom2 = 8,    // Reserved for generator-specific customization
}

// Maximum valid value for TileType when represented as a raw u8.
pub const MAX_TILE_TYPE_VALUE: u8 = 8;

// -----------------------------------------------------------------------------
// üîß Default Implementation
// -----------------------------------------------------------------------------
// Provides a predictable default: all tiles start as `Void` unless specified.
// -----------------------------------------------------------------------------
impl Default for TileType {
    fn default() -> Self {
        TileType::Void
    }
}

// -----------------------------------------------------------------------------
// üîß Conversion & Lookup Methods
// -----------------------------------------------------------------------------
// Utility functions for working with TileType in raw form or rendering contexts.
// -----------------------------------------------------------------------------
impl TileType {
    /// Converts the enum into its underlying `u8` representation.
    /// Useful for serialization or compact storage.
    #[inline(always)] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Converts a raw `u8` back into a `TileType`, if valid.
    /// Returns `None` if the value is outside the defined range.
    #[inline(always)]
    pub fn from_u8(value: u8) -> Option<Self> {
        if value <= MAX_TILE_TYPE_VALUE {
            // SAFETY: We checked that the value is within [0, 8].
            Some(unsafe { std::mem::transmute(value) })
        } else {
            None
        }
    }
    
    /// Provides a default unique ID for this tile type.
    /// By convention, this is just its `u8` value.
    #[inline(always)]
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Returns default atlas coordinates (X, Y) for rendering.
    /// These are used by the rendering system to look up textures.
    #[inline(always)]
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            _ => (0, 0), // Void and custom types default to origin
        }
    }
}

// -----------------------------------------------------------------------------
// üîß Semantic Helper Methods
// -----------------------------------------------------------------------------
// These methods provide higher-level meaning for tile types, used in gameplay
// logic such as collision, traversal, and fluid simulation.
// -----------------------------------------------------------------------------
impl TileType {
    /// Returns true if the tile can typically be walked on.
    #[inline(always)]
    pub const fn is_walkable(self) -> bool {
        matches!(self, TileType::Grass | TileType::Mountain | TileType::Structure | TileType::Rock)
    }

    /// Returns true if the tile is a fluid (e.g., water).
    #[inline(always)]
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Returns true if the tile is empty (Void).
    #[inline(always)]
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}

// --- END: rust/ssxl_shared/src\tile\tile_type.rs ---
        44 LOC | rust/ssxl_sync/src\animation_conductor.rs
// --- START: rust/ssxl_sync/src\animation_conductor.rs ---
// ============================================================================
// üé¨ Animation Conductor (FFI Worker Wrapper)
// File: ssxl_sync/src/animation_conductor.rs
// ----------------------------------------------------------------------------
// This module defines the SSXL Animation Conductor, which is responsible for
// coordinating animation logic in a background thread. It acts as the bridge
// between the Godot runtime (via FFI) and the Rust engine‚Äôs animation system.
//
// Key responsibilities:
//   ‚Ä¢ Set up non-blocking channels for communication between Godot and Rust.
//   ‚Ä¢ Maintain initial animation state for the worker thread.
//   ‚Ä¢ Spawn the heavy background worker (`CoreAnimationWorker`) defined in
//     the `ssxl_animate` crate.
//   ‚Ä¢ Resolve type mismatches by aliasing the exact nested types required.
//
// Educational notes:
//   ‚Ä¢ Rust‚Äôs `tokio::sync::mpsc` channels are used for async, multi-producer,
//     single-consumer communication. Here, they connect Godot commands to the
//     worker and worker updates back to Godot.
//   ‚Ä¢ Aliasing `AnimationUpdate` ensures type signatures match exactly across
//     crate boundaries, fixing compiler errors like E0308.
//   ‚Ä¢ Splitting into two stages (FAST setup vs HEAVY spawn) separates lightweight
//     channel creation from expensive thread spawning.
// ============================================================================

use ssxl_shared::{
    AnimationConductorHandle, // Public handle for sending commands to the conductor
    AnimationState,           // Global animation state struct
    AnimationCommand,         // Enum of animation commands (start, stop, etc.)
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender}; // Async channels
use tracing::info; // Structured logging

// FIX: Import the exact nested type required by CoreAnimationWorker.
// Aliased as `AnimationUpdate` to resolve type mismatch errors (E0308).
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: The core worker implementation lives in the `ssxl_animate` crate.
// We alias it here for clarity and to emphasize the separation of concerns.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct
// -----------------------------------------------------------------------------
// This struct holds the internal channels and initial state required to spawn
// the background worker. It is not exposed directly to FFI consumers; instead,
// it is used internally during setup.
// -----------------------------------------------------------------------------
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,                  // Starting animation state
    pub command_receiver: UnboundedReceiver<AnimationCommand>, // Commands from Godot
    pub update_sender: UnboundedSender<AnimationUpdate>,       // Updates back to Godot
}

// -----------------------------------------------------------------------------
// 2. Public Conductor Struct
// -----------------------------------------------------------------------------
// This is the FFI-facing wrapper. It exposes safe methods for setting up
// channels and spawning the background worker thread.
// -----------------------------------------------------------------------------
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup
    // -------------------------------------------------------------------------
    // Creates the necessary channels and initializes the animation state.
    // This stage is lightweight and non-blocking.
    //
    // Returns:
    //   1. AnimationConductorInternalSetup: internal handles for spawning.
    //   2. AnimationConductorHandle: public command sender for Godot.
    //   3. UnboundedReceiver<AnimationUpdate>: public update receiver for Godot.
    // -------------------------------------------------------------------------
    pub fn setup_channels_and_state() -> (
        AnimationConductorInternalSetup,
        AnimationConductorHandle,
        UnboundedReceiver<AnimationUpdate>,
    ) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channel for commands: Godot ‚Üí worker
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channel for updates: worker ‚Üí Godot
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        // Initialize animation state to defaults
        let initial_state = AnimationState::default();

        // Bundle internal setup handles
        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        // Public handle for sending commands into the conductor
        let public_command_handle: AnimationConductorHandle = command_tx;

        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------
    // Consumes the setup handles and spawns the background worker thread.
    // This stage is heavier because it involves thread creation and worker
    // initialization.
    //
    // Arguments:
    //   ‚Ä¢ setup: internal channels and initial state from Stage 1.
    //
    // Returns:
    //   ‚Ä¢ AnimationConductor: opaque public handle representing the running worker.
    // -------------------------------------------------------------------------
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // Spawn the core worker with the correct channel types and initial state.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the public wrapper
        AnimationConductor {} 
    }
}

// --- END: rust/ssxl_sync/src\animation_conductor.rs ---
        21 LOC | rust/ssxl_sync/src\lib.rs
// --- START: rust/ssxl_sync/src\lib.rs ---
//! ============================================================================
//! ‚ö° SSXL Synchronization and Concurrency (`ssxl_sync`)
//! ----------------------------------------------------------------------------
//! This crate provides the concurrency backbone of the SSXL engine.
//! It defines thread-safe primitives, manages worker pools, and exposes
//! high-level FFI channel handles for communication across asynchronous
//! boundaries (e.g., between Rust workers and Godot).
//!
//! Educational notes:
//!   ‚Ä¢ Synchronization: ensures safe sharing of resources across threads.
//!   ‚Ä¢ Concurrency: organizes work into pools and tasks for efficient parallelism.
//!   ‚Ä¢ FFI channels: provide a standardized way to send/receive messages
//!     between Rust and external runtimes.
//!
//! By centralizing these utilities, `ssxl_sync` acts as the glue layer
//! that keeps the engine‚Äôs multi-threaded systems coordinated.
//! ============================================================================

use tokio::sync::mpsc; // Tokio channels for async communication

// -----------------------------------------------------------------------------
// üîó External Imports
// -----------------------------------------------------------------------------
// Import core contract types from `ssxl_shared`. These are the fundamental
// message and error types used across the engine.
// -----------------------------------------------------------------------------
use ssxl_shared::{
    SSXLError,        // Standardized error type for engine operations
    AnimationUpdate,  // Struct representing animation update messages
    AnimationCommand, // Enum representing animation commands
    // AnimationConductorHandle could be imported directly if needed
};

// FIX: Import and re-export the core struct in one step.
// This avoids duplicate definitions (E0252) or conflicting re-exports (E0365).
pub use ssxl_animate::AnimationConductor;

// -----------------------------------------------------------------------------
// üìÇ Internal Modules
// -----------------------------------------------------------------------------
// These modules implement the building blocks of synchronization:
//   ‚Ä¢ primitives: atomic resources and channel helpers
//   ‚Ä¢ pool: worker pool and task scheduling
//   ‚Ä¢ animation_conductor: FFI-facing wrapper for animation threads
// -----------------------------------------------------------------------------
pub mod primitives;
pub mod pool;
pub mod animation_conductor;

// -----------------------------------------------------------------------------
// üåê Public Re-exports (Crate Facade)
// -----------------------------------------------------------------------------
// Re-export commonly used types so downstream crates can access them directly
// from `ssxl_sync` without needing deep paths.
// -----------------------------------------------------------------------------
pub use primitives::{AtomicResource, create_unbounded_channel};

pub use pool::{
    WorkerPool,       // Thread pool manager
    GenerationTask,   // Task definition for chunk generation
    ConductorResult,  // Result type for conductor operations
    Task,             // Generic task abstraction
    TaskResult,       // Result type for tasks
};

// -----------------------------------------------------------------------------
// üõ†Ô∏è FFI Wrappers and Type Aliases (Crate Root API)
// -----------------------------------------------------------------------------
// These type aliases define the public API surface for FFI communication.
// They standardize the channel types used to send commands and updates
// across the Rust ‚Üî Godot boundary.
// -----------------------------------------------------------------------------
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>; // Receives animation commands
pub type UpdateSender   = mpsc::UnboundedSender<AnimationUpdate>;     // Sends animation updates
pub type CommandResult  = Result<(), SSXLError>;                     // Standardized command result

// ‚úÖ No struct wrapper here ‚Äî we rely on the alias from `ssxl_shared`
// to keep the API surface consistent and avoid duplication.

// --- END: rust/ssxl_sync/src\lib.rs ---
        96 LOC | rust/ssxl_sync/src\pool.rs
// --- START: rust/ssxl_sync/src\pool.rs ---
// ============================================================================
// ‚öôÔ∏è Thread Pool Manager (`ssxl_sync::pool_manager`)
// ----------------------------------------------------------------------------
// This module implements a fixed-size thread pool for executing synchronous,
// CPU-intensive generation tasks outside of the main thread and Tokio runtime.
// It is the backbone for high-throughput batch processing of `ChunkData`,
// ensuring that heavy work does not block async event loops.
//
// Key Concepts:
//   ‚Ä¢ Worker: Represents a single thread in the pool, with an ID and join handle.
//   ‚Ä¢ GenerationTask: Enum describing the unit of work (e.g., generate a chunk,
//     or shut down gracefully).
//   ‚Ä¢ ConductorResult: Enum describing the result of a task (completed chunk or error).
//   ‚Ä¢ WorkerPool: Manages the pool of workers, task queue, and graceful shutdown.
//
// Design Choices:
//   ‚Ä¢ Fixed pool size (POOL_SIZE = 4) for predictable resource usage.
//   ‚Ä¢ `crossbeam_channel` used for task/result communication because it provides
//     synchronous, blocking semantics ideal for CPU-bound work.
//   ‚Ä¢ `Arc<Receiver<Task>>` allows multiple worker threads to share the same
//     task queue safely.
//   ‚Ä¢ Results are sent back to the Conductor via a separate channel, enabling
//     centralized collection of completed work.
//
// Workflow:
//   1. Initialization (`WorkerPool::new`):
//      - Creates task and result channels.
//      - Spawns N worker threads, each running `run_worker_loop`.
//   2. Task submission (`submit_task`):
//      - Sends a `GenerationTask` into the pool‚Äôs task channel.
//   3. Worker loop (`run_worker_loop`):
//      - Blocks until a task arrives.
//      - Processes the task (e.g., generate a chunk).
//      - Sends back a `ConductorResult`.
//      - Shuts down gracefully if the channel is closed.
//   4. Shutdown (`Drop` impl):
//      - Sends a `Shutdown` task to unblock workers.
//      - Joins all worker threads to ensure clean termination.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a classic concurrency pattern: a fixed-size
//     worker pool consuming tasks from a shared queue.
//   ‚Ä¢ By separating task submission, worker execution, and result collection,
//     the system achieves both parallelism and safety.
//   ‚Ä¢ Graceful shutdown ensures no threads are leaked and all resources are
//     properly cleaned up.
// ============================================================================


use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData; 

const POOL_SIZE: usize = 4;

struct Worker {
    id: usize,
    handle: Option<JoinHandle<()>>,
}

#[derive(Debug)]
pub enum GenerationTask {
    GenerateChunk,
    Shutdown,
}

#[derive(Debug)]
pub enum ConductorResult {
    CompletedChunk(Arc<ChunkData>),
    Error(String),
}

pub type Task = GenerationTask;
pub type TaskResult = ConductorResult;

pub struct WorkerPool {
    task_sender: Sender<Task>,
    workers: Vec<Worker>,
}

impl WorkerPool {
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                workers,
            },
            result_rx,
        )
    }

    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            match task_rx.recv() {
                Ok(task) => {
                    info!("Worker {} processing task {:?}", id, task);
                    
                    let result: TaskResult = TaskResult::CompletedChunk(
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        break;
                    }
                }
                Err(_) => {
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

impl Drop for WorkerPool {
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        let _ = self.task_sender.send(Task::Shutdown);
        
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}



// --- END: rust/ssxl_sync/src\pool.rs ---
        27 LOC | rust/ssxl_sync/src\primitives.rs
// --- START: rust/ssxl_sync/src\primitives.rs ---
// ============================================================================
// üîí Synchronization Primitives (`ssxl_sync::primitives`)
// ----------------------------------------------------------------------------
// This module defines two foundational building blocks for safe, concurrent
// programming in the SSXL engine:
//
// 1. AtomicResource<T>
//    ‚Ä¢ A thread-safe wrapper around shared data.
//    ‚Ä¢ Internally uses `Arc<RwLock<T>>` from the `parking_lot` crate.
//    ‚Ä¢ Provides cheap cloning (`Arc`) and fine-grained read/write access
//      (`RwLock`), allowing multiple readers or a single writer at a time.
//    ‚Ä¢ Exposes ergonomic `read()` and `write()` methods that return guards,
//      ensuring Rust‚Äôs borrow checker enforces safe access.
//    ‚Ä¢ Implements `Default` so resources can be initialized predictably.
//
//    Educational note:
//    ‚Ä¢ `RwLock` (read‚Äìwrite lock) is ideal when reads are frequent and writes
//      are rare, as it allows concurrent readers but exclusive writers.
//    ‚Ä¢ Wrapping in `Arc` makes the resource clonable and shareable across
//      threads without copying the underlying data.
//    ‚Ä¢ This pattern is common in game engines and async runtimes where shared
//      state (e.g., configuration, animation state) must be accessed safely
//      by multiple worker threads.
//
// 2. create_unbounded_channel<M>
//    ‚Ä¢ A helper function that creates an unbounded multi-producer,
//      single-consumer channel using `crossbeam_channel`.
//    ‚Ä¢ Generic over message type `M`, so it can be used for any kind of
//      communication payload (commands, updates, events).
//    ‚Ä¢ Unbounded channels are useful for high-throughput pipelines where
//      backpressure is not desired (e.g., logging, fire-and-forget updates).
//
//    Educational note:
//    ‚Ä¢ Channels are a core concurrency primitive in Rust, enabling safe
//      message passing between threads without shared mutable state.
//    ‚Ä¢ `crossbeam_channel` provides blocking semantics, which are well-suited
//      for CPU-bound worker pools (as opposed to async channels in Tokio).
//
// Why this matters:
// ‚Ä¢ Together, `AtomicResource` and `create_unbounded_channel` provide the
//   foundation for building higher-level concurrency abstractions in SSXL.
// ‚Ä¢ They encapsulate common patterns (shared state + message passing) in a
//   reusable, ergonomic way.
// ‚Ä¢ By centralizing these primitives, the engine ensures consistency and
//   reduces boilerplate across subsystems (generation, animation, networking).
// ============================================================================



use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline(always)]
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline(always)]
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

pub fn create_unbounded_channel<M>() -> (Sender<M>, Receiver<M>) {
    unbounded()
}

// --- END: rust/ssxl_sync/src\primitives.rs ---
        50 LOC | rust/ssxl_tools/src\lib.rs
// --- START: rust/ssxl_tools/src\lib.rs ---
// ============================================================================
// ‚öôÔ∏è SSXL Engine Configuration (`ssxl_tools::config`)
// ----------------------------------------------------------------------------
// This module defines the configuration management system for the SSXL engine.
// It provides a lightweight way to load, validate, and fall back to defaults
// when configuration files are missing or invalid.
//
// Key Concepts:
//   ‚Ä¢ SSXLConfig struct:
//       - Holds core engine settings such as the default world generator ID
//         and the default Cellular Automata ruleset.
//       - Designed to be clonable and debuggable for easy inspection.
//   ‚Ä¢ Default constants:
//       - DEFAULT_CONFIG_PATH: canonical location of the engine‚Äôs config file.
//       - DEFAULT_GENERATOR: fallback generator ID if none is specified.
//       - DEFAULT_CA_RULESET: fallback ruleset ID for Cellular Automata.
//   ‚Ä¢ Fallback strategy:
//       - If configuration loading fails, the engine logs a warning and
//         initializes with hardcoded defaults to guarantee safe startup.
//       - This ensures the engine can always run, even in environments where
//         configuration files are missing or corrupted.
//
// Design Choices:
//   ‚Ä¢ File I/O is simulated (no TOML parsing yet) to minimize complexity.
//     - The system checks for file existence, then applies a simulated override.
//     - This allows developers to test configuration flow without full parsing.
//   ‚Ä¢ Logging via `tracing`:
//     - `info!` logs successful load attempts.
//     - `warn!` logs failures and fallback usage.
//   ‚Ä¢ Accessor methods (`get_default_generator_id`, `get_ca_default_ruleset`)
//     provide O(1) retrieval of settings, keeping runtime overhead negligible.
//
// Workflow:
//   1. Engine calls `get_config_from_path()` with an optional path.
//   2. If the file exists, a simulated override config is returned.
//   3. If the file does not exist, defaults are returned with a warning.
//   4. Downstream systems (generation, simulation) query the config via
//      accessor methods to determine which generator and ruleset to use.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a common pattern in engine design:
//       - Centralized configuration management.
//       - Safe fallbacks to ensure robustness.
//       - Clear logging for observability.
//   ‚Ä¢ Even though parsing is simulated here, the structure is ready to be
//     extended with real TOML/JSON/YAML parsing in the future.
// ============================================================================


use tracing::{info, warn};
use std::io;
use std::fs::File;

const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
const DEFAULT_CA_RULESET: u8 = 0;

#[derive(Debug, Clone)]
pub struct SSXLConfig {
    default_generator_id: String,
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(_file) => {
                info!("SSXLConfig: Config file found. Simulating config override (No TOML parsing).");
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(),
                    ca_default_ruleset: 1,
                })
            },
            Err(e) => Err(e),
        }
    }

    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            SSXLConfig::new_with_defaults()
        }
    }
}

// --- END: rust/ssxl_tools/src\lib.rs ---
       147 LOC | rust/ssxl_cli/src\actions\actions.rs
// --- START: rust/ssxl_cli/src\actions\actions.rs ---
// ============================================================================
// üß™ SSXL Engine Concurrency & Communication Tests
// ----------------------------------------------------------------------------
// This module defines a suite of diagnostic tests for validating the integrity
// of communication channels, data streaming, and conductor tempo in the SSXL
// engine. Each test simulates real-world concurrency scenarios to ensure that
// threads, channels, and timing behave correctly under load.
//
// Key Tests:
//   ‚Ä¢ run_communication_channel_test
//       - Validates basic async communication between threads using std::mpsc.
//       - Worker thread simulates heavy work (500ms sleep) before sending a
//         completion signal back to the main thread.
//       - Ensures signals are received within a timeout window, confirming
//         thread jump integrity.
//
//   ‚Ä¢ run_map_generation_test
//       - Simulates procedural map generation across multiple chunks.
//       - Worker thread emits chunk IDs via a data channel while main thread
//         consumes them with tempo checks.
//       - Validates streaming behavior, completion signaling, and resilience
//         against dropped channels.
//       - Confirms that all expected chunks are received before completion.
//
//   ‚Ä¢ run_data_channel_test
//       - Validates chunk/tile data channel integrity.
//       - Relies on `run_map_generation_test` for implicit validation.
//       - Provides a placeholder for explicit FFI type validation logic.
//
//   ‚Ä¢ run_animation_conductor_test
//       - Stress-tests the animation conductor‚Äôs ability to emit high-frequency
//         signals (approx. 120 signals in 2 seconds).
//       - Worker thread emits signals at ~120Hz (8.3ms intervals).
//       - Main thread measures latency (min/max) and counts signals received.
//       - Validates conductor tempo, signal integrity, and latency bounds.
//
// Design Choices:
//   ‚Ä¢ std::mpsc channels provide simple, synchronous communication primitives
//     for testing thread-to-thread message passing.
//   ‚Ä¢ Thread sleeps simulate heavy workloads and tempo-controlled signal
//     emission, mimicking real engine tasks.
//   ‚Ä¢ Timeout-based receivers ensure robustness against hangs or dropped
//     channels.
//   ‚Ä¢ Structured logging via `tracing` provides visibility into success/failure
//     states, making debugging straightforward.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how to validate concurrency primitives in Rust:
//       - Channels for message passing.
//       - Threads for parallel execution.
//       - Timeouts and latency checks for performance guarantees.
//   ‚Ä¢ By running these diagnostics, developers can confirm that the SSXL engine
//     maintains communication integrity, streaming reliability, and conductor
//     tempo under realistic workloads.
// ============================================================================


use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

pub fn run_communication_channel_test() {
    info!("TEST [2]: Starting Async Communication Channel Validation (Thread Jump Tempo Check)...");

    let (tx, rx) = mpsc::channel::<(String, String)>();

    let engine_test_thread = thread::spawn(move || {
        info!("WORKER: Starting 500ms sleep simulation (Simulating heavy map chunk 1 work)...");
        thread::sleep(Duration::from_millis(500));

        let message = "Async signal emission successful. Latency: 500ms".to_string();

        if tx.send(("TEST_COMPLETE".to_string(), message)).is_err() {
            error!("WORKER: Failed to send test signal. Receiver dropped (Godot side crashed?).");
        } else {
            info!("WORKER: Successfully sent TEST_COMPLETE signal back to main thread.");
        }
    });

    match rx.recv_timeout(Duration::from_secs(2)) {
        Ok((status, message)) => {
            if status == "TEST_COMPLETE" {
                info!("‚úÖ SUCCESS: Communication Channel Validated. {}", message);
                info!("   Thread jump integrity confirmed.");
            } else {
                error!("‚ùå FAIL: Received incorrect status: {}", status);
            }
        },
        Err(mpsc::RecvTimeoutError::Timeout) => {
            error!("‚ùå FAIL: Timeout (2s). Communication channel failed to establish required tempo.");
        },
        Err(mpsc::RecvTimeoutError::Disconnected) => {
            error!("‚ùå FAIL: Worker thread disconnected unexpectedly (Systemic Entropy).");
        }
    }

    engine_test_thread.join().unwrap();
}

pub fn run_map_generation_test() {
    info!("TEST [4]: Starting Map Generation Flow Validation (Procedural Purity & Streaming)...");

    let (data_tx, data_rx) = mpsc::channel::<usize>();
    let (done_tx, done_rx) = mpsc::channel::<()>();

    let total_chunks = 5;
    let engine_gen_thread = thread::spawn(move || {
        info!("WORKER: Starting map generation for {} chunks.", total_chunks);

        for i in 1..=total_chunks {
            thread::sleep(Duration::from_millis(50));

            if data_tx.send(i).is_err() {
                warn!("WORKER: Data channel dropped after chunk {}. Stopping.", i);
                return;
            }
            info!("WORKER: Emitted Chunk #{} (Data Payload Crypto Coded).", i);
        }

        if done_tx.send(()).is_err() {
            error!("WORKER: Failed to send generation_complete signal.");
        }
        info!("WORKER: Generation finished.");
    });

    let mut chunks_received = 0;

    loop {
        match data_rx.recv_timeout(Duration::from_millis(10)) {
            Ok(chunk_id) => {
                chunks_received += 1;
                info!("MAIN: Processed Chunk #{} (Data Channel) - Tempo maintained.", chunk_id);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                if done_rx.try_recv().is_ok() {
                    info!("MAIN: Detected Completion Signal (Generation Complete).");
                    break;
                }
                thread::sleep(Duration::from_millis(1));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                error!("‚ùå FAIL: Data channel disconnected prematurely (Systemic Entropy).");
                break;
            }
        }

        if done_rx.try_recv().is_ok() {
            info!("MAIN: Detected Completion Signal (Generation Complete).");
            break;
        }
    }

    engine_gen_thread.join().unwrap();

    if chunks_received == total_chunks {
        info!("‚úÖ SUCCESS: Map Generation Flow Validated. Received {}/{} chunks.", chunks_received, total_chunks);
        info!("   All data channels validated and quantum alignment achieved.");
    } else {
        error!("‚ùå FAIL: Map Generation Failed. Expected {} chunks, received {}.", total_chunks, chunks_received);
    }
}

pub fn run_data_channel_test() {
    info!("TEST [3]: Starting Chunk/Tile Data Channel Integrity Check...");

    info!("TEST [3]: Data channel integrity is validated implicitly and explicitly.");
    info!("   Implicitly: By checking successful channel send/receive in Action 4.");
    info!("   Explicitly: The FFI data type validation logic should be integrated here.");

    run_map_generation_test();
}

pub fn run_animation_conductor_test() {
    info!("TEST [5]: Starting Animation Conductor Tempo Validation (High-Frequency Loop Check)...");

    let (tx, rx) = mpsc::channel::<u64>();
    let required_signals = 120;
    let target_duration = Duration::from_millis(2000);

    let conductor_thread = thread::spawn(move || {
        info!("WORKER: Animation Conductor spun up. Targeting high tempo signal emission.");
        let start_time = Instant::now();
        let mut count = 0;

        while start_time.elapsed() < target_duration {
            thread::sleep(Duration::from_nanos(8333));

            if tx.send(start_time.elapsed().as_micros() as u64).is_err() {
                warn!("WORKER: Conductor signal dropped (Receiver disconnected).");
                return;
            }
            count += 1;
        }
        info!("WORKER: Conductor stopped. Emitted {} signals.", count);
    });

    let mut signals_received = 0;
    let mut min_latency_us = u64::MAX;
    let mut max_latency_us = 0;
    let main_start_time = Instant::now();

    while main_start_time.elapsed() < target_duration + Duration::from_millis(500) {
        match rx.recv_timeout(Duration::from_millis(1)) {
            Ok(timestamp_us) => {
                signals_received += 1;
                let elapsed_us = main_start_time.elapsed().as_micros() as u64;
                let latency_us = elapsed_us.saturating_sub(timestamp_us);

                min_latency_us = min_latency_us.min(latency_us);
                max_latency_us = max_latency_us.max(latency_us);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                thread::sleep(Duration::from_nanos(100));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                info!("MAIN: Conductor thread finished/disconnected.");
                break;
            }
        }
    }

    conductor_thread.join().unwrap();

    let success = signals_received >= required_signals;

    if success {
        info!("‚úÖ SUCCESS: Animation Conductor Tempo Validated.");
        info!("   Target Signals: {} | Received: {}", required_signals, signals_received);
        info!("   Latency (Main Thread Read Lag): Min {}¬µs, Max {}¬µs.", min_latency_us, max_latency_us);
    } else {
        error!("‚ùå FAIL: Animation Conductor FAILED to achieve required tempo.");
        error!("   Expected signals: {} | Received: {}. Check worker thread throttling.", required_signals, signals_received);
        error!("   Latency range suggests systemic entropy in signal marshalling.");
    }
}

// --- END: rust/ssxl_cli/src\actions\actions.rs ---
        66 LOC | rust/ssxl_cli/src\actions\benchmarking.rs
// --- START: rust/ssxl_cli/src\actions\benchmarking.rs ---
// ============================================================================
// üîÆ SSXL Signal Inspector & Benchmark Stub
// ----------------------------------------------------------------------------
// This module provides a command-line utility for monitoring the real-time
// status of the SSXL Conductor. It is designed as a diagnostic tool to give
// developers visibility into the conductor‚Äôs runtime behavior, queue depth,
// and generator activity.
//
// Key Components:
//   ‚Ä¢ start_signal_inspector
//       - Initializes the Conductor and begins a live feed loop.
//       - Displays frame count, conductor status, active generator ID, and
//         queue depth in real time.
//       - Uses Ctrl-C handling to gracefully shut down the conductor when
//         requested by the user.
//       - Monitors for critical states (ShuttingDown, Error) and triggers
//         teardown automatically.
//       - Provides a baseline metric (MVG_BASELINE) for tile throughput,
//         useful for performance comparisons.
//
//   ‚Ä¢ run_benchmark
//       - Placeholder function for future benchmarking logic.
//       - Currently logs a warning when invoked, signaling that benchmarking
//         is not yet implemented.
//
// Workflow:
//   1. Conductor initialization via `Conductor::new(None)`.
//   2. Wrap conductor in `Arc<Mutex>` for safe concurrent shutdown handling.
//   3. Register Ctrl-C handler:
//        - Sets running flag to false.
//        - Calls conductor‚Äôs graceful teardown.
//        - Prints shutdown message to stdout.
//   4. Enter live feed loop:
//        - Increment frame counter.
//        - Query conductor state for status, queue depth, and active generator.
//        - Print formatted status line to stdout.
//        - Flush output for real-time display.
//        - Sleep briefly to maintain tempo.
//   5. Exit loop when conductor signals shutdown or error.
//   6. Clear terminal line and log inspector termination.
//
// Design Choices:
//   ‚Ä¢ `Arc<Mutex>` ensures safe shared ownership of the conductor across
//     threads, particularly for shutdown handling.
//   ‚Ä¢ `AtomicBool` provides a lightweight flag for controlling the live feed
//     loop and responding to Ctrl-C signals.
//   ‚Ä¢ `ctrlc` crate integrates OS-level interrupt handling for graceful exits.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging
//     for visibility and debugging.
//   ‚Ä¢ Real-time printing with carriage return (`\r`) creates a dynamic,
//     single-line live feed in the terminal.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a responsive, real-time inspector
//     in Rust using concurrency primitives, structured logging, and signal
//     handling.
//   ‚Ä¢ It highlights the importance of graceful shutdown in long-running
//     systems, ensuring resources are cleaned up and runtime state is safely
//     terminated.
// ============================================================================


use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering}
};
use std::thread;
use std::time::Duration;
use ctrlc;

use ssxl_generate::conductor::{Conductor, ConductorStatus};

pub fn start_signal_inspector() {
    warn!("üîÆ Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    let (conductor, state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("‚ùå Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        print!("\r");
        print!("üîÆ LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        thread::sleep(Duration::from_millis(50));
    }

    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

#[allow(dead_code)]
pub fn run_benchmark() {
    warn!("‚è±Ô∏è Benchmark execution not yet implemented. Placeholder called.");
}

// --- END: rust/ssxl_cli/src\actions\benchmarking.rs ---
       102 LOC | rust/ssxl_cli/src\actions\godot_harness.rs
// --- START: rust/ssxl_cli/src\actions\godot_harness.rs ---
// ============================================================================
// üéÆ SSXL CLI: Godot Harness (`ssxl_cli::actions::godot_harness`)
// ----------------------------------------------------------------------------
// This module provides command-line utilities for integrating the SSXL engine
// with the Godot editor and runtime. It automates critical setup tasks such as
// copying the compiled Rust dynamic library into the Godot project and
// launching Godot in either editor or headless mode.
//
// Key Functions:
//   ‚Ä¢ copy_dll_to_tester_project_at_boot
//       - Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the
//         `target` build directory into the Godot project‚Äôs GDExtension folder.
//       - Ensures Godot loads the latest engine code when the project runs.
//       - Validates source path existence, logs warnings if missing, and
//         handles errors gracefully (e.g., file locked by running Godot).
//
//   ‚Ä¢ launch_godot_client
//       - Launches the Godot Editor in a non-blocking subprocess.
//       - Useful for debugging scenes and testing engine integration with GUI.
//       - Uses `--editor` flag to open the editor instead of running the game.
//       - Logs success/failure and provides guidance if the executable path is
//         misconfigured.
//
//   ‚Ä¢ launch_headless_godot
//       - Launches Godot in headless mode (no GUI).
//       - Ideal for automated testing, CI pipelines, or server-side execution.
//       - Uses `--headless` flag to run without a graphical interface.
//       - Logs success/failure and ensures correct path configuration.
//
// Workflow:
//   1. Build Rust engine (`cargo build`).
//   2. Run `copy_dll_to_tester_project_at_boot` to sync DLL into Godot project.
//   3. Launch Godot via either `launch_godot_client` (editor mode) or
//      `launch_headless_godot` (headless mode).
//   4. Godot loads the DLL from its GDExtension folder, enabling engine
//      integration.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` provides portable subprocess execution.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) ensure structured logging for
//     visibility and debugging.
//   ‚Ä¢ Path construction uses `env::current_dir` combined with project-specific
//     constants for portability across environments.
//   ‚Ä¢ Non-blocking subprocesses (`spawn`) allow the CLI to continue running
//     while Godot executes.
//
// Educational Note:
//   ‚Ä¢ This harness demonstrates how Rust can act as a build-time and runtime
//     companion to Godot, automating repetitive tasks and ensuring smooth
//     integration.
//   ‚Ä¢ By centralizing DLL copying and process launching here, developers avoid
//     manual setup errors and streamline the workflow between Rust and Godot.
// ============================================================================


use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};

pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    source.push(DLL_NAME);
    let source_path = source.as_path();

    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "‚úÖ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            Err(format!(
                "‚ùå FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}

pub fn launch_godot_client() {
    info!("üöÄ LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        .arg("--editor")
        .arg("--path")
        .arg(&project_path_abs)
        .spawn()
    {
        Ok(_) => {
            info!("‚úÖ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("‚ùå Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

pub fn launch_headless_godot() {
    info!("üöÄ LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        .arg("--headless")
        .arg("--path")
        .arg(&project_path_abs)
        .spawn()
    {
        Ok(_) => {
            info!("‚úÖ Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!("‚ùå Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}

// --- END: rust/ssxl_cli/src\actions\godot_harness.rs ---
        25 LOC | rust/ssxl_cli/src\actions\godot_tests.rs
// --- START: rust/ssxl_cli/src\actions\godot_tests.rs ---
// ============================================================================
// üß™ SSXL CLI: Godot Integration Tests (`godot_harness_tests`)
// ----------------------------------------------------------------------------
// This module defines a set of CLI-accessible integration tests that validate
// the connection between the Rust engine (via FFI/GDExtension) and the Godot
// runtime. Each test launches a specific Godot scene and checks for expected
// success signals, ensuring that critical subsystems are wired correctly.
//
// Key Functions:
//   ‚Ä¢ run_ffi_bridge_validation
//       - Validates the Foreign Function Interface (FFI) bridge between Rust
//         and Godot.
//       - Confirms that the compiled Rust dynamic library is correctly loaded
//         into Godot via GDExtension.
//       - Ensures bidirectional communication between Rust and Godot succeeds.
//
//   ‚Ä¢ run_headless_generation_integration_test
//       - Runs a headless Godot scene that exercises the full map generation
//         pipeline.
//       - Validates procedural generation, streaming, and integration without
//         requiring a graphical interface.
//       - Confirms that generated chunks are correctly processed and aligned.
//
//   ‚Ä¢ run_headless_animation_tempo_test
//       - Executes a headless Godot scene focused on animation conductor tempo.
//       - Validates high-frequency signal emission and latency handling.
//       - Ensures the conductor loop maintains expected performance under load.
//
// Workflow:
//   1. Each function calls `run_godot_test`, passing:
//        - A human-readable test description.
//        - The path to the Godot scene to execute.
//        - The expected success message for validation.
//   2. Godot runs the scene (editor or headless).
//   3. The CLI captures output and checks for the success string.
//   4. Results are logged, confirming subsystem integrity.
//
// Design Choices:
//   ‚Ä¢ Headless tests allow automated validation in CI/CD pipelines without GUI.
//   ‚Ä¢ Scene-based testing leverages Godot‚Äôs runtime to validate integration
//     rather than relying solely on unit tests.
//   ‚Ä¢ Success messages provide clear, human-readable confirmation of subsystem
//     health.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how to bridge Rust and Godot using FFI and
//     GDExtension, ensuring that engine subsystems (map generation, animation,
//     conductor tempo) are validated in real runtime conditions.
//   ‚Ä¢ By centralizing these checks in the CLI, developers can quickly confirm
//     integration health before deploying or debugging in the editor.
// ============================================================================


use super::{
    run_godot_test, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_ffi_bridge_validation() {
    run_godot_test(
        "FFI Bridge and GDExtension Integration Validation",
        GODOT_TEST_SCENE,
        "FFI/GDExtension Bridge VALIDATION SUCCEEDED!",
    );
}

pub fn run_headless_generation_integration_test() {
    run_godot_test(
        "Headless Map Generation Integration Test",
        HEADLESS_GEN_TEST_SCENE,
        "Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.",
    );
}

pub fn run_headless_animation_tempo_test() {
    run_godot_test(
        "Headless Animation Conductor Tempo Test",
        HEADLESS_ANIM_TEST_SCENE,
        "Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.",
    );
}

// --- END: rust/ssxl_cli/src\actions\godot_tests.rs ---
        46 LOC | rust/ssxl_cli/src\actions\mod.rs
// --- START: rust/ssxl_cli/src\actions\mod.rs ---
// ============================================================================
// ‚öôÔ∏è SSXL CLI Actions Module (`ssxl_cli::actions`)
// ----------------------------------------------------------------------------
// This module acts as the central fa√ßade for all command-line actions in the
// SSXL engine CLI. It aggregates constants, utilities, and exports from child
// modules, providing a unified interface for launching Godot, running tests,
// monitoring conductor status, and initiating benchmarks.
//
// Structure:
//   ‚Ä¢ Submodules:
//       - benchmarking: Tools for real-time monitoring of the Conductor and
//         placeholders for benchmark logic.
//       - godot_harness: Utilities for launching and managing the external
//         Godot tester project (editor and headless modes).
//       - testing: Menu and orchestration logic for executing test suites.
//       - test_suites: Self-contained architectural and data validation tests.
//       - test_core_suites: Tests requiring external processes like `cargo`
//         builds and Godot FFI validation.
//
//   ‚Ä¢ Configuration Constants:
//       - GODOT_EXE_PATH: Absolute path to the Godot executable.
//       - RELATIVE_PROJECT_PATH_FRAGMENT: Relative path to the Godot tester
//         project‚Äôs GDExtension folder.
//       - DLL_NAME: Expected name of the compiled Rust dynamic library.
//       - SOURCE_DLL_PATH_FRAGMENT: Path fragment where the compiled DLL is
//         found (e.g., `target/debug/`).
//       - GODOT_TEST_SCENE: Scene path for FFI bridge validation.
//       - HEADLESS_GEN_TEST_SCENE: Scene path for headless generation pipeline
//         validation.
//       - HEADLESS_ANIM_TEST_SCENE: Scene path for headless animation tempo
//         validation.
//
//   ‚Ä¢ Utility Functions:
//       - get_godot_project_abs_path: Calculates the absolute path to the Godot
//         tester project root, ensuring portability across environments.
//
//   ‚Ä¢ Public Exports (Fa√ßade):
//       - start_signal_inspector: Real-time conductor monitoring feed.
//       - copy_dll_to_tester_project_at_boot, launch_godot_client,
//         launch_headless_godot: Godot harness utilities.
//       - run_cargo_tests, run_ffi_bridge_validation,
//         run_headless_generation_integration_test,
//         run_headless_animation_tempo_test: Core test suite exports.
//       - run_communication_channel_test, run_data_channel_test,
//         run_map_generation_test, run_animation_conductor_test: General test
//         suite exports.
//       - execute_testing_menu: Entry point for orchestrating test execution.
//
// Design Choices:
//   ‚Ä¢ Modular organization ensures separation of concerns between harnessing,
//     benchmarking, and testing logic.
//   ‚Ä¢ Constants centralize configuration for portability and maintainability.
//   ‚Ä¢ Re-exports provide a clean fa√ßade, allowing external callers to interact
//     with CLI actions without needing to know internal module structure.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates the fa√ßade pattern in Rust: exposing a curated
//     set of functions and constants from multiple submodules to simplify
//     external usage.
//   ‚Ä¢ By consolidating CLI actions here, developers gain a single, predictable
//     entry point for managing Godot integration, conductor monitoring, and
//     validation pipelines.
// ============================================================================


use std::env;
use std::path::PathBuf;

mod benchmarking;
mod godot_harness;
mod testing;
mod test_suites;
mod test_core_suites;

pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXLtester2/";
pub const DLL_NAME: &str = "ssxl_engine.dll";
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; 
pub const HEADLESS_GEN_TEST_SCENE: &str = "res://tests/headless_gen_pipeline.tscn";
pub const HEADLESS_ANIM_TEST_SCENE: &str = "res://tests/headless_anim_tempo.tscn";

pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}

pub use benchmarking::start_signal_inspector;

pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
};

pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};

#[allow(unused_imports)]
pub use testing::execute_testing_menu;

// --- END: rust/ssxl_cli/src\actions\mod.rs ---
        36 LOC | rust/ssxl_cli/src\actions\testing.rs
// --- START: rust/ssxl_cli/src\actions\testing.rs ---
// ============================================================================
// üß™ SSXL CLI: Testing Menu (`ssxl_cli::actions::testing`)
// ----------------------------------------------------------------------------
// This module provides a command-line menu for executing various validation
// suites. It acts as the central dispatcher, delegating execution to both
// internal architectural tests and external integration tests.
//
// Purpose:
//   ‚Ä¢ Offer a unified interface for developers to run different categories of
//     tests directly from the CLI.
//   ‚Ä¢ Simplify orchestration by exposing a menu-driven workflow rather than
//     requiring manual invocation of individual test functions.
//   ‚Ä¢ Ensure that both Rust-only validation (unit/integration tests) and
//     Godot-linked integration tests can be triggered consistently.
//
// Key Components:
//   ‚Ä¢ TEST_ACTIONS (LazyLock<Vec<CliAction>>)
//       - Defines the available test actions as menu items.
//       - Each action has an identifier (`id`) and a description.
//       - LazyLock ensures thread-safe, runtime initialization of the menu.
//
//   ‚Ä¢ execute_testing_menu
//       - Central entry point for the testing menu.
//       - Creates a `CliMenu` with all available test actions.
//       - Enters a loop, prompting the user to select an action.
//       - Matches the selected action against its `id` and delegates execution
//         to the appropriate test function.
//       - Supports returning to the main menu via the "back" action.
//
// Supported Actions:
//   ‚Ä¢ "cargo"      ‚Üí Runs all standard Rust unit/integration tests via Cargo.
//   ‚Ä¢ "ffi"        ‚Üí Runs FFI bridge and GDExtension integration validation
//                    (headless Godot).
//   ‚Ä¢ "channel"    ‚Üí Runs communication channel tempo test (non-blocking mpsc).
//   ‚Ä¢ "generation" ‚Üí Runs Perlin-based map generation test.
//   ‚Ä¢ "animation"  ‚Üí Runs animation conductor data contract test.
//   ‚Ä¢ "back"       ‚Üí Exits the testing menu and returns to the main CLI menu.
//
// Design Choices:
//   ‚Ä¢ `CliAction` and `CliMenu` abstract away menu logic, keeping this module
//     focused on orchestration.
//   ‚Ä¢ LazyLock ensures initialization happens only once, avoiding global
//     mutable state issues.
//   ‚Ä¢ Pattern matching on `id` strings provides a simple, extensible way to
//     add new test actions in the future.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a fa√ßade for test orchestration,
//     combining multiple subsystems into a single, developer-friendly entry
//     point.
//   ‚Ä¢ By centralizing test execution here, developers can quickly validate
//     both internal architecture and external integration without switching
//     contexts or running multiple commands manually.
// ============================================================================


use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;
use crate::actions::test_core_suites;
use std::sync::LazyLock;

#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    CliAction::new("back", "‚Ü©Ô∏è Return to Main Menu"), 
]);

#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}

// --- END: rust/ssxl_cli/src\actions\testing.rs ---
       103 LOC | rust/ssxl_cli/src\actions\tests_core.rs
// --- START: rust/ssxl_cli/src\actions\tests_core.rs ---
// ============================================================================
// üß™ SSXL CLI: Core Test Runner (`ssxl_cli::actions::test_core_runner`)
// ----------------------------------------------------------------------------
// This module provides utilities for executing both Rust-based unit/integration
// tests and Godot-based headless integration tests. It acts as the backbone of
// the CLI testing framework, ensuring that internal Rust logic and external
// Godot integration are validated consistently.
//
// Key Functions:
//   ‚Ä¢ run_cargo_tests
//       - Executes the full Rust test suite via `cargo test`.
//       - Runs with `--nocapture` to stream output directly to the console.
//       - Reports success/failure based on Cargo‚Äôs exit status.
//
//   ‚Ä¢ read_all_output_from_stream
//       - Helper function for reading all output from a process stream.
//       - Runs in a separate thread to avoid blocking the main process.
//       - Collects stdout/stderr into strings for later logging.
//
//   ‚Ä¢ run_godot_test
//       - Generic runner for Godot-based integration tests.
//       - Accepts a test title, scene path, and success message.
//       - Spawns Godot in headless mode with the specified scene.
//       - Captures stdout and stderr concurrently for full visibility.
//       - Logs formatted output and reports success/failure based on Godot‚Äôs
//         exit status.
//
// Workflow:
//   1. Rust unit/integration tests are executed via `run_cargo_tests`.
//   2. Godot is launched in headless mode with a specific test scene.
//   3. Output streams (stdout/stderr) are captured in parallel threads.
//   4. Results are logged to the console, including success/failure messages.
//   5. Exit codes and captured output provide detailed diagnostics.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` is used to spawn external processes (Cargo, Godot).
//   ‚Ä¢ `Stdio::piped` allows capturing stdout/stderr for real-time logging.
//   ‚Ä¢ Threads are used to read output streams concurrently, preventing blocking.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Headless Godot execution ensures tests can run in CI/CD pipelines without
//     requiring a GUI.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can orchestrate external processes to
//     validate integration with another engine (Godot).
//   ‚Ä¢ By combining Cargo tests with Godot headless scenes, developers gain
//     confidence that both the Rust engine and its FFI bridge are functioning
//     correctly in real runtime conditions.
// ============================================================================


use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, 
    GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE, HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("üöÄ Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("‚úÖ All Rust unit and integration tests passed.");
    } else {
        error!("‚ùå Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub(crate) fn run_godot_test(
    test_title: &str,
    test_scene: &str,
    success_message: &str,
) -> bool {
    info!("üî• STARTING: {}...", test_title);

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå {} failed: {}", test_title, e);
            return false;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(test_scene)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process for {}: {}", test_title, e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return false;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait for {}: {}", test_title, e);
            return false;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());
    
    println!("\n--- GODOT {} TEST OUTPUT START ---", test_title.to_uppercase());
    println!("{}", stdout_output);
    println!("--- GODOT {} TEST OUTPUT END ---\n", test_title.to_uppercase());

    if status.success() {
        info!("‚úÖ {} SUCCEEDED! {}", test_title, success_message);
        true
    } else {
        error!(
            "‚ùå {} FAILED! Exit code: {:?}",
            test_title,
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
        false
    }
}

// --- END: rust/ssxl_cli/src\actions\tests_core.rs ---
       234 LOC | rust/ssxl_cli/src\actions\test_core_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_core_suites.rs ---
// ============================================================================
// üß™ SSXL CLI: Core Test Suites (`ssxl_cli::actions::test_core_suites`)
// ----------------------------------------------------------------------------
// This module defines the core integration tests that validate communication
// between the Rust engine and the Godot runtime. Unlike lightweight unit tests,
// these tests spawn external processes (Cargo and Godot) to ensure that the
// full pipeline‚Äîfrom compilation to FFI bridge to headless execution‚Äîworks
// correctly in real runtime conditions.
//
// Key Functions:
//   ‚Ä¢ run_cargo_tests
//       - Executes the full Rust test suite via `cargo test`.
//       - Runs with `--nocapture` to stream output directly to the console.
//       - Validates that all Rust unit and integration tests pass before
//         attempting Godot integration.
//
//   ‚Ä¢ run_ffi_bridge_validation
//       - Launches Godot in headless mode with the FFI bridge validation scene.
//       - Confirms that the Rust dynamic library is correctly loaded via
//         GDExtension and that communication between Rust and Godot succeeds.
//       - Captures stdout/stderr from the Godot process for detailed logging.
//       - Reports success/failure based on Godot‚Äôs exit status.
//
//   ‚Ä¢ run_headless_generation_integration_test
//       - Executes a headless Godot scene that validates the full map generation
//         pipeline.
//       - Ensures procedural generation, streaming, and integration logic work
//         without requiring a graphical interface.
//       - Captures and logs Godot output for debugging and validation.
//
//   ‚Ä¢ run_headless_animation_tempo_test
//       - Runs a headless Godot scene focused on animation conductor tempo.
//       - Validates high-frequency signal emission and latency handling in the
//         conductor loop.
//       - Confirms that the conductor maintains expected performance under load.
//
// Workflow:
//   1. Rust unit/integration tests are executed via `run_cargo_tests`.
//   2. Godot is launched in headless mode with specific test scenes.
//   3. Output streams (stdout/stderr) are captured in parallel threads.
//   4. Results are logged to the console, including success/failure messages.
//   5. Exit codes and captured output provide detailed diagnostics.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` is used to spawn external processes (Cargo, Godot).
//   ‚Ä¢ `Stdio::piped` allows capturing stdout/stderr for real-time logging.
//   ‚Ä¢ Threads are used to read output streams concurrently, preventing blocking.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Headless Godot execution ensures tests can run in CI/CD pipelines without
//     requiring a GUI.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how Rust can orchestrate external processes to
//     validate integration with another engine (Godot).
//   ‚Ä¢ By combining Cargo tests with Godot headless scenes, developers gain
//     confidence that both the Rust engine and its FFI bridge are functioning
//     correctly in real runtime conditions.
// ============================================================================


use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("üöÄ Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("‚úÖ All Rust unit and integration tests passed.");
    } else {
        error!("‚ùå Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub fn run_ffi_bridge_validation() {
    info!("üî• STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(
            "‚ùå FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_generation_integration_test() {
    info!("üî• STARTING: Headless Map Generation Integration Test (Full Pipeline Validation)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_GEN_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS GENERATION TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS GENERATION TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.");
    } else {
        error!(
            "‚ùå Headless Generation Integration Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_animation_tempo_test() {
    info!("üî• STARTING: Headless Animation Conductor Tempo Test (Signal Latency Check)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_ANIM_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT START ---\n");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.");
    } else {
        error!(
            "‚ùå Headless Animation Tempo Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
// --- END: rust/ssxl_cli/src\actions\test_core_suites.rs ---
       107 LOC | rust/ssxl_cli/src\actions\test_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_suites.rs ---
// ============================================================================
// üß™ SSXL CLI: Internal Architectural & Data Validation Suites
// ----------------------------------------------------------------------------
// This module defines self-contained Rust tests that validate the integrity of
// internal data contracts, concurrency models, and core generation logic. Unlike
// integration tests that rely on external processes (e.g., Godot), these suites
// focus purely on architectural correctness within the Rust engine itself.
//
// Key Functions:
//   ‚Ä¢ run_communication_channel_test
//       - Validates non-blocking `mpsc` channels used between Godot‚Äôs main thread
//         and Rust worker threads (Generation and Animation Conductors).
//       - Simulates a conductor thread receiving commands while the CLI floods
//         the channel with messages.
//       - Confirms that messages are successfully transmitted and received within
//         a bounded test duration.
//
//   ‚Ä¢ run_data_channel_test
//       - Alias for `run_communication_channel_test`.
//       - Provides a semantic entry point for validating data channel integrity.
//
//   ‚Ä¢ run_map_generation_test
//       - Validates core map generation logic using the Perlin noise generator.
//       - Generates a chunk at specific coordinates and verifies tile count
//         against the expected `CHUNK_SIZE`¬≤.
//       - Reports generation time and throughput (tiles/sec) for performance
//         benchmarking.
//       - Ensures chunk data integrity and correctness of procedural generation.
//
//   ‚Ä¢ run_animation_conductor_test
//       - Validates the data contract for animation updates.
//       - Ensures the `AnimationUpdate` struct can be serialized and deserialized
//         using `bincode` without data loss.
//       - Confirms that tile coordinates and atlas coordinates remain consistent
//         after round-trip encoding/decoding.
//       - Provides confidence that animation updates can safely traverse FFI
//         boundaries and channels.
//
// Workflow:
//   1. Communication channels are stress-tested for throughput and reliability.
//   2. Map generation is validated for correctness and performance metrics.
//   3. Animation conductor data contracts are verified for serialization safety.
//   4. Results are logged via `tracing` for visibility and debugging.
//
// Design Choices:
//   ‚Ä¢ `mpsc` channels simulate real conductor communication without external
//     dependencies.
//   ‚Ä¢ `PerlinGenerator` provides deterministic procedural generation for chunk
//     validation.
//   ‚Ä¢ `bincode` ensures efficient serialization for FFI and channel transport.
//   ‚Ä¢ `tracing` macros (`info`, `error`) provide structured logging for clarity.
//
// Educational Note:
//   ‚Ä¢ These suites demonstrate how to validate concurrency, procedural generation,
//     and serialization contracts in isolation.
//   ‚Ä¢ By ensuring architectural correctness here, developers can trust that
//     higher-level integration tests (with Godot) are built on a solid foundation.
// ============================================================================


use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

use ssxl_generate::Generator;
use ssxl_generate::perlin::PerlinGenerator;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::chunk::chunk_data::CHUNK_SIZE;
use ssxl_shared::tile::tile_data::AnimationUpdate;

pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1));
    }
    
    drop(cli_sender);

    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("‚ùå Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("‚úÖ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("‚ùå Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}

pub fn run_data_channel_test() {
    run_communication_channel_test();
}

pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords);
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("‚úÖ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("‚ùå Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("‚ùå Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("‚ùå Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("‚úÖ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("‚ùå Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}

// --- END: rust/ssxl_cli/src\actions\test_suites.rs ---
       129 LOC | rust/ssxl_cli/src\cli_util_bench.rs
// --- START: rust/ssxl_cli/src\cli_util_bench.rs ---
// ============================================================================
// ‚ö° SSXL CLI: Benchmarking Utilities (`ssxl_cli::cli_util_bench`)
// ----------------------------------------------------------------------------
// This module provides command-line utilities for validating and benchmarking
// the SSXL engine‚Äôs generation and conductor subsystems. It focuses on three
// core areas: synchronous chunk generation, placeholder conversion routines,
// and large-scale throughput benchmarking.
//
// Key Functions:
//   ‚Ä¢ test_generation_and_placement_cli
//       - Validates the Conductor by attempting chunk generation with multiple
//         generators (Perlin and Cellular Automata).
//       - Confirms that chunks can be generated synchronously via `get_chunk_data`.
//       - Reports success/failure based on the number of chunks generated.
//       - Ensures generator IDs are correctly registered and active.
//
//   ‚Ä¢ run_bitmask_conversion
//       - Placeholder function simulating conversion of a world image into tile
//         placement data.
//       - Logs a fixed number of tiles placed to demonstrate workflow.
//       - Serves as a stub for future image-to-world conversion logic.
//
//   ‚Ä¢ run_max_grid_benchmark
//       - Executes a large-scale workload benchmark to measure maximum tile
//         generation throughput.
//       - Spawns two threads:
//           1. Workload thread: runs `benchmark_generation_workload` to simulate
//              tile generation across a massive grid.
//           2. Ticker thread: monitors progress, calculates throughput, and
//              prints real-time updates to stdout.
//       - Reports final throughput in tiles/sec and diagnostics in tiles/ms.
//       - Compares results against baseline (MVG_BASELINE) and target thresholds
//         (ITERATION5_TARGET) to evaluate performance.
//       - Provides structured logging for success, warnings, or critical failures.
//
// Workflow:
//   1. Initialize Conductor or workload counters.
//   2. Spawn threads for generation and progress monitoring.
//   3. Capture progress in real time, printing formatted output to the console.
//   4. Join threads and calculate final throughput metrics.
//   5. Compare results against baseline/target thresholds and log outcomes.
//
// Design Choices:
//   ‚Ä¢ `Arc<AtomicU64>` provides thread-safe counters for progress tracking.
//   ‚Ä¢ `std::thread::spawn` enables concurrent workload execution and monitoring.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Real-time progress printing with carriage return (`\r`) creates a dynamic,
//     single-line ticker in the terminal.
//   ‚Ä¢ Baseline and target thresholds allow performance regression detection.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build benchmarking tools in Rust using
//     concurrency primitives, atomic counters, and structured logging.
//   ‚Ä¢ By validating both correctness (chunk generation) and performance
//     (throughput benchmarks), developers gain confidence in the scalability
//     and reliability of the SSXL engine.
// ============================================================================


use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc,
    atomic::{AtomicU64, Ordering}
};
use std::io::{self, Write};
use std::time::Duration;

use ssxl_generate::benchmark_generation_workload;
use ssxl_generate::conductor::Conductor;
use ssxl_math::prelude::Vec2i;

pub fn test_generation_and_placement_cli() {
    warn!("üß™ Running CLI Test: Generation and Placement (Conductor Validation)...");

    let (mut conductor, _state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("‚ùå Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    let perlin_id = "perlin_basic_2d";
    if conductor.set_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            let _chunk = conductor.get_chunk_data(&coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    let ca_id = "cellular_automata_basic";
    if conductor.set_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.get_chunk_data(&coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    if chunks_generated > 0 {
        info!("‚úÖ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).",
            chunks_generated,
            conductor.get_active_generator_id()
        );
    } else {
        error!("‚ùå CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    conductor.graceful_teardown();
}

pub fn run_bitmask_conversion() {
    warn!("üß™ Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("‚úÖ Conversion complete. Tiles placed: {}", tiles_placed);
}

pub fn run_max_grid_benchmark() {
    warn!("üß™ Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000;

    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone);
    });

    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            let throughput = if elapsed > 0.0 {
                (current as f64 / elapsed).round() as u64
            } else {
                0
            };

            print!("\r‚è≥ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s",
                percentage,
                current / 1_000_000,
                WORKLOAD_TILES / 1_000_000,
                throughput
            );
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    let start = Instant::now();
    
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        let _ = println!("\r‚ùå Benchmark failed: Generation thread panic. {: <100}", " ");
        return;
    }
    
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    println!("\r‚úÖ Benchmark complete. Workload: {} tiles. Duration: {:.2}s",
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("‚ö° Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("‚ö° Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("üöÄ CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("üìà Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("‚ö†Ô∏è Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("‚ùå Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}

// --- END: rust/ssxl_cli/src\cli_util_bench.rs ---
       137 LOC | rust/ssxl_cli/src\cli_util_inspect.rs
// --- START: rust/ssxl_cli/src\cli_util_inspect.rs ---
// ============================================================================
// üå≤ SSXL CLI: Developer Utilities (`ssxl_cli::cli_util_dev_scan`)
// ----------------------------------------------------------------------------
// This module provides developer-facing utilities for scanning and visualizing
// the SSXL engine‚Äôs Rust workspace and Godot API surface. It is designed to
// help contributors quickly understand project structure and validate exposed
// FFI/GDExtension methods and signals.
//
// Key Functions:
//   ‚Ä¢ print_module_tree
//       - Recursively scans all crate source directories in the SSXL workspace.
//       - Prints a tree view of `.rs` files, highlighting core entry points
//         (`lib.rs`, `main.rs`) for each crate.
//       - Helps developers visualize module organization and identify where
//         architectural logic resides.
//       - Uses `walkdir` for recursive traversal and structured output.
//
//   ‚Ä¢ print_godot_api_surface
//       - Scans targeted Godot and FFI source files for callable methods and
//         registered signals.
//       - Uses regex to detect:
//           - `#[func]` annotated methods (GDExtension entry points).
//           - `#[no_mangle] pub extern "C"` functions (FFI core).
//           - `#[signal]` annotated broadcasts (Godot signal definitions).
//       - Collects method signatures (name, args, return type) and signal
//         signatures for reporting.
//       - Prints a consolidated ‚ÄúMASTER API Surface‚Äù showing all callable
//         methods and signals, grouped by source file.
//       - Differentiates between `[FFI CORE]` and `[GDExt]` methods for clarity.
//
// Workflow:
//   1. `print_module_tree` scans crate directories and prints a visual tree.
//   2. `print_godot_api_surface` reads targeted files, applies regex, and
//      extracts callable methods and signals.
//   3. Results are printed to stdout with structured formatting and markers.
//   4. Developers can use this output to validate API exposure and ensure
//      consistency across Rust and Godot integration layers.
//
// Design Choices:
//   ‚Ä¢ `walkdir` provides robust recursive directory traversal.
//   ‚Ä¢ `regex` enables flexible detection of annotated methods and signals.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     success, warnings, and errors.
//   ‚Ä¢ Output formatting emphasizes clarity, highlighting core files and FFI
//     entry points.
//   ‚Ä¢ A short sleep (`thread::sleep`) ensures logs are flushed before returning.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust tooling can be extended to provide
//     developer ergonomics beyond compilation‚Äîoffering visibility into project
//     structure and API contracts.
//   ‚Ä¢ By centralizing scans here, contributors gain confidence that workspace
//     modules are organized correctly and that Godot-facing APIs are properly
//     exposed for integration.
// ============================================================================


use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;

pub fn print_module_tree() {
    println!("\n=========================================================================");
    println!("| üå≤ RUST WORKSPACE MODULE TREE (Scanning...)                            |");
    println!("=========================================================================");
    
    let crate_dirs = [
        "ssxl_cache/src",
        "ssxl_engine_ffi/src",
        "ssxl_generate/src",
        "ssxl_godot/src",
        "ssxl_math/src",
        "ssxl_shared/src",
        "ssxl_sync/src",
        "ssxl_tools/src",
        "ssxl_cli/src",
    ];

    for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
        println!("\nüîç Crate: {}", crate_dir);

        if crate_path.exists() && crate_path.is_dir() {
            for entry in WalkDir::new(&crate_path).min_depth(1) {
                match entry {
                    Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "‚îú‚îÄ‚îÄ [CORE] "
                            } else {
                                "‚îÇ   ‚îî‚îÄ‚îÄ "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
                    },
                    Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
                }
            }
        } else {
            warn!("Path does not exist or is not a directory: {}", crate_dir);
        }
    }
    println!("=========================================================================\n");
}

pub fn print_godot_api_surface() {
    let godot_api_files: [&str; 4] = [ 
        "ssxl_godot/src/engine/init.rs",
        "ssxl_godot/src/ffi/oracle.rs",      
        "ssxl_godot/src/ffi/signals.rs",
        "ssxl_engine_ffi/src/lib.rs", 
    ];

    println!("üß™ API scan triggered (targeting {} files in ssxl_godot/src/ and FFI core)...", godot_api_files.len());
    
    // FIX: Replaced literal newlines in annotations with \s* to match any whitespace.
    let method_regex = Regex::new(
        r#"(?s)(?:\s*#\s*\[func\]\s*.*?|#\s*\[no_mangle\]\s*.*?pub\s+extern\s+"C"\s*)\s*(?:pub\s+fn|fn)\s+(\w+)\s*(\([^\{;]*)\s*(?:->\s*([^\{]*))?"#
    ).unwrap();

    let signal_signature_regex = Regex::new(
        r"^\s*fn\s+(\w+)\s*(\([^;]*)\s*;\s*$"
    ).unwrap();
    // FIX: Replaced literal newlines in annotation with \s*.
    let signal_marker_regex = Regex::new(r"^\s*#\s*\[signal\]\s*$").unwrap();
    
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();
    let mut api_signals: Vec<(String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        
        let mut signal_line_pending = false;

        match fs::read_to_string(path) {
            Ok(contents) => {
                info!("Successfully read {}", path.display());
                
                for cap in method_regex.captures_iter(&contents) {
                    let method_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                    let args = cap.get(2)
                        .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                        .unwrap_or_default();
                    let return_type = cap.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                    
                    let clean_args = args.replace("self, ", "self,").trim().trim_start_matches("self").trim_start_matches(",").trim().to_string();

                    api_methods.push((method_name, clean_args, return_type, file_name.to_string()));
                }

                for line in contents.lines() {
                    let trimmed_line = line.trim();

                    if signal_marker_regex.is_match(trimmed_line) {
                        signal_line_pending = true;
                        continue;
                    }
                    
                    if signal_line_pending {
                        if let Some(captures) = signal_signature_regex.captures(trimmed_line) {
                            let signal_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_signal").to_string();
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            api_signals.push((signal_name, args, file_name.to_string()));
                            signal_line_pending = false; 
                        } else if !trimmed_line.is_empty() {
                            signal_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

    println!("\n--- üéÆ SSXL Engine Developer MASTER API Surface ---");
    
    println!("\n‚úÖ Callable Methods ({} total):", api_methods.len());
    if api_methods.is_empty() {
        warn!(" No callable methods found in targeted files (check FFI core!).");
    } else {
        for (name, args, return_type, source_file) in &api_methods {
            let marker = if source_file == "lib.rs" && api_methods.iter().any(|(n,_,_,s)| n == name && s == source_file) {
                "[FFI CORE]"
            } else {
                "[GDExt]"
            };
            println!(" > func {}({}) -> {} {} [{}]", name, args, return_type, marker, source_file);
        }
    }

    println!("\n‚≠ê Registered Signal Broadcasts ({} total):", api_signals.len());
    if api_signals.is_empty() {
        warn!(" No #[signal] broadcasts found in targeted files.");
    } else {
        for (name, args, source_file) in &api_signals {
            println!(" > signal {}({}) [{}]", name, args, source_file);
        }
    }
    println!("--------------------------------------------------");

    info!("API scan complete: {} methods and {} signals detected.", api_methods.len(), api_signals.len());
    thread::sleep(Duration::from_secs(2));
}
// --- END: rust/ssxl_cli/src\cli_util_inspect.rs ---
       106 LOC | rust/ssxl_cli/src\cli_util_loc.rs
// --- START: rust/ssxl_cli/src\cli_util_loc.rs ---
// ============================================================================
// üìä SSXL CLI: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
// ----------------------------------------------------------------------------
// This module provides developer utilities for scanning the SSXL-ext workspace,
// calculating Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`)
// files, and generating reports consumed by the Godot engine.
//
// Purpose:
//   ‚Ä¢ Track codebase growth and complexity across Rust and Godot components.
//   ‚Ä¢ Provide a single-number LOC file (`RUST_LOC_TOTAL.txt`) for fast parsing
//     by Godot at bootup.
//   ‚Ä¢ Generate detailed reports with per-file LOC counts and full file contents
//     for auditing and review.
//
// Key Components:
//   ‚Ä¢ OUTPUT_FINAL_LOC_FILE
//       - Fixed-name file (`RUST_LOC_TOTAL.txt`) written to the project root.
//       - Contains a single integer: the total Rust LOC count.
//       - Used by Godot for quick boot-time validation.
//
//   ‚Ä¢ LOC_REPORTS_DIR
//       - Directory (`../loc_reports`) where full LOC reports are stored.
//       - Each report is timestamped with epoch seconds for uniqueness.
//
//   ‚Ä¢ count_loc_from_content
//       - Helper function that counts non-empty, non-comment lines.
//       - Ignores lines starting with `//` (Rust) or `#` (GDScript).
//       - Provides a simplified but effective LOC metric.
//
//   ‚Ä¢ write_final_loc_total
//       - Writes the total Rust LOC count to the fixed-name file.
//       - Ensures Godot can quickly parse LOC without scanning the workspace.
//
//   ‚Ä¢ scan_and_report_loc
//       - Main entry point for LOC analysis.
//       - Scans all Rust crate directories under `ssxl-ext/rust/`.
//       - Scans GDScript files under `../ssxl_engine_tester`.
//       - Aggregates LOC counts, builds a detailed report, and writes both:
//           1. A full report with per-file LOC and file contents.
//           2. A single-number LOC file for Godot boot parsing.
//       - Uses `WalkDir` for recursive traversal and `fs::read_to_string`
//         for file content analysis.
//       - Sleeps briefly at the end to ensure logs and writes are flushed.
//
// Workflow:
//   1. Traverse Rust and GDScript source directories.
//   2. Count LOC for each file using `count_loc_from_content`.
//   3. Build a detailed report with LOC counts and file contents.
//   4. Write the report to `../loc_reports/ssxl_loc_report_live_<timestamp>.txt`.
//   5. Write the total Rust LOC to `../RUST_LOC_TOTAL.txt`.
//   6. Log results for developer visibility.
//
// Design Choices:
//   ‚Ä¢ Simplified LOC counting avoids parsing complexity while still providing
//     meaningful metrics.
//   ‚Ä¢ Reports include full file contents for transparency and auditing.
//   ‚Ä¢ Timestamped filenames prevent overwriting and allow historical tracking.
//   ‚Ä¢ Fixed-name LOC file ensures fast integration with Godot boot logic.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can be used to build developer tooling
//     that integrates with external engines (Godot).
//   ‚Ä¢ By automating LOC analysis, developers gain visibility into codebase
//     growth and maintainability, while Godot gains a quick boot-time metric.
// ============================================================================


use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";

fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

fn write_final_loc_total(loc_count: u64) {
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("üî• SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("‚ùå CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("‚ùå Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("‚úÖ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("‚ùå Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}

// --- END: rust/ssxl_cli/src\cli_util_loc.rs ---
       158 LOC | rust/ssxl_cli/src\cli_util_menu.rs
// --- START: rust/ssxl_cli/src\cli_util_menu.rs ---
// ============================================================================
// üß≠ SSXL CLI: Developer Console Menu (`ssxl_cli::cli_util_menu`)
// ----------------------------------------------------------------------------
// This module defines the interactive command-line menu system for the SSXL
// engine developer console. It provides a structured way to organize, present,
// and execute various developer actions, including validation tests, benchmarks,
// and inspection utilities.
//
// Purpose:
//   ‚Ä¢ Offer a unified interface for developers to run tests, benchmarks, and
//     debugging tools directly from the CLI.
//   ‚Ä¢ Simplify orchestration by exposing a menu-driven workflow rather than
//     requiring manual invocation of individual functions.
//   ‚Ä¢ Ensure that both Rust-only validation and Godot-linked integration tests
//     can be triggered consistently.
//
// Key Components:
//   ‚Ä¢ CliAction
//       - Represents a single executable action in the menu.
//       - Contains:
//           ‚Ä¢ key: the character used to trigger the action.
//           ‚Ä¢ label: human-readable description shown in the menu.
//           ‚Ä¢ id: internal identifier for the action.
//           ‚Ä¢ action: closure wrapping the function to execute.
//       - Provides a `new` constructor for placeholder actions.
//
//   ‚Ä¢ CliMenu
//       - Represents a group of actions under a common title.
//       - Provides `new` for initialization.
//       - Includes `prompt_action` (currently unimplemented) for interactive
//         selection logic.
//
//   ‚Ä¢ build_menu
//       - Constructs the full list of available actions for the developer console.
//       - Organizes actions into categories:
//           I. Core Rust Validation (cargo tests, FFI, channels, map generation, animation).
//           II. Headless Integration Tests (Godot-based generation and animation validation).
//           III. Engine Launch & Debugging Tools (launch Godot client/headless, signal inspector).
//           IV. Benchmarks & Utilities (generation tests, grid benchmarks, bitmask conversion).
//           V. System Control (exit).
//       - Each action is mapped to a key and closure for execution.
//
//   ‚Ä¢ print_menu
//       - Prints the structured menu to the console.
//       - Displays each action‚Äôs key and label for user selection.
//       - Provides a clear prompt for interaction.
//
// Workflow:
//   1. Developer runs the CLI console.
//   2. `build_menu` constructs the list of available actions.
//   3. `print_menu` displays the menu with keys and labels.
//   4. User selects an action by pressing the corresponding key.
//   5. The associated closure executes the requested function.
//
// Design Choices:
//   ‚Ä¢ Actions are closures wrapped in `Box<dyn Fn()>` for flexibility and dynamic dispatch.
//   ‚Ä¢ Keys are single characters for quick selection in interactive mode.
//   ‚Ä¢ Labels use emojis and descriptive text for clarity and developer ergonomics.
//   ‚Ä¢ Menu organization mirrors developer workflows: validation, integration, debugging,
//     benchmarking, and control.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a modular CLI menu system in Rust,
//     combining structured data (CliAction, CliMenu) with dynamic execution.
//   ‚Ä¢ By centralizing developer actions here, contributors gain a predictable,
//     ergonomic interface for testing and debugging the SSXL engine.
// ============================================================================


use crate::actions::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use tracing::warn;

pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    pub fn new(id: &'static str, label: &'static str) -> Self {
        CliAction {
            key: '?',
            label,
            id,
            action: Box::new(|| {})
        }
    }
}

pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    pub fn prompt_action(&self) -> CliAction {
        unimplemented!()
    }
}

pub fn build_menu() -> Vec<CliAction> {
    vec![
        CliAction { 
            key: '0', 
            label: "‚úÖ Run: Full Cargo Test Suite", 
            id: "cargo_all", 
            action: Box::new(run_cargo_tests) 
        },
        CliAction {    
            key: '1',    
            label: "‚úÖ Validate: FFI Bridge Data Transfer (Data Integrity)",    
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction {    
            key: '2',    
            label: "‚úÖ Validate: Async Communication Channels (Godot <-> Rust)",    
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction {    
            key: '3',    
            label: "‚úÖ Validate: Chunk/Tile Data Channels (Crypto Coded)",    
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction {    
            key: '4',    
            label: "‚úÖ Validate: Map Generation Logic (Procedural Purity)",    
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction {    
            key: '5',    
            label: "‚úÖ Validate: Animation Conductor Tempo (Frame Consistency)",    
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },
        CliAction { 
            key: '6', 
            label: "‚úÖ Validate: Headless Generation Integration (Full Pipeline Simulation)", 
            id: "headless_gen_integration",
            action: Box::new(run_headless_generation_integration_test)
        },
        CliAction { 
            key: '7', 
            label: "‚úÖ Validate: Headless Animation Tempo Integration (Signal Latency Check)", 
            id: "headless_anim_tempo",
            action: Box::new(run_headless_animation_tempo_test)
        },
        CliAction {    
            key: 'L',    
            label: "üöÄ Launch: Godot Client (Non-Headless)",    
            id: "launch_client",
            action: Box::new(launch_godot_client)    
        },
        CliAction {    
            key: 'H',    
            label: "üéÆ Launch: Headless Godot (External)",    
            id: "launch_headless",
            action: Box::new(launch_headless_godot)    
        },
        CliAction {    
            key: 'S',    
            label: "üîÆ Start: Signal Inspector / Live Feed (TODO)",    
            id: "start_inspector",
            action: Box::new(start_signal_inspector)    
        },
        CliAction {    
            key: 'T',    
            label: "üß™ Test: Generation & Placement CLI",    
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli)    
        },
        CliAction {    
            key: 'B',    
            label: "üß™ Benchmark: Max Grid Placement",    
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)    
        },
        CliAction {    
            key: 'P',    
            label: "‚úÖ Perform: Bitmask PNG Conversion",    
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)    
        },
        CliAction {    
            key: 'A',    
            label: "‚úÖ Inspect: SSXL Developer API Surface (Callable + Signals)",    
            id: "api_surface",
            action: Box::new(print_godot_api_surface)    
        },
        CliAction {    
            key: 'I',    
            label: "‚úÖ Inspect: Rust Module Tree",    
            id: "module_tree",
            action: Box::new(print_module_tree)    
        },
        CliAction {    
            key: 'R',    
            label: "‚ö†Ô∏è Run: Trailkeeper Scan (TODO)",    
            id: "trailkeeper_scan",
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented."))    
        },
        CliAction { key: 'E', label: "‚úÖ Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}

pub fn print_menu(menu: &[CliAction]) {
    println!("\nüß≠ SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}

// --- END: rust/ssxl_cli/src\cli_util_menu.rs ---
        92 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
// ============================================================================
// üß≠ SSXL-ext CLI Developer Console (`ssxl_cli::main`)
// ----------------------------------------------------------------------------
// This module is the main entry point for the interactive developer console
// of the SSXL-ext engine. It orchestrates initialization, logging, FFI runtime
// setup, menu construction, and the interactive loop that allows developers
// to run validation tests, benchmarks, and inspection utilities.
//
// Purpose:
//   ‚Ä¢ Provide a unified, interactive interface for developers to control and
//     validate the SSXL engine from the command line.
//   ‚Ä¢ Simplify workflows by centralizing access to tests, benchmarks, and
//     external Godot integration tools.
//   ‚Ä¢ Ensure critical initialization steps (logging, FFI runtime, DLL copy)
//     are performed before any developer actions are executed.
//
// Key Components:
//   ‚Ä¢ Module Imports
//       - `actions`: Core functions for tests, benchmarks, and Godot interaction.
//       - `cli_util_inspect`: Utilities for scanning the Rust workspace and API surface.
//       - `cli_util_menu`: Menu structure and display logic (public for reuse).
//       - `cli_util_bench`: Benchmark and generation workload utilities.
//       - `cli_util_loc`: LOC (Lines of Code) analysis utilities.
//
//   ‚Ä¢ wait_for_enter
//       - Pauses execution until the user presses Enter.
//       - Used to provide acknowledgment before returning to the main menu.
//
//   ‚Ä¢ init_logging_and_engine
//       - Configures the tracing/logging system with INFO-level output.
//       - Initializes the SSXL engine core via FFI (`ssxl_start_runtime`).
//       - Ensures the latest compiled DLL is copied into the Godot tester project.
//
//   ‚Ä¢ main
//       - Performs initialization (logging, FFI, DLL copy).
//       - Declares symbolic references to FFI functions to ensure linker inclusion.
//       - Runs a LOC scan at startup for visibility into codebase size.
//       - Prints ASCII art banner to signal console readiness.
//       - Builds the menu structure via `build_menu`.
//       - Enters the main interactive loop:
//           1. Displays menu options.
//           2. Polls for key events using `crossterm`.
//           3. Debounces input to prevent repeated triggers.
//           4. Executes the selected action closure.
//           5. Waits for user acknowledgment before returning to menu.
//           6. Exits gracefully when the 'E' key is pressed.
//
// Workflow:
//   1. Initialize logging and engine runtime.
//   2. Copy DLL into Godot tester project.
//   3. Perform LOC scan and print startup banner.
//   4. Build and display the interactive menu.
//   5. Await user input and execute corresponding actions.
//   6. Continue until exit key is pressed.
//
// Design Choices:
//   ‚Ä¢ `tracing` and `tracing_subscriber` provide structured, leveled logging.
//   ‚Ä¢ `crossterm` enables cross-platform key event polling for interactive input.
//   ‚Ä¢ Input debouncing ensures smooth user experience without repeated triggers.
//   ‚Ä¢ Modular design separates concerns: actions, benchmarks, inspection, menu,
//     and LOC utilities are imported and orchestrated here.
//   ‚Ä¢ ASCII art banner provides a friendly, recognizable startup signal.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can be used to build an interactive,
//     developer-focused CLI with structured logging, FFI integration, and
//     modular action orchestration.
//   ‚Ä¢ By centralizing initialization and menu-driven workflows, developers gain
//     a predictable and ergonomic interface for testing and debugging the SSXL engine.
// ============================================================================


mod actions;
mod cli_util_inspect;
pub mod cli_util_menu;
mod cli_util_bench;
mod cli_util_loc;

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_shared::ssxl_start_runtime;
use crate::cli_util_loc::scan_and_report_loc;
use crate::actions::copy_dll_to_tester_project_at_boot;

fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

fn init_logging_and_engine() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    if ssxl_start_runtime() {
        info!("Engine FFI core initialized.");
    } else {
        error!("Failed to initialize Engine FFI core.");
    }
    
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    init_logging_and_engine();
    
    extern "C" {
        fn ssxl_set_cell(x: i32, y: i32, tile_id: i32);
        fn ssxl_notify_tilemap_update();
    }

    let _ = ssxl_set_cell as *const ();
    let _ = ssxl_notify_tilemap_update as *const ();
    
    scan_and_report_loc();
    
    println!(
        r#"
                (__)      
                (oo)
          /------\/
         / |    ||
        * ||----||
          ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    let menu = build_menu();
    let mut last_keys = HashSet::new();

    loop {
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                (item.action)();

                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return;
                                }

                                wait_for_enter();
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}

// --- END: rust/ssxl_cli/src\main.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("üåô Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("üßø Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("‚ö†Ô∏è No idle method found. Skipping ticker.")

func start_idle():
    print("ü™∂ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("‚ö° Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("üß∫ Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("üåÄ SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("‚ú® SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("‚ö†Ô∏è SSXL instance missing 'enter_idle' method.")
            else:
                push_error("‚ùå Failed to instantiate SSXL script.")
        else:
            push_error("‚ùå Invalid script resource at: %s" % script_path)
    else:
        push_error("‚ùå SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("üßπ SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("üß∫ SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("üåô SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("üßø Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("‚ö†Ô∏è No idle method found. Skipping ticker.")

func start_idle():
    print("ü™∂ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("‚ö° SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("üß∫ SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## üß≠ NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## ‚öôÔ∏è CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## üîó LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("‚ùå CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("‚úÖ Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## ‚å®Ô∏è INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## üñºÔ∏è CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## üì° PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("‚ö†Ô∏è Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("‚û°Ô∏è Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("‚û°Ô∏è Switched to Camera 2 (Map View).")
	else:
		push_warning("‚ö†Ô∏è Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED ‚Üí (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid ‚Äî cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature ‚Äî set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated ‚Üí", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error ‚Üí", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated ‚Üí (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete ‚Üí", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine ‚Üí Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine ‚Üí SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle ‚Üí Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected ‚Üí", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected ‚Üí", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("‚ùå FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "‚ùå CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("‚öôÔ∏è FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "üïí " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # ‚Üê THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # ‚Üê Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # ‚Üê Chunk data holder

# Old reference ‚Äî we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX ‚Äî only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready ‚Üí CONNECTED (first time)")
		else:
			print("chunk_data_ready ‚Üí already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\nüé∂ Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("‚ùå Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("‚ùå Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\nüìú Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd ‚Äî FINAL VERSION (2025 SSXL FFI Sync) ‚Äî RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle ‚Üí Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle ‚Üí Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine ‚Üí SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing ‚Äî no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED ‚Äî EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready ‚Üí tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready ‚Üí _on_chunk_data_ready CONNECTED ‚Äî RENDERING ENABLED")
		else:
			print("chunk_data_ready ‚Üí already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd ‚Äî Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("üì¢ SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("‚ùå FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("üì¢ SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("‚úÖ SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("‚úÖ GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("‚ùå GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("‚úÖ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("‚ùå FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
       4438 LOC | *.rs (Rust Total)
       961 LOC | *.gd (GDScript Total)
       5399 LOC | TOTALS
