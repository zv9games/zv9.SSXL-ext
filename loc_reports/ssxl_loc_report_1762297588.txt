SSXL-ext Codebase LOC Report
Generated (Epoch Seconds): 1762297588
Root Directory: ../rust/
Scan Time: 8.00ms
Total Files Scanned: 64
Total Lines of Code (LOC): 6006

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
  251 LOC | ssxl_godot\src\ssxl_engine.rs
  237 LOC | ssxl_sync\src\primitives.rs
  225 LOC | ssxl_generate\src\conductor.rs
  215 LOC | ssxl_sync\src\pool_manager.rs
  197 LOC | ssxl_generate\src\cellular_automata_generator.rs
  194 LOC | ssxl_cli\src\cli_util_bench.rs
  193 LOC | ssxl_cli\src\scan\report_formatter.rs
  166 LOC | ssxl_godot\src\animation_api.rs
  162 LOC | ssxl_cli\src\cli_util_inspect.rs
  157 LOC | ssxl_cli\src\actions\testing.rs
  156 LOC | ssxl_shared\src\chunk_data.rs
  155 LOC | ssxl_generate\src\task_queue.rs
  140 LOC | ssxl_math\src\coordinate_system.rs
  132 LOC | ssxl_shared\src\tile_data.rs
  130 LOC | ssxl_godot\src\chunk_presenter.rs
  128 LOC | ssxl_tools\src\lib.rs
  122 LOC | ssxl_godot\src\async_poll.rs
  121 LOC | ssxl_cli\src\main.rs
  119 LOC | ssxl_godot\src\api_initializers.rs
  118 LOC | ssxl_cli\src\actions\godot_harness.rs
  117 LOC | ssxl_godot\src\generation_api.rs
  117 LOC | ssxl_shared\src\tile_type.rs
  112 LOC | ssxl_sync\src\animation_conductor.rs
  109 LOC | ssxl_generate\src\perlin_generator.rs
  107 LOC | ssxl_cli\src\actions\benchmarking.rs
  107 LOC | ssxl_cli\src\cli_util_menu.rs
  103 LOC | ssxl_math\src\hashing.rs
  102 LOC | ssxl_cache\src\lib.rs
  101 LOC | ssxl_engine_ffi\src\lib.rs
   98 LOC | ssxl_godot\src\channel_handler.rs
   93 LOC | ssxl_generate\src\conductor_state.rs
   92 LOC | manifest.rs
   87 LOC | ssxl_generate\src\lib.rs
   86 LOC | ssxl_generate\src\generator_manager.rs
   85 LOC | ssxl_godot\src\ssxl_oracle.rs
   84 LOC | ssxl_generate\src\config_validator.rs
   81 LOC | ssxl_generate\src\batch_processor.rs
   74 LOC | ssxl_shared\src\lib.rs
   66 LOC | ssxl_cli\src\actions\mod.rs
   65 LOC | ssxl_cli\src\scan\file_walker.rs
   64 LOC | ssxl_shared\src\errors.rs
   58 LOC | ssxl_shared\src\grid_bounds.rs
   53 LOC | ssxl_godot\src\build.rs
   52 LOC | ssxl_godot\src\ssxl_signals.rs
   45 LOC | ssxl_math\src\generation_utils.rs
   45 LOC | ssxl_math\src\primitives.rs
   44 LOC | ssxl_generate\src\runtime_manager.rs
   43 LOC | ssxl_generate\src\benchmark_logic.rs
   42 LOC | ssxl_generate\src\ca\rule_set.rs
   41 LOC | ssxl_shared\src\math_primitives.rs
   39 LOC | ssxl_godot\src\gde_api_defs.rs
   34 LOC | ssxl_math\src\lib.rs
   32 LOC | ssxl_generate\src\ca\neighbor_check.rs
   32 LOC | ssxl_cli\src\scan\mod.rs
   32 LOC | ssxl_godot\src\lib.rs
   29 LOC | ssxl_shared\src\generation_message.rs
   22 LOC | ssxl_sync\src\lib.rs
   20 LOC | ssxl_shared\src\messages.rs
   18 LOC | ssxl_generate\src\generator.rs
   16 LOC | manifest_tips.rs
   15 LOC | ssxl_generate\src\sync.rs
   14 LOC | no_space_batch.rs
    7 LOC | ssxl_shared\src\config.rs
    5 LOC | ssxl_generate\src\ca\mod.rs




======================================================
SSXL-ext Codebase DETAILED CONTENT DUMP
======================================================



//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_engine.rs (251 LOC)
//////////////////////////////////////////////////////

use godot::prelude::*;
use godot::classes::{Node, TileMap};
use godot::obj::{Base, Gd, WithBaseField};
use godot::builtin::GString;

// Standard library dependencies
use std::sync::{Arc, Mutex};
use tracing::info;

// Internal Crate Dependencies for State
use ssxl_generate::Conductor;
use ssxl_generate::conductor_state::ConductorState;
use ssxl_sync::AnimationConductorHandle;
use ssxl_sync::primitives::AnimationState;

// --- NEW DELEGATE MODULES ---
use crate::async_poll::AsyncPoller;
use crate::chunk_presenter::ChunkPresenter;
use crate::channel_handler::ChannelHandler;
use crate::api_initializers::EngineInitializer;
use crate::generation_api::GenerationAPI;
use crate::animation_api::AnimationAPI; // This module must contain the command sending logic

// -------------------------------------------------------------------------------------------------
// SSXL ENGINE GODOT WRAPPER
// -------------------------------------------------------------------------------------------------

/// The Godot-facing wrapper class for the SSXL Engine.
// ... (omitted struct definition - no change)
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLEngine {
    // --- CORE STATE (Shared with worker threads) ---
    conductor: Option<Arc<Mutex<Conductor>>>,
    animation_conductor: Option<AnimationConductorHandle>,

    // Store the thread-safe state objects to access the workers' status.
    conductor_state: Option<ConductorState>,
    animation_state: Option<AnimationState>,

    // --- GODOT NODE REFERENCES ---
    signals_node: Option<Gd<Node>>,
    tilemap_node: Option<Gd<TileMap>>,

    // --- DELEGATE OBJECTS (Perform all work) ---
    initializer: EngineInitializer,
    poller: AsyncPoller,
    presenter: ChunkPresenter,
    handler: ChannelHandler,

    #[base]
    base: Base<Node>,
}


// ------------------------------------------------------------------------------------
// Constructor & Lifecycle
// ------------------------------------------------------------------------------------
// ... (omitted impl SSXLEngine - no change)
impl SSXLEngine {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            conductor: None,
            animation_conductor: None,
            conductor_state: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,
            
            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            presenter: ChunkPresenter::new(),
            handler: ChannelHandler::new(),
            
            base,
        }
    }

    // Private helper for safe signal emission (required by GDExtension).
    fn emit_status_updated(&mut self, status: GString) {
        self.base_mut().emit_signal("status_updated", &[status.to_variant()]);
    }

    /// Internal helper called by gde_api_defs::_ready.
    pub fn on_ready(&mut self) {
        // Initialize workers and get their channel handles AND the state objects.
        let (conductor_arc, gen_rx, gen_state) = self.initializer.ensure_conductor();
        let (anim_handle, anim_rx, anim_state) = self.initializer.ensure_animation_conductor();

        self.conductor = conductor_arc;
        self.conductor_state = gen_state;
        self.animation_conductor = anim_handle;
        self.animation_state = anim_state;
        
        // Configure the Poller and Handler with the communication channels and presenter.
        self.poller.set_generation_receiver(gen_rx);
        self.poller.set_animation_receiver(anim_rx);
        self.handler.set_presenter(self.presenter.clone());
        self.handler.set_signals_node(self.signals_node.clone());
    }

    // Handle generation polling and processing with mutable borrow
    fn poll_generation(&mut self) {
        // Poll for completed generation chunks and messages
        let gen_messages = self.poller.poll_generation_messages();
        
        // Process generation messages (applies chunk data, emits signals)
        if let Some(status_update) = self.handler.process_generation_messages(
            gen_messages,
            self.conductor.as_ref().map(|arc| arc.clone()),
            self.tilemap_node.as_mut(),
        ) {
            self.emit_status_updated(status_update);
        }
    }
}


// ------------------------------------------------------------------------------------
// GODOT API DELEGATION
// ------------------------------------------------------------------------------------
#[godot_api]
impl SSXLEngine {
    // ... (omitted get_status, signals, and tick methods - no change)
    #[func]
    pub fn get_status(&self) -> GString {
        // Reads the actual, dynamically updated status from the thread-safe state objects.
        let gen_status = self.conductor_state.as_ref()
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));
        
        let anim_status = self.animation_state.as_ref()
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let mut status = String::from("STATUS: ");
        status.push_str("Generation: ");
        status.push_str(&gen_status);
        status.push_str(" | Animation: ");
        status.push_str(&anim_status);

        GString::from(status.as_str())
    }

    #[signal]
    fn status_updated(status_message: godot::prelude::GString);

    // Signal definition for the animation bridge
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    /// Main engine tick method, delegates polling and processing.
    #[func]
    // In ssxl_godot\src\ssxl_engine.rs, inside #[godot_api] impl SSXLEngine
	pub fn tick(&mut self, _current_tick: u64) {
		// 1. Handle all mutable operations
		self.poll_generation();

		// 2. Poll for animation updates with mutable base to emit signals
		{
			// Clone the base's Gd<Node> reference so it can be passed as a mutable,
			// independent emitter, avoiding conflicts with the mutable borrow of self.poller.
			let mut emitter_gd = self.base().clone().upcast::<Node>();
			self.poller.poll_animations(&mut emitter_gd); // Pass the mutable reference
		} // emitter_gd is dropped here
	}
    
    // --- CONDUCTOR API DELEGATION ---
    // ... (omitted GenerationAPI functions - no change)
    #[func]
    pub fn build_map(&mut self, width: i32, height: i32, seed: GString, generator_name: GString) {
        GenerationAPI::new(self.conductor.as_ref()).build_map(width, height, seed, generator_name, self.signals_node.as_ref());
    }
    
    #[func]
    pub fn set_generator(&mut self, id: GString) -> bool {
        GenerationAPI::new(self.conductor.as_ref()).set_generator(id)
    }

    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        GenerationAPI::new(self.conductor.as_ref()).get_active_generator_id()
    }

    // --- ANIMATION API DELEGATION ---

    #[func]
    pub fn start_loading_animation(&mut self, framerate: f32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).start_loading_animation(framerate, self.signals_node.as_ref());
    }
    
    #[func]
    pub fn register_chunk_for_animation(&mut self, chunk_x: i32, chunk_y: i32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).register_chunk_for_animation(chunk_x, chunk_y);
    }

    #[func]
    pub fn stop_loading_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).stop_loading_animation(self.signals_node.as_ref());
    }

    // ðŸŒŸ REQUIRED FIX: Expose the method the GDScript is trying to call ðŸŒŸ
    #[func]
    pub fn send_animation_command(&mut self, command_name: GString) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .send_command_by_name(command_name.to_string());
    }
    
    // --- NEW TEST ANIMATION API DELEGATION (FIXED LOCATION) ---
    // ... (omitted start_test_animation and stop_test_animation - no change)
    /// Starts the dedicated 30x30 self-clocked test animation.
    /// This runs in the Rust core and uses TileMap::force_update() for rendering.
    #[func]
    pub fn start_test_animation(&mut self) {
        // Pass both conductors and the TileMap reference to the AnimationAPI
        // The TileMap is critical because the Rust core is now responsible for rendering (force_update).
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .start_test_animation(self.tilemap_node.as_ref());
    }

    /// Stops the dedicated 30x30 self-clocked test animation.
    #[func]
    pub fn stop_test_animation(&mut self) {
        // Pass only the animation conductor as the stop command doesn't need the TileMap
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .stop_test_animation(self.signals_node.as_ref());
    }
    
    // --- NODE SETTERS ---
    // ... (omitted setters and shutdown_engine - no change)
    #[func]
    pub fn set_signals_node(&mut self, signals_node: Gd<Node>) {
        self.signals_node = Some(signals_node.clone());
        self.handler.set_signals_node(Some(signals_node));
        info!("SSXLEngine: Signals Node reference set.");
    }
    
    #[func]
    pub fn set_tilemap(&mut self, tilemap_node: Gd<TileMap>) {
        self.tilemap_node = Some(tilemap_node);
        info!("SSXLEngine: TileMap Node reference set.");
    }
    
    /// Expose a function for Godot to call on cleanup.
    #[func]
    pub fn shutdown_engine(&mut self) {
        info!("SSXLEngine: Shutting down.");
        self.initializer.shutdown(self.animation_conductor.take(), self.conductor.take());
        self.poller.clear_receivers();
    }
}



//////////////////////////////////////////////////////
// FILE: ssxl_sync\src\primitives.rs (237 LOC)
//////////////////////////////////////////////////////

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use std::sync::Mutex; 
use crossbeam_channel::{unbounded, Receiver, Sender};
use tracing::{info, error}; 
use ssxl_shared::chunk_data::ChunkData;
use ssxl_shared::tile_data::AnimationUpdate;
use tokio::sync::mpsc;
// ðŸ›‘ CRITICAL FIX: Add Godot imports required for AnimationCommand variants
// NOTE: These imports are left here, but are no longer needed for the fixed AnimationCommand
use godot::obj::Gd;         
use godot::classes::Node;   


// NOTE: We are using String as a temporary placeholder for the complex
// AetherionData struct, which will be defined later in the project.

// --- 1. Thread-Safe Resource Wrapper ---

/// A thread-safe wrapper for resources that allows multiple readers
/// or a single writer at any time.
#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    /// Creates a new AtomicResource instance.
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    /// Acquires a read lock on the resource.
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    /// Acquires a write lock on the resource.
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

// --- 2. Channel Utilities ---

/// Creates an unbounded crossbeam channel pair.
pub fn create_sync_channel() -> (Sender<String>, Receiver<String>) {
    unbounded()
}

/// Starts the main synchronization worker task.
pub fn start_sync_worker() {
    info!("SSXL Synchronization Worker placeholder started.");
}

// ------------------------------------------------------------------
// 3. ANIMATION CONDUCTION (Exposed Types)
// ------------------------------------------------------------------

/// Represents a command sent from the main thread to the animation worker.
#[derive(Debug, Clone)]
pub enum AnimationCommand {
    Start,
    Stop,
    UpdateFramerate(f32),
    /// Command to register a generated chunk's data for the animator to track and update.
    RegisterChunk(Arc<ChunkData>),
    Complete,   
    
    // âœ… CRITICAL FIX APPLIED: Removed the Gd<Node> field entirely, as it violates the Send bound required by mpsc channel for cross-thread communication.
    StartTestAnimation, // <--- REVERTED TO UNIT VARIANT
    StopTestAnimation,  
}

/// The manager for the animation worker thread.
/// It holds the sender for issuing commands to the worker.
/// The `new()` and `send_command()` methods are implemented in `pool_manager.rs`.
#[derive(Debug)]
pub struct AnimationConductor {
    // This private field is public only to other modules in the crate (`pub(crate)`)
    // so `pool_manager.rs` can access it for implementation.
    pub(crate) command_sender: mpsc::UnboundedSender<AnimationCommand>,
}

// âœ… FIX: Added a public getter method for the private command_sender field.
impl AnimationConductor {
    /// Public getter for the command sender handle.
    /// Returns a clone of the sender handle, which is cheap for MPSC Senders.
    pub fn get_command_sender(&self) -> AnimationConductorHandle {
        self.command_sender.clone()
    }
}

// FIX: Add the missing type aliases needed for re-export in lib.rs
/// The type alias for the sender handle to the animation worker.
pub type AnimationConductorHandle = mpsc::UnboundedSender<AnimationCommand>;

/// The type alias for the receiver of animation updates from the worker.
pub type AnimationReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;


// ------------------------------------------------------------------
// 4. ANIMATION STATUS AND STATE (NEW SECTION)
// ------------------------------------------------------------------

/// Represents the operational state of the Animation Conductor.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AnimationStatus {
    // Maps to "Animation Init Pending" status
    Initializing,
    Running,
    Paused,
    ShuttingDown,
    Error,
}

/// Shared, thread-safe state exposed to the FFI consumer for animation monitoring.
/// This fixes the "Animation Init Pending" log by providing a status mechanism.
#[derive(Clone)]
pub struct AnimationState {
    status: Arc<Mutex<AnimationStatus>>,
}

impl AnimationState {
    pub fn new() -> Self {
        AnimationState {
            status: Arc::new(Mutex::new(AnimationStatus::Initializing)),
        }
    }

    /// Public Getter (Read Access for FFI/CLI)
    pub fn get_status(&self) -> AnimationStatus {
        match self.status.lock() {
            Ok(guard) => *guard,
            Err(e) => {
                error!("Mutex poisoned when reading animation status: {}", e);
                AnimationStatus::Error
            }
        }
    }

    /// Internal Mutator (For Animation Worker state changes)
    pub(crate) fn set_status(&self, new_status: AnimationStatus) {
        // Use a simple unwrap here, as a panic indicates a poisoned worker thread anyway.
        *self.status.lock().unwrap() = new_status;
    }
}


// ---------------------------
// IMPL: Unit Tests (Phase 1 Validation)
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    // --- Channel Tests ---

    #[test]
    fn test_channel_functionality() {
        let (sender, receiver) = create_sync_channel();
        let test_message = "Test data for Phase 1 sync check".to_string();

        sender.send(test_message.clone()).expect("Failed to send test message");
        let received_message = receiver.recv().expect("Failed to receive test message");

        assert_eq!(received_message, test_message, "Received message did not match sent message.");
    }

    #[test]
    fn test_sync_worker_placeholder_runs() {
        start_sync_worker();
    }
    
    // --- AtomicResource Tests ---

    /// Tests that the AtomicResource correctly handles concurrent reads and a single write.
    #[test]
    fn test_concurrent_read_write() {
        let resource = AtomicResource::new(0);

        // 1. Concurrent Reads (Must all read 0)
        let mut handles = vec![];
        for _ in 0..5 {
            let res_clone = resource.clone();
            handles.push(thread::spawn(move || {
                let value = *res_clone.read();
                assert_eq!(value, 0);
            }));
        }

        for h in handles {
            h.join().unwrap();
        }

        // 2. Single Write (Set to 42)
        let mut writer_guard = resource.write();
        *writer_guard = 42;
        drop(writer_guard); // Lock released

        // 3. New Concurrent Reads (Must all read 42)
        let mut handles = vec![];
        for _ in 0..5 {
            let res_clone = resource.clone();
            handles.push(thread::spawn(move || {
                let value = *res_clone.read();
                assert_eq!(value, 42); // Verify the change
            }));
        }
        
        for h in handles {
            h.join().unwrap();
        }
    }

    /// Tests basic read/write access without concurrency.
    #[test]
    fn test_basic_read_write() {
        let resource = AtomicResource::new(10);
        
        {
            let value = *resource.read();
            assert_eq!(value, 10);
        }
        
        {
            let mut writer = resource.write();
            *writer = 20;
        }

        assert_eq!(*resource.read(), 20, "Basic write failed.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\conductor.rs (225 LOC)
//////////////////////////////////////////////////////

//! The central manager for the procedural generation pipeline.
//! This struct is now an orchestrator that delegates tasks to dedicated modules.

use tokio::sync::mpsc::{self, Sender};
use tracing::{info, error};
use std::sync::{Arc, Mutex};
use std::io;

// --- CORE DEPENDENCIES (External Crates) ---
use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;
use ssxl_shared::chunk_data::ChunkData;
use ssxl_tools::get_config_from_path;

// --- DELEGATE MODULES ---
use crate::runtime_manager::RuntimeManager;
use crate::config_validator::{ConfigValidator, GeneratorConfig};
use crate::task_queue::{
    handle_chunk_unit, start_request_loop,
    // Note: The imports below are made public inside task_queue.rs
    GenerationTask as ChunkRequest, GenerationMessage, 
};
pub use crate::conductor_state::{ConductorState, ConductorStatus}; // Added pub use for ConductorStatus
// FIX (E0603): Remove Generator from this import path since it's defined at crate root
use crate::generator_manager::GeneratorManager; 
// FIX (E0603): Import Generator trait directly from crate root, as suggested by the note.
use crate::Generator; 
use crate::batch_processor::spawn_batch_generation_task; // NEW IMPORT

// --- MPSC Channel Configuration (Bounded for progress, Unbounded for requests) ---
const PROGRESS_CHANNEL_BOUND: usize = 1024;
// NOTE: Request channel is now UNBOUNDED to match start_request_loop signature
const REQUEST_CHANNEL_BOUND: usize = 128; // This constant is now unused for request_sender, but kept for context


// -----------------------------------------------------------------------------
// CONDUCTOR MANAGER
// -----------------------------------------------------------------------------

/// The central manager for the procedural generation pipeline.
/// This struct is the lightweight orchestrator for the entire generation process.
pub struct Conductor {
    // Delegates
    runtime_manager: RuntimeManager,
    generator_manager: GeneratorManager,
    // State
    internal_state: ConductorState,
    chunk_cache: Arc<Mutex<ChunkCache>>,
    // Communication
    progress_sender: Sender<GenerationMessage>,
    // FIX: Changed request_sender type to mpsc::UnboundedSender in the struct to match the channel creation below
    request_sender: mpsc::UnboundedSender<ChunkRequest>,
}

impl Conductor {
    /// Initializes the Conductor, starts the runtime, creates the MPSC channels.
    /// 
    /// Returns the Conductor, its internal state, the progress receiver (ProgressReceiver),
    /// and the request sender (RequestSender).
    pub fn new(config_path: Option<&str>) -> Result<(Self, ConductorState, mpsc::Receiver<GenerationMessage>, mpsc::UnboundedSender<ChunkRequest>), io::Error> {
        
        let config = get_config_from_path(config_path)?;

        let runtime_manager = RuntimeManager::new()?;
        let handle = runtime_manager.get_handle();

        let generator_manager = GeneratorManager::new().map_err(|e| {
            io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
        })?;
        // NOTE: generator_manager.get_map_clone() returns HashMap<String, Arc<DynGenerator>>
        // The start_request_loop expects Arc<HashMap<String, Arc<DynGenerator>>>.
        // We must Arc-wrap the clone *before* passing it.
        let generators_for_loop = Arc::new(generator_manager.get_map_clone());

        let chunk_cache = Arc::new(Mutex::new(ChunkCache::new().map_err(|e| {
            error!("Failed to initialize ChunkCache: {:?}", e);
            io::Error::new(io::ErrorKind::Other, format!("Cache initialization failed: {:?}", e))
        })?));
        let chunk_cache_for_loop = chunk_cache.clone();

        // 1. Create Bounded channel for progress (MPSC::Sender/Receiver)
        let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
        
        // 2. FIX: Create UNBOUNDED channel for requests (mpsc::UnboundedSender/UnboundedReceiver)
        // This resolves the expected UnboundedReceiver<GenerationTask> vs found Receiver<_> error (E0308).
        let (request_sender, request_receiver) = mpsc::unbounded_channel(); 
        
        let initial_id = generator_manager.get_initial_id(config.get_default_generator_id());
        
        let state = ConductorState::new(initial_id.clone());
        state.set_status(ConductorStatus::Running);
        let state_for_loop = state.clone();

        info!("Conductor initialized. Active generator: {}", initial_id);

        // Start Request Processing Loop (Delegated)
        // FIX (E0308): Arguments reordered and Arc-wrapped to match start_request_loop signature:
        // (handle, request_rx, progress_tx, generators, chunk_cache, conductor_state)
        start_request_loop(
            handle,                                         // 1. rt_handle: Handle
            request_receiver,                               // 2. request_rx: mpsc::UnboundedReceiver<GenerationTask> (FIXED channel type above)
            progress_sender.clone(),                        // 3. progress_tx: mpsc::Sender<GenerationMessage>
            generators_for_loop,                            // 4. generators: Arc<HashMap<...>> (FIXED Arc::new() above)
            chunk_cache_for_loop,                           // 5. chunk_cache: Arc<Mutex<...>>
            Arc::new(state_for_loop),                       // 6. conductor_state: Arc<ConductorState> (FIXED: Wrapped in Arc::new())
        );

        let conductor = Conductor {
            runtime_manager,
            generator_manager,
            internal_state: state.clone(),
            chunk_cache,
            progress_sender: progress_sender.clone(),
            request_sender: request_sender.clone(), // This is now mpsc::UnboundedSender
        };

        // FIX: Update the returned type of request_sender
        Ok((conductor, state, progress_receiver, request_sender))
    }
    // ... (rest of impl Conductor remains unchanged)
    
    /// Provides public read-access to the active generator ID.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    // -------------------------------------------------------------------------
    // CORE GENERATION COMMAND ENTRY POINT (Delegated Batch Jobs)
    // -------------------------------------------------------------------------

    /// Handles the main map generation command from an FFI wrapper (like Godot).
    pub fn start_generation(&mut self, config: GeneratorConfig) -> Result<(), Box<dyn std::error::Error>> {
        // 1. Validation
        ConfigValidator::validate_map_dimensions(&config)?;

        // 2. Set the active generator
        self.set_active_generator(&config.generator_name)?;
        
        // âš ï¸ CRITICAL FIX: Set the status to Generating immediately before spawning the batch job.
        // This provides debug visibility and ensures the EngineMonitor receives the status change
        // even if the batch job panics later.
        self.internal_state.set_status(ConductorStatus::Generating);

        // 3. Delegate the async, blocking generation task
        spawn_batch_generation_task(
            &self.runtime_manager.get_handle(),
            self.generator_manager.get_map_clone(),
            self.chunk_cache.clone(),
            self.internal_state.get_active_generator_id(),
            self.progress_sender.clone(),
            self.internal_state.clone(),
            config,
        );

        Ok(())
    }

    // -------------------------------------------------------------------------
    // SYNCHRONOUS ACCESS PATHWAY (Used by FFI/Godot read functions)
    // -------------------------------------------------------------------------

    /// SYNCHRONOUS ACCESS: Loads or generates a single chunk, blocking the caller.
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();

        // Create a temporary channel to capture the result
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        // Call the core processing logic helper
        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
        );
        
        // Block here to ensure the data is returned synchronously as requested.
        match temp_receiver.blocking_recv() {
            Some(GenerationMessage::ChunkGenerated(_coords, chunk_data_arc)) => {
                // Try to unwrap the Arc for the owned ChunkData, fall back to cloning if other references exist.
                Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone())
            },
            _ => {
                panic!("get_chunk_data failed to receive ChunkGenerated message.");
            }
        }
    }

    // -------------------------------------------------------------------------
    // GENERATOR MANAGEMENT & SHUTDOWN
    // -------------------------------------------------------------------------

    /// Changes the algorithm used for subsequent generation tasks.
    pub fn set_active_generator(&mut self, id: &str) -> Result<(), String> {
        if self.generator_manager.get_map_ref().contains_key(id) {
            info!("Active generator set to: {}", id);
            self.internal_state.set_active_generator_id(id);
            Ok(())
        } else {
            let err = format!("Generator ID '{}' not found. Available IDs: {:?}", id, self.generator_manager.get_map_ref().keys());
            error!("{}", err);
            Err(err)
        }
    }

    /// SYNCHRONOUS PATHWAY (For CLI/Benchmarking).
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let active_id = self.internal_state.get_active_generator_id();
        self.generator_manager.generate_single_chunk(chunk_coords, &active_id)
    }
    
    /// Signals the Conductor's internal state to begin a graceful shutdown process.
    pub fn signal_shutdown_graceful(&self) {
        info!("SSXL Conductor signaled for shutdown. Setting status to ShuttingDown.");
        self.internal_state.set_status(ConductorStatus::ShuttingDown);
    }

    /// Performs a full, graceful teardown of the Conductor.
    pub fn graceful_teardown(self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
        info!("SSXL Conductor full teardown complete.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_sync\src\pool_manager.rs (215 LOC)
//////////////////////////////////////////////////////

use tokio::sync::mpsc;
use std::thread;
use std::collections::HashMap;
use std::sync::Arc;
use tracing::{info, error};
use tokio::runtime;
// Re-import the crossbeam channel for the handshake, since the new module doesn't use the top-level lib imports.
use crossbeam_channel::unbounded;

use ssxl_shared::tile_data::AnimationUpdate;
use ssxl_shared::chunk_data::ChunkData;
use ssxl_math::Vec2i;

// Import the types defined in the primitives module, including the new state object.
use super::primitives::{AnimationConductor, AnimationCommand, AnimationState, AnimationStatus};

// ðŸ›‘ REMOVED: Godot imports are no longer necessary since the handle is not stored/sent.
// use godot::obj::Gd;
// use godot::classes::Node; 

// --- Worker Thread Internal State ---

/// Persistent state held by the animation worker thread.
struct ChunkAnimationState {
    /// Registry of all chunks the animation worker is actively tracking.
    /// Key: Chunk's world-space coordinates. Value: Arc to the chunk's data.
    registry: HashMap<Vec2i, Arc<ChunkData>>,
    current_frame_index: i32,
    total_frames: i32,
    // ðŸ›‘ REMOVED: This field contained Gd<Node>, which is not Send, causing the E0277 error.
    // tilemap_handle: Option<Gd<Node>>, 
}

// ----------------------------------------

impl AnimationConductor {
    /// Fully implements the worker thread to process animation commands and send updates.
    /// This function is now **blocking** until the worker thread has successfully started its Tokio runtime.
    ///
    /// FIX: Function now returns the thread-safe AnimationState object to the caller.
    pub fn new() -> Result<(Self, mpsc::UnboundedReceiver<AnimationUpdate>, AnimationState), String> { // <--- UPDATED SIGNATURE
        // 1. Command Channel (Main thread sends, Worker thread receives)
        let (cmd_tx, mut cmd_rx) = mpsc::unbounded_channel();

        // 2. Update Channel (Worker thread sends, Main thread receives)
        let (update_tx, update_rx) = mpsc::unbounded_channel();
        
        // 3. Handshake Channel: Used to confirm the worker thread is running.
        let (ready_tx, ready_rx) = unbounded();

        // 4. Create the shared state object
        let state_handle = AnimationState::new();
        let state_for_worker = state_handle.clone(); // Clone for worker thread (Moved into thread::spawn)

        // 5. Spawn a dedicated worker thread
        // This is the line where the Send requirement is enforced:
        thread::spawn(move || {
            // 6. Create a dedicated Tokio runtime for this worker
            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("Failed to create tokio runtime for animation worker.");
            
            // FIX (DEADLOCK): Signal the main thread that the runtime is active and we are ready.
            // This must be done BEFORE rt.block_on(async move { loop { ... } }) to unblock the main thread.
            if let Err(e) = ready_tx.send(()) {
                error!("Failed to send ready signal during worker startup: {:?}", e);
                state_for_worker.set_status(AnimationStatus::Error); // Set error status on failure (using state_for_worker)
                return;
            }

            // Clone the state handle for the async block, so state_for_worker remains for final synchronous cleanup.
            let state_for_async = state_for_worker.clone();
            
            rt.block_on(async move { // <--- state_for_async moved here
                use tokio::time::{self, Duration, MissedTickBehavior};

                info!("Animation Worker thread started and awaiting commands.");

                // Initialize the persistent worker state
                let mut state = ChunkAnimationState {
                    registry: HashMap::new(),
                    current_frame_index: 0,
                    total_frames: 4,
                    // ðŸ›‘ REMOVED: tilemap_handle field initialization
                };

                let mut is_running = false;
                let mut frame_duration = Duration::from_millis(100); // Default 10 FPS
                
                // Initialize interval timer
                let mut interval = time::interval(frame_duration);
                interval.set_missed_tick_behavior(MissedTickBehavior::Delay);

                loop {
                    // Use tokio::select! to concurrently wait for commands AND the next animation tick.
                    tokio::select! {
                        // 1. Wait for the next command from the main thread (Godot)
                        cmd = cmd_rx.recv() => {
                            match cmd {
                                Some(AnimationCommand::Start) => {
                                    is_running = true;
                                    state_for_async.set_status(AnimationStatus::Running); // <--- Use state_for_async
                                    // Consume the immediate tick created by `interval.new()` to start the timer properly
                                    let _ = interval.tick().await;
                                    info!("Animation Worker: Received START command. Loop active.");
                                }
                                Some(AnimationCommand::Stop) => {
                                    is_running = false;
                                    state_for_async.set_status(AnimationStatus::Paused); // <--- Use state_for_async
                                    info!("Animation Worker: Received STOP command. Loop paused.");
                                }
                                Some(AnimationCommand::Complete) => { // <--- ADDED: Handle shutdown command
                                    info!("Animation Worker: Received COMPLETE command. Shutting down.");
                                    state_for_async.set_status(AnimationStatus::ShuttingDown); // <--- Use state_for_async
                                    return;
                                }
                                Some(AnimationCommand::UpdateFramerate(fps)) => {
                                    if fps > 0.0 {
                                        frame_duration = Duration::from_secs_f32(1.0 / fps);
                                        // Recreate interval with new duration
                                        interval = time::interval(frame_duration);
                                        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
                                        let _ = interval.tick().await; // Consume the immediate tick of the new interval
                                        info!("Animation Worker: Framerate set to {} FPS.", fps);
                                    }
                                }
                                // âœ… CRITICAL FIX: Match the unit variant (no tilemap_handle argument)
                                Some(AnimationCommand::StartTestAnimation) => {
                                    info!("Animation Worker: Received StartTestAnimation command. Starting test animation.");
                                    // ðŸ›‘ REMOVED: state.tilemap_handle = Some(tilemap_handle);
                                    state_for_async.set_status(AnimationStatus::Running);
                                    is_running = true;
                                }
                                Some(AnimationCommand::StopTestAnimation) => {
                                    info!("Animation Worker: Received StopTestAnimation command. Stopping test animation.");
                                    state_for_async.set_status(AnimationStatus::Paused);
                                    is_running = false;
                                    // ðŸ›‘ REMOVED: state.tilemap_handle = None;
                                }

                                Some(AnimationCommand::RegisterChunk(chunk)) => {
                                    info!("Animation Worker: Registering chunk bounds: {:?}", chunk.bounds);
                                
                                    // Manual conversion: Pull x/y from Coord2D and build Vec2i
                                    let chunk_key = Vec2i::new(chunk.bounds.min.x, chunk.bounds.min.y);
                                
                                    state.registry.insert(chunk_key, Arc::clone(&chunk));
                                    info!("Animation Worker: Registered {} chunks.", state.registry.len());
                                }

                                None => {
                                    state_for_async.set_status(AnimationStatus::ShuttingDown); // <--- Use state_for_async
                                    info!("Animation Worker: Command channel closed. Shutting down.");
                                    return; // Command channel closed, shut down worker.
                                }
                            }
                        }
                        
                        // 2. Perform animation tick only when 'is_running' is true
                        _ = interval.tick(), if is_running => {
                            // Animation State Update (The actual animation logic)

                            // Update global frame state
                            state.current_frame_index = (state.current_frame_index + 1) % state.total_frames;
                            
                            // Converted i32 to i64 using .into()
                            let new_atlas_coords = Vec2i::new(state.current_frame_index.into(), 10i64);

                            // Iterate over all registered chunks to generate updates
                            for (chunk_coord, _chunk_data) in state.registry.iter() {
                                // Placeholder Logic: Send one update per chunk using the chunk's coordinate
                                let tile_coord = *chunk_coord;
                                
                                let update = AnimationUpdate {
                                    tile_coords: tile_coord,
                                    new_atlas_coords,
                                    layer: 0,
                                    source_id: 0,
                                };

                                // Send update to be read by Godot
                                if update_tx.send(update).is_err() {
                                    info!("Animation update channel closed. Shutting down worker.");
                                    return; // Update channel closed, shut down worker.
                                }
                            }
                        }
                    }
                }
            });
            // This line is now only reached if the inner loop exits (which only happens on 'Complete' or channel close)
            state_for_worker.set_status(AnimationStatus::ShuttingDown); // Final status check (uses original state_for_worker)
            info!("Animation Worker thread gracefully shut down.");
        });

        // 7. Main Thread: Wait for the ready signal from the worker thread.
        match ready_rx.recv() {
            Ok(_) => info!("*** ANIMATION CONDUCTOR: Worker thread confirmed running. ***"),
            Err(e) => {
                state_handle.set_status(AnimationStatus::Error); // Set error status on join/recv failure
                return Err(format!("Failed to receive ready signal from worker: {:?}", e));
            }
        }

        // 8. Main Thread: The auto-start logic is intentionally commented out.

        // Return the Conductor and the update receiver to the main thread, along with the state handle.
        Ok((AnimationConductor { command_sender: cmd_tx }, update_rx, state_handle)) // <--- UPDATED RETURN VALUE
    }

    pub fn send_command(&self, command: AnimationCommand) -> Result<(), mpsc::error::SendError<AnimationCommand>> {
        self.command_sender.send(command)
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\cellular_automata_generator.rs (197 LOC)
//////////////////////////////////////////////////////

use crate::Generator;
use ssxl_math::Vec2i;
use fastrand;
use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    grid_bounds::GridBounds,
    tile_data::TileData,
    tile_type::TileType,
};
use tracing::{info, warn};

// --- MODULE DECLARATIONS ---
// Removed: mod rule_set; and mod neighbor_check;
// These are now declared in ssxl_generate/src/ca.rs

// --- Imports from new modules (using the correct crate::ca path) ---
use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;


// --- CONSTANTS ---
const CA_ITERATIONS: u8 = 4;
const INITIAL_FILL_PERCENT: u8 = 45; // 45% of tiles start as 'Rock'


/// âš™ï¸ Implements a 2D Cellular Automata (CA) generator for pattern-based terrain.
#[allow(dead_code)]
pub struct CellularAutomataGenerator {
    /// The ID of the CA ruleset to use (e.g., 0 for Cave, 1 for Maze).
    ruleset: u8,
}

impl CellularAutomataGenerator {
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// -------------------------------------------------------------------------
// STATIC PATTERN GENERATION
// -------------------------------------------------------------------------

/// Generates a simple, static pattern that does not require CA iterations.
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    // 1. Chunk Metadata Initialization
    let chunk_tile_size = CHUNK_SIZE as i64;
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
    
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );
    
    // Using the imported constants
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };
    
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
    let mut tiles = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    // 2. Pattern Generation
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    // Tile type alternates based on (x + y) parity
                    if (x + y) % 2 == 0 {
                        TileType::Rock
                    } else {
                        TileType::Void
                    }
                }
                _ => TileType::Void, // Should not happen
            };
            tiles.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}


/// Applies one step of the Cellular Automata rule to the chunk grid.
fn apply_ca_step(chunk_data: &mut ChunkData, ruleset: u8) {
    let mut new_tiles: Vec<TileData> = chunk_data.tiles.iter().cloned().collect();

    for x in 0..CHUNK_SIZE {
        for y in 0..CHUNK_SIZE {
            let index = (y * CHUNK_SIZE + x) as usize;
            let current_tile = &chunk_data.tiles[index];
            
            // Logic moved to neighbor_check::count_live_neighbors
            let live_neighbors = count_live_neighbors(chunk_data, x as u32, y as u32);

            // Logic moved to rule_set::get_next_tile_type
            let new_type = get_next_tile_type(
                current_tile.tile_type,
                live_neighbors,
                ruleset
            );

            // Retain existing noise value
            new_tiles[index] = TileData::new(new_type, current_tile.noise_value);
        }
    }
    chunk_data.insert_tiles(new_tiles);
}


// --- TRAIT IMPLEMENTATION ---

impl Generator for CellularAutomataGenerator {
    fn id(&self) -> &str {
        // Updated to use the correct crate::ca::rule_set path
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // 1. Check for static patterns and execute non-CA logic
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // 2. DETERMINISTIC PRNG SEEDING
        // Use chunk coordinates to create a predictable seed for fastrand's thread-local generator.
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        // Simple scrambling of the coordinates for distribution.
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);
        
        // 3. CHUNK METADATA INITIALIZATION (for CA algorithms)
        let chunk_tile_size = CHUNK_SIZE as i64;

        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string(); // Use the ID as the dimension name

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // 4. INITIAL RANDOM FILL (Seed)
        let mut tiles = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            // Generate a random number from 0 to 99.
            let random_val: u8 = fastrand::u8(0..100);
            // The tile is rock if the random number is less than INITIAL_FILL_PERCENT.
            let is_rock = random_val < INITIAL_FILL_PERCENT;

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            tiles.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles);

        // 5. APPLY CA ITERATIONS
        for i in 0..CA_ITERATIONS {
            apply_ca_step(&mut chunk_data, self.ruleset);
            info!("CA Generator: Iteration {} complete.", i + 1);
        }

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        chunk_data
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_bench.rs (194 LOC)
//////////////////////////////////////////////////////

//! Utilities for running generation benchmarks and conversion tests.

use tracing::{info, warn, error};
use std::time::Instant;
// Imports for Concurrency and Live Ticker
use std::thread;
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};
use std::io::{self, Write};
use std::time::Duration;

// --- EXTERNAL CRATE DEPENDENCIES ---
use ssxl_generate::benchmark_generation_workload; 
use ssxl_generate::conductor::Conductor;
use ssxl_math::Vec2i;

// --- Test Utilities ---

/// ðŸ§ª CLI-safe test: Initializes the Conductor, switches generators, and generates
/// a small set of chunks to validate the core pipeline.
pub fn test_generation_and_placement_cli() {
    warn!("ðŸ§ª Running CLI Test: Generation and Placement (Conductor Validation)...");

    // 1. Initialize Conductor and retrieve state
    // FIX E0308: Updated destructuring to handle the new 4-element tuple (Conductor, ConductorState, Progress Receiver, Request Sender).
    let (mut conductor, _state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("âŒ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    // --- 2. Test Perlin Generator ---
    let perlin_id = "perlin_mvg"; 
    if conductor.set_active_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            let _chunk = conductor.generate_single_chunk(coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    // --- 3. Test Cellular Automata Generator ---
    let ca_id = "cellular_automata_basic"; 
    if conductor.set_active_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.generate_single_chunk(coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    // --- 4. Report and Shutdown ---
    if chunks_generated > 0 {
        info!("âœ… CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).", 
            chunks_generated, 
            conductor.get_active_generator_id() // Reports the last active ID
        );
    } else {
        error!("âŒ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    // Use the consuming teardown method.
    conductor.graceful_teardown();
}

// --- Conversion Utilities ---

/// ðŸ§ª Converts a PNG into a tile chunk using bitmask logic (Placeholder).
pub fn run_bitmask_conversion() {
    warn!("ðŸ§ª Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("âœ… Conversion complete. Tiles placed: {}", tiles_placed);
}

// --- Benchmark Utilities ---

/// ðŸ§ª Benchmarks tile placement throughput.
///
/// Executes a fixed workload concurrently with a live progress ticker.
pub fn run_max_grid_benchmark() {
    warn!("ðŸ§ª Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000; 

    // --- 1. SETUP SHARED ATOMIC STATE ---
    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    // --- 2. START THE WORKLOAD (GENERATION) THREAD ---
    // NOTE: Conductor::new() is called inside benchmark_generation_workload 
    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone); 
    });

    // --- 3. START THE TICKER (CLI REPORTING) THREAD ---
    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            // Load the current progress atomically
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            // Calculate live throughput
            let throughput = if elapsed > 0.0 { 
                (current as f64 / elapsed).round() as u64 
            } else { 
                0 
            };

            // Use \r to reset the cursor to the start of the line for a live update
            print!("\râ³ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s", 
                percentage, 
                current / 1_000_000, // Display in Millions
                WORKLOAD_TILES / 1_000_000, // Display Total in Millions
                throughput
            );
            // Ensure the output is immediately visible
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            // Poll progress every 50ms
            thread::sleep(Duration::from_millis(50));
        }
    });

    // --- 4. WAIT FOR WORKLOAD AND MEASURE TIME ---
    let start = Instant::now();
    
    // Block until the generation work is finished
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        // Clean the line and exit
        let _ = println!("\râŒ Benchmark failed: Generation thread panic. {: <100}", " "); 
        return; 
    }
    
    // Ensure the ticker thread prints 100% and finishes its loop
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64; 
    let actual_tiles_placed = WORKLOAD_TILES;
    
    // Clear the progress line before printing final results
    println!("\râœ… Benchmark complete. Workload: {} tiles. Duration: {:.2}s", 
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        // --- Outputting Max Possible Throughput ---
        println!("âš¡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("âš¡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        // --- Performance Analysis ---
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("ðŸš€ CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("ðŸ“ˆ Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("âš ï¸ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector [B] to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("âŒ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\scan\report_formatter.rs (193 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/actions/report_formatter.rs

use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{info, error};

// Import necessary items from the file_walker sibling module.
use super::file_walker::{recursive_loc_scan, FileLoc, ROOT_DIR};


// --- CONFIGURATION ---
const OUTPUT_FILENAME_PREFIX: &str = "ssxl_loc_report_";
const OUTPUT_DIR: &str = "../loc_reports/";


/// Helper function to generate a simple epoch seconds string for the filename.
fn get_timestamp_string() -> String {
    let now = SystemTime::now();
    let since_the_epoch = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    format!("{}", since_the_epoch.as_secs())
}

/// Executes the full LOC scan, prints the summary, and writes the detailed report.
pub fn execute_loc_scan() {
    info!("LOC Scanner: Starting recursive scan for Rust files in {}", ROOT_DIR);
    
    let root_path = PathBuf::from(ROOT_DIR);
    if !root_path.exists() {
        error!("LOC Scanner failed: Root directory not found at {}", root_path.display());
        return;
    }

    let scan_start = SystemTime::now();

    // 1. Execute the scan using file_walker
    let mut loc_results = match recursive_loc_scan(&root_path, "rs") {
        Ok(results) => results,
        Err(e) => {
            error!("LOC Scanner: Recursive scan failed: {}", e);
            return;
        }
    };
    
    let scan_duration = scan_start.elapsed()
        .map_or("N/A".to_string(), |d| format!("{:.2}ms", d.as_millis() as f32));

    let total_loc: usize = loc_results.iter().map(|f| f.loc).sum();
    let file_count = loc_results.len();

    // --- Generate Output File ---
    let timestamp_str = get_timestamp_string();
    let output_filename = format!("{}{}.txt", OUTPUT_FILENAME_PREFIX, timestamp_str);
    let output_path = PathBuf::from(OUTPUT_DIR).join(&output_filename);

    // Ensure output directory exists
    if let Err(e) = fs::create_dir_all(PathBuf::from(OUTPUT_DIR)) {
        error!("Failed to create output directory {}: {}", OUTPUT_DIR, e);
        return;
    }

    match fs::File::create(&output_path) {
        Ok(mut file) => {
            // Sort results by LOC descending for the report
            loc_results.sort_unstable_by(|a, b| b.loc.cmp(&a.loc));
            
            // 2. Write Header, Summary Table, and Content Dump
            if let Err(e) = write_report_header(&mut file, &root_path, &scan_duration, total_loc, file_count, &timestamp_str) {
                error!("Failed to write header to LOC report: {}", e);
                return;
            }

            if let Err(e) = write_summary_table(&mut file, &loc_results, &root_path) {
                error!("Failed to write summary table to LOC report: {}", e);
            }

            if let Err(e) = write_content_dump(&mut file, &loc_results, &root_path) {
                 error!("Failed to write content dump to LOC report: {}", e);
            }
            
            // Final Footer
            if file.write_all(b"\n\n======================================================\nEND OF REPORT\n======================================================\n").is_err() {
                error!("Failed to write report footer.");
            }

            info!("LOC Report: Successfully created report file: {}", output_path.display());

            // Print summary to console
            println!("\n[ LOC Scan Complete ]");
            println!("Total Rust Files: {}", file_count);
            println!("Total Lines of Code: {}", total_loc);
            println!("Report saved to: {}", output_path.display());
        }
        Err(e) => {
            error!("Failed to create LOC report file {}: {}", output_path.display(), e);
        }
    }
}

// --- Internal Report Writing Helpers ---

fn write_report_header(
    file: &mut fs::File,
    root_path: &PathBuf,
    scan_duration: &str,
    total_loc: usize,
    file_count: usize,
    timestamp_str: &str,
) -> io::Result<()> {
    let header = format!(
        "SSXL-ext Codebase LOC Report\n\
        Generated (Epoch Seconds): {}\n\
        Root Directory: {}\n\
        Scan Time: {}\n\
        Total Files Scanned: {}\n\
        Total Lines of Code (LOC): {}\n\n\
        ------------------------------------------------------\n\
        {:>5} LOC | Relative File Path\n\
        ------------------------------------------------------\n",
        timestamp_str,
        root_path.display(),
        scan_duration,
        file_count,
        total_loc,
        "FILE"
    );
    file.write_all(header.as_bytes())
}

fn write_summary_table(
    file: &mut fs::File,
    loc_results: &[FileLoc],
    root_path: &PathBuf,
) -> io::Result<()> {
    for result in loc_results {
        // Attempt to strip the root prefix for cleaner output path
        let path_str = result.path.strip_prefix(root_path)
                                 .unwrap_or(&result.path)
                                 .display()
                                 .to_string();
        let line = format!("{:>5} LOC | {}\n", result.loc, path_str);
        // Using write_all ensures all bytes are written or an error is returned.
        file.write_all(line.as_bytes())?;
    }
    Ok(())
}

fn write_content_dump(
    file: &mut fs::File,
    loc_results: &[FileLoc],
    root_path: &PathBuf,
) -> io::Result<()> {
    let content_header = format!(
        "\n\n\n\n======================================================\n\
        SSXL-ext Codebase DETAILED CONTENT DUMP\n\
        ======================================================\n"
    );
    file.write_all(content_header.as_bytes())?;

    for result in loc_results {
        let path_str = result.path.strip_prefix(root_path)
                                 .unwrap_or(&result.path)
                                 .display()
                                 .to_string();
        
        let file_separator = format!(
            "\n\n\n//////////////////////////////////////////////////////\n\
             // FILE: {} ({} LOC)\n\
             //////////////////////////////////////////////////////\n\n",
            path_str,
            result.loc
        );

        file.write_all(file_separator.as_bytes())?;

        // Read and write the entire file content
        match fs::read_to_string(&result.path) {
            Ok(content) => {
                if let Err(e) = file.write_all(content.as_bytes()) {
                    error!("Failed to write content for {}: {}", path_str, e);
                }
            }
            Err(e) => {
                let error_message = format!("\n[ ERROR: FAILED TO READ FILE CONTENT: {} ]\n", e);
                if let Err(e) = file.write_all(error_message.as_bytes()) {
                    error!("Failed to write error message for {}: {}", path_str, e);
                }
            }
        }
    }
    Ok(())
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\animation_api.rs (166 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/animation_api.rs

use godot::prelude::*;
use godot::classes::{Node, TileMap}; 
use godot::obj::Gd;

use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

// Internal Crate Dependencies
use ssxl_generate::Conductor;
use ssxl_shared::chunk_data::ChunkData; 
use ssxl_math::Vec2i; 
use ssxl_sync::{AnimationConductorHandle, AnimationCommand}; 


/// Delegate struct responsible for handling all calls from Godot related to 
/// animation control and sending commands to the background AnimationConductor thread.
#[derive(Default)] 
pub struct AnimationAPI<'a> {
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

impl<'a> AnimationAPI<'a> {
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }

    // --------------------------------------------------------------------------
    // API IMPLEMENTATION
    // --------------------------------------------------------------------------

    /// Maps a Godot String command name to an AnimationCommand enum and sends it.
    /// This resolves the GDScript call `ssxl_engine.send_animation_command("...")`.
    pub fn send_command_by_name(&self, command_name: String) {
        if let Some(handle) = self.animation_conductor {
            let command = match command_name.as_str() {
                "StartTestAnimation" => {
                    info!("AnimationAPI: Mapping to StartTestAnimation command.");
                    AnimationCommand::StartTestAnimation 
                },
                "StopTestAnimation" => {
                    info!("AnimationAPI: Mapping to StopTestAnimation command.");
                    AnimationCommand::StopTestAnimation
                },
                _ => {
                    warn!("AnimationAPI: Received unrecognized command: {}", command_name);
                    return; // Exit if command is unrecognized
                }
            };
            
            // Send the command via the conductor handle
            if let Err(e) = handle.send(command) {
                error!("AnimationAPI: Failed to send command to worker: {}", e);
            }
        } else {
            warn!("AnimationAPI: Command '{}' received, but animation conductor is not initialized.", command_name);
        }
    }

    /// Starts the dedicated 30x30 self-clocked test animation.
    /// This only sends the start command to the worker, keeping the TileMap handle 
    /// on the main thread (Godot side).
    pub fn start_test_animation(&self, _tilemap_node: Option<&Gd<TileMap>>) {
        if let Some(handle) = self.animation_conductor {
            // âœ… UPDATED: Assuming AnimationCommand::StartTestAnimation is a unit variant.
            let command = AnimationCommand::StartTestAnimation;

            match handle.send(command) {
                Ok(_) => info!("AnimationAPI: Sent StartTestAnimation command."),
                Err(e) => error!("Failed to send StartTestAnimation command: {}", e),
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start test animation.");
        }
    }

    /// Stops the dedicated 30x30 self-clocked test animation.
    pub fn stop_test_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping 30x30 test animation.");
            
            // Assuming AnimationCommand::StopTestAnimation is defined
            if let Err(e) = handle.send(AnimationCommand::StopTestAnimation) {
                 error!("Failed to send StopTestAnimation command: {}", e);
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop test animation.");
        }
    }

    /// Starts the animation worker thread's update loop.
    pub fn start_loading_animation(
        &self,
        framerate: f32,
        _signals_node: Option<&Gd<Node>>,
    ) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Starting loading animation at {:.2} FPS.", framerate);
            
            let update_result = handle.send(AnimationCommand::UpdateFramerate(framerate));
            let start_result = handle.send(AnimationCommand::Start);
            
            if let Err(e) = update_result {
                error!("Failed to send UpdateFramerate command: {}", e);
            }
            if let Err(e) = start_result {
                 error!("Failed to send Start command: {}", e);
            }
            
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start animation.");
        }
    }

    /// Registers a specific chunk's coordinates to be included in the animation update cycle.
    pub fn register_chunk_for_animation(&self, chunk_x: i32, chunk_y: i32) {
        if let Some(handle) = self.animation_conductor {
            
            // Cast i32 to i64 to satisfy Vec2i::new argument types.
            let coords = Vec2i::new(chunk_x as i64, chunk_y as i64); 
            
            if let Some(conductor_arc) = self._conductor {
                let result = conductor_arc.lock().map(|conductor| {
                    
                    let chunk_data = conductor.get_chunk_data(&coords);
                    let chunk_arc = Arc::new(chunk_data);
                    
                    handle.send(AnimationCommand::RegisterChunk(chunk_arc))
                        .map_err(|e| error!("Failed to send RegisterChunk command: {}", e))
                        .ok();
                    info!("AnimationAPI: Registered chunk ({}, {}) for animation.", chunk_x, chunk_y);
                });

                if let Err(e) = result {
                    error!("Failed to lock Conductor mutex for chunk registration: {}", e);
                }
            } else {
                warn!("Generation Conductor is not initialized. Cannot register chunk data.");
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot register chunk.");
        }
    }

    /// Stops the animation worker thread's update loop.
    pub fn stop_loading_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping loading animation.");
            
            if let Err(e) = handle.send(AnimationCommand::Stop) {
                 error!("Failed to send Stop command: {}", e);
            }
            
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop animation.");
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_inspect.rs (162 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/cli_util_inspect.rs (Final, Cleaned Code)

//! Inspection utilities for diagnostics and developer introspection.

use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration; 

// --- Module Tree Inspection ---

/// ðŸ“¦ Prints a tree of Rust modules across all workspace crates.
/// NOTE: This assumes the CLI is executed from the 'rust/' directory.
pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| ðŸŒ² RUST WORKSPACE MODULE TREE (Scanning...)Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â |");
	println!("=========================================================================");
	
	// Assuming execution from the workspace root (e.g., 'rust/')
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\nðŸ” Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                // Core files are highlighted
                                "â”œâ”€â”€ [CORE] "
                            } else {
                                "â”‚Â  Â â””â”€â”€ "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


// --- API Inspection ---

/// ðŸ§ª Scans for GDScript-callable Rust methods exposed via #[func]
/// NOTE: This assumes the CLI is executed from the 'rust/' directory.
pub fn print_godot_api_surface() {
    // FIX: Define an array of all known Godot API files.
	let godot_api_files: [&str; 3] = [
        "ssxl_godot/src/ssxl_engine.rs",
        "ssxl_godot/src/ssxl_oracle.rs", // Assuming this is where oracle functions live
        "ssxl_godot/src/ssxl_signals.rs",
    ];

    println!("ðŸ§ª API scan triggered (targeting {} files in ssxl_godot/src/)...", godot_api_files.len());
    
    // Regex to find the function signature line that follows #[func].
    // Captures: 1=method_name, 2=arguments, 3=return_type
    let fn_signature_regex = Regex::new(
        r"^\s*pub\s+fn\s+(\w+)\s*(\([^\{]*)\s*(?:->\s*([^\{]*))?\s*\{"
    ).unwrap();

    // Regex to find the #[func] marker line.
    let func_marker_regex = Regex::new(r"^\s*#\[func\]\s*$").unwrap();

    // Store API methods with source file name
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();

    // Iterate over all target files
    for file_path_str in godot_api_files.iter() {
        // FIX: The following variables are correctly scoped to the loop iteration.
        let godot_lib_path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        let mut func_line_pending = false;

        match fs::read_to_string(godot_lib_path) {
            Ok(contents) => {
                info!("Successfully read {}", godot_lib_path.display());
                
                for line in contents.lines() {
                    // 1. Check for the #[func] marker
                    if func_marker_regex.is_match(line) {
                        func_line_pending = true;
                        continue;
                    }

                    // 2. If marker was found, check for the function signature
                    if func_line_pending {
                        if let Some(captures) = fn_signature_regex.captures(line) {
                            
                            let method_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                            
                            // Argument capture: remove surrounding parentheses and trim whitespace
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            // Return type capture: trim whitespace, default to "()"
                            let return_type = captures.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                            
                            // Store the method along with its source file name
                            api_methods.push((method_name, args, return_type, file_name.to_string()));
                            
                            func_line_pending = false;
                        } else if !line.trim().is_empty() {
                            func_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                // FIX: Use `file_path_str` here to report the error correctly.
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- ðŸŽ® SSXL Engine Godot API Surface ---");
    if api_methods.is_empty() {
        warn!("No #[func] methods found in the targeted ssxl_godot API files. Is the Godot binding active?");
    } else {
        println!("Registered {} callable methods:", api_methods.len());
        for (name, args, return_type, source_file) in &api_methods {
            // Display as: MethodName(arguments) -> ReturnType [SourceFile]
            println!("  âœ… func {}({}) -> {} [{}]", name, args, return_type, source_file);
        }
    }
	println!("-------------------------------------------\n");

    info!("API scan complete: {} methods detected.", api_methods.len());
    thread::sleep(Duration::from_secs(2));
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\actions\testing.rs (157 LOC)
//////////////////////////////////////////////////////

use std::process::{Command, Stdio};
use tracing::{info, error, warn};
use std::thread;
use std::io;

// Import constants and core pathing utility from the parent module (actions/mod.rs).
// CORRECTED PATH: Changed 'super::super' to 'super'.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    GODOT_TEST_SCENE,
};

// -----------------------------------------------------------------------------
// CARGO AND PRIORITY TESTS
// -----------------------------------------------------------------------------

/// ðŸš€ Runs the full Rust test suite via Cargo
pub fn run_cargo_tests() {
	println!("ðŸš€ Running full cargo test suite...");

	let status = Command::new("cargo")
		.args(&["test", "--", "--nocapture"])
		.status()
		.expect("Failed to run cargo test");

	if status.success() {
		info!("âœ… All tests passed.");
	} else {
		error!("âŒ Some tests failed.");
	}
}

/// Runs only the unit tests defined in the Phase 1 Foundation Layer packages.
pub fn run_priority_1_tests() {
	info!("Running Phase 1 Foundation Layer (P1) test suite...");

	let result = Command::new("cargo")
		.arg("test")
		.arg("--package")
		.arg("ssxl_shared")
		.arg("--package")
		.arg("ssxl_math")
		.arg("--package")
		.arg("ssxl_sync")
		.arg("--all-targets")
		.status();

	match result {
		Ok(status) if status.success() => {
			info!("âœ… Phase 1 Validation Complete: All foundation tests passed successfully.");
		}
		_ => {
			error!("âŒ Phase 1 Validation Failed. Check the errors above.");
		}
	}
}

// -----------------------------------------------------------------------------
// FFI BRIDGE VALIDATION (E2E FINAL)
// -----------------------------------------------------------------------------

/// ðŸ”¥ Runs an end-to-end test of the FFI bridge by launching Godot headless
/// to load the dedicated GDExtension test scene and validate data transfer.
pub fn run_ffi_bridge_validation() {
    info!("ðŸ”¥ STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("âŒ Validation failed: {}", e);
            return;
        }
    };

    info!("Launching Godot (Headless) from: {}", GODOT_EXE_PATH);
    info!("Running test scene: {} in project (Absolute Path): {}", GODOT_TEST_SCENE, project_path_abs);

    // --- 3. Launch Godot Headless to Execute the GDExtension Test ---
    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--headless") 
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--quit") // CRITICAL FIX: Ensures Godot process exits immediately after running the scene
        .stdout(Stdio::piped()) // FIX: Explicitly pipe stdout for reading
        .stderr(Stdio::piped()); // FIX: Explicitly pipe stderr for reading

    // Spawn the process
    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("âŒ Failed to spawn Godot process: {}", e);
            warn!("Please ensure the Godot executable is in the correct path relative to your CLI: {}", GODOT_EXE_PATH);
            return;
        }
    };

    // Capture streams BEFORE waiting for the process to exit
    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    // 1. Concurrently read STDOUT in a separate thread to prevent pipe deadlock
    let stdout_handle = thread::spawn(move || {
        io::read_to_string(stdout).unwrap_or_else(|_| "Failed to read stdout.".to_string())
    });

    // 2. Concurrently read STDERR in another thread to prevent pipe deadlock
    let stderr_handle = thread::spawn(move || {
        io::read_to_string(stderr).unwrap_or_else(|_| "Failed to read stderr.".to_string())
    });

    // 3. Main thread waits for the Godot process to exit
    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("âŒ Godot process failed to wait: {}", e);
            return;
        }
    };

    // 4. Retrieve captured output from the concurrent threads
    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    // --- 5. Process the Output ---
    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("âœ… FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!("âŒ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}", status.code());
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

// -----------------------------------------------------------------------------
// CORE TEST SUITE EXECUTION (ADDED)
// -----------------------------------------------------------------------------

/// ðŸ§ª Runs a consolidated test suite, typically including priority tests,
/// cargo tests, and the final FFI bridge validation.
/// This function is added to resolve the E0432 unresolved import error in 
/// ssxl_cli/src/actions/mod.rs.
pub fn run_test_suite() {
    warn!("ðŸ§ª Full Test Suite execution not yet fully implemented. Placeholder called.");
    
    // In a final implementation, this would likely chain:
    // run_priority_1_tests();
    // run_cargo_tests();
    // run_ffi_bridge_validation();
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\chunk_data.rs (156 LOC)
//////////////////////////////////////////////////////

//! Canonical data structure for a single, dimension-agnostic chunk of procedural data.

use serde::{Serialize, Deserialize};
use std::time::SystemTime;

// Import types from other modules in aetherion_shared
use crate::grid_bounds::GridBounds;
use crate::tile_data::TileData;
use crate::math_primitives; // Used for the SystemTime serde helper

// Import Vec2i from the dedicated aetherion_math crate (External Dependency)
use ssxl_math::Vec2i;

use serde_big_array::BigArray;

// --- EXPORTED STRUCTS ---

/// Canonical coordinates for a chunk in the grid (Chunk Space).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}

// --- CONSTANTS ---

/// The canonical size for all chunks in the SSXL Engine (32x32 tiles).
pub const CHUNK_SIZE: u32 = 32;
/// The total number of tiles in a single chunk (CHUNK_SIZE * CHUNK_SIZE = 1024).
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;

// --- STRUCT DEFINITION ---
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
	pub id: u64,
	pub bounds: GridBounds,
	/// The fixed-size array containing all tile data. `BigArray` is used for efficient
	/// serialization of the large array.
	#[serde(with = "BigArray")]
	pub tiles: [TileData; TILE_ARRAY_SIZE],
	pub dimension_tag: String,
	#[serde(with = "math_primitives::system_time_serde")]
	pub generated_at: SystemTime,
}

// --- IMPLEMENTATION ---

impl ChunkData {
	pub const SIZE: u32 = CHUNK_SIZE;

	/// Creates a new, empty ChunkData instance initialized with default data.
	pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
		let tiles = [TileData::default(); TILE_ARRAY_SIZE];
		ChunkData {
			id,
			bounds,
			tiles,
			dimension_tag,
			generated_at: SystemTime::now(),
		}
	}
	
	/// Creates a new ChunkData instance using only the chunk coordinates.
	pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
		let chunk_size_i64 = Self::SIZE as i64;
		
		// Convert chunk coordinates (Vec2i is i64-based) to world-space grid coordinates
		let min_x = chunk_coords.x * chunk_size_i64;
		let min_y = chunk_coords.y * chunk_size_i64;
		// Max coordinates are inclusive
		let max_x = min_x + chunk_size_i64 - 1;
		let max_y = min_y + chunk_size_i64 - 1;

		let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
		
		// Simple, deterministic ID derived from chunk coordinates using XOR for fast hashing.
		let id = chunk_coords.x as u64 ^ chunk_coords.y as u64;
		let tiles = [TileData::default(); TILE_ARRAY_SIZE];

		ChunkData {
			id,
			bounds,
			tiles,
			dimension_tag: "Default".to_string(),
			generated_at: SystemTime::now(),
		}
	}

	/// Converts local (x, y) coordinates to a flattened array index.
	#[inline(always)]
	fn coord_to_index(x: u32, y: u32) -> Option<usize> {
		if x < Self::SIZE && y < Self::SIZE {
			Some((y * Self::SIZE + x) as usize)
		} else {
			None
		}
	}

	/// Returns the data for a tile at the given local (x, y) coordinates.
	pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
		Self::coord_to_index(x, y).map(|index| {
			&self.tiles[index]
		})
	}
	
	/// Replaces the chunk's fixed-size tile array with a new set of tiles.
	/// Used by generators (like Cellular Automata) that produce a `Vec<TileData>`.
	pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
		if tiles_vec.len() == TILE_ARRAY_SIZE {
			// Efficiently copy the vector's contents into the fixed-size array
			self.tiles.clone_from_slice(&tiles_vec);
		} else {
			// Panic signals a contract violation: the generator must produce the correct number of tiles.
			panic!(
				"Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
				self.bounds,
				tiles_vec.len(),
				TILE_ARRAY_SIZE
			);
		}
	}
	
	/// Returns a mutable reference to the tile data at the given local (x, y) coordinates.
	pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
		Self::coord_to_index(x, y).map(|index| {
			&mut self.tiles[index]
		})
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	/// Tests the coordinate flattening function for standard and edge cases.
	#[test]
	fn test_coord_to_index() {
		// Chunk size is 32 (CHUNK_SIZE)
		
		// 1. Basic check (0, 0)
		assert_eq!(ChunkData::coord_to_index(0, 0), Some(0));

		// 2. Middle point check
		// (Y=16 * SIZE=32) + X=16 = 512 + 16 = 528
		assert_eq!(ChunkData::coord_to_index(16, 16), Some(528));

		// 3. Max boundary check (31, 31)
		// (Y=31 * SIZE=32) + X=31 = 992 + 31 = 1023 (TILE_ARRAY_SIZE - 1)
		assert_eq!(ChunkData::coord_to_index(31, 31), Some(1023));

		// 4. Out-of-bounds check (size is 32, so 32 is out)
		assert_eq!(ChunkData::coord_to_index(32, 0), None);
		assert_eq!(ChunkData::coord_to_index(0, 32), None);
		assert_eq!(ChunkData::coord_to_index(33, 33), None);
	}
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\task_queue.rs (155 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/task_queue.rs

//! The core manager for asynchronous generation tasks, chunk requests,
//! and the coordination of the blocking work pool.

use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tracing::{info, error, warn};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// Imports updated to support i64 (64-bit) coordinates
use glam::I64Vec3;
use ssxl_math::{Vec2i, prelude::ChunkKey};

// Internal Crate Dependencies
use ssxl_cache::ChunkCache;
use crate::Generator; // Generator is correctly at crate root (lib.rs)
use crate::conductor_state::ConductorState;

// External Crate Dependencies
use ssxl_shared::chunk_data::ChunkData;
// âœ… Imports fixed to resolve E0432 for ssxl_shared modules
pub use ssxl_shared::config::CHUNK_SIZE as SHARED_CHUNK_SIZE;
pub use ssxl_shared::generation_message::{GenerationMessage, GenerationTask};


// Define a type alias for the generator trait object
type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- CONSTANTS (Moved from Conductor) ---
/// The size of a chunk in tiles.
// âœ… Made public to resolve E0603 in batch_processor.rs
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64; // Use the canonical size, cast to i64 for coordinate math

// -----------------------------------------------------------------------------
// ASYNCHRONOUS TASK QUEUE LOGIC
// -----------------------------------------------------------------------------

/// Encapsulates the core logic for loading from cache, generating, and saving a single chunk.
/// This function is thread-safe and blocking-pool safe.
// âœ… Made public to resolve E0432 in conductor.rs (via the missing start_request_loop)
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<Mutex<ChunkCache>>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
) {
    let key_vec3 = I64Vec3::new(chunk_coords.x, chunk_coords.y, 0);
    let chunk_key = ChunkKey(key_vec3);
    let chunk_data: ChunkData;

    match chunk_cache.lock() {
        Ok(cache_lock) => { 
            match cache_lock.load_chunk(&chunk_key) {
                Ok(Some(data)) => {
                    info!("Chunk Unit: Retrieved chunk {:?} from cache (Gen: {}).", chunk_coords, generator_name);
                    chunk_data = data;
                },
                Ok(None) => {
                    info!("Chunk Unit: Chunk {:?} not found in cache. Generating with {}.", chunk_coords, generator_name);
                    let generator_arc = generators
                        .get(generator_name)
                        .expect("Generator ID must be registered in Conductor.");
                    
                    chunk_data = generator_arc.generate_chunk(chunk_coords);
                    
                    // Save to cache (requires mutable cache_lock)
                    if let Err(e) = cache_lock.save_chunk(&chunk_key, &chunk_data) {
                        error!("Chunk Unit: Failed to save chunk {:?} to cache: {:?}", chunk_coords, e);
                    } else {
                        info!("Chunk Unit: Saved chunk {:?} to cache.", chunk_coords);
                    }
                },
                Err(e) => {
                    warn!("Chunk Unit: Cache load failed for {:?}: {:?}. Falling back to generation without caching.", chunk_coords, e);
                    let generator_arc = generators
                        .get(generator_name)
                        .expect("Generator ID must be registered in Conductor.");
                    chunk_data = generator_arc.generate_chunk(chunk_coords);
                }
            }
        },
        Err(e) => {
            error!("Chunk Unit: Cache Mutex poisoned: {}. Falling back to generation without caching.", e);
            let generator_arc = generators
                .get(generator_name)
                .expect("Generator ID must be registered in Conductor.");
            chunk_data = generator_arc.generate_chunk(chunk_coords);
        }
    }
    
    // Emit signal with the zero-copy bulk data payload
    let chunk_data_arc = Arc::new(chunk_data);
    
    // ðŸ›‘ IMPROVEMENT: Add proper error handling for channel send.
    if let Err(e) = progress_sender.blocking_send(
        GenerationMessage::ChunkGenerated(chunk_coords, chunk_data_arc)
    ) {
        // If the main thread's receiver is dropped, this error occurs.
        error!("Chunk Unit: Failed to send ChunkGenerated message for {:?}: {:?}", chunk_coords, e);
    }
}


/// Starts the asynchronous request loop on the provided Tokio runtime handle.
/// This loop continuously processes incoming GenerationTask requests.
pub fn start_request_loop(
    rt_handle: Handle,
    request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<Mutex<ChunkCache>>,
    conductor_state: Arc<ConductorState>,
) {
    // Note: We move the request receiver into the async block, 
    // where it will be polled for new tasks.
    rt_handle.spawn(async move {
        info!("Generation Task Queue active.");

        let mut request_rx = request_rx;
        
        while let Some(task) = request_rx.recv().await {
            // âœ… FIX: Replaced non-existent `is_running()` with the new `is_active()` method from ConductorState.
            if !conductor_state.as_ref().is_active() { 
                warn!("Request received while Conductor is paused. Dropping task: {:?}", task.chunk_coords);
                continue;
            }

            // Spawn the blocking work unit onto the dedicated blocking thread pool
            // This prevents long-running generation tasks from blocking the Tokio executor.
            let progress_tx_clone = progress_tx.clone();
            let generators_clone = generators.clone();
            let chunk_cache_clone = chunk_cache.clone();

            tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators_clone,
                    &chunk_cache_clone,
                    &progress_tx_clone,
                );
            });
        }
        
        // When the command sender is dropped and request_rx closes, we signal completion.
        info!("Generation Task Queue shutting down.");
        // FIX (E0599): Use the correct variant name: GenerationComplete
        if progress_tx.blocking_send(GenerationMessage::GenerationComplete).is_err() { 
            error!("Failed to send final GenerationComplete message.");
        }
    });
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\coordinate_system.rs (140 LOC)
//////////////////////////////////////////////////////

//!
//! Defines the coordinate system types used throughout the engine and provides
//! conversion utilities between them.
//!
//! The Aetherion engine uses a chunked, tile-based world system.
//! - WorldPos: Global coordinate, precise to the tile (i64).
//! - ChunkKey: Identifier for the chunk the tile belongs to (i64).
//! - TileOffset: Local position of the tile within its chunk (i64, though 0-31).

use serde::{Serialize, Deserialize};
// ðŸ“ BULLDOZER FIX: Imported CHUNK_SIZE_I64 and switched from IVec3 to I64Vec3.
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;


// --- 1. Coordinate Types ---

/// A global coordinate precise to the tile level.
/// Used for physics, networking, and high-level queries.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

/// The key/identifier for a specific chunk in the world grid.
/// Used for data fetching, loading/unloading, and persistent storage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

/// The local coordinate of a tile *within* its chunk.
/// Used for array indexing and rendering offsets.
// Switched to I64Vec3 for consistency with I64 world coordinates.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);


// --- 2. Coordinate Conversion Functions ---

impl WorldPos {
    /// Converts a global WorldPos into its corresponding ChunkKey and local TileOffset.
    ///
    /// The conversion uses the relationship:
    /// WorldPos = (ChunkKey * CHUNK_SIZE) + TileOffset
    ///
    /// This requires using the Euclidean remainder (`rem_euclid`) for the offset,
    /// and then deriving the ChunkKey via floor division to correctly handle negative coordinates.
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        
        let chunk_size: i64 = CHUNK_SIZE_I64;

        // 1. Tile Offset calculation (uses Euclidean remainder, which is correct)
        // Self.0 is I64Vec3, so all coordinates are i64.
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // 2. Chunk Key calculation (Use Euclidean quotient derivation)
        // ChunkKey = (WorldPos - TileOffset) / CHUNK_SIZE_I64
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

impl ChunkKey {
    /// Converts a ChunkKey and a local TileOffset back into a global WorldPos.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size: i64 = CHUNK_SIZE_I64;

        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// ---------------------------
// IMPL: Unit Tests (Updated to use I64Vec3 and test high coordinates)
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;
    // NOTE: CHUNK_SIZE_I64 is 32 for test context.

    #[test]
    fn test_world_to_chunk_positive() {
        // Test high coordinate (i64 test)
        let huge_coord = 5_000_000_000i64; // Well over i32::MAX
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64; // 156,250,000
        let expected_offset = huge_coord % CHUNK_SIZE_I64; // 0
        
        // Position (huge_coord, 10, 64)
        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();
        
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        // Test 1: Position (-1, -1, -1) - The critical check for Euclidean remainder.
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        // Must correctly resolve to chunk key (-1, -1, -1)
        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        // Must correctly resolve to max offset (31, 31, 31)
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test 2: Deep inside the negative space
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();
        
        // Expected Key: -2, -2, -4. Expected Offset: 31, 0, 28.
        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        // Test round trip with large negative coordinate to ensure no i64 overflow errors
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));
        
        // 1. Convert
        let (key, offset) = original_pos.to_chunk_coords();
        
        // 2. Convert back
        let final_pos = key.to_world_pos(offset);

        // 3. Verify
        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\tile_data.rs (132 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/tile_data.rs

//! Defines the TileData structure: a compact, serializable unit holding all
//! generated and runtime data for a single tile in the world grid.
//!
//! Total size is 6 bytes (1 + 4 + 1), which is highly memory-efficient for bulk storage.

use super::tile_type::TileType;
use serde::{Serialize, Deserialize};

// CRITICAL FIX: Required import for AnimationUpdate coordinates.
// Assumes Vec2i is available from the ssxl_math crate.
use ssxl_math::Vec2i;

// --------------------------------------------------------------------------------
// CORE TILE DATA STRUCTURE
// --------------------------------------------------------------------------------

/// A compact structure holding the state of a single tile in the world.
///
/// This type is designed to be small, cheap to copy, and highly serializable for
/// use in the aetherion_cache.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The fundamental type of terrain/feature, determined by the MVG.
    /// This uses the u8 discriminant of the TileType enum.
    pub tile_type: TileType,
    
    /// The raw noise value V âˆˆ [0.0, 1.0] used to determine the `tile_type`.
    /// This serves as the primary elevation/metric field, combining the roles of 
    /// the previous `height_value` and potentially `aux_value` for simplicity.
    pub noise_value: f32, // 4 bytes
    
    /// An 8-bit field for general-purpose runtime flags (e.g., IsModified, IsTraversable).
    pub flags: u8, // 1 byte
}

impl Default for TileData {
    /// Provides a default, uninitialized state.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(), // Defaults to Void
            noise_value: 0.0,
            flags: 0,
        }
    }
}

// --------------------------------------------------------------------------------
// ANIMATION & COMMUNICATION DATA STRUCTURE (Fixes E0432)
// --------------------------------------------------------------------------------

/// Represents a simple tile update message for the animation worker.
/// This struct is sent from `ssxl_sync` (worker) to `ssxl_godot` (main thread)
/// to apply a single tile graphic change without affecting the underlying `TileData`.
#[derive(Debug, Clone)]
pub struct AnimationUpdate {
    pub layer: i32,
    pub source_id: i32,
    pub tile_coords: Vec2i,
    pub new_atlas_coords: Vec2i,
}


// ---------------------------
// IMPL: TileData Constructor, Flags Utility and Logic
// ---------------------------

/// Bitmask constants for the `flags` field
pub mod tile_flags { 
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001; // Bit 0: Is the tile physically passable?
    pub const IS_RENDERED:    u8 = 0b0000_0010; // Bit 1: Is the tile currently visible/rendered?
    pub const IS_MODIFIED:    u8 = 0b0000_0100; // Bit 2: Has this tile been manually changed post-generation?
    pub const HAS_RESOURCE:   u8 = 0b0000_1000; // Bit 3: Does this tile contain a gatherable resource?
    // Bits 4-7 are available for future logic.
}

impl TileData {
    /// Creates a new TileData instance with the generated type and noise value.
    /// This is the primary constructor used by the aetherion_generate MVG.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        // Initialize other fields to their defaults when constructed by the generator
        TileData {
            tile_type,
            noise_value,
            flags: 0, 
        }
    }

    /// Checks if the tile is considered solid or non-traversable (Air/Void).
    /// This relies on the `TileType`'s inherent logic for better consistency.
    pub const fn is_solid(&self) -> bool {
        !self.tile_type.is_empty()
    }

    /// Sets a specific bit flag by index (0-7).
    pub fn set_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            self.flags |= 1 << flag_index;
        }
    }

    /// Clears a specific bit flag by index (0-7).
    pub fn clear_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            self.flags &= !(1 << flag_index);
        }
    }

    /// Checks if a specific bit flag is set by index (0-7).
    pub fn check_flag_by_index(&self, flag_index: u8) -> bool {
        if flag_index < 8 {
            (self.flags & (1 << flag_index)) != 0
        } else {
            false
        }
    }
    
    /// Sets or clears a flag using the public constant masks (e.g., tile_flags::IS_TRAVERSABLE).
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            self.flags |= flag_mask;
        } else {
            self.flags &= !flag_mask;
        }
    }

    /// Checks if a specific flag is set using the public constant masks.
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        (self.flags & flag_mask) != 0
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\chunk_presenter.rs (130 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/chunk_presenter.rs (FIXED)

use godot::prelude::*;
use godot::classes::TileMap;

use ssxl_shared::{ChunkData, CHUNK_SIZE};
use ssxl_shared::tile_type::TileType;

use ssxl_shared::messages::ChunkMessage;
use ssxl_shared::tile_data::AnimationUpdate;

use std::io::Error as GodotError;

// Define the TileMap layer ID used by SSXL.
const SSXL_LAYER: i32 = 0;
// Define the atlas source ID for the TileSet, common for all tiles.
const ATLAS_SOURCE_ID: i32 = 0;

/// The ChunkPresenter is responsible for applying generated chunk data
/// to the Godot TileMap instance.
#[derive(Clone, Default, Debug)]
pub struct ChunkPresenter {}

impl ChunkPresenter {
    /// Creates a new presenter instance.
    pub fn new() -> Self {
        ChunkPresenter {}
    }

    // --------------------------------------------------------------------------
    // MESSAGE HANDLERS
    // --------------------------------------------------------------------------

    /// Implements the present_chunk method expected by ChannelHandler.
    pub fn present_chunk(&self, tile_map: &mut Gd<TileMap>, msg: ChunkMessage) {
        if let ChunkMessage::Generated(chunk_data) = msg {
            if let Err(e) = self.apply_chunk_data(tile_map, chunk_data) {
                godot_print!("Error applying chunk data: {:?}", e);
            }
        }
    }

    /// Implements the update_animated_tile method expected by ChannelHandler.
    pub fn update_animated_tile(&self, tile_map: &mut Gd<TileMap>, update: AnimationUpdate) {
        // Convert Vec2i tile_coords (i64) to Vector2i (i32)
        let cell_pos = Vector2i::new(
            update.tile_coords.x as i32, 
            update.tile_coords.y as i32
        );
        // Convert Vec2i new_atlas_coords (i64) to Vector2i (i32)
        let atlas_coords = Vector2i::new(
            update.new_atlas_coords.x as i32, 
            update.new_atlas_coords.y as i32
        );

        // Using the fluent set_cell_ex pattern to apply the new tile frame
        tile_map.set_cell_ex(
            SSXL_LAYER, 		// The target layer
            cell_pos 		    // FIX: Removed No-Break Space // The cell position
        )
        .source_id(ATLAS_SOURCE_ID)	
        .atlas_coords(atlas_coords)
        .alternative_tile(0);
    }
    
    // --------------------------------------------------------------------------
    // GENERATION DATA APPLICATION
    // --------------------------------------------------------------------------

    /// Applies a single, fully generated ChunkData structure to the Godot TileMap.
    pub fn apply_chunk_data(&self, tile_map: &mut Gd<TileMap>, chunk_data: ChunkData) -> Result<(), GodotError> {
        
        let chunk_size_i32 = CHUNK_SIZE as i32;
        
        // ðŸ›‘ CRITICAL FIX: Convert World Coordinate (bounds.min) back to TileMap Cell Coordinate
        // chunk_coords = world_coords / chunk_size
        let chunk_grid_x = (chunk_data.bounds.min.x / CHUNK_SIZE as i64) as i32;
        let chunk_grid_y = (chunk_data.bounds.min.y / CHUNK_SIZE as i64) as i32;

        // The starting GLOBAL cell position in the TileMap grid.
        let chunk_pos_grid = Vector2i::new(
            chunk_grid_x * chunk_size_i32,
            chunk_grid_y * chunk_size_i32,
        );

        // Step 1: Iterate over all tiles and set them on the TileMap
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                // De-reference the fixed array to get the TileData
                let tile = &chunk_data.tiles[index]; 

                let tile_type = tile.tile_type;
                
                let (_tile_id_render) = tile_type.get_default_tile_id();
                let (atlas_x, atlas_y) = tile_type.get_default_atlas_coords();

                // Skip drawing empty tiles (Void type)
                if tile_type.is_empty() {
                    continue;
                }
                
                // Calculate the final GLOBAL TileMap cell position
                let cell_pos = chunk_pos_grid + Vector2i::new(x as i32, y as i32);

                // Get the coordinates within the TileSet atlas texture
                let atlas_coords = Vector2i::new(
                    atlas_x as i32,
                    atlas_y as i32
                );

                // Use the set_cell_ex builder pattern with the correct chained methods.
                tile_map.set_cell_ex(
                    SSXL_LAYER, 		// The target layer
                    cell_pos 		    // FIX: Removed No-Break Space // The cell position
                )
                .source_id(ATLAS_SOURCE_ID) 	// Set the TileSet source (i32)
                .atlas_coords(atlas_coords) 	// Set coordinates within the TileSet atlas (Vector2i)
                .alternative_tile(0);			// Set the alternative tile index (i32, 0 for default)
            }
        }

        // âœ… FINAL FIX: Use the standard, public API for forcing a TileMap update.
        // Replaces the unstable tile_map.call("notify_runtime_tile_data_update", ...)
        // The TileMap::force_update() method in Godot's Rust bindings takes no arguments.
        tile_map.force_update();
        
        Ok(())
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_tools\src\lib.rs (128 LOC)
//////////////////////////////////////////////////////

// ssxl_tools/src/lib.rs (Final, Corrected Code)

//! Core utilities for configuration, asset management, and data validation.

// Restored missing necessary imports
use once_cell::sync::Lazy;
use regex::Regex;
use tracing::{info, warn}; 
use std::io::{self, Read}; 
use std::fs::File; 

// --- CRATE DEPENDENCIES ---
use ssxl_shared::SSXLData; 

// --- CONFIGURATION CONSTANTS ---
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml"; 
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
const DEFAULT_CA_RULESET: u8 = 0; 

// -----------------------------------------------------------------------------
// SSXL CONFIGURATION UTILITIES (RESTORED DEFINITION)
// -----------------------------------------------------------------------------

/// ðŸ”§ Stores all global, static configuration settings for the SSXL Engine.
// E0412 & E0433 Fix: SSXLConfig struct definition is now present.
pub struct SSXLConfig {
    default_generator_id: String,
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Private constructor to initialize config with defaults.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to load configuration from the specified path.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                file.read_to_string(&mut contents)?;

                // --- SIMULATED PARSING ---
                info!("SSXLConfig: File read successfully. Simulating config override.");
                // Return a simulated config that is NOT the default
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), 
                    ca_default_ruleset: 1, 
                })
            },
            Err(e) => {
                // Return the I/O error
                Err(e)
            }
        }
    }

    /// Accessor for the default generator ID.
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Accessor for the Cellular Automata default ruleset ID.
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Public function to load config, allowing the caller (Conductor) to specify the path.
pub fn get_config_from_path(path: Option<&str>) -> Result<SSXLConfig, io::Error> {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            Ok(config)
        },
        Err(e) => {
            // Log error and return defaults (Crucial for FFI stability)
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            Ok(SSXLConfig::new_with_defaults())
        }
    }
}

/// Provides thread-safe, static access to a configuration instance *initialized only with defaults*.
static CONFIG: Lazy<SSXLConfig> = Lazy::new(SSXLConfig::new_with_defaults);

/// DEPRECATED: Public function to retrieve a reference to the global configuration.
pub fn get_config() -> &'static SSXLConfig {
    warn!("DEPRECATED: Called `get_config()`. Use `get_config_from_path()` for correct FFI CWD handling.");
    &CONFIG
}

// -----------------------------------------------------------------------------
// DATA VALIDATION UTILITIES (RESTORED DEFINITION)
// -----------------------------------------------------------------------------

/// Provides a thread-safe, lazily initialized Regex instance for data ID validation.
// E0425 Fix: ID_REGEX static definition is now present.
static ID_REGEX: Lazy<Regex> = Lazy::new(|| {
    // Requires IDs to be numeric strings.
    Regex::new(r"^\d+$").expect("Failed to compile ID validation regex")
});

/// Validates the ID field of an AetherionData primitive against a standard regex pattern.
pub fn validate_data_id(data: &SSXLData) -> bool {
    // Assumes AetherionData::id is accessible and implements ToString (e.g., u64).
    ID_REGEX.is_match(&data.id.to_string())
}


// -----------------------------------------------------------------------------
// CRATE ENTRY
// -----------------------------------------------------------------------------

/// Initializes the `aetherion_tools` crate.
pub fn initialize() {
    // Force initialization of the static regex.
    let _ = &*ID_REGEX; 
    info!("SSXL Tools: Configuration and data validation utilities initialized.");
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\async_poll.rs (122 LOC)
//////////////////////////////////////////////////////

use godot::prelude::*; // Added to ensure all Godot traits are in scope
use godot::classes::Node;
use godot::obj::{GodotClass, Inherits, Gd, WithBaseField}; // For emit_signal
use godot::meta::ToGodot; // For to_variant
use std::sync::Arc;

// Import Tokio components for the generation receiver as the channel is Tokio-based
use tokio::sync::mpsc::{Receiver as TokioReceiver, UnboundedReceiver as TokioUnboundedReceiver, error::TryRecvError as TokioTryRecvError};

// Internal Crate Dependencies
use ssxl_shared::messages::ChunkMessage;
use ssxl_generate::task_queue::GenerationMessage;
use ssxl_shared::tile_data::AnimationUpdate;
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_shared::chunk_data::ChunkData;

// Type aliases for clarity
pub type GenerationReceiver = TokioReceiver<GenerationMessage>;
pub type AnimationReceiver = TokioUnboundedReceiver<AnimationUpdate>;

/// The **AsyncPoller** is responsible for **non-blocking retrieval** of generated
/// chunks and animation updates from the asynchronous worker threads. It is called
/// every frame by the Godot main loop (`_process` / `tick`).
#[derive(Default)]
pub struct AsyncPoller {
    generation_receiver: Option<GenerationReceiver>,
    animation_receiver: Option<AnimationReceiver>,
}

impl AsyncPoller {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn set_generation_receiver(&mut self, receiver: Option<GenerationReceiver>) {
        self.generation_receiver = receiver;
    }

    pub fn set_animation_receiver(&mut self, receiver: Option<AnimationReceiver>) {
        self.animation_receiver = receiver;
    }

    pub fn clear_receivers(&mut self) {
        self.generation_receiver = None;
        self.animation_receiver = None;
    }

    pub fn poll_generation_messages(&mut self) -> Vec<ChunkMessage> {
        let mut messages = Vec::new();

        if let Some(mut receiver) = self.generation_receiver.take() {
            loop {
                match receiver.try_recv() {
                    Ok(message) => {
                        let chunk_message = match message {
                            GenerationMessage::ChunkGenerated(_coords, chunk_data_arc) => {
                                let chunk_data = Arc::try_unwrap(chunk_data_arc)
                                    .unwrap_or_else(|arc| (*arc).clone());
                                ChunkMessage::Generated(chunk_data)
                            }
                            GenerationMessage::GenerationComplete => {
                                // This is a sentinel message; Godot side should handle completion
                                ChunkMessage::Generated(ChunkData::new(
                                    0,
                                    GridBounds::default(),
                                    "complete".to_string(), // Sentinel string
                                ))
                            }
                            // âœ… FIX: Removed Error and StatusUpdate, as they are not defined
                            // on GenerationMessage from ssxl_generate::task_queue.
                            // The Conductor's state now tracks status and errors directly.
                        };
                        messages.push(chunk_message);
                    }
                    Err(TokioTryRecvError::Empty) => break,
                    Err(TokioTryRecvError::Disconnected) => {
                        eprintln!("[SSXL-SYNC ERROR] Generation channel disconnected.");
                        // Put the receiver back if it disconnected, though this is usually fatal
                        self.generation_receiver = Some(receiver); 
                        return messages;
                    }
                }
            }
            self.generation_receiver = Some(receiver);
        }

        messages
    }

    pub fn poll_animation_updates<T: GodotClass + Inherits<Node>>(
        &mut self,
        emitter: &mut Gd<T>,
    ) {
        if let Some(mut receiver) = self.animation_receiver.take() {
            loop {
                match receiver.try_recv() {
                    Ok(update) => {
                        let mut node = emitter.clone().upcast::<Node>();
                        node.emit_signal(
                            "tile_flip_updated",
                            &[
                                (update.tile_coords.x as i32).to_variant(),
                                (update.new_atlas_coords.x as i32).to_variant(),
                            ],
                        );

                    }
                    Err(TokioTryRecvError::Empty) => break,
                    Err(TokioTryRecvError::Disconnected) => {
                        eprintln!("[SSXL-SYNC ERROR] Animation channel disconnected.");
                        return;
                    }
                }
            }
            self.animation_receiver = Some(receiver);
        }
    }

    pub fn poll_animations(&mut self, emitter: &mut Gd<Node>) {
        self.poll_animation_updates(emitter);
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\main.rs (121 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/main.rs

// --- MODULES ---
// These files must be created in the ssxl_cli/src directory.
mod actions;	        // CONSOLIDATED: Contains the menu action functions (e.g., run_tests)
mod cli_util_inspect;	// Contains inspection functions (API surface, module tree)
mod cli_util_menu;		// Contains MenuItem struct, build_menu, and print_menu
mod cli_util_bench;		// Contains benchmark/conversion functions
mod scan;	            // RENAMED: Recursive LOC scanning utility (was cli_util_loc_scan)

// --- EXTERNAL IMPORTS ---
use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};
//use std::fs; // Now commented, as it was in the original

// Tracing imports are correct.
use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

// --- INTERNAL IMPORTS ---
use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // To be called once on startup
use crate::scan::execute_loc_scan; // UPDATED: Import the LOC function from the new `scan` module
// ðŸ†• Import the public copy function from the new `actions::godot_harness` module
use crate::actions::copy_dll_to_tester_project_at_boot; 


/// ðŸ–ï¸ Optional pause after action
fn wait_for_enter() {
	println!("\nPress Enter to return to menu...");
	let _ = io::stdin().read_line(&mut String::new());
}

fn init_logging_and_engine() {
	// This sets up a simple console logger for the CLI environment.
	tracing_subscriber::registry()
		.with(
			tracing_subscriber::fmt::layer()
				.with_writer(io::stdout) // Direct output to stdout
				.with_filter(LevelFilter::INFO),
		)
		.init();

	info!("SSXLBinary: Interactive CLI initializing.");

	// Call the FFI initialization (placeholder for engine boot)
	if ssxl_initialize_engine() {
		info!("Engine FFI core initialized.");
	} else {
		error!("Failed to initialize Engine FFI core.");
	}
    
    // ðŸ†• AUTOMATIC DLL COPY on boot
	if let Err(e) = copy_dll_to_tester_project_at_boot() {
		error!("{}", e);
	}
}

fn main() {
	// ðŸ§  Startup
	init_logging_and_engine();
	
	// Execute LOC scan on startup and generate file
	execute_loc_scan(); // UPDATED: Run the LOC scan at bootup

	println!(
        r#"
            (__)
            (oo)
     /-------\/
    / |     ||
   * ||-----||
      ~~     ~~
SSXL-ext Engine Console Initialized
"#
);

	// ðŸ§­ Menu setup
	let menu = build_menu();
	let mut last_keys = HashSet::new();

	// ðŸ” Main loop
	loop {
		print_menu(&menu);
		info!("Console: Awaiting menu selection...");
		print!("> ");
		io::stdout().flush().unwrap();

		// Wait for keypress
		loop {
			if event::poll(Duration::from_millis(500)).unwrap() {
				if let Event::Key(key_event) = event::read().unwrap() {
					if let KeyCode::Char(c) = key_event.code {
						if last_keys.insert(c) {
							if let Some(item) = menu.iter().find(|m| m.key == c) {
								info!("Menu: Selected: {}", item.label);
								println!("\n[{}] {}\n", c, item.label);
								(item.action)();

								if c == '9' {
									info!("Exit: Engine shutdown complete.");
									return;
								}

								wait_for_enter();
								break;	
							}
						}
					}
				}
			} else {
				last_keys.clear();
			}

			thread::sleep(Duration::from_millis(10));
		}
	}
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\api_initializers.rs (119 LOC)
//////////////////////////////////////////////////////

use std::sync::{Arc, Mutex};
use tracing::{info, error};

// Internal Crate Dependencies
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    ConductorRequestSender,
};
use ssxl_generate::conductor_state::ConductorState; // Corrected import path

use ssxl_sync::{
    AnimationConductor,
    AnimationConductorHandle,
    AnimationReceiver,
    AnimationCommand,
};
use ssxl_sync::primitives::AnimationState; // Corrected import path (assuming primitives)


/// Responsible for initializing and managing the lifetime of the core Rust
/// worker threads (`Conductor` and `AnimationConductor`).
#[derive(Debug, Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    pub fn new() -> Self {
        EngineInitializer {}
    }

    /// Ensures the Conductor runtime is initialized and returns the thread-safe
    /// handle, the generation channel receiver, and the **ConductorState**.
    ///
    /// Returns: (Arc<Mutex<Conductor>>, ConductorProgressReceiver, ConductorState)
    pub fn ensure_conductor(
        &self
    ) -> (
        Option<Arc<Mutex<Conductor>>>,
        Option<ConductorProgressReceiver>,
        Option<ConductorState>
    ) {
        info!("EngineInitializer: Attempting to initialize Conductor...");
        
        // Conductor::new returns: (Conductor, ConductorState, ProgressReceiver, RequestSender).
        match Conductor::new(None) {
            Ok((conductor, state, gen_rx, _request_tx)) => {
                info!("Conductor initialized and background thread started successfully.");
                (Some(Arc::new(Mutex::new(conductor))), Some(gen_rx), Some(state)) 
            }
            Err(e) => {
                error!("Failed to initialize Conductor: {}", e);
                (None, None, None)
            }
        }
    }

    /// Ensures the AnimationConductor runtime is initialized and returns the
    /// thread-safe handle, the animation channel receiver, and the **AnimationState**.
    ///
    /// Returns: (AnimationConductorHandle, AnimationReceiver, AnimationState)
    pub fn ensure_animation_conductor(
        &self
    ) -> (
        Option<AnimationConductorHandle>,
        Option<AnimationReceiver>,
        Option<AnimationState>
    ) {
        info!("EngineInitializer: Attempting to initialize AnimationConductor...");
        
        // AnimationConductor::new() returns: (ConductorStruct, AnimationReceiver, AnimationState).
        let Ok((conductor_struct, anim_rx_found, anim_state_found)) = AnimationConductor::new() else {
            error!("Failed to initialize AnimationConductor.");
            return (None, None, None);
        };
        
        info!("AnimationConductor initialized and thread started successfully.");
        
        (
            Some(conductor_struct.get_command_sender()),
            Some(anim_rx_found),
            Some(anim_state_found)
        )
    }

    /// Gracefully shuts down both conductors and ensures worker threads join.
    pub fn shutdown(
        &self,
        mut anim_handle: Option<AnimationConductorHandle>,
        mut conductor_arc: Option<Arc<Mutex<Conductor>>>,
    ) {
        info!("EngineInitializer: Starting graceful shutdown process...");
        
        // 1. Shutdown the Generation Conductor
        if let Some(arc) = conductor_arc.take() {
            match Arc::try_unwrap(arc) {
                Ok(mutex) => {
                    info!("Shutting down Conductor...");
                    mutex.into_inner().unwrap().graceful_teardown();
                    info!("Conductor shutdown complete.");
                }
                Err(_) => {
                    error!("Could not unwrap Conductor Arc; other references may exist.");
                }
            }
        }

        // 2. Shutdown the Animation Conductor
        if let Some(handle) = anim_handle.take() {
            // âœ… FIX: Using AnimationCommand::Stop for clearer graceful shutdown.
            match handle.send(AnimationCommand::Stop) { 
                Ok(_) => info!("AnimationConductor shutdown command sent successfully."),
                Err(e) => error!("Failed to send shutdown command to AnimationConductor: {}", e),
            }
            info!("AnimationConductor shutdown complete.");
        }
        
        info!("EngineInitializer: All background runtimes terminated.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\actions\godot_harness.rs (118 LOC)
//////////////////////////////////////////////////////

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Import constants and core pathing utility from the parent module (actions/mod.rs).
// CORRECTED PATH: Changed 'super::super' to 'super'.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


// -----------------------------------------------------------------------------
// DLL COPY FUNCTION
// -----------------------------------------------------------------------------

/// Copies the latest compiled DLL from the Rust target directory to the Godot tester project.
/// Designed to be run automatically during CLI boot.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // 1. Construct Source Path
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source: {}", e))?;
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // 2. Construct Destination Path
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination: {}", e))?;
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // 3. Check if Source DLL exists (implies a successful cargo build run)
    if !source_path.exists() {
        // If the DLL is missing, it's not a fatal error for the CLI, just a warning
        warn!("Source DLL not found at: {}. Have you run `cargo build` recently?", source_path.display());
        return Ok(());
    }

    // 4. Perform Copy
    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!("âœ… DLL Copied: {} -> {}", source_path.file_name().unwrap_or_default().to_string_lossy(), destination_path.display());
            Ok(())
        }
        Err(e) => {
            // Note: If Godot is running and locked the file, this will fail.
            Err(format!("âŒ FAILED to copy DLL. Check permissions/if Godot is running. Error: {}", e))
        }
    }
}


// -----------------------------------------------------------------------------
// GODOT CLIENT LAUNCH
// -----------------------------------------------------------------------------

/// ðŸš€ Launches the full **Godot Editor** (non-headless) with the project loaded.
pub fn launch_godot_client() {
    info!("ðŸš€ LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("âŒ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs);

    match Command::new(GODOT_EXE_PATH)
        .arg("--editor") 
        .arg("--path")
        .arg(&project_path_abs)
        .spawn()
    {
        Ok(_) => {
            info!("âœ… Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("âŒ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is in the correct path relative to your CLI: {}", GODOT_EXE_PATH);
        }
    }
}


/// ðŸŽ® Placeholder to launch headless Godot
pub fn launch_headless_godot() {
	warn!("ðŸŽ® Placeholder: Attempting to launch headless Godot (simple path check)...");
	
	match Command::new(GODOT_EXE_PATH).arg("--version").status() {
		Ok(status) if status.success() => info!("ðŸš€ Headless Godot launch command ready (path check OK)."),
		_ => error!("âŒ Godot executable not found or command failed. Check path: {}", GODOT_EXE_PATH),
	}
}

// -----------------------------------------------------------------------------
// HARNESS EXECUTION (ADDED)
// -----------------------------------------------------------------------------

/// âš™ï¸ Executes the Godot test harness, typically running a specific scene 
/// or script in headless mode to validate FFI communication.
/// This function is added to resolve the E0432 unresolved import error in 
/// ssxl_cli/src/actions/mod.rs.
pub fn run_godot_harness() {
    warn!("âš™ï¸ Godot Test Harness execution not yet fully implemented. Placeholder called.");
    // Implementation will go here later: call headless Godot to run a test scene.
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\generation_api.rs (117 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/generation_api.rs

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Gd;
use godot::builtin::GString;

use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

// Internal Crate Dependencies
use ssxl_generate::Conductor;
// FIX: Replace the unresolved ssxl_shared import with the correctly exposed GeneratorConfig.
use ssxl_generate::GeneratorConfig; 


/// Delegate struct responsible for handling all calls from Godot related to 
/// map generation and sending commands to the background Conductor thread.
// âœ… FIX 1: Removed `Debug` because `Conductor` doesn't implement it, which prevents the derive macro from working.
#[derive(Default)] 
pub struct GenerationAPI<'a> {
    conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

impl<'a> GenerationAPI<'a> {
    pub fn new(conductor: Option<&'a Arc<Mutex<Conductor>>>) -> Self {
        GenerationAPI { conductor }
    }

    // --------------------------------------------------------------------------
    // API IMPLEMENTATION
    // --------------------------------------------------------------------------

    /// Sends a request to the Conductor to start building a map.
    pub fn build_map(
        &self, 
        width: i32, 
        height: i32, 
        seed: GString, 
        generator_name: GString,
        _signals_node: Option<&Gd<Node>>,
    ) {
        if let Some(arc) = self.conductor {
            let result = arc.lock().map(|mut conductor| {
                info!("GenerationAPI: Attempting to build map with width={} height={}...", width, height);

                // FIX: Construct GeneratorConfig directly, aligning with Conductor's API.
                let config = GeneratorConfig {
                    width: width as usize,
                    height: height as usize,
                    seed: seed.to_string(),
                    generator_name: generator_name.to_string(),
                };
                
                // Call the Conductor's core method, which now takes a single config struct.
                conductor.start_generation(config)
            });

            match result {
                Ok(Ok(())) => info!("Generation command successfully dispatched to Conductor."),
                Ok(Err(e)) => error!("Failed to start map generation: {}", e),
                Err(e) => error!("Failed to lock Conductor mutex: {}", e),
            }

        } else {
            warn!("GenerationAPI: Conductor is not initialized. Cannot build map.");
        }
    }

    /// Attempts to change the active generator used by the Conductor.
    pub fn set_generator(&self, id: GString) -> bool {
        let generator_id: String = id.to_string(); // FIX: Use String instead of the undefined GeneratorId
        
        if let Some(arc) = self.conductor {
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for set_generator: {}", e);
                    false
                },
                |mut conductor| {
                    // FIX: Pass a String slice (&str) to set_active_generator
                    match conductor.set_active_generator(&generator_id) { 
                        Ok(()) => {
                            info!("GenerationAPI: Active generator set to '{}'.", generator_id);
                            true
                        }
                        Err(e) => {
                            error!("GenerationAPI: Failed to set generator '{}': {}", generator_id, e);
                            false
                        }
                    }
                },
            );
        }
        warn!("GenerationAPI: Conductor is not initialized. Cannot set generator.");
        false
    }
    
    /// Gets the ID of the currently active generator.
    pub fn get_active_generator_id(&self) -> GString {
        if let Some(arc) = self.conductor {
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for get_active_generator_id: {}", e);
                    GString::from("Error: Mutex Lock Failed")
                },
                |conductor| {
                    let id_string = conductor.get_active_generator_id();
                    // âœ… FIX 2: Convert the returned String to &String (reference) 
                    // which satisfies the GString::from trait bound.
                    GString::from(&id_string) 
                },
            );
        }
        GString::from("Error: Conductor Not Initialized")
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\tile_type.rs (117 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/tile_type.rs

//! Defines the canonical set of fundamental types that a Tile can represent.
//!
//! This enum is used by the generation modules to assign meaning to raw noise values,
//! and by the rendering engine (Godot) to select the correct visual asset.

use serde::{Serialize, Deserialize};

/// The fundamental, physical classification of a tile, aligned with the MVG schema.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] // Ensures compact storage for cache serialization
pub enum TileType {
    /// 0: The default, empty, or uninitialized state (Void/Air).
    Void = 0,
    /// 1: Represents a water body (V < 0.3).
    Water = 1,
    /// 2: Represents standard ground/plains (0.3 <= V < 0.6).
    Grass = 2,
    /// 3: Represents high-elevation terrain (V >= 0.6).
    Mountain = 3,
    /// 4: Represents a boundary or special-condition tile that cannot be traversed or modified easily.
    Boundary = 4,
    /// 5: Reserved for future structured objects/built environment (Structure/Roads).
    Structure = 5,
    /// 6: **(CA GENERATOR)** Represents solid ground or a wall, used as the 'live' cell by the Cellular Automata Generator.
    Rock = 6,
    /// 7: Reserved for future expansion or custom user types.
    Custom1 = 7,
    /// 8: Reserved for future expansion or custom user types.
    Custom2 = 8,
}

// ---------------------------
// IMPL: Default and Conversion
// ---------------------------

impl Default for TileType {
    /// The default state of a tile is non-solid and empty.
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Helper function to convert the enum variant into its underlying u8 representation.
    #[inline] // Hint to the compiler for potential inlining for performance
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a u8 into a TileType. Returns None if the value is outside the defined range.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TileType::Void),
            1 => Some(TileType::Water),
            2 => Some(TileType::Grass),
            3 => Some(TileType::Mountain),
            4 => Some(TileType::Boundary),
            5 => Some(TileType::Structure),
            6 => Some(TileType::Rock),
            7 => Some(TileType::Custom1),
            8 => Some(TileType::Custom2),
            _ => None,
        }
    }
    
    // --- RENDERING HELPER METHODS (NEW) ---

    /// Returns the default Godot Tile ID (source layer/index) associated with this type.
    /// This is a fallback used by the ChunkPresenter.
    pub const fn get_default_tile_id(self) -> u16 {
        // Since TileType itself is the key data, we use its discriminant as a simple ID.
        self.to_u8() as u16
    }

    /// Returns the default Godot Atlas Coordinates (frame x, frame y) for this tile type.
    /// This provides the ChunkPresenter the necessary visual data for a static representation.
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // Mapping from TileType to a position in the tileset atlas (x, y).
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            _ => (0, 0), // Default to (0, 0) for Void, Custom, etc.
        }
    }
}

// ---------------------------
// IMPL: Gameplay Logic Helpers
// ---------------------------

impl TileType {
    /// Checks if the tile type indicates a ground-based, traversable surface.
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type indicates a liquid that typically requires fluid dynamics simulation.
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is a placeholder state that hasn't been generated yet.
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_sync\src\animation_conductor.rs (112 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/api_initializers.rs

use std::sync::{Arc, Mutex};
use tracing::{info, error};

// Internal Crate Dependencies
use ssxl_generate::{
    Conductor, 
    ConductorProgressReceiver, 
    ConductorRequestSender
};
use ssxl_sync::{
    AnimationConductor, 
    AnimationConductorHandle, 
    AnimationReceiver,
    // We import AnimationCommand to use it in the shutdown logic
    AnimationCommand 
};


/// Responsible for initializing and managing the lifetime of the core Rust
/// worker threads (`Conductor` and `AnimationConductor`).
#[derive(Debug, Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    pub fn new() -> Self {
        EngineInitializer {}
    }

    /// Ensures the Conductor runtime is initialized and returns the thread-safe
    /// handle and the generation channel receiver.
    /// 
    /// Returns: (Arc<Mutex<Conductor>>, ConductorProgressReceiver)
    pub fn ensure_conductor(
        &self
    ) -> (Option<Arc<Mutex<Conductor>>>, Option<ConductorProgressReceiver>) {
        info!("EngineInitializer: Attempting to initialize Conductor...");
        
        // Conductor::new returns an Ok((Conductor, ConductorState, ProgressReceiver, RequestSender)) tuple.
        match Conductor::new(None) {
            // âœ… FIX 1: The ProgressReceiver (gen_rx) is the third element.
            // The argument order here matches the Conductor::new return order.
            Ok((conductor, _state, gen_rx, _gen_tx)) => {
                info!("Conductor initialized and background thread started successfully.");
                (Some(Arc::new(Mutex::new(conductor))), Some(gen_rx))
            }
            Err(e) => {
                error!("Failed to initialize Conductor: {}", e);
                (None, None)
            }
        }
    }

    /// Ensures the AnimationConductor runtime is initialized and returns the 
    /// thread-safe handle and the animation channel receiver.
    /// 
    /// Returns: (AnimationConductorHandle, AnimationReceiver)
    pub fn ensure_animation_conductor(
        &self
    ) -> (Option<AnimationConductorHandle>, Option<AnimationReceiver>) {
        info!("EngineInitializer: Attempting to initialize AnimationConductor...");
        
        // AnimationConductor::new() returns: Result<(AnimationConductor (Handle), AnimationReceiver), String>
        // The destructuring must match the return order.
        let Ok((handle_found, anim_rx_found)) = AnimationConductor::new() else {
            error!("Failed to initialize AnimationConductor.");
            return (None, None);
        };
        
        info!("AnimationConductor initialized and thread started successfully.");
        
        // âœ… FIX 2 & 3: Return the values in the order of the function signature: (Handle, Receiver).
        (Some(handle_found), Some(anim_rx_found))
    }

    /// Gracefully shuts down both conductors and ensures worker threads join.
    pub fn shutdown(
        &self, 
        mut anim_handle: Option<AnimationConductorHandle>,
        mut conductor_arc: Option<Arc<Mutex<Conductor>>>, 
    ) {
        info!("EngineInitializer: Starting graceful shutdown process...");

        // 1. Shutdown the Generation Conductor
        if let Some(arc) = conductor_arc.take() {
            match Arc::try_unwrap(arc) {
                Ok(mutex) => {
                    info!("Shutting down Conductor...");
                    // This method name is confirmed by conductor.rs
                    mutex.into_inner().unwrap().graceful_teardown(); 
                    info!("Conductor shutdown complete.");
                }
                Err(_) => {
                    error!("Could not unwrap Conductor Arc; other references may exist.");
                }
            }
        }

        // 2. Shutdown the Animation Conductor
        if let Some(handle) = anim_handle.take() {
            // âœ… FIX 4: Send the shutdown command using the correct method.
            match handle.send_command(AnimationCommand::Complete) {
                Ok(_) => info!("AnimationConductor shutdown command sent successfully."),
                Err(e) => error!("Failed to send shutdown command to AnimationConductor: {}", e),
            }
            info!("AnimationConductor shutdown complete.");
        }
        
        info!("EngineInitializer: All background runtimes terminated.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\perlin_generator.rs (109 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/perlin_generator.rs

use crate::Generator;
// FIX 1: Import ChunkData and CHUNK_SIZE directly from chunk_data.
use ssxl_shared::chunk_data::{ChunkData, CHUNK_SIZE};
// FIX 2: Import GridBounds directly from its sub-module (aetherion_shared/src/grid_bounds.rs).
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_math::Vec2i;
use ssxl_shared::tile_data::TileData;
use ssxl_shared::tile_type::TileType;

// --- External Dependency ---
// FIX 3 (Warning): Removed unused 'Seedable' import.
use noise::{NoiseFn, Perlin};
use tracing::info;

/// Implements the Minimal Viable Generator (MVG) using Perlin Noise.
pub struct PerlinGenerator {
    /// Noise function instance for generation.
    perlin: Perlin,
    /// The scale factor to control the 'zoom' of the noise.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator with a fixed seed and configurable scale.
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42; // A simple, fixed seed for consistency
        PerlinGenerator {
            // FIX: Supply the required u32 seed argument to Perlin::new()
            perlin: Perlin::new(DEFAULT_SEED), // <--- CHANGE THIS LINE
            scale,
        }
    }
}

impl Generator for PerlinGenerator {
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates the content for a single chunk using 2D Perlin noise.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        // FIX: Cast CHUNK_SIZE to i64 to match chunk_coords.x/y type
        let chunk_tile_size = CHUNK_SIZE as i64;

        // 1. Calculate the World-Space Start Position of the chunk
        // These are now i64 * i64 = i64. No error.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // ChunkData::new arguments: id, bounds, dimension_name
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // FIX: GridBounds::new uses i64. Calculations are now i64 + i64 = i64.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // 2. Loop through every tile in the chunk
        // FIX: Iterate from 0..chunk_tile_size (i64) to make x and y i64, fixing inner loop errors.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                // FIX: world_start_x/y (i64) + x/y (i64) is valid, then cast to f64.
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // 3. Use the noise function to get a height value
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Map the noise range [-1.0, 1.0] to a positive range [0.0, 1.0]
                let normalized_value = (noise_value + 1.0) / 2.0;

                // 4. Map the height value to a TileType and populate the ChunkData
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // TileData::new requires 2 arguments: tile_type, noise_value: f32
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }

        // set_tiles renamed to insert_tiles
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data // Return the generated and populated chunk data
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\actions\benchmarking.rs (107 LOC)
//////////////////////////////////////////////////////

use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}};
use std::thread;
use std::time::Duration;
use ctrlc;

// Import Conductor types and ConductorStatus from the parent module (actions/mod.rs).
// The parent module (super) imports and re-exports these from ssxl_generate.
use super::{Conductor, ConductorStatus}; // CORRECTED PATH: Removed one 'super::'


// -----------------------------------------------------------------------------
// PHASE 4: SIGNAL INSPECTOR / LIVE FEED
// -----------------------------------------------------------------------------

/// ðŸ”® Starts the live **Signal Inspector** utility (CLI Menu [B]).
/// It monitors the Conductor's state and prints it to the console in real-time.
pub fn start_signal_inspector() {
    warn!("ðŸ”® Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // 1. Initialize Conductor and retrieve the thread-safe state
    // FIX E0308: Updated destructuring to match the new 4-element tuple (Conductor, ConductorState, Receiver, Sender).
    let (conductor, state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("âŒ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    // Wrap Conductor in Arc<Mutex<Option<>>> for safe, single consumption by the ctrlc handler.
    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    // 2. Setup atomic flag for graceful exit via Ctrl-C
    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    // Set a Ctrl-C handler to stop the loop and shut down the Conductor
    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    // 3. Main Live Feed Loop
    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        // --- REAL-TIME DATA POLLING ---
        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        // Use carriage return (`\r`) to overwrite the current line.
        print!("\r");
        print!("ðŸ”® LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        // Check for internal shutdown signals (e.g., error in Conductor)
        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        // Wait 50ms (20 FPS refresh)
        thread::sleep(Duration::from_millis(50));
    }

    // 4. Cleanup: Clear the line after exiting the loop
    let _ = writeln!(io::stdout(), "\r{: <200}", " "); // Overwrite and clear the line
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

// -----------------------------------------------------------------------------
// PHASE 5: BENCHMARK EXECUTION
// -----------------------------------------------------------------------------

/// â±ï¸ Executes a full set of engine benchmarks (CLI Menu [B] or [1]).
/// This placeholder function is added to resolve the E0432 unresolved import error
/// in ssxl_cli/src/actions/mod.rs.
pub fn run_benchmark() {
    warn!("â±ï¸ Benchmark execution not yet implemented. Placeholder called.");
    // Implementation will go here later: setup benchmarks, run, and report results.
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_menu.rs (107 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/cli_util_menu.rs

use crate::actions::{
    run_cargo_tests,
    launch_godot_client,
    launch_headless_godot,
    run_priority_1_tests,
    start_signal_inspector,
    run_ffi_bridge_validation,
};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use tracing::warn;

/// ðŸ§© Menu item definition (Kept for completeness, not edited)
pub struct MenuItem {
    pub key: char,
    pub label: &'static str,
    pub action: Box<dyn Fn()>,
}

/// ðŸ§­ Builds the interactive dev console menu, prioritized for completion.
pub fn build_menu() -> Vec<MenuItem> {
    vec![
        // --- 0. CORE VALIDATION (The Essential Checklist) ---
        MenuItem { key: '0', label: "âœ… Run: Full Cargo Test Suite", action: Box::new(run_cargo_tests) },
        MenuItem { 
            key: '1', 
            label: "âœ… Validate: FFI Bridge Data Transfer (E2E Final)", 
            action: Box::new(run_ffi_bridge_validation) // Formerly key '9'
        },
        MenuItem { 
            key: '2', 
            label: "âœ… Validate: Phase 1 Final Integration Check", 
            action: Box::new(run_priority_1_tests) // Formerly key 'C'
        },
        MenuItem { 
            key: '3', 
            label: "âœ… Inspect: Godot-Callable API Surface", 
            action: Box::new(print_godot_api_surface) 
        },

        // --- 1. RUNTIME & INTEGRATION (The Bulldozer Launch) ---
        MenuItem { 
            key: '4', 
            label: "ðŸš€ Launch: Godot Client (Non-Headless)", 
            action: Box::new(launch_godot_client) 
        },
        MenuItem { 
            key: '5', 
            label: "ðŸŽ® Launch: Headless Godot (External)", 
            action: Box::new(launch_headless_godot) 
        },

        // --- 2. GENERATION & PERFORMANCE (The Tempo Checks) ---
        MenuItem { 
            key: '6', 
            label: "ðŸ§ª Test: Generation & Placement CLI", 
            action: Box::new(test_generation_and_placement_cli) 
        },
        MenuItem { 
            key: '7', 
            label: "ðŸ§ª Benchmark: Max Grid Placement", 
            action: Box::new(run_max_grid_benchmark) 
        },

        // --- 3. UTILITIES & INSPECTION (The Maintenance Layer) ---
        MenuItem { 
            key: '8', 
            label: "âœ… Perform: Bitmask PNG Conversion", 
            action: Box::new(run_bitmask_conversion) 
        },
        MenuItem { 
            key: '9', 
            label: "âœ… Inspect: Rust Module Tree", 
            action: Box::new(print_module_tree) 
        },

        // --- 4. FUTURE EXPANSION / TODOS ---
        MenuItem { 
            key: 'A', 
            label: "ðŸ”® Start: Signal Inspector / Live Feed (TODO)", 
            action: Box::new(start_signal_inspector) 
        },
        MenuItem { 
            key: 'B', 
            label: "âš ï¸ Run: Trailkeeper Scan (TODO)", 
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented.")) 
        },
        
        // --- 5. EXIT ---
        MenuItem { key: 'E', label: "âœ… Exit Console", action: Box::new(|| {}) },
        // Item 'F' could be used for 'Export Chunk Hashes for Streaming' if that becomes a priority.
    ]
}

// ... print_menu function remains the same ...

/// ðŸ–¥ Prints the menu to the console
pub fn print_menu(menu: &[MenuItem]) {
	
	println!("\nðŸ§­ SSXL-ext Engine Dev Console\n");
	for item in menu {
		println!("[{}] {}", item.key, item.label);
	}
	println!("\nSelect an option by pressing its number key or letter key...\n");
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\hashing.rs (103 LOC)
//////////////////////////////////////////////////////

//! Core hashing utilities for converting coordinate data into unique identifiers (hashes).
//! These hashes are primarily used as stable keys for the cache and storage layers.

use crate::primitives::SSXLResult;
// ðŸ“ BULLDOZER FIX: Changed IVec3 (i32) to I64Vec3 (i64) to support coordinates beyond 2.1 billion chunks.
use glam::I64Vec3; 
use sha2::{Digest, Sha256};

/// Generates a unique SHA-256 hash string for a given 3D integer coordinate (chunk position).
///
/// This hash is deterministic and collision-resistant, making it ideal for use as a
/// primary key in the cache or database for persistent data lookup.
///
/// # Arguments
///
/// * `coords` - The 3D integer coordinates (e.g., chunk index).
///
/// # Returns
///
/// A `String` containing the hexadecimal representation of the SHA-256 hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // 1. Format the coordinate string: "x:y:z"
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Hash the string using SHA-256
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash result to a hexadecimal string
    Ok(format!("{:x}", result))
}

/// Generates a unique content hash for a piece of data (e.g., a ChunkData struct).
///
/// This is a placeholder function that will be fully implemented later once we have the
/// full `ChunkData` structure. For now, it returns a simple hash based on a u64 key.
///
/// # Arguments
///
/// * `data_key` - A unique identifier or version number for the data.
///
/// # Returns
///
/// A `String` containing a placeholder hash.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    let key_string = data_key.to_string();
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    Ok(format!("content_{:x}", result))
}

// ---------------------------
// IMPL: Unit Tests
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;

    /// Tests that the SHA-256 hashing of coordinates is strictly deterministic.
    #[test]
    fn test_chunk_coords_determinism() {
        // Test with a coordinate that exceeds i32 limits to prove i64 is active.
        let coords = I64Vec3::new(3_000_000_000, -5, 100); 
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();
        
        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    /// Tests that adjacent coordinates produce different hashes and verifies the format.
    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        // SHA-256 produces 64 characters in hex format
        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    /// Tests that the content hash is deterministic and prepends the 'content_' prefix.
    #[test]
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;
        
        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        // Determinism check
        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        // Format check
        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // The SHA-256 hex part is 64 chars long. "content_" is 8 chars. Total: 72 chars.
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cache\src\lib.rs (102 LOC)
//////////////////////////////////////////////////////

// In-memory caching layer for storing and retrieving procedural generation data (Chunks).
//
// This module defines the core thread-safe cache (`ChunkCache`) responsible for holding
// `ChunkData` generated by the SSXL engine. It is optimized for high-speed concurrent
// access across multiple worker threads using `ssxl_sync::AtomicResource`.

use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
use ssxl_shared::chunk_data::ChunkData;
use std::collections::HashMap;
use std::io; // Required for the Result type, ensuring robust initialization and I/O interface.
use tracing::{info, warn};

// --- 1. Type Definitions ---

// Type alias for the thread-safe core map.
// Maps a unique spatial identifier (`ChunkKey`) to the chunk's content (`ChunkData`).
type CacheMap = HashMap<ChunkKey, ChunkData>;

// --- 2. Cache Structure ---

// The thread-safe, in-memory cache for generated Chunk data.
//
// Wraps a standard HashMap in an **AtomicResource** to allow safe, concurrent
// read/write access across game engine worker threads. This is the **tempo** optimization.
#[derive(Debug, Clone)]
pub struct ChunkCache {
    // The underlying storage map protected by an `AtomicResource`.
    storage: AtomicResource<CacheMap>,
}

impl ChunkCache {
    // Creates a new, empty, thread-safe cache instance.
    //
    // The return type is wrapped in `Result<Self, io::Error>` to align with the
    // Conductor's initialization interface, promoting robust project **completion**.
    pub fn new() -> Result<Self, io::Error> {
        info!("SSXL ChunkCache initialized: Ready for thread-safe storage.");
        Ok(ChunkCache {
            // Initialize the AtomicResource with an empty HashMap.
            storage: AtomicResource::new(HashMap::new()),
        })
    }

    // Attempts to retrieve a ChunkData by its ChunkKey (Cache Load implementation).
    //
    // # Arguments
    // * `key`: The unique spatial key identifying the desired chunk.
    //
    // # Returns
    // `Ok(Some(ChunkData))` if found, or `Ok(None)` if a cache miss occurs.
    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<ChunkData>, io::Error> {
        // Acquire a read lock on the internal map.
        let map = self.storage.read();

        // Retrieve the data, clone it (to give the caller ownership), and wrap in Ok.
        Ok(map.get(key).cloned())
    }

    // Inserts a ChunkData into the cache (Cache Save implementation).
    //
    // # Arguments
    // * `key`: The unique spatial key to store the chunk under.
    // * `data`: A reference to the chunk data to be cloned and stored.
    //
    // # Returns
    // `Ok(())` on successful insertion or update.
    pub fn save_chunk(&self, key: &ChunkKey, data: &ChunkData) -> Result<(), io::Error> {
        // Acquire a write lock on the internal map.
        let mut map = self.storage.write();

        // Insert the cloned data. If `insert` returns `None`, it was a new key.
        // We use `info` for new data and `warn` for overwrites for easy debug monitoring.
        if map.insert(*key, data.clone()).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
        } else {
            // Otherwise, an existing chunk was overwritten (this shouldn't happen often).
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }

    // Reports the current number of chunks stored in the cache.
    //
    // This requires briefly acquiring a read lock to access the underlying map.
    pub fn len(&self) -> usize {
        self.storage.read().len()
    }

    // Clears all entries from the cache.
    //
    // Acquires a write lock to empty the underlying HashMap (a **bulldozer** operation).
    pub fn clear(&self) {
        self.storage.write().clear();
        info!("SSXL ChunkCache cleared.");
    }

    // Checks if the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_engine_ffi\src\lib.rs (101 LOC)
//////////////////////////////////////////////////////

// ssxl_engine_ffi/src/lib.rs (Functional Fix)

//! Low-level C FFI Bridge for Godot Communication.
//!
//! This module exposes functions to C/Godot that manage the SSXL runtime lifecycle
//! and facilitate the transfer of generated chunk data.

use std::ffi::CString;
use std::sync::OnceLock;

// --- EXTERNAL CRATE DEPENDENCIES ---
use ssxl_generate::{Conductor, start_runtime_placeholder};
use ssxl_shared::initialize_shared_data;
use tracing::{info, error};

// --- 1. Conductor Management (Singleton State) ---

/// A thread-safe, lazily initialized global instance of the Conductor.
static CONDUCTOR: OnceLock<Conductor> = OnceLock::new();

/// Initializes the Aetherion Runtime (Conductor) and stores it globally.
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    initialize_shared_data(); 

    if CONDUCTOR.get().is_some() {
        info!("FFI Bridge: Runtime already running.");
        return true;
    }

    match Conductor::new(None) {
        // FIX E0308: Correctly destructure the 4-element tuple:
        // (Conductor, ConductorState, Progress Receiver, Request Sender)
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            if CONDUCTOR.set(conductor).is_err() {
                error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                return false;
            }
            info!("FFI Bridge: Conductor Runtime started successfully.");
            true
        }
        Err(e) => {
            tracing::error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
            false
        }
    }
}

/// Gracefully shuts down the Conductor by signaling its internal state.
#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    if let Some(conductor) = CONDUCTOR.get() {
        conductor.signal_shutdown_graceful();
        info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
    }
}

/// Checks if the engine's asynchronous core has been successfully initialized.
#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    CONDUCTOR.get().is_some()
}

// --- 2. Generation Bridge (If applicable, call internal logic here) ---

// --- 3. Compatibility and Utility Functions (Kept for CLI) ---

/// Triggers the structural test of the Conductor (used by CLI menu).
#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    info!("FFI Bridge: Received command to trigger Conductor structural test.");
    start_runtime_placeholder();
    info!("FFI Bridge: Conductor test sequence complete.");
}

#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

#[no_mangle]
pub extern "C" fn ssxl_get_status(id: u32) -> *mut std::os::raw::c_char {
    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        CONDUCTOR.get().is_some()
    );
    match CString::new(status) {
        Ok(c_string) => c_string.into_raw(),
        Err(_) => CString::new("Error: Invalid Status String").unwrap().into_raw(),
    }
}

/// FFI function to free strings allocated by Rust.
#[no_mangle]
pub extern "C" fn ssxl_free_string(s: *mut std::os::raw::c_char) {
    unsafe {
        if s.is_null() { return }
        let _ = CString::from_raw(s);
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\channel_handler.rs (98 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/channel_handler.rs (CONFIRMED FIXED)

use godot::prelude::*;
use godot::classes::{Node, TileMap};
// FIX 1: TRef is deprecated and should be removed. Gd handles object references.
use godot::obj::Gd;
use godot::builtin::GString;

// Internal Crate Dependencies
use ssxl_generate::Conductor;
// FIX 2: Correct imports based on where the messages actually live or should live.
use ssxl_shared::tile_data::AnimationUpdate;
// Assuming ChunkMessage is defined in a new shared messages module
use ssxl_shared::messages::ChunkMessage;

// We need the ChunkPresenter type to be accessible
use crate::chunk_presenter::ChunkPresenter;

use std::sync::{Arc, Mutex};

/// Handles incoming messages and data from the background worker threads (Conductor)
/// and applies the changes to the Godot world (TileMap and Signals).
#[derive(Debug, Default, Clone)]
pub struct ChannelHandler {
    // Reference to the presenter delegate
    // âš¡ï¸ E0277 FIXED by adding #[derive(Debug)] to ChunkPresenter
    presenter: Option<ChunkPresenter>,
    
    // Node references are required for emitting signals
    signals_node: Option<Gd<Node>>,
}

impl ChannelHandler {
    pub fn new() -> Self {
        ChannelHandler::default()
    }

    /// Sets the presenter delegate.
    pub fn set_presenter(&mut self, presenter: ChunkPresenter) {
        self.presenter = Some(presenter);
    }

    /// Sets the signals node reference.
    pub fn set_signals_node(&mut self, signals_node: Option<Gd<Node>>) {
        self.signals_node = signals_node;
    }

    /// Processes a batch of ChunkMessages from the generation thread.
    /// Returns a status update message if an important state change occurred.
    pub fn process_generation_messages(
        &mut self,
        messages: Vec<ChunkMessage>,
        _conductor: Option<Arc<Mutex<Conductor>>>,
        tilemap_node: Option<&mut Gd<TileMap>>,
    ) -> Option<GString> {
        if messages.is_empty() {
            return None;
        }

        // Delegate chunk presentation to the ChunkPresenter
        if let Some(ref mut presenter) = self.presenter {
            if let Some(tilemap) = tilemap_node {
                for msg in messages {
                    // âš¡ï¸ E0599 FIXED by implementing present_chunk on ChunkPresenter
                    presenter.present_chunk(tilemap, msg);
                }
            }
        }

        // Placeholder for emitting final status or errors
        None
    }

    /// Processes a batch of AnimationUpdates from the animation thread.
    /// Returns a status update message if an important state change occurred.
    pub fn process_animation_updates(
        &mut self,
        updates: Vec<AnimationUpdate>,
        tilemap_node: Option<&mut Gd<TileMap>>,
    ) -> Option<GString> {
        if updates.is_empty() {
            return None;
        }

        // Delegate animation updates to the ChunkPresenter
        if let Some(ref mut presenter) = self.presenter {
            if let Some(tilemap) = tilemap_node {
                for update in updates {
                    // âš¡ï¸ E0599 FIXED by implementing update_animated_tile on ChunkPresenter
                    presenter.update_animated_tile(tilemap, update);
                }
            }
        }
        
        // Note: Real implementation would emit signals for animation completion
        None
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\conductor_state.rs (93 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/conductor_state.rs

//! Contains the thread-safe, shared state objects used by the Conductor for
//! monitoring and status reporting to external systems (like Godot FFI).

use tracing::error;
use std::sync::{Arc, Mutex, atomic::{AtomicUsize, Ordering}};

// -----------------------------------------------------------------------------
// CONDUCTOR STATUS ENUM
// -----------------------------------------------------------------------------

/// Represents the operational state of the Conductor.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,
    Running,
    Paused,
    // CRITICAL FIX: Add the missing 'Generating' state.
    Generating, 
    ShuttingDown,
    Error,
}

// -----------------------------------------------------------------------------
// CONDUCTOR STATE STRUCT
// -----------------------------------------------------------------------------

/// Shared, thread-safe state exposed to the FFI consumer (Godot) for monitoring.
#[derive(Clone)]
pub struct ConductorState {
    status: Arc<Mutex<ConductorStatus>>,
    queue_depth: Arc<AtomicUsize>,
    active_generator_id: Arc<Mutex<String>>,
}

impl ConductorState {
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: Arc::new(Mutex::new(ConductorStatus::Initializing)),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: Arc::new(Mutex::new(initial_generator_id)),
        }
    }

    // --- Public Getters (Read Access for FFI/CLI) ---

    pub fn get_status(&self) -> ConductorStatus {
        match self.status.lock() {
            Ok(guard) => *guard,
            Err(e) => {
                error!("Mutex poisoned when reading status: {}", e);
                ConductorStatus::Error
            }
        }
    }
    
    // âœ… FIX: Added the missing public method to check for active states.
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    pub fn get_active_generator_id(&self) -> String {
        self.active_generator_id.lock().unwrap().clone()
    }

    // --- Public Mutators (Used by task_queue and batch_processor) ---

    /// Increments the current count of active generation tasks.
    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    /// Decrements the current count of active generation tasks.
    pub fn decrement_queue_depth(&self) {
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }

    // --- Internal Mutators (For Conductor-only state changes) ---

    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.lock().unwrap() = new_status;
    }

    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.lock().unwrap() = id.to_string();
    }
}


//////////////////////////////////////////////////////
// FILE: manifest.rs (92 LOC)
//////////////////////////////////////////////////////

SSXL-ext is a mythic core â€” a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ â†’).

ðŸª¶ Manifest v9.0.seed


#files


C:/ZV9/zv9.SSXL-ext/rust

Crate: ssxl_cache/src
â”œâ”€â”€ [CORE]  lib.rs

ðŸ” Crate: ssxl_engine_ffi/src
â”œâ”€â”€ [CORE]  lib.rs

ðŸ” Crate: ssxl_generate/src
â”‚Â  Â â””â”€â”€  batch_processor.rs
â”‚Â  Â â””â”€â”€  benchmark_logic.rs
â”‚Â  Â â””â”€â”€  ca\mod.rs
â”‚Â  Â â””â”€â”€  ca\neighbor_check.rs
â”‚Â  Â â””â”€â”€  ca\rule_set.rs
â”‚Â  Â â””â”€â”€  cellular_automata_generator.rs
â”‚Â  Â â””â”€â”€  conductor.rs
â”‚Â  Â â””â”€â”€  conductor_state.rs
â”‚Â  Â â””â”€â”€  config_validator.rs
â”‚Â  Â â””â”€â”€  generator.rs
â”‚Â  Â â””â”€â”€  generator_manager.rs
â”œâ”€â”€ [CORE]  lib.rs
â”‚Â  Â â””â”€â”€  perlin_generator.rs
â”‚Â  Â â””â”€â”€  runtime_manager.rs
â”‚Â  Â â””â”€â”€  sync.rs
â”‚Â  Â â””â”€â”€  task_queue.rs

ðŸ” Crate: ssxl_godot/src
â”‚Â  Â â””â”€â”€  animation_api.rs
â”‚Â  Â â””â”€â”€  api_initializers.rs
â”‚Â  Â â””â”€â”€  async_poll.rs
â”‚Â  Â â””â”€â”€  build.rs
â”‚Â  Â â””â”€â”€  channel_handler.rs
â”‚Â  Â â””â”€â”€  chunk_presenter.rs
â”‚Â  Â â””â”€â”€  gde_api_defs.rs
â”‚Â  Â â””â”€â”€  generation_api.rs
â”œâ”€â”€ [CORE]  lib.rs
â”‚Â  Â â””â”€â”€  ssxl_engine.rs
â”‚Â  Â â””â”€â”€  ssxl_oracle.rs
â”‚Â  Â â””â”€â”€  ssxl_signals.rs

ðŸ” Crate: ssxl_math/src
â”‚Â  Â â””â”€â”€  coordinate_system.rs
â”‚Â  Â â””â”€â”€  generation_utils.rs
â”‚Â  Â â””â”€â”€  hashing.rs
â”œâ”€â”€ [CORE]  lib.rs
â”‚Â  Â â””â”€â”€  primitives.rs

ðŸ” Crate: ssxl_shared/src
â”‚Â  Â â””â”€â”€  chunk_data.rs
â”‚Â  Â â””â”€â”€  config.rs
â”‚Â  Â â””â”€â”€  errors.rs
â”‚Â  Â â””â”€â”€  generation_message.rs
â”‚Â  Â â””â”€â”€  grid_bounds.rs
â”œâ”€â”€ [CORE]  lib.rs
â”‚Â  Â â””â”€â”€  math_primitives.rs
â”‚Â  Â â””â”€â”€  messages.rs
â”‚Â  Â â””â”€â”€  tile_data.rs
â”‚Â  Â â””â”€â”€  tile_type.rs

ðŸ” Crate: ssxl_sync/src
â”‚Â  Â â””â”€â”€  animation_conductor.rs
â”œâ”€â”€ [CORE]  lib.rs
â”‚Â  Â â””â”€â”€  pool_manager.rs
â”‚Â  Â â””â”€â”€  primitives.rs

ðŸ” Crate: ssxl_tools/src
â”œâ”€â”€ [CORE]  lib.rs

ðŸ” Crate: ssxl_cli/src
â”‚Â  Â â””â”€â”€  actions\benchmarking.rs
â”‚Â  Â â””â”€â”€  actions\godot_harness.rs
â”‚Â  Â â””â”€â”€  actions\mod.rs
â”‚Â  Â â””â”€â”€  actions\testing.rs
â”‚Â  Â â””â”€â”€  cli_util_bench.rs
â”‚Â  Â â””â”€â”€  cli_util_inspect.rs
â”‚Â  Â â””â”€â”€  cli_util_menu.rs
â”œâ”€â”€ [CORE]  main.rs
â”‚Â  Â â””â”€â”€  scan\file_walker.rs
â”‚Â  Â â””â”€â”€  scan\mod.rs
â”‚Â  Â â””â”€â”€  scan\report_formatter.rs





//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\lib.rs (87 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/lib.rs

//! Core generation algorithms, runtime orchestration, and task management.

// -------------------------------------------------------------------------------------------------
// MODULE EXPOSURE
// -------------------------------------------------------------------------------------------------
// Expose the Conductor (the validated Runtime/Orchestration core).
pub mod conductor;
pub mod benchmark_logic;
pub mod perlin_generator;
pub mod cellular_automata_generator;
pub mod ca; 

// Core orchestration modules required by Conductor.
pub mod runtime_manager; 
pub mod config_validator;
pub mod task_queue;
pub mod conductor_state;
pub mod generator_manager;
pub mod batch_processor;

// FIX: Add the synchronization module required for channel type aliases.
pub mod sync; 


// -------------------------------------------------------------------------------------------------
// CORE TRAIT DEFINITION (Generator Interface)
// -------------------------------------------------------------------------------------------------
use ssxl_shared::chunk_data::ChunkData;
use ssxl_math::Vec2i;

/// Defines the core contract for all procedural generation algorithms.
/// Every generator (Perlin, CA, DiamondSquare, etc.) must implement this trait.
pub trait Generator {
    /// The unique identifier for this specific algorithm (e.g., "perlin_2d_v1").
    fn id(&self) -> &str;

    /// Generates the content for a single Chunk.
    /// It takes a Vec2i which is the world-space coordinate of the chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


// -------------------------------------------------------------------------------------------------
// PUBLIC EXPORTS
// -------------------------------------------------------------------------------------------------

// Direct re-exports of concrete implementations
pub use cellular_automata_generator::CellularAutomataGenerator;
pub use perlin_generator::PerlinGenerator;

// Main components for FFI/Godot use.
pub use conductor::Conductor;
pub use config_validator::GeneratorConfig; 

// FIX: Re-export the channel types and core Task struct from the `sync` and `task_queue` modules.
pub use sync::ConductorProgressReceiver;
pub use sync::ConductorRequestSender;
pub use task_queue::GenerationTask; // Key type sent to the Conductor

// EXPOSED BENCHMARK FUNCTION
pub use benchmark_logic::benchmark_generation_workload;

// -------------------------------------------------------------------------------------------------
// PUBLIC API FOR CLI/FFI (Validation Entry Points)
// -------------------------------------------------------------------------------------------------
use tracing::{info, error};

/// Starts the ssxl Runtime, creating and immediately shutting down the Conductor.
///
/// NOTE: This is the **structural validation test for CLI Menu [4]** (Start Runtime).
pub fn start_runtime_placeholder() {
    // Pass None as the config_path argument to satisfy the updated Conductor::new signature.
    match Conductor::new(None) {
        // Correctly destructure the 4-element tuple
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Call the consuming teardown method.
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\generator_manager.rs (86 LOC)
//////////////////////////////////////////////////////

//! Manages the registration, initialization, and selection of procedural
//! generation algorithms (Generators).

use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::Vec2i;
use ssxl_shared::chunk_data::ChunkData;

// Generator trait and implementations
use crate::Generator;
use crate::perlin_generator::PerlinGenerator;
use crate::cellular_automata_generator::CellularAutomataGenerator;

// CORRECTED: Import rule constants directly from their source module (ca::rule_set).
use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

// Define a type alias for thread-safe dynamic generators
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// -----------------------------------------------------------------------------
// GENERATOR MANAGER
// -----------------------------------------------------------------------------

/// Responsible for initializing and providing access to all registered generator
/// algorithms.
pub struct GeneratorManager {
    generators: HashMap<String, Arc<DynGenerator>>,
    default_perlin_id: String,
}

impl GeneratorManager {
    /// Initializes all generator algorithms and registers them by their unique ID.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // Instantiate and register Perlin
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // Instantiate and register Cellular Automata variants
        // The constants are now correctly in scope.
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    /// Provides a reference to the internal map (for ID validation).
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    /// Provides a cloned map for passing to asynchronous worker loops.
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    /// Finds and runs a generator synchronously for a single chunk.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        generator_arc.generate_chunk(chunk_coords)
    }

    /// Determines the initial generator ID based on configuration, falling back to Perlin.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, self.default_perlin_id);
            self.default_perlin_id.clone()
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_oracle.rs (85 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/SSXL_oracle.rs (Cleaned and updated for v8.2)

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use godot::builtin::Variant;
use crate::ssxl_engine::SSXLEngine; 

/// ðŸ”® SSXLOracle â€” Godot-facing node for manually driving the AetherionEngine 
/// and providing complex query/lookup logic (future state).
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    /// Link to the SSXL instance. Stored as Gd<SSXLEngine> for safety.
    engine: Option<Gd<SSXLEngine>>, 
    tick_count: u64,
}

impl SSXLOracle {
    pub fn init(base: Base<Node>) -> Self { 
        Self { 
            base, 
            engine: None, 
            tick_count: 0 
        } 
    }
}

#[godot_api]
impl SSXLOracle {

    /// Called when the node enters the scene tree.
    #[func]
    fn _ready(&mut self) {
        godot_print!("ðŸ”® SSXLOracle (v8.2) is online. I await the ignition.");
        self.base_mut().set_process(true);
    }

    /// Links the Oracle to a target engine node.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
        godot_print!("ðŸ”— Oracle: Engine link established.");
    }

    /// Sends a tick to the linked engine (via an explicit call to the engine's tick function).
    /// This is the primary driver for processing tasks in the SSXLEngine.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // Assuming SSXLEngine will have a #[func] called 'tick'
                let args = [Variant::from(self.tick_count)];
                engine.call("tick", &args); 
                
                godot_print!("ðŸ”® Oracle: Tick {} â†’ Engine", self.tick_count);
                self.tick_count += 1;
            }
            None => {
                godot_warn!("âš ï¸ Oracle: No engine linked. Tick aborted.");
            }
        }
    }

    /// Responds to a ping from external systems.
    #[func]
    pub fn ping(&self) {
        godot_print!("ðŸ”® Oracle: Ping received. I am awake.");
    }

    /// Resets the internal tick counter.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
        godot_print!("ðŸ”„ Oracle: Tick counter reset.");
    }

    /// Returns the current tick count.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\config_validator.rs (84 LOC)
//////////////////////////////////////////////////////

//! Contains data structures and logic for validating map generation parameters
//! against engine constraints.

use tracing::{error, info};
use std::fmt;

// --- CONSTANTS (Copied from Conductor for self-contained validation logic) ---
/// The size of a chunk in tiles.
const CHUNK_SIZE: i64 = 64;

/// A safety measure to prevent the Conductor from trying to generate or track
/// an excessive number of chunks that could lead to memory exhaustion.
const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

// -----------------------------------------------------------------------------
// GENERATOR CONFIGURATION
// -----------------------------------------------------------------------------

/// Configuration data passed from the Godot API to the Conductor to start a
/// full map generation run. (Moved from conductor.rs)
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
}

impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ Width: {}, Height: {}, Seed: '{}', Generator: '{}' }}",
            self.width, self.height, self.seed, self.generator_name
        )
    }
}

// -----------------------------------------------------------------------------
// VALIDATION LOGIC
// -----------------------------------------------------------------------------

/// Responsible for checking configuration limits before starting a batch generation job.
pub struct ConfigValidator;

impl ConfigValidator {
    /// Validates the map dimensions against the maximum allowed chunk count.
    ///
    /// # Returns
    /// A Result indicating success or a detailed error message if validation fails.
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE;
        // Calculate chunks needed (ceiling division for chunk coverage)
        let width_in_chunks = (config.width as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (config.height as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        if total_chunks == 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}. Dimensions are too small.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}. Adjust MAX_ACTIVE_CHUNKS or reduce map size.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\batch_processor.rs (81 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/batch_processor.rs

//! Contains the logic for spawning and managing the CPU-intensive batch
//! generation task, utilizing tokio's blocking thread pool and Rayon.

use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::{info};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// Rayon for CPU parallelization
use rayon::prelude::*;

// Core dependencies
use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;

// Delegate Modules and Types
use crate::config_validator::GeneratorConfig;
use crate::task_queue::{handle_chunk_unit, GenerationMessage, CHUNK_SIZE};
use crate::conductor_state::ConductorState;
use crate::generator_manager::DynGenerator;


/// Spawns an asynchronous, blocking task to handle the generation of an entire map
/// in parallel using Rayon.
///
/// This function moves all necessary clones of the shared state (generators, cache,
/// state tracker, and sender) into the dedicated thread for execution.
pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<Mutex<ChunkCache>>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: ConductorState,
    config_clone: GeneratorConfig,
) {
    info!("Conductor spawning BATCH generation task. Config: {}", config_clone);

    // --- Offload CPU-Intensive Work to Blocking Pool (THE TEMPO BOOST) ---
    runtime_handle.spawn_blocking(move || {
        // Track this generation batch task
        internal_state_clone.increment_queue_depth();
        
        // Calculate grid dimensions
        let chunk_size_i64 = CHUNK_SIZE;
        let width_in_chunks = (config_clone.width as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (config_clone.height as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        
        // 1. Create a flattened collection of all chunk coordinates
        // ðŸ›‘ CRITICAL FIX: Swap ranges to iterate X (width) first, then Y (height), 
        // aligning with the conventional Vec2i::new(x, y) argument order and standard map processing.
        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();

        // 2. Parallelize the entire generation workload using Rayon
        all_chunk_coords
            .par_iter()
            .for_each(|&chunk_coords| {
                // Use the centralized chunk processing unit (Delegated)
                handle_chunk_unit(
                    chunk_coords,
                    &active_generator_id,
                    &generators_clone,
                    &chunk_cache_clone,
                    &progress_sender_clone,
                );
            }); // END of rayon parallel processing

        // Send final completion message
        let _ = progress_sender_clone.blocking_send(GenerationMessage::GenerationComplete);

        // Decrement queue depth on completion
        internal_state_clone.decrement_queue_depth();

        info!("Batch generation task finished processing command: {}", config_clone);
    });
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\lib.rs (74 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/lib.rs

//! The Foundation Layer crate. Defines all core data structures, common utilities,
//! and the canonical error type for the entire Aetherion Engine workspace.

use serde::{Serialize, Deserialize};
use tracing; // Import tracing for logging initialization

// --- MODULE DEFINITIONS ---
// P1 Data Structures
pub mod chunk_data;
pub mod tile_data;
pub mod grid_bounds;
pub mod tile_type;
pub mod errors;
pub mod messages;
pub mod config; // Add this line
pub mod generation_message; // Add this line

// P1 Math/Utility (To be implemented next)
pub mod math_primitives;

// --- CRITICAL TYPE EXPORTS ---
// Export the primary data structures
pub use chunk_data::ChunkData;
pub use chunk_data::CHUNK_SIZE;
pub use tile_data::TileData;
pub use grid_bounds::GridBounds;
pub use tile_type::TileType;

// Export the canonical error type and the engine-wide Result alias
pub use errors::{SSXLError, SSXLResult};

// ------------------------------------------------------------------
// CORE ENGINE FUNCTIONALITY
// ------------------------------------------------------------------

/// Initializes global data primitives and configuration for the engine.
/// This function is typically called once on engine startup by the FFI bridge.
// FIX: Added the missing function (E0425) expected by aetherion_engine_ffi.
pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
    // Future work: Add validation of global constants (e.g., CHUNK_SIZE) here.
}

// ------------------------------------------------------------------
// COMPATIBILITY EXPORTS (Temporary/Legacy/Simple Structures)
// ------------------------------------------------------------------

// Re-export the anyhow crate for macro usage (e.g., anyhow!("...")).
pub use anyhow;

/// A simple, generic data structure used by placeholder logic (e.g., aetherion_cache).
/// This structure provides the fields expected by the current implementation of calculate_data_hash.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

// --- COMMON EXPORTS (PRELUDE) ---
/// A common prelude to be imported by other crates for quick access
/// to fundamental types and the core error handling alias.
pub mod prelude {
    // Shared Data
    pub use super::chunk_data::ChunkData;
    pub use super::tile_data::TileData;
    pub use super::grid_bounds::GridBounds;
    pub use super::tile_type::TileType;
    
    // Shared Error Handling
    pub use super::errors::{SSXLError, SSXLResult};
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\actions\mod.rs (66 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/actions/mod.rs (Consolidated and Cleaned)

// --- MODULE DECLARATION (Only once) ---
mod benchmarking;
mod godot_harness;
mod testing;

// --- CRATE IMPORTS & RE-EXPORTS ---
// OLD: use ssxl_generate::Conductor; // <-- DELETE THIS LINE
use ssxl_tools::get_config_from_path;
use tracing::{info, error, warn};

// Import necessary std libraries
use std::process::{Command, Stdio};
use std::io;
use std::env;
use std::fs;

// Import Conductor types for re-export (This line correctly handles the import and re-export)
pub use ssxl_generate::conductor::Conductor; // Conductor is pub in its module
// FIX: Import ConductorStatus from its correct, publicly accessible path, as it is not
// directly re-exported by the 'conductor' module.
pub use ssxl_generate::conductor_state::ConductorStatus;


// --- CONSTANTS ---
pub const GODOT_EXE_PATH: &str = "./../SSXL_engine_tester/godot.windows.editor.x86_64.exe";
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXL_engine_tester";
pub const GODOT_TEST_SCENE: &str = "res://test_scene/test_ffi_data.tscn";
pub const DLL_NAME: &str = "SSXL_engine.dll";
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";


// --- CORE CLI ACTIONS ---

/// Helper to calculate the absolute path to the Godot project tester directory.
pub fn get_godot_project_abs_path() -> Result<String, String> {
    let mut current_dir = env::current_dir()
        .map_err(|e| format!("Failed to determine CWD: {}", e))?;

    current_dir.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    current_dir.canonicalize()
        .map(|p| p.to_string_lossy().to_string())
        .map_err(|e| format!("Cannot resolve project path fragment '{}': {}. Does the directory exist?", RELATIVE_PROJECT_PATH_FRAGMENT, e))
}

// --- PUBLIC RE-EXPORTS ---

// Re-export functions from the three sub-modules for the CLI's main entry point.
pub use benchmarking::start_signal_inspector;
pub use benchmarking::run_benchmark;

pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
    run_godot_harness,
};

pub use testing::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_priority_1_tests,
    run_test_suite,
};


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\scan\file_walker.rs (65 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/actions/file_walker.rs

use std::fs;
use std::io;
use std::path::PathBuf;
use tracing::{warn, error};

// --- CONFIGURATION ---
/// The root directory to start the LOC scan from.
pub const ROOT_DIR: &str = "../rust/";

/// ðŸ“ Represents the LOC result for a single file.
#[derive(Debug, Clone)]
pub struct FileLoc {
    pub path: PathBuf,
    pub loc: usize,
}

/// Public entry point for the file walking process.
/// Recursively scans the target directory for all files matching the given extension
/// and calculates their Lines of Code (LOC).
pub fn recursive_loc_scan(root_path: &PathBuf, extension: &str) -> io::Result<Vec<FileLoc>> {
    let mut results = Vec::new();
    // Start the recursive traversal from the root path
    scan_dir(root_path, extension, &mut results)?;
    Ok(results)
}

/// Internal function to perform the recursive directory scan.
fn scan_dir(path: &PathBuf, extension: &str, results: &mut Vec<FileLoc>) -> io::Result<()> {
    if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                // Skip the build output directory (target/) and obsolete directories
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "target") {
                    warn!("LOC Scanner skipping build output directory: {}", path.display());
                    continue;
                }
                
                // Skip the temporary/obsolete directory 'iteration5'
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "iteration5") {
                    warn!("LOC Scanner skipping obsolete directory: {}", path.display());
                    continue;
                }

                scan_dir(&path, extension, results)?;
            } else if path.extension().map_or(false, |ext| ext == extension) {
                // Only process files with the specified extension (e.g., "rs")
                match fs::read_to_string(&path) {
                    Ok(content) => {
                        let loc = content.lines().count();
                        results.push(FileLoc { path, loc });
                    }
                    Err(e) => {
                        error!("Failed to read file {}: {}", path.display(), e);
                    }
                }
            }
        }
    }
    Ok(())
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\errors.rs (64 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/errors.rs
//! Defines the canonical error type for the entire Aetherion Engine workspace.
//!
//! All crates should return an 'AetherionError' to ensure clean, consistent
//! error propagation throughout the engine layers (Core, Generation, Godot Interface).

use thiserror::Error;

/// The primary result type used throughout the Aetherion Engine.
/// Aliases the standard Result using the engine's canonical error type.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// Canonical error type for all Aetherion Engine components.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Errors related to file operations, configuration loading, or I/O failure.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors related to data serialization or deserialization (e.g., failed bincode/serde operation).
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors caused by data structures being in an invalid or impossible state (e.g., malformed GridBounds).
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the generation pipeline, often due to configuration or boundary failures.
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors related to external FFI or GDExtension communication.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// An error that should never happen, indicating a fundamental bug in logic or state management.
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Catch-all for other external errors, often used when converting from third-party crates.
    /// This variant is primarily used to wrap `anyhow::Error`.
    #[error("External Crate Error: {0}")]
    External(String),
}

// --- Helper Conversion Implementations (for common libraries) ---

/// Example conversion for the 'bincode' serialization library.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Allows conversion from a generic `anyhow::Error` into the canonical `AetherionError`.
/// This is CRITICAL for using the `anyhow!` macro in dependent crates.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        SSXLError::External(format!("General anyhow error: {}", err))
    }
}

// You can add more 'From' implementations here as you introduce new dependencies,
// like 'tokio::JoinError' or 'rand::Error'.



//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\grid_bounds.rs (58 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/grid_bounds.rs
//! Defines the spatial boundaries for a Chunk or any defined area within the procedural world.
//!
//! Uses i64 coordinates to support extremely large, super-massive, expansive arcs.

use serde::{Serialize, Deserialize};

/// Represents a simple 2D integer coordinate (X, Y).
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    pub x: i64,
    pub y: i64,
}

/// Defines the minimum (min) and maximum (max) corners of a rectangular area
/// in the Aetherion world space, typically used to bound a Chunk or Region.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum corner of the bounding box (bottom-left).
    pub min: Coord2D,
    /// The exclusive maximum corner of the bounding box (top-right + 1).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new GridBounds instance.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size of the bounded area along the X and Y axes.
    /// The size is calculated as max - min.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within these bounds (inclusive minimum, exclusive maximum).
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Provides a default (zero-sized) GridBounds instance.
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}



//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\build.rs (53 LOC)
//////////////////////////////////////////////////////

// rust/SSXL_godot/build.rs

use std::env;
use std::path::PathBuf;
use std::process::Command; // ðŸ›‘ New import for executing shell commands

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // The directory where cargo.toml resides (e.g., .../rust/aetherion_godot)
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    
    // The name of the resulting GDExtension DLL (must match your .gdextension file)
    let dll_name = "ssxl_engine.dll"; 
    
    // Determine the profile (debug or release)
    let profile = env::var("PROFILE").unwrap();    

    // --- 1. Calculate Source Path ---
    let src_path = manifest_dir
        .parent().unwrap() // .. to rust/
        .join("target")
        .join(&profile)
        .join(dll_name);

    // --- 2. Calculate Destination Path ---
    let dst_path = manifest_dir
        .parent().unwrap()      // up to rust/
        .parent().unwrap()      // up to zv9.aetherion/
        .join("ssxl_engine_tester")
        .join(dll_name);

    // --- 3. Execute Native Windows Copy Command ---
    // Using `cmd /C copy /Y` is more robust on Windows than fs::copy.
    let status = Command::new("cmd")
        // /C runs the command and terminates; copy /Y overwrites without prompt
        .args(&["/C", "copy", "/Y"]) 
        .arg(&src_path)
        .arg(&dst_path)
        .status();

    match status {
        Ok(s) if s.success() => {
            println!("cargo:warning=âœ… SUCCESS (CMD): Deployed {} to {}", dll_name, dst_path.display());
        }
        _ => {
            println!("cargo:warning=ðŸš¨ CRITICAL FAILURE (CMD): DLL deployment failed!");
            println!("cargo:warning=  Source Path: {}", src_path.display());
            println!("cargo:warning=  Dest Path: {}", dst_path.display());
            println!("cargo:warning=  Note: The shell command failed. Check file locks or path permissions.");
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_signals.rs (52 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/ssxl_signals.rs
// This GDExtension class serves as a dedicated signal bus for the SSXL-ext engine,
// allowing the Rust core to communicate asynchronous events back to Godot's GDScript layer.

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Base;

// -------------------------------------------------------------------------------------------------
// SSXL SIGNALS GODOT WRAPPER
// -------------------------------------------------------------------------------------------------

/// A dedicated Node for holding and emitting signals related to the SSXL-ext engine's operations.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

#[godot_api]
impl SSXLSignals {
    pub fn init(base: Base<Node>) -> Self {
        SSXLSignals {
            base,
        }
    }

    // ---------------------------------------------------------------------
    // ðŸ“¢ Signal Declarations
    // ---------------------------------------------------------------------

    /// Emitted when the map generation process starts.
    #[signal]
    fn build_map_start();

    /// Emitted when a new chunk of data has been generated and applied to the TileMap.
    #[signal]
    fn chunk_generated(x: i32, y: i32);

    /// Emitted when the entire map generation process is complete.
    #[signal]
    fn build_map_complete();

    /// Emitted when the AnimationConductor sends a tile update for progressive visual loading.
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: godot::builtin::Vector2i);
    
    /// Emitted when the generation worker reports an unrecoverable error.
    #[signal]
    fn generation_error(error_message: godot::prelude::GString); 
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\generation_utils.rs (45 LOC)
//////////////////////////////////////////////////////

//! Utility module for core functions used by the generation pipeline.

use crate::primitives::SSXLData; 
// FIX: Simplified imports. thread_rng is now used, removing the need for SeedableRng, Pcg64, etc.
use rand::Rng; 

// -----------------------------------------------------------------------------
// I. RANDOMNESS UTILITIES
// -----------------------------------------------------------------------------

/// A simple, thread-local generator for random values.
/// This uses the standard library's thread-local RNG (`rand::thread_rng()`)
/// to efficiently generate random numbers, bypassing the complex manual
/// setup that caused trait resolution errors.
/// 
/// Returns `0` if a generated random value (0-99) is less than `target_percent`.
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // thread_rng() returns a thread-local, seeded generator.
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    if rand_val < target_percent {
        0
    } else {
        1
    }
}

// -----------------------------------------------------------------------------
// II. CORE PROCESS UTILITIES
// -----------------------------------------------------------------------------

/// Processes the input data, applying a placeholder mathematical transformation.
///
/// # Arguments
///
/// * `data` - A reference to the core `AetherionData` structure containing relevant state.
///
/// # Returns
///
/// A simple derived u64 value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Uses the trait methods defined on SSXLData in ssxl_math/src/primitives.rs
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\primitives.rs (45 LOC)
//////////////////////////////////////////////////////

//! Core types and constants for the Aetherion math foundation layer.

use serde::{Serialize, Deserialize};

// -------------------------------------------------------------------------
// I. PRIMITIVE TYPES AND TRAITS (MUST BE PUB)
// -------------------------------------------------------------------------

/// ðŸ“ **BULLDOZER FIX:** The canonical signed 2D integer vector for coordinate system logic (Chunk Coords).
/// Must use i64 to support a world scale that exceeds 2.1 billion chunks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    pub x: i64, // Updated from i32
    pub y: i64, // Updated from i32
}

/// A simplified, common result type.
pub type SSXLResult<T> = Result<T, String>;

/// A simplified, common data structure trait implemented by data structs like ChunkData.
pub trait SSXLData: Send + Sync {
    fn get_id(&self) -> u64; 
    fn get_value_len(&self) -> usize;
}

// -------------------------------------------------------------------------
// II. CORE CONSTANTS (MUST BE PUB)
// -------------------------------------------------------------------------

/// **BULLDOZER FIX:** The standard size (width, height, depth) of a chunk in tiles,
/// defined as i64 to ensure seamless arithmetic with the new i64-based Vec2i and GridBounds.
pub const CHUNK_SIZE_I64: i64 = 32;

/// Standard epsilon value for floating-point comparisons (f32).
pub const F32_EPSILON: f32 = 1.0e-6;

// -------------------------------------------------------------------------
// III. IMPLEMENTATION
// -------------------------------------------------------------------------

impl Vec2i {
    pub fn new(x: i64, y: i64) -> Self { // Updated arguments to i64
        Vec2i { x, y }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\runtime_manager.rs (44 LOC)
//////////////////////////////////////////////////////

//! Manages the lifecycle and configuration of the Tokio asynchronous runtime.
//! This ensures the Conductor remains decoupled from low-level thread pool setup.

use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

/// Manages the Tokio Runtime, which provides the thread pool necessary
/// for executing asynchronous and blocking generation tasks.
pub struct RuntimeManager {
    runtime: Runtime,
}

impl RuntimeManager {
    /// Initializes a new multi-threaded Tokio Runtime, configured to use
    /// all available logical CPU cores for maximum concurrency.
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads (all logical cores).", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?;
            
        Ok(RuntimeManager { runtime })
    }

    /// Provides a thread-safe handle to the Runtime for spawning tasks
    /// from various parts of the Conductor.
    pub fn get_handle(&self) -> Handle {
        self.runtime.handle().clone()
    }

    /// Performs a graceful shutdown of the underlying Tokio runtime.
    /// This should be called during the `Conductor`'s teardown process.
    pub fn shutdown_graceful(self) {
        info!("Tokio Runtime signaling graceful shutdown.");
        // This stops the Tokio runtime pool, freeing its resources.
        self.runtime.shutdown_background();
        info!("Tokio Runtime full teardown complete.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\benchmark_logic.rs (43 LOC)
//////////////////////////////////////////////////////

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

/// ðŸ§ª Executes a fixed tile generation workload for throughput benchmarking.
///
/// This function simulates the work of the Minimal Viable Generator (MVG) by
/// iterating a fixed number of times, representing the processing of each tile.
///
/// It accepts an atomic counter to update real-time progress for the CLI ticker.
pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    // We only update the progress counter every 10 million tiles to minimize atomic overhead.
    const UPDATE_INTERVAL: u64 = 10_000_000; 

    // Placeholder for actual generation work.
    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        // A minimal, but non-trivial, calculation that depends on the loop variable 'i'.
        // This simulates the core work (e.g., noise lookup, pattern mapping).
        result = result.wrapping_add(i % 17);
        
        // --- REAL-TIME PROGRESS UPDATE ---
        if (i + 1) % UPDATE_INTERVAL == 0 {
            // Atomically increment the counter by the interval.
            // Ordering::Relaxed is sufficient as we only care about the final value and ordering within the thread.
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    // Ensure the counter is set to the final value, covering any remaining tiles in the last batch.
    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    // Print a result outside the loop to ensure the calculation itself is not optimized away.
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\ca\rule_set.rs (42 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/ca/rule_set.rs

use ssxl_shared::tile_type::TileType;

// --- RULESET DEFINITIONS ---
pub const RULE_BASIC_CAVE: u8 = 0; // Generates large, open cave systems.
pub const RULE_MAZE: u8 = 1;        // Generates thin, winding maze/pillar structures.
pub const RULE_SOLID: u8 = 2;       // Fills the entire chunk with a solid tile.
pub const RULE_CHECKERBOARD: u8 = 3; // Generates a checkerboard pattern.

/// Determines the next tile type based on the current type, live neighbors, and the active ruleset.
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    // NOTE: Only handles Rock/Void transitions.

    // Define Birth (B) and Survival (S) conditions based on the ruleset
    // Bx/Sy: Birth if live neighbors in [x], Survive if live neighbors in [y].
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),          // B3/S1-4 (Favors thin, complex structures)
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // B4-5/S1-7 (Favors large, open caves)
    };

    match current_type {
        TileType::Rock => {
            // Survival Rule: Rock stays Rock
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                TileType::Void // Dies (becomes Void)
            }
        }
        TileType::Void => {
            // Birth Rule: Void becomes Rock
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                TileType::Void // Stays Void
            }
        }
        // Preserve any other tile types
        _ => current_type,
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\math_primitives.rs (41 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/math_primitives.rs
//! This module holds utility functions and constants needed by shared data structures,
//! primarily serialization helpers for standard library types.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};

// NOTE: CHUNK_SIZE_I32 and F32_EPSILON are removed from here.
// CHUNK_SIZE_I32 should be moved to aetherion_math/src/primitives.rs to break the cycle.
// F32_EPSILON is a generic math constant and should also live in aetherion_math.

// -----------------------------------------------------------------------------
// SERDE HELPERS (Remains in Shared, as it aids shared data structures)
// -----------------------------------------------------------------------------

/// Serde serialization and deserialization helpers for `std::time::SystemTime`.
///
/// This allows `SystemTime` to be used in structs with `#[derive(Serialize/Deserialize)]`
/// by converting it to and from a serializable `u64` (milliseconds since epoch).
pub mod system_time_serde {
    use super::*;

    /// Serializes `SystemTime` as milliseconds elapsed since the Unix epoch (u64).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        let ms = duration.as_millis() as u64;
        serializer.serialize_u64(ms)
    }

    /// Deserializes milliseconds (u64) back into a `SystemTime` struct.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        let ms = u64::deserialize(deserializer)?;
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\gde_api_defs.rs (39 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/gde_api_defs.rs

use godot::prelude::*;
use godot::classes::Node; // Explicitly import Node for the Base<Node> usage
use crate::ssxl_engine::SSXLEngine;

// --- Godot Initialization and Registration ---

/// Registers all Godot classes exposed by the SSXL-ext GDExtension library.
/// This is the entry point for Godot to discover our Rust-defined classes.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    builder.add_class::<SSXLEngine>();
}

// --- Trait Implementations for Godot Lifecycle ---

/// Required trait implementation to expose Rust methods to GDScript.
impl ExtensionLibrary for SSXLEngine {
    /// Initialization logic is delegated to the main SSXLEngine constructor
    /// to keep this file clean.
    fn _init(base: Base<Node>) -> Self {
        SSXLEngine::init(base)
    }

    /// Godot's callback for the main game loop update.
    /// This delegates to the internal `tick()` for MPSC polling.
    fn _process(&mut self, delta: f64) {
        // Pass the delta time, cast to u64. This is a placeholder for a true tick count
        // and is ignored by the current SSXLEngine::tick logic.
        self.tick(delta as u64); 
    }
    
    /// Godot's callback when the node enters the scene tree.
    fn _ready(&mut self) {
        // Initialization of presenters, poller, and channel configuration occurs here.
        self.on_ready(); 
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\lib.rs (34 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/lib.rs

//! The Foundation Layer crate for all spatial types, vector math,
//! coordinate systems, and deterministic hashing algorithms.

// --- MODULE DEFINITIONS ---
pub mod coordinate_system;
pub mod generation_utils;
pub mod hashing;
// --- FIX: Renamed to primitives to match usage below ---
pub mod primitives; 

// -------------------------------------------------------------------------
// EXPORTS FOR DOWNSTREAM CRATES
// -------------------------------------------------------------------------
pub use coordinate_system::{ChunkKey, WorldPos, TileOffset};
pub use crate::generation_utils::process_data;
// Exports correctly point to the 'primitives' module
pub use crate::primitives::Vec2i; 
pub use crate::primitives::SSXLResult;
pub use crate::primitives::SSXLData;

/// Math-specific prelude for convenient imports in downstream crates.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    // Exports correctly point to the 'primitives' module
    pub use super::primitives::*; 
}

pub fn initialize_math_system() {
    tracing::info!("SSXL Math system initialized and ready.");
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\ca\neighbor_check.rs (32 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/neighbor_check.rs

use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    tile_type::TileType,
};

/// Counts the number of 'live' (TileType::Rock) neighbors for a given coordinate (Moore neighborhood).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;

    for dx in -1..=1 {
        for dy in -1..=1 {
            if dx == 0 && dy == 0 {
                continue;
            }

            let nx = cx as i32 + dx;
            let ny = cy as i32 + dy;

            // Check if neighbor is within chunk bounds
            if nx >= 0 && nx < CHUNK_SIZE as i32 && ny >= 0 && ny < CHUNK_SIZE as i32 {
                let index = (ny as u32 * CHUNK_SIZE + nx as u32) as usize;

                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\scan\mod.rs (32 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/scan/mod.rs (Cleaned content for LOC utility)

use tracing::{info, warn, error};
use std::io;
use std::env;
use std::fs;
use std::process::{Command, Stdio}; // Keeping if any scan logic uses external commands (unlikely)

// --- MODULE DECLARATION (Only LOC-related modules remain) ---

/// Contains the logic for recursively scanning the codebase.
mod file_walker;
/// Contains the logic for processing LOC data and formatting the final report.
mod report_formatter;

// NOTE: benchmarking, godot_harness, and testing declarations removed here.
// NOTE: All Godot/DLL constants and functions (like get_godot_project_abs_path) 
// should be moved to ssxl_cli/src/actions/mod.rs or godot_harness.rs.


// --- LOC SCANNER CORE FUNCTION ---
// The direct definition of execute_loc_scan is removed to prevent collision.

// --- PUBLIC RE-EXPORTS ---

// Re-export LOC Scanner entry point from its appropriate sub-module
// This makes the function available as `crate::scan::execute_loc_scan`
pub use report_formatter::execute_loc_scan; 

// Re-exports for file_walker and report_formatter utility functions (Optional)
// pub use file_walker::walk_directory;
// pub use report_formatter::{format_report, LOCReport};


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\lib.rs (32 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/lib.rs

// ðŸ›‘ Declare sub-modules (existing)
pub mod ssxl_engine;
pub mod ssxl_signals;
pub mod ssxl_oracle;

// ðŸ› ï¸ FIX: New module declarations required by ssxl_engine.rs
// These modules contain the delegate structs (AsyncPoller, ChunkPresenter, etc.).
mod async_poll;
mod chunk_presenter;
mod channel_handler;
mod api_initializers;
mod generation_api;
mod animation_api;

use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel}; 

// --- GDEXTENSION ENTRY POINT ---

struct SSXLExtension;

// ðŸ›‘ FIX: Use the simple, stable, declarative ExtensionLibrary implementation.
// This is the correct signature for your version and relies on the #[derive(GodotClass)] 
// in the sub-modules to perform registration.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    fn on_level_init(_level: InitLevel) {
        // Leave the body empty. Registration happens automatically via macros.
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\generation_message.rs (29 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/generation_message.rs

use crate::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use std::sync::Arc;

// --- Task Sent TO the Generator Worker ---

/// Represents a single request for a chunk generation task.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    /// The coordinates of the chunk to be generated (world-space tile origin).
    pub chunk_coords: Vec2i,
    /// The ID of the generator to use for this task.
    pub generator_id: String,
}


// --- Message Sent FROM the Generator Worker ---

/// Represents a progress update or completion signal from the generation worker.
#[derive(Debug)]
pub enum GenerationMessage {
    /// Sent when a chunk has been successfully loaded or generated.
    ChunkGenerated(Vec2i, Arc<ChunkData>),
    /// Signals that the worker pool has finished processing all tasks.
    // This variant matches the usage in ssxl_generate/src/batch_processor.rs and ssxl_generate/src/task_queue.rs.
    GenerationComplete, 
}


//////////////////////////////////////////////////////
// FILE: ssxl_sync\src\lib.rs (22 LOC)
//////////////////////////////////////////////////////

// ssxl_sync/src/lib.rs

//! Provides the core synchronization and communication channels for the engine,
//! allowing data exchange between the main thread, Godot, and worker threads.

// Declare the new modules containing the split logic.
pub mod primitives;
mod pool_manager;

// Re-export core synchronization items.
pub use primitives::AtomicResource;
pub use primitives::{create_sync_channel, start_sync_worker};

// Re-export the worker conductor types.
pub use primitives::{AnimationConductor, AnimationCommand};

// FIX: Re-export the type aliases required by external crates (like ssxl_godot).
// These were defined in primitives.rs in the previous step.
pub use primitives::AnimationConductorHandle; 
pub use primitives::AnimationReceiver; 

// NOTE: We may need to re-export AnimationUpdate from ssxl_shared if the full crate structure is checked.


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\messages.rs (20 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/messages.rs

use serde::{Serialize, Deserialize};
use crate::chunk_data::ChunkData;

// --------------------------------------------------------------------------------
// MESSAGE DATA STRUCTURES
// --------------------------------------------------------------------------------

/// A message wrapper sent from the generation worker thread (Conductor) to the
/// main thread (ChannelHandler) containing the result of a completed chunk task.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChunkMessage {
    /// A chunk was successfully generated and is ready for presentation.
    Generated(ChunkData),
    /// A request was completed but returned no data (e.g., a known missing chunk).
    NoData,
    /// An error occurred during the generation process.
    Error(String),
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\generator.rs (18 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/generator.rs

use ssxl_shared::chunk_data::ChunkData;
// FIX: Imported Vec2i from aetherion_math, where it is now defined and exported.

use ssxl_math::Vec2i;

/// Defines the core contract for all procedural generation algorithms.
/// Every generator (Perlin, CA, DiamondSquare, etc.) must implement this trait.
#[allow(dead_code)]
pub trait Generator {
    /// The unique identifier for this specific algorithm (e.g., "perlin_2d_v1").
    fn id(&self) -> &str;

    /// Generates the content for a single Chunk.
    /// It takes a Vec2i which is the world-space coordinate of the chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


//////////////////////////////////////////////////////
// FILE: manifest_tips.rs (16 LOC)
//////////////////////////////////////////////////////

tidbits:

1.
Search the Windows Start Menu for "Edit the system environment variables" and open it.

Click the "Environment Variables..." button.

Under "User variables for [YourName]", click "New...".

Set the Variable name to GODOT4_BIN.

Set the Variable value to C:\zv9\zv9.SSXL-ext\SSXL_engine_tester\godot.windows.editor.x86_64.exe.

Click OK.





//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\sync.rs (15 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/sync.rs

use tokio::sync::mpsc;
// âœ… FIX: Changed the import path as suggested by the compiler.
use crate::task_queue::GenerationMessage; 
use crate::task_queue::GenerationTask;

// --- Public Type Aliases for Communication Channels ---

/// The channel sender used by Godot/main thread to request new chunks from the Conductor worker.
pub type ConductorRequestSender = mpsc::UnboundedSender<GenerationTask>;

/// The channel receiver used by Godot/main thread to read chunk generation results/progress.
// âœ… This type alias is now correct and matches the return type of Conductor::new().
pub type ConductorProgressReceiver = mpsc::Receiver<GenerationMessage>;


//////////////////////////////////////////////////////
// FILE: no_space_batch.rs (14 LOC)
//////////////////////////////////////////////////////

# powershell command. removes no break space. 

(Get-Content -Path ssxl_sync/src/lib.rs) -replace [char]0x00A0, ' ' | Set-Content -Path ssxl_sync/src/lib.rs

# powershell command. removes new visibile corruption from no break space removal. 

# Step 2: Replace the corrupted 'Ã‚' character (U+00C2) with nothing, and the NBSP (U+00A0) with a standard space.
(Get-Content -Path ssxl_sync/src/lib.rs) -replace [char]0x00C2, '' -replace [char]0x00A0, ' ' | Set-Content -Path ssxl_sync/src/lib.rs

#powershell command. cleans the whole directory. 

Get-ChildItem -Path . -Include *.rs -Recurse | ForEach-Object {
    (Get-Content $_.FullName) -replace [char]0x00C2, '' -replace [char]0x00A0, ' ' | Set-Content $_.FullName
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\config.rs (7 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/config.rs

/// The canonical size for all chunks in the SSXL Engine (32x32 tiles).
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles in a single chunk (CHUNK_SIZE * CHUNK_SIZE = 1024).
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\ca\mod.rs (5 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/ca/mod.rs

// Declare the modules residing in the ssxl_generate/src/ca/ directory
pub mod rule_set;
pub mod neighbor_check;

======================================================
END OF REPORT
======================================================
