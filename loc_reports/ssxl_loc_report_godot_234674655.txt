SSXL-ext Live LOC Report
Generated (UTC): 2025-11-16 22:46:48
Generated (Epoch Seconds): 1763333208
Root Directories: .\SSXL_engine_tester
Target Extensions: gd

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       21 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
       31 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
       21 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\SSXL.gd
      109 LOC | SSXL_engine_tester\root_scripts\cameras.gd
        1 LOC | SSXL_engine_tester\root_scripts\camera_2.gd
      114 LOC | SSXL_engine_tester\root_scripts\controlpanelanimation.gd
      182 LOC | SSXL_engine_tester\root_scripts\controlpanelgenlogic.gd
       68 LOC | SSXL_engine_tester\root_scripts\controlpanelsignalhandler.gd
      121 LOC | SSXL_engine_tester\root_scripts\controlpaneluisetup.gd
      155 LOC | SSXL_engine_tester\root_scripts\controlpanelutility.gd
      133 LOC | SSXL_engine_tester\root_scripts\control_panel.gd
       37 LOC | SSXL_engine_tester\root_scripts\engine_monitor.gd
       22 LOC | SSXL_engine_tester\root_scripts\init.gd
        1 LOC | SSXL_engine_tester\root_scripts\logger.gd
       70 LOC | SSXL_engine_tester\root_scripts\main.gd
      100 LOC | SSXL_engine_tester\root_scripts\main1.gd
       22 LOC | SSXL_engine_tester\root_scripts\root.gd
       10 LOC | SSXL_engine_tester\root_scripts\scenescanner.gd
        5 LOC | SSXL_engine_tester\root_scripts\tester.gd
       23 LOC | SSXL_engine_tester\test_scripts\control_panel.gd
       72 LOC | SSXL_engine_tester\test_scripts\test_ffi_data.gd
------------------------------------------------------
     1318 LOC | TOTAL
------------------------------------------------------


======================================================
      RAW SOURCE CODE DUMP (FOR CONTEXT)
======================================================
======================================================
>>> FILE START: SSXL_engine_tester\addons\S2O_godot_plugin\Aetherion.gd (21 LOC) <<<
======================================================
extends Node

func enter_idle():
    print("🌙 Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 Aetherion teardown.")
    # Optional: stop ticker, release ligatures

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\Aetherion.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd (31 LOC) <<<
======================================================
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("🌀 SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("✨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("⚠️ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("❌ Failed to instantiate SSXL script.")
        else:
            push_error("❌ Invalid script resource at: %s" % script_path)
    else:
        push_error("❌ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("🧹 SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("🧺 SSXL instance freed.")
    ssxl_instance = null

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\addons\S2O_godot_plugin\SSXL.gd (21 LOC) <<<
======================================================
extends Node

func enter_idle():
    print("🌙 SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 SSXL teardown.")
    # Optional: stop ticker, release ligatures

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\SSXL.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\cameras.gd (109 LOC) <<<
======================================================
extends Node

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robust access)
# ----------------------------------------------------------------------

@onready var camera1: Camera2D = $camera1
@onready var camera2: Camera2D = $camera2

# ----------------------------------------------------------------------
## CONSTANTS & STATE
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1 
const MIN_ZOOM: float = 0.05 
const MAX_ZOOM: float = 10.0 

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Ensure camera nodes exist before attempting to use them
	if camera1 == null or camera2 == null:
		push_error("❌ Critical: Camera nodes (camera1 or camera2) not found as children.")
		return
		
	# Start by making camera1 current
	camera1.make_current()

# ----------------------------------------------------------------------
## INPUT HANDLING (Toggle, Zoom, & Pan)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	# --- 1. Camera Toggle Logic (Space/Tab) ---
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.is_action("ui_accept") or event.is_action("ui_focus_next"):
			get_viewport().set_input_as_handled()
			_toggle_camera()
			return

	# Only proceed with Mouse/Map controls if camera2 is the current active camera
	if camera2 and camera2.is_current():
		
		# --- 2. Combined Mouse Input Handling (Zoom & Pan State) ---
		if event is InputEventMouseButton:
			
			var current_zoom: Vector2 = camera2.zoom
			var new_zoom: Vector2 = current_zoom
			
			# --- A. ZOOM LOGIC (Scroll Wheel) ---
			# We only check for the press event to prevent double-processing.
			if event.is_pressed():
				if event.button_index == MOUSE_BUTTON_WHEEL_UP:
					# Zoom IN
					new_zoom -= Vector2(ZOOM_SPEED, ZOOM_SPEED)
				elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
					# Zoom OUT
					new_zoom += Vector2(ZOOM_SPEED, ZOOM_SPEED)
			
			if new_zoom != current_zoom:
				# Apply and clamp zoom
				new_zoom = new_zoom.clamp(Vector2(MIN_ZOOM, MIN_ZOOM), Vector2(MAX_ZOOM, MAX_ZOOM))
				camera2.zoom = new_zoom
				get_viewport().set_input_as_handled()
				return 
			
			# --- B. PANNING STATE LOGIC (Middle Click) ---
			if event.button_index == MOUSE_BUTTON_MIDDLE:
				is_panning = event.is_pressed()
				
				if is_panning:
					last_mouse_position = event.position
				
				get_viewport().set_input_as_handled()
				return 

		# --- 3. Camera Pan Logic (Mouse Motion) ---
		elif event is InputEventMouseMotion and is_panning:
			
			var delta: Vector2 = event.position - last_mouse_position
			
			# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
			camera2.position -= delta / camera2.zoom
			
			last_mouse_position = event.position
			get_viewport().set_input_as_handled()
			return

# ----------------------------------------------------------------------
## PUBLIC API (No functional change, uses @onready variables)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	if camera1 == null or camera2 == null:
		print("⚠️ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("➡️ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("➡️ Switched to Camera 2 (Map View).")
	else:
		print("⚠️ Invalid camera index passed.")

func _toggle_camera() -> void:
	if camera1 == null or camera2 == null:
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Use public API for consistency
	elif camera2.is_current():
		switch_to_camera(1) # Use public API for consistency
	else:
		# Fallback: if neither is current, default to camera1
		switch_to_camera(1)

>>> FILE END: SSXL_engine_tester\root_scripts\cameras.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\camera_2.gd (1 LOC) <<<
======================================================
extends Camera2D

>>> FILE END: SSXL_engine_tester\root_scripts\camera_2.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\controlpanelanimation.gd (114 LOC) <<<
======================================================
class_name control_panel_animation_logic extends RefCounted

## 🎯 Properties
var controller: Control
# Queue to hold incoming tile updates (flips) from the engine
var tile_flip_queue: Array = []
# Maximum number of tile updates to process per animation tick
const MAX_FLIPS_PER_TICK: int = 1000


func _init(p_controller: Control) -> void:
	# Store a reference to the main controller node
	controller = p_controller


## ANIMATION STATE CONTROL

func on_animate_checkbox_toggled(button_pressed: bool) -> void:
	"""
    Updates the controller's local animation state and sends the new mode 
    to the Rust engine via FFI to update its status.
	"""
	controller.is_animated = button_pressed
	print("⚙️ Animation Toggled: %s" % controller.is_animated)
	
	# FFI: Call the direct Rust function to set the enabled state.
	# This resolves the 'Nonexistent function 'send_animation_command'' error.
	if is_instance_valid(controller.ssxl_engine):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	# Automatically switch the polling mechanism based on the animation mode
	setup_animation_worker(button_pressed)


func setup_animation_worker(should_animate: bool) -> void:
	"""
    Starts the correct timer (throttled animation or fast engine poll)
    based on the user's animation choice.
	"""
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			# Slower tick for visual updates
			controller.animation_timer.start()
		if is_instance_valid(controller.engine_timer):
			# Stop the fast poll
			controller.engine_timer.stop()
	else:
		if is_instance_valid(controller.engine_timer):
			# Fast tick for engine polling
			controller.engine_timer.start()
		if is_instance_valid(controller.animation_timer):
			# Stop the animation loop
			controller.animation_timer.stop()


## ⏱️ TIMER HANDLERS (Polling & Animation Loop)

func _on_engine_timer_timeout() -> void:
	"""
    Called by the fast (e.g., 0.01s) engine_timer when NOT animating.
    Its primary job is to poll the Rust engine for updates.
	"""
	if not controller.is_generating or not is_instance_valid(controller.ssxl_engine):
		return
	
	controller.engine_tick_count += 1
	# Manually poll the engine status
	controller.ssxl_engine.get_status()


func _on_animation_timer_timeout() -> void:
	"""
    Called by the throttled animation_timer when ANIMATING.
    Processes a batch of tile flips and updates the screen once.
	"""
	if not controller.is_generating:
		return
	
	# 1. Determine how many flips to process
	var flips_to_process: int = mini(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	if flips_to_process > 0:
		# Process the first batch of flips directly from the queue
		for i in range(flips_to_process):
			var flip_data: Array = tile_flip_queue[i]
			var tile_id: int = flip_data[0]
			var flip_frame: int = flip_data[1]
			
			process_tile_flip(tile_id, flip_frame)
			
		# Remove the processed elements from the queue using pop_front()
		for i in range(flips_to_process):
			tile_flip_queue.pop_front()


	# 2. Update Map and Poll Engine Status
	if is_instance_valid(controller.expansive_tilemap):
		# Force the TileMap to refresh with the batch of new tiles
		controller.expansive_tilemap.force_update()
	
	# Poll Engine Status (Less frequently in animation mode)
	if is_instance_valid(controller.ssxl_engine):
		controller.ssxl_engine.get_status()


## 💡 TILE FLIP PROCESSING

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	"""Converts linear tile ID to grid coords and applies the visual flip/frame."""
	if not is_instance_valid(controller.expansive_tilemap) or not is_instance_valid(controller.grid_width):
		return

	# Use the current grid width value (which is likely a SpinBox or similar)
	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	# Convert linear tile_id back to grid coordinates (x, y)
	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	# Apply the tile flip/alternative tile index
	controller.expansive_tilemap.set_cell_alt(0, coords, flip_frame)


func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
    Signal handler connected to SSXLSignals.
    Queues the incoming tile flip data for processing on the next animation tick.
	"""
	# Only queue updates if the system is running and animation is enabled
	if not controller.is_animated or not controller.is_generating:
		return

	# Store the data in the queue immediately
	tile_flip_queue.append([tile_id, flip_frame])

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelanimation.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\controlpanelgenlogic.gd (182 LOC) <<<
======================================================
class_name control_panel_gen_logic extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
# ⏯️ TOGGLE (UI ENTRY POINT)
# ------------------------------------------------------------------------------
func toggle_generation() -> void:
	"""
	Toggles map generation between start and stop based on the current state.
	This is the function connected directly to the 'Generate' button.
	"""
	if controller.is_generating:
		stop_generation()
	else:
		start_generation()

# ------------------------------------------------------------------------------
# 🛑 STOP GENERATION LOGIC
# ------------------------------------------------------------------------------
func stop_generation() -> void:
	print("🛑 ControlPanel: Stop button pressed. Halting generation.")
	
	# Attempt to send a stop command to the FFI/Rust engine
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("send_stop_command"): # Refactored method name for clarity
		controller.ssxl_engine.send_stop_command()
		print("🛑 ControlPanel: Sent explicit stop command to SSXL Engine.")
		
	# Reset state and update UI
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🛑 Generation halted by user."
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	
	# Switch back to the Control Panel camera
	controller.utility.switch_to_camera_view(1) # Delegated to utility script
	print("➡️ Switched to Camera 1 (Control Panel View).")


# ------------------------------------------------------------------------------
# 🟢 START GENERATION LOGIC
# ------------------------------------------------------------------------------
func start_generation() -> void:
	# Critical node checks
	if not controller.utility.check_critical_nodes():
		return # Error message handled in utility

	# Input gathering: Grid size
	var width: int = int(controller.grid_width.value) if is_instance_valid(controller.grid_width) else 0
	var height: int = int(controller.grid_height.value) if is_instance_valid(controller.grid_height) else 0
	
	# Input validation
	if width <= 0 or height <= 0:
		if is_instance_valid(controller.status_label):
			controller.status_label.text = "⚠️ Invalid grid size."
		return

	# Retrieve inputs using safer, single-purpose functions
	var generator_name: String = get_selector_item_text(controller.placement_mode_selector, "perlin_basic_2d", "Generator list empty. Using default: %s")
	var tile_type_name: String = get_selector_item_text(controller.tile_type_selector, "tile_type_grass")
	var seed: int = get_and_set_seed()
		
	# State Setup
	if controller.ssxl_engine.has_method("set_generator"):
		controller.ssxl_engine.set_generator(tile_type_name)
		print("⚙️ ControlPanel: set_generator called with tile_type %s" % tile_type_name)

	controller.utility.clear_generation_state()
	controller.is_generating = true
	controller.is_animated = controller.animate_checkbox.button_pressed
	
	controller.animation_logic.setup_animation_worker(controller.is_animated)

	controller.generation_start_time_ms = Time.get_ticks_msec()
	
	# Progress Bar Setup
	var total_chunks_x: float = ceil(float(width) / controller.CHUNK_SIZE_X)
	var total_chunks_y: float = ceil(float(height) / controller.CHUNK_SIZE_Y)
	
	if is_instance_valid(controller.progress_bar):
		var total_tiles: float = total_chunks_x * total_chunks_y * controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
		controller.progress_bar.max_value = total_tiles
		controller.progress_bar.value = 0.0
		controller.progress_bar.visible = true
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🧬 Generating map with mode: %s..." % [generator_name]
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		controller.generate_button.text = "STOP"
	
	prepopulate_map(width, height)
	controller.get_tree().process_frame

	# Camera switch to map view
	controller.utility.switch_to_camera_view(2)
	print("➡️ Switched to Camera 2 (Map View).")

	# FFI CALL 2: Queues the task in the Rust engine
	controller.ssxl_engine.build_map(width, height, str(seed), generator_name)
	print("🧪 ControlPanel: build_map called with seed %d and generator %s (Task Queued)" % [seed, generator_name])

	# Start the appropriate timer based on animation state
	if controller.is_animated and is_instance_valid(controller.animation_timer):
		controller.animation_timer.start()
	elif is_instance_valid(controller.engine_timer):
		controller.engine_timer.start()

# ------------------------------------------------------------------------------
# ⚙️ UTILITY FUNCTIONS
# ------------------------------------------------------------------------------

func get_selector_item_text(selector: OptionButton, default_value: String, warning_message: String = "") -> String:
	"""Safely retrieves the selected item text from an OptionButton, or returns a default."""
	if not is_instance_valid(selector) or selector.get_item_count() == 0:
		if not warning_message.is_empty() and is_instance_valid(controller.status_label):
			controller.status_label.text = warning_message % default_value
		return default_value
		
	var selected_idx: int = max(0, selector.selected)
	if selected_idx < selector.get_item_count():
		return selector.get_item_text(selected_idx)
		
	return default_value # Should not happen if item_count > 0, but safe fallback

func get_and_set_seed() -> int:
	"""Retrieves the seed from input or generates a new random one, updating the UI."""
	if is_instance_valid(controller.seed_input) and controller.seed_input.text.is_valid_int():
		return int(controller.seed_input.text)
	
	var new_seed: int = randi() % 1_000_000
	if is_instance_valid(controller.seed_input):
		controller.seed_input.text = str(new_seed)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "⚠️ Invalid seed. Using random seed: %d" % new_seed
	
	return new_seed

func prepopulate_map(width: int, height: int) -> void:
	"""Pre-fills the entire map with a base tile to reserve space and show bounds."""
	if not is_instance_valid(controller.expansive_tilemap):
		push_error("Cannot prepopulate: TileMap invalid.")
		return

	controller.expansive_tilemap.clear_layer(0)
	for x in range(width):
		for y in range(height):
			controller.expansive_tilemap.set_cell(0, Vector2i(x, y), controller.BASE_SOURCE_ID, controller.BASE_ATLAS_COORDS, controller.BASE_ALT_ID)
	
	# Note: force_update() is called after build_map_complete for final drawing.
	print("🎨 ControlPanel: Map prepopulated with base tile (%d x %d)." % [width, height])


# ------------------------------------------------------------------------------
# ✅ COMPLETION HANDLER
# ------------------------------------------------------------------------------
func _on_build_map_complete_received() -> void:
	# This function is connected directly to the ssxl_signals build_map_complete signal
	on_build_map_complete()
	
func on_build_map_complete() -> void:
	print("✅ Finalizing map generation.")
	
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	var elapsed_placement_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var elapsed_placement_time_sec: float = float(elapsed_placement_time_ms) / 1000.0
	
	var final_tile_count: int = controller.total_tiles_placed
	
	# Update labels
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % final_tile_count
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "⏱️ Tile Placement Time: %.2fs" % elapsed_placement_time_sec
		
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "⏱️ Final Runtime: %.2fs | Ticks: %d" % [elapsed_placement_time_sec, controller.engine_tick_count]

	# Final camera positioning and zoom (Delegate this logic to Utility)
	controller.utility.set_map_zoom_and_position()
	
	if is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	
	controller.get_tree().process_frame

	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "✅ Generation Complete. Map built. (%d tiles)" % final_tile_count
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelgenlogic.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\controlpanelsignalhandler.gd (68 LOC) <<<
======================================================
class_name control_panel_signal_handler extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

## 🔄 ENGINE STATUS/ERROR SIGNALS
# 
func _on_engine_status_updated(status_message: String) -> void:
	"""Updates the status label with a general message from the engine."""
	if is_instance_valid(controller.status_label):
		# Only update the status if it's a critical or final state, 
		# allowing chunk_generated to handle progress status.
		if status_message.begins_with("ERROR:") or status_message.begins_with("IDLE:"):
			controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	"""Handles a critical error signal from the generation process."""
	print("❌ ERROR: Generation failed: %s" % error_message)
	
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "❌ ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"


## 🏗️ GENERATION PROGRESS SIGNALS
func _on_build_map_start() -> void:
	"""Fired when the FFI build_map call is successfully received by the Rust engine."""
	print("📡 Signal: build_map_start received.")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🏗️ Engine task started..."

func _on_chunk_generated(chunk_x: int, chunk_y: int) -> void:
	"""Updates progress bar and tile count when a chunk is processed by the engine."""
	var tiles_in_chunk: int = controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
	
	# Update Progress Bar and Tile Count
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value += float(tiles_in_chunk)
	
	controller.total_tiles_placed += tiles_in_chunk
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % controller.total_tiles_placed
	
	# Request the utility module to schedule a visual TileMap redraw (throttled)
	# This is the key to fixing the map refresh rate.
	controller.utility.request_redraw()

	# Update the status label with percentage progress
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if is_instance_valid(controller.status_label):
		# Only update status if the percentage value has changed significantly (e.g., 5%)
		if percent != controller.last_percent and (percent % 5 == 0 or percent == 100):
			controller.status_label.text = "🏗️ Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent


## 💡 ANIMATION/TILE FLIP SIGNAL
# 
func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
	Handles an individual tile flip update signal, delegating the data to the
	Animation Logic module for queueing and processing.
	"""
	if not is_instance_valid(controller.animation_logic):
		return
	
	# FIX: Delegate the flip data to the animation logic module for queueing.
	controller.animation_logic._on_tile_flip_updated(tile_id, flip_frame)

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelsignalhandler.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\controlpaneluisetup.gd (121 LOC) <<<
======================================================
class_name control_panel_ui_setup extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller


# ------------------------------------------------------------------------------
## 🛠️ CORE LIFECYCLE
# ------------------------------------------------------------------------------
func setup_all() -> void:
	"""Combines all setup functions for the main controller's _ready()."""
	setup_timers()
	setup_engine_links()
	setup_ui()
	connect_signals()
	print("⚙️ ControlPanel UI Setup complete.")


# ------------------------------------------------------------------------------
## ⏱️ TIMER CONFIGURATION
# ------------------------------------------------------------------------------
func setup_timers() -> void:
	"""Sets up timer properties and connects timeouts to the appropriate handler."""
	
	# Engine Timer (Fast poll for non-animated generation)
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.01
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	# Animation Timer (Throttled tick for animated generation)
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	# Clock Timer
	if is_instance_valid(controller.clock_timer):
		# Connect to the Utility module for clock updates
		controller.clock_timer.timeout.connect(controller.utility.on_clock_timer_timeout)
		
	# Redraw Throttle Timer (Map Gen batch redraw)
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1


# ------------------------------------------------------------------------------
## 🔗 EXTERNAL NODE LINKING
# ------------------------------------------------------------------------------
func setup_engine_links() -> void:
	"""Passes necessary Godot node references to the SSXL engine components."""
	if is_instance_valid(controller.ssxl_engine):
		if is_instance_valid(controller.ssxl_signals) and controller.ssxl_engine.has_method("set_signals_node"):
			controller.ssxl_engine.set_signals_node(controller.ssxl_signals)
		if is_instance_valid(controller.expansive_tilemap) and controller.ssxl_engine.has_method("set_tilemap"):
			controller.ssxl_engine.set_tilemap(controller.expansive_tilemap)
	else:
		push_error("❌ SSXLEngine node not found.")

# ------------------------------------------------------------------------------
## 📐 UI INITIALIZATION (Populate OptionButtons)
# ------------------------------------------------------------------------------
func setup_ui() -> void:
	"""Sets initial values and properties for core UI elements and populates selectors."""
	
	# 1. Grid Size SpinBoxes
	if is_instance_valid(controller.grid_width) and is_instance_valid(controller.grid_height):
		# Set sensible bounds and default values based on CHUNK_SIZE
		controller.grid_width.max_value = 1_000_000_000.0
		controller.grid_width.step = float(controller.CHUNK_SIZE_X)
		controller.grid_width.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		controller.grid_height.max_value = 1_000_000_000.0
		controller.grid_height.step = float(controller.CHUNK_SIZE_Y)
		controller.grid_height.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	# 2. Tile Type Selector
	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.clear()
		controller.tile_type_selector.add_item("tile_type_grass")
		controller.tile_type_selector.add_item("tile_type_water")
		controller.tile_type_selector.add_item("tile_type_mountain")
		controller.tile_type_selector.select(0)
	
	# 3. Placement Mode Selector
	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.clear()
		controller.placement_mode_selector.add_item("perlin_basic_2d")
		controller.placement_mode_selector.add_item("cellular_automata_checkerboard")
		controller.placement_mode_selector.add_item("drunkards_walk")
		controller.placement_mode_selector.add_item("maze_recursive_division")
		controller.placement_mode_selector.select(0)
		
	# 4. Status and Progress Bar
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."


# ------------------------------------------------------------------------------
## 🔌 SIGNAL CONNECTIONS
# ------------------------------------------------------------------------------
func connect_signals() -> void:
	"""Connects all UI and external engine signals to the appropriate handler functions."""
	
	# --- UI Connections (Delegated to helper scripts) ---
	if is_instance_valid(controller.generate_button):
		controller.generate_button.pressed.connect(controller.gen_logic.toggle_generation)
	
	if is_instance_valid(controller.animate_ui_button):
		controller.animate_ui_button.pressed.connect(controller.utility.toggle_camera_view)
		
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.pressed.connect(controller.utility.on_toggle_terminal_button_pressed)
		
	if is_instance_valid(controller.animate_checkbox):
		controller.animate_checkbox.toggled.connect(controller.animation_logic.on_animate_checkbox_toggled)
	
	# --- External Engine Connections (SSXLSignals Hub) ---

	if is_instance_valid(controller.ssxl_signals):
		# Signals related to map start/chunk/error go to the dedicated Signal Handler
		controller.ssxl_signals.build_map_start.connect(controller.signal_handler._on_build_map_start)
		controller.ssxl_signals.chunk_generated.connect(controller.signal_handler._on_chunk_generated)
		controller.ssxl_signals.generation_error.connect(controller.signal_handler._on_generation_error)
		
		# Completion signal connects directly to the Generation Logic to finalize the process
		controller.ssxl_signals.build_map_complete.connect(controller.gen_logic._on_build_map_complete_received)

>>> FILE END: SSXL_engine_tester\root_scripts\controlpaneluisetup.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\controlpanelutility.gd (155 LOC) <<<
======================================================
class_name control_panel_utility extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
# ⚠️ CRITICAL NODE CHECKING
# ------------------------------------------------------------------------------
func check_critical_nodes() -> bool:
	"""Checks if all core FFI and rendering nodes are present and valid."""
	var valid: bool = true
	var missing_nodes: Array[String] = []

	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false

	if not valid:
		var error_msg: String = "❌ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid

# ------------------------------------------------------------------------------
# ⌨️ INPUT HANDLING
# ------------------------------------------------------------------------------
func handle_input_event(event: InputEvent) -> void:
	"""Handles global input events delegated from _input()."""
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.keycode == KEY_SPACE:
			# Check if any input field is focused (prevent spacebar from activating buttons)
			var is_input_focused: bool = (is_instance_valid(controller.seed_input) and controller.seed_input.has_focus()) or \
										 (is_instance_valid(controller.grid_width) and controller.grid_width.has_focus()) or \
										 (is_instance_valid(controller.grid_height) and controller.grid_height.has_focus())
			
			if not is_input_focused:
				# Spacebar toggles the camera view between UI and Map
				toggle_camera_view()
				controller.get_viewport().set_input_as_handled()
				

# ------------------------------------------------------------------------------
# 🔄 REDRAW THROTTLING
# ------------------------------------------------------------------------------
func request_redraw() -> void:
	"""
	Starts the redraw throttle timer if not already running.
	Limits TileMap updates to the timer's wait_time (e.g., 10 FPS).
	"""
	if not controller.redraw_pending and is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.start()
		controller.redraw_pending = true

func _on_redraw_throttle_timeout() -> void:
	"""Forces a TileMap update when the throttle timer times out."""
	if controller.is_generating and is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	controller.redraw_pending = false


# ------------------------------------------------------------------------------
# 📷 CAMERA / UI TOGGLES (Delegated Logic)
# ------------------------------------------------------------------------------

func toggle_camera_view() -> void:
	"""The handler connected to the 'Animate/Toggle View' button and SPACEBAR."""
	# Toggle the current ID: 1 becomes 2, 2 becomes 1
	var new_camera_id: int = 2 if controller.current_camera_id == 1 else 1
	switch_to_camera_view(new_camera_id)

func switch_to_camera_view(target_id: int) -> void:
	"""
	Sets the camera to the target_id (1=UI, 2=Map View) and updates the controller state.
	This is called by both toggle_camera_view and gen_logic.
	"""
	if not is_instance_valid(controller.cameras) or not controller.cameras.has_method("switch_to_camera"):
		return
		
	controller.current_camera_id = target_id
	controller.cameras.switch_to_camera(controller.current_camera_id)
	print("Camera switched to: %d" % controller.current_camera_id)

func set_map_zoom_and_position() -> void:
	"""Positions the map camera (camera2) to center the generated map and calculates appropriate zoom."""
	if not is_instance_valid(controller.camera2) or not is_instance_valid(controller.grid_width) or not is_instance_valid(controller.grid_height):
		return
		
	var map_width_tiles: int = int(controller.grid_width.value)
	var map_height_tiles: int = int(controller.grid_height.value)
	
	var full_map_width: float = float(map_width_tiles) * controller.tile_size.x
	var full_map_height: float = float(map_height_tiles) * controller.tile_size.y

	# Center the camera on the map
	controller.camera2.global_position = Vector2(full_map_width / 2.0, full_map_height / 2.0)
	
	# Calculate zoom
	var viewport_size: Vector2 = controller.get_viewport_rect().size
	var zoom_factor: float = min(viewport_size.x / full_map_width, viewport_size.y / full_map_height) * 0.9
	
	controller.camera2.zoom = Vector2(clampf(zoom_factor, 0.05, 1.0), clampf(zoom_factor, 0.05, 1.0))
	controller.initial_zoom_set = true
	print("Camera 2 positioned and zoomed after generation.")


func on_toggle_terminal_button_pressed() -> void:
	"""Toggles the visibility and size of the control panel."""
	controller.panel_collapsed = !controller.panel_collapsed
	
	var target_y: float = 32.0 if controller.panel_collapsed else 300.0
	var button_text: String = "EXPAND 🔽" if controller.panel_collapsed else "COLLAPSE 🔼"
	
	# Apply changes
	controller.custom_minimum_size.y = target_y
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.text = button_text
	
	# Hide/Show all main controls when collapsed
	for child in controller.get_children():
		if child != controller.toggle_terminal_button and child is Control:
			child.visible = not controller.panel_collapsed


# ------------------------------------------------------------------------------
# 🧹 STATE MANAGEMENT & MISC UTILITIES
# ------------------------------------------------------------------------------

func on_clock_timer_timeout() -> void:
	"""Updates the clock label."""
	if is_instance_valid(controller.clock_label):
		controller.clock_label.text = "🕒 " + Time.get_datetime_string_from_system()

func reset_temporary_state() -> void:
	"""Resets generation-specific state flags and stops timers."""
	controller.is_generating = false
	controller.redraw_pending = false
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
		
	controller.engine_tick_count = 0
	
func clear_generation_state() -> void:
	"""Resets all generation-related counters and labels to zero/default."""
	reset_temporary_state() # Calls the basic reset
	
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "⏱️ Tile Placement Time: N/A"

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelutility.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\control_panel.gd (133 LOC) <<<
======================================================
# control_panel.gd
extends Control

# ------------------------------------------------------------------------------
# --- CHUNK & RENDER CONSTANTS ⚙️ ---
# ------------------------------------------------------------------------------
# These constants define the dimensions used by the Rust generation logic.
const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# ------------------------------------------------------------------------------
# 🧭 UI Node & External References (DATA HUB)
# ------------------------------------------------------------------------------
# All @onready references use explicit type hints for performance and clarity.
# UI Elements
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var animate_checkbox: CheckBox = $animatecheckbox
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton

# Timers
@onready var engine_timer: Timer = $enginetimer             # Fast poll when NOT animating
@onready var animation_timer: Timer = $AnimationTimer       # Animation loop when animating
@onready var redraw_throttle_timer: Timer = $redrawthrottle # Map Gen batch redraw

# Timer Labels
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene Tree Nodes (Critical Engine References)
@onready var main: Node2D = get_parent() as Node2D
# Use NodePath strings directly in @onready where possible for robust reference initialization
@onready var ssxl_engine: Node = main.get_node("SSXLEngine")
@onready var ssxl_oracle: Node = main.get_node("SSXLOracle")
@onready var ssxl_signals: Node = main.get_node("SSXLSignals") # <-- CRITICAL FIX: Named correctly!
@onready var expansive_tilemap: TileMap = main.get_node("expansive_tilemap") as TileMap
@onready var clock_label: Label = main.get_node("tilemap/clocklabel") as Label
@onready var clock_timer: Timer = main.get_node("tilemap/clocktimer") as Timer
@onready var tilemap_node: Node2D = main.get_node("tilemap") as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var camera1: Camera2D = main.get_node("cameras/camera1") as Camera2D
@onready var camera2: Camera2D = main.get_node("cameras/camera2") as Camera2D

# 📊 State Variables (Shared data)
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var is_animated: bool = false
var animation_tilemap_handle: TileMap = null # Initialize to null with explicit type

# 🔗 Composed Helper Scripts (Typed instantiation)
# Note: Type hints use the script resource's type for better safety
var ui_setup: control_panel_ui_setup
var gen_logic: control_panel_gen_logic
var signal_handler: control_panel_signal_handler
var animation_logic: control_panel_animation_logic
var utility: control_panel_utility


# ------------------------------------------------------------------------------
# 🧭 CORE LIFECYCLE (COORDINATION)
# ------------------------------------------------------------------------------

func _ready() -> void:
	# Use preload() for optimal, faster resource loading and type safety
	const SCRIPT_PATH = "res://root_scripts/"
	
	# 1. Instantiate Helper Scripts
	# Using preload().new() is generally faster than load().new()
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self) as control_panel_ui_setup
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self) as control_panel_gen_logic
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self) as control_panel_signal_handler
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self) as control_panel_animation_logic
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self) as control_panel_utility

	# 2. Critical Node Validation (Ensure engine and map are present)
	if not is_instance_valid(expansive_tilemap):
		push_error("❌ FATAL: Initialization Error: TileMap missing.")
		if is_instance_valid(status_label):
			status_label.text = "❌ FATAL: TileMap missing."
		return

	# Validate Engine references (Crucial for GDExtension FFI)
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals):
		push_error("❌ FATAL: SSXLEngine or SSXLSignals GDExtension nodes missing.")
		return

	# --- 3. Delegate Initialization Tasks ---
	ui_setup.setup_all()
	
	# Final ready steps
	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	var tileset: TileSet = expansive_tilemap.get_tileset()
	if tileset:
		tile_size = tileset.get_tile_size()

	# Initialize animation state
	if is_instance_valid(animate_checkbox):
		animation_logic.on_animate_checkbox_toggled(animate_checkbox.button_pressed)

	# --- 4. Connect Engine Signals to Handlers ---
	
	# High-Frequency Signals (Animation)
	# This signal is only connected here and in ui_setup.gd (for animation checkbox)
	# The animation logic relies on the GDExtension's ability to emit high-frequency data.
	ssxl_signals.tile_flip_updated.connect(animation_logic._on_tile_flip_updated) 
	
	# Status signal: check existence before connecting (Good practice preserved)
	if ssxl_signals.has_signal("engine_status_updated"):
		ssxl_signals.engine_status_updated.connect(signal_handler._on_engine_status_updated)
	else:
		push_error("❌ FATAL: Engine status signal not found. Check Rust GDExtension.")


	# --- 5. Connect Timers to Logic (Separating concerns) ---
	
	# Map Generation Redraw Throttling (Map Gen Draw)
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)

	# Animation/Polling Timers (Animation Draw & Status Polling)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)
	engine_timer.timeout.connect(animation_logic._on_engine_timer_timeout)
	
	# Ensure one polling mechanism is active
	animation_logic.setup_animation_worker(is_animated)


func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)


func _process(_delta: float) -> void:
	# Process polling is handled by timers. This remains empty, prioritizing
	# asynchronous Rust conduction over synchronous _process() polling.
	pass

>>> FILE END: SSXL_engine_tester\root_scripts\control_panel.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\engine_monitor.gd (37 LOC) <<<
======================================================
extends Node

# Use the more specific Node type hint for GDExtension nodes
var engine_ref: Node = null
var status: String = "Unknown"

# Links this monitor to the SSXLEngine node and establishes signal communication.
func set_engine(engine: Node) -> void:
	# 1. Disconnect safely if a previous engine was linked
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Check if the signal is ALREADY connected before trying to disconnect
		if engine_ref.status_updated.is_connected(Callable(self, "_on_status_updated")):
			engine_ref.status_updated.disconnect(Callable(self, "_on_status_updated"))

	# 2. Set the new engine reference
	engine_ref = engine
	print("✅ EngineMonitor: Engine linked.")

	# 3. Connect the signal (now guaranteed to connect only once)
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Use the modern signal syntax for cleaner code
		engine_ref.status_updated.connect(_on_status_updated)
		print("📶 EngineMonitor: Connected to 'status_updated' signal.")
	else:
		push_warning("⚠️ EngineMonitor: Engine missing 'status_updated' signal.")


# Polls the engine for its current status (used by the engine_timer).
func update_status() -> void:
	if not is_instance_valid(engine_ref):
		push_error("🚨 EngineMonitor: Engine not linked.")
		return

	# Check for the existence of the method (essential for FFI/GDExtension calls)
	if not engine_ref.has_method("get_status"):
		push_error("🚨 EngineMonitor: Engine missing 'get_status' method.")
		return

	# Use call() for safety when interacting with GDExtension
	status = engine_ref.call("get_status") as String
	print("📡 EngineMonitor: Polled status → %s" % status)


# Handler for the status_updated signal (Asynchronous update from Rust).
func _on_status_updated(status_msg: String) -> void:
	status = status_msg
	print("📡 EngineMonitor: Received status → %s" % status)

>>> FILE END: SSXL_engine_tester\root_scripts\engine_monitor.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\init.gd (22 LOC) <<<
======================================================
extends Node

var initialized_nodes: Array = []

func initialize():
	print("\n🎶 Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("❌ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	var tester := root_node.get_node("ssxltester")
	if tester == null:
		push_error("❌ Init: AetherionTester node not found. No one to receive the scroll.")
		return

	print("\n📜 Init: Scroll prepared. Delivering to AetherionTester...")
	tester.call("report_initialized", initialized_nodes)

func _recursive_initialize(node: Node) -> void:
	print("✨ Init: Blessing node → %s" % node.name)
	initialized_nodes.append(node)

	for child in node.get_children():
		if child is Node:
			_recursive_initialize(child)

>>> FILE END: SSXL_engine_tester\root_scripts\init.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\logger.gd (1 LOC) <<<
======================================================
extends Node

>>> FILE END: SSXL_engine_tester\root_scripts\logger.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\main.gd (70 LOC) <<<
======================================================
extends Node2D

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robustness)
# ----------------------------------------------------------------------

# System Nodes (Children of this Main node, must match GDExtension names)
@onready var ssxl_oracle: Node = $SSXLOracle
@onready var ssxl_engine: Node = $SSXLEngine
@onready var ssxl_signals: Node = $SSXLSignals

# Global Utility Nodes (Explicitly typed for performance)
@onready var clock_timer: Timer = $/root/ssxltester/main/tilemap/clocktimer
@onready var engine_monitor: Node = $/root/ssxltester/main/EngineMonitor

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Check for critical timer node before connecting
	if is_instance_valid(clock_timer):
		# Start the primary orchestration loop
		clock_timer.timeout.connect(_on_clock_tick)
		clock_timer.start()
	else:
		push_error("❌ Clock timer not found. Main orchestration failed to start.")
	
	# We call this here to ensure all engine links are established immediately
	# after the clock timer is configured.
	enter_idle_state()


# Initializes the links between the Godot-side controllers and the Rust GDExtension engine.
func enter_idle_state() -> void:
	print("\n🎬 Main: Entering idle state. Systems standing by...")

	# Validate all core systems before proceeding
	if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine) and is_instance_valid(engine_monitor):
		
		# --- 1. Oracle Link (Tells the Oracle which Engine to command) ---
		print("🔗 Linking Oracle to Engine...")
		ssxl_oracle.set_engine(ssxl_engine) 
		print("🔗 Oracle: Engine link established.")

		# --- 2. Monitor Link (Tells the Monitor which Engine to observe) ---
		print("📡 Linking EngineMonitor to Engine...")
		engine_monitor.set_engine(ssxl_engine)
		print("✅ EngineMonitor: Engine linked.")

		# --- 3. Signals Link (Tells the Engine which Godot Node to use for signal emission) ---
		if is_instance_valid(ssxl_signals):
			# 💡 FIX APPLIED: Changed AetherionSignals to SSXLSignals
			print("📶 Connecting Engine to SSXLSignals...")
			ssxl_engine.set_signals_node(ssxl_signals) 
			
			# The Monitor-Signal connection is trusted to happen within set_engine()
			print("✅ EngineMonitor connected to status signal.")
		else:
			push_warning("⚠️ SSXLSignals node not found. Signal emission connection skipped.")

		# --- 4. First Pulse ---
		# The Oracle's initial tick primes the Rust system's state machine.
		print("🔮 Oracle linked. Delivering first pulse...")
		ssxl_oracle.tick() 

		print("⚙️ Engine confirmed idle.")
	else:
		# Use push_error to make this visible in the debugger
		push_error("❌ Failed to link Core Systems (Oracle/Engine/Monitor). Invocation aborted.")


# ----------------------------------------------------------------------
## RUNTIME (Clock Tick)
# ----------------------------------------------------------------------

# Drives the core update loop for the engine and monitor systems.
func _on_clock_tick() -> void:
	print("🕰️ Clock tick.")

	if is_instance_valid(ssxl_oracle):
		# Tick the Oracle, which in turn commands the Rust engine
		ssxl_oracle.tick() 

	if is_instance_valid(engine_monitor):
		# Polls the engine for its current status (should be throttled or non-blocking)
		engine_monitor.update_status()

>>> FILE END: SSXL_engine_tester\root_scripts\main.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\main1.gd (100 LOC) <<<
======================================================
extends Node2D

# 🧭 Node references
@onready var control_panel: Control = get_node("/root/main/ControlPanel")
@onready var aetherion_engine: Node = get_node("/root/main/AetherionEngine")
@onready var aetherion_signals: Node = get_node("/root/main/AetherionSignals")
@onready var expansive_tilemap: TileMap = get_node("/root/main/Expansive_TileMap")
@onready var camera1: Camera2D = get_node("/root/main/Cameras/Camera1")
@onready var camera2: Camera2D = get_node("/root/main/Cameras/Camera2")
@onready var terminal_output: RichTextLabel = get_node_or_null("/root/main/ControlPanel/TerminalOutput")


# 📊 State
var dragging: bool = false
var active_camera: int = 1
var last_mouse_position: Vector2 = Vector2.ZERO
var tile_size: Vector2 = Vector2(16, 16)

func _ready() -> void:
	if not aetherion_signals.generation_complete.is_connected(_on_generation_complete):
		aetherion_signals.generation_complete.connect(_on_generation_complete)

	# 🛡️ Prevent duplicate Main nodes
	var main_nodes := get_tree().get_nodes_in_group("Main")
	if main_nodes.size() > 1:
		GlobalLogger.log("⚠️ Multiple Main nodes detected: %s" % main_nodes, "WARN")
		queue_free()
		return

	
	GlobalLogger.log("🟢 Main.gd is ready. AetherionEngine is idle.")
	GlobalLogger.log("⚠️ Multiple Main nodes detected: %s" % [main_nodes], "WARN")


	# 🎥 Camera configuration
	camera1.enabled = true
	camera1.make_current()
	camera2.enabled = false
	camera2.zoom = Vector2(1.0, 1.0)

	# 🔧 Initialize AetherionEngine
	aetherion_engine.set_signals_node(aetherion_signals)
	aetherion_engine.set_tilemap(expansive_tilemap)

	# 🧪 Debug: TileMap state
	GlobalLogger.log("TileMap position: %s" % expansive_tilemap.global_position)
	GlobalLogger.log("TileMap scale: %s" % expansive_tilemap.scale)
	GlobalLogger.log("TileMap layer enabled: %s" % expansive_tilemap.is_layer_enabled(0))
	GlobalLogger.log("TileMap tileset: %s" % expansive_tilemap.get_tileset())
	GlobalLogger.log("TileMap used rect: %s" % expansive_tilemap.get_used_rect())

	# 🧪 Debug: Camera states
	GlobalLogger.log("Camera1 position: %s" % camera1.global_position)
	GlobalLogger.log("Camera1 enabled: %s" % camera1.enabled)
	GlobalLogger.log("Camera1 is current: %s" % camera1.is_current())
	GlobalLogger.log("Camera2 position: %s" % camera2.global_position)
	GlobalLogger.log("Camera2 zoom: %s" % camera2.zoom)
	GlobalLogger.log("Camera2 enabled: %s" % camera2.enabled)
	GlobalLogger.log("Camera2 is current: %s" % camera2.is_current())

	# 🧠 TileSet analysis
	var tileset := expansive_tilemap.get_tileset()
	if tileset:
		tile_size = tileset.get_tile_size()
		GlobalLogger.log("TileSet tile size: %s" % tile_size)

		if tileset.get_source_count() > 0:
			var source := tileset.get_source(0)
			if source and source.is_class("TileSetAtlasSource"):
				var atlas_source := source as TileSetAtlasSource
				GlobalLogger.log("TileSet atlas grid size: %s" % atlas_source.get_atlas_grid_size())
				GlobalLogger.log("Tile (0, 0) exists: %s" % atlas_source.has_tile(Vector2i(0, 0)))
				GlobalLogger.log("Tile (1, 0) exists: %s" % atlas_source.has_tile(Vector2i(1, 0)))

func _toggle_camera() -> void:
	var status_label: Label = get_node("/root/main/ControlPanel/StatusLabel")

	if active_camera == 1:
		if camera2.is_inside_tree() and camera2.enabled:
			camera2.make_current()
			active_camera = 2
			status_label.text = "🧭 Switched to Map View"
			GlobalLogger.log("🎥 Camera2 is now active.")
		else:
			GlobalLogger.log("⚠️ Camera2 is not ready.", "WARN")
	else:
		if camera1.is_inside_tree() and camera1.enabled:
			camera1.make_current()
			active_camera = 1
			status_label.text = "🎛️ Returned to Control Panel"
			GlobalLogger.log("🎥 Camera1 is now active.")
		else:
			GlobalLogger.log("⚠️ Camera1 is not ready.", "WARN")

func _unhandled_input(event: InputEvent) -> void:
	#GlobalLogger.log("Active camera: %d | Zoom: %s" % [active_camera, camera2.zoom])

	if event is InputEventKey and event.pressed and event.keycode == KEY_SPACE:
		_toggle_camera()

	if active_camera == 2:
		if event is InputEventMouseButton:
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				camera2.zoom *= 0.9
			elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
				camera2.zoom *= 1.1

			camera2.zoom.x = clamp(camera2.zoom.x, 0.5, 5.0)
			camera2.zoom.y = clamp(camera2.zoom.y, 0.5, 5.0)

			if event.button_index == MOUSE_BUTTON_LEFT:
				dragging = event.pressed
				last_mouse_position = event.position

		if event is InputEventMouseMotion and dragging:
			var delta: Vector2 = event.position - last_mouse_position
			camera2.position -= delta / camera2.zoom
			last_mouse_position = event.position

func _on_generation_complete(results: Dictionary) -> void:
	GlobalLogger.log("🧭 Generation complete signal received.")
	_toggle_camera()

>>> FILE END: SSXL_engine_tester\root_scripts\main1.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\root.gd (22 LOC) <<<
======================================================
extends Node2D

var init_node: Node
var main_node: Node2D
var initialized_nodes: Array = []

func _ready():
	get_tree().get_root().print_tree()

	print("🚀 AetherionTester: Summoning subsystems...")

	init_node = get_node("init")
	main_node = get_node("main")

	if init_node == null:
		push_error("❌ AetherionTester: Init node not found.")
		return

	if main_node == null:
		push_error("❌ AetherionTester: Main node not found.")
		return

	print("🧭 AetherionTester: Launching initialization sequence...")
	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes
	print("✅ AetherionTester: Initialization complete. All nodes accounted for.")
	print("🎙️ AetherionTester: Delegating control to Main...")
	main_node.call("enter_idle_state")

>>> FILE END: SSXL_engine_tester\root_scripts\root.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\scenescanner.gd (10 LOC) <<<
======================================================
extends Node

signal tree_ready(map)

func scan_tree():
	var map = {}
	_recursive_scan(get_tree().root, map)
	emit_signal("tree_ready", map)

func _recursive_scan(node: Node, map: Dictionary):
	map[node.name.to_lower()] = node.get_path()
	for child in node.get_children():
		_recursive_scan(child, map)

>>> FILE END: SSXL_engine_tester\root_scripts\scenescanner.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\root_scripts\tester.gd (5 LOC) <<<
======================================================
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

>>> FILE END: SSXL_engine_tester\root_scripts\tester.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\test_scripts\control_panel.gd (23 LOC) <<<
======================================================
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

>>> FILE END: SSXL_engine_tester\test_scripts\control_panel.gd <<<

======================================================
>>> FILE START: SSXL_engine_tester\test_scripts\test_ffi_data.gd (72 LOC) <<<
======================================================
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("✅ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("❌ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

>>> FILE END: SSXL_engine_tester\test_scripts\test_ffi_data.gd <<<

