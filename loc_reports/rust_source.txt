>>> FILE START: rust\cargo.toml (77 LOC) <<<
[workspace]
# Defines the members (crates) of the SSXL Engine workspace, grouped by
# their architectural layer as defined in the development plan.
members = [
    # 1. Foundation Layer (Core Data & Primitives - P1)
    "ssxl_shared",
    "ssxl_math",
    "ssxl_sync",

    # 2. Processing Layer (Computation & Persistence - P2)
    "ssxl_generate",
    "ssxl_cache",

    # 3. Interface Layer (External Bridges - P3)
    "ssxl_engine_ffi",
    "ssxl_godot",

    # 4. Tooling & Execution Layer
    "ssxl_tools",
    "ssxl_cli",
	"ssxl_animate",
]
resolver = "2" # Use the new cargo feature resolver

[workspace.package]
edition = "2021"
license = "MIT OR Apache-2.0"
rust-version = "1.75" # Set a standard base Rust version

[workspace.dependencies]
# ------------------------------------------------------------------
# CORE UTILITIES & DATA MANAGEMENT
# ------------------------------------------------------------------
serde               = { version = "1.0", features = ["derive"] }
serde_json          = "1.0"
serde-big-array = "0.4.1"
bincode             = "1.3"
thiserror           = "1.0"  # Canonical error definition (used by aetherion_shared)
uuid                = { version = "1.8", features = ["v4", "fast-rng"] }
# FIX: Added anyhow to workspace dependencies to resolve the inheritance error.
anyhow              = "1.0" 

# ------------------------------------------------------------------
# TRACING AND DIAGNOSTICS
# ------------------------------------------------------------------
tracing             = "0.1" # Core tracing library (replaces 'log')
tracing-subscriber  = "0.3" # Used to manage and output tracing data (replaces 'env_logger')

# ------------------------------------------------------------------
# TIME, RANDOMNESS, AND PARSING
# ------------------------------------------------------------------
chrono              = { version = "0.4", features = ["serde"] } 
rand                = { version = "0.8", features = ["small_rng"] }
rand_pcg            = "0.9"
nom                 = "7.1"
regex               = "1.11"
once_cell           = "1.19" # Preferred over lazy_static for statics

# ------------------------------------------------------------------
# CONCURRENCY AND MATH
# ------------------------------------------------------------------
tokio               = { version = "1.37", features = ["sync", "rt-multi-thread", "macros"] } # The primary async runtime
rayon               = "1.10" # Used for parallel synchronous processing
crossbeam           = "0.8"
crossbeam-channel   = "0.5"
parking_lot         = "0.12" # High-performance synchronization primitives
glam                = "0.28" # High-performance linear algebra library (Vectors, Matrices)
sha2                = "0.10"
image               = "0.24" # For image processing in aetherion_tools
noise               = "0.9"
async-trait         = "0.1"
# ------------------------------------------------------------------
# CLI AND CONSOLE UTILITIES
# ------------------------------------------------------------------
crossterm           = "0.27" 
walkdir             = "2.5" 
ctrlc               = "3.4"
godot = { path = "../../zv9.gdext/godot", features = ["serde"] } 
godot-ffi = { path = "../../zv9.gdext/godot-ffi", features = ["api-custom"] }
fastrand = "2.0"
num_cpus = "1.17.0"

[workspace.lints.rust]
unsafe_code      = "deny"
unused_variables = "warn"
dead_code        = "warn"


<<< FILE END: rust\cargo.toml >>>

>>> FILE START: rust\manifest.rs (148 LOC) <<<
SSXL-ext is a mythic core — a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ →).

🪶 Manifest v9.0.seed


#files


FullName                                                                     Type Length
--------                                                                     ---- ------
C:\zv9\zv9.ssxl-ext\rust\.cargo                                              Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate                                        Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_cache                                          Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli                                            Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_config                                         Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_engine_ffi                                     Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate                                       Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot                                          Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_math                                           Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared                                         Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync                                           Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_tools                                          Dir
C:\zv9\zv9.ssxl-ext\rust\Cargo.lock                                          File 46266
C:\zv9\zv9.ssxl-ext\rust\cargo.toml                                          File 3480
C:\zv9\zv9.ssxl-ext\rust\manifest.rs                                         File 11749
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\src                                    Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\Cargo.toml                             File 615
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\src\animation_logic.rs                 File 6001
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\src\conductor.rs                       File 4342
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\src\lib.rs                             File 2751
C:\zv9\zv9.ssxl-ext\rust\ssxl_animate\src\worker.rs                          File 3181
C:\zv9\zv9.ssxl-ext\rust\ssxl_cache\src                                      Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_cache\Cargo.toml                               File 400
C:\zv9\zv9.ssxl-ext\rust\ssxl_cache\src\lib.rs                               File 4564
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src                                        Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\Cargo.toml                                 File 1353
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions                                Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\cli_util_bench.rs                      File 5908
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\cli_util_inspect.rs                    File 7527
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\cli_util_loc.rs                        File 6953
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\cli_util_menu.rs                       File 7871
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\main.rs                                File 6282
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\actions.rs                     File 7267
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\benchmarking.rs                File 3000
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\godot_harness.rs               File 5751
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\mod.rs                         File 3635
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\testing.rs                     File 2774
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\test_core_suites.rs            File 8648
C:\zv9\zv9.ssxl-ext\rust\ssxl_cli\src\actions\test_suites.rs                 File 5738
C:\zv9\zv9.ssxl-ext\rust\ssxl_config\src                                     Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_config\src\engine.toml                         File 599
C:\zv9\zv9.ssxl-ext\rust\ssxl_engine_ffi\src                                 Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_engine_ffi\Cargo.toml                          File 643
C:\zv9\zv9.ssxl-ext\rust\ssxl_engine_ffi\src\lib.rs                          File 7035
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src                                   Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\Cargo.toml                            File 979
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\ca                                Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\conductor                         Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager                           Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\perlin                            Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\task                              Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\lib.rs                            File 2618
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\ca\cellular_automata_generator.rs File 9325
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\ca\mod.rs                         File 1148
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\ca\neighbor_check.rs              File 2952
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\ca\rule_set.rs                    File 2898
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\conductor\conductor.rs            File 9841
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\conductor\conductor_state.rs      File 1923
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\conductor\mod.rs                  File 400
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\conductor\sync.rs                 File 1209
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager\config_validator.rs       File 2447
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager\generator.rs              File 1617
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager\generator_manager.rs      File 4421
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager\mod.rs                    File 318
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\manager\runtime_manager.rs        File 1114
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\perlin\mod.rs                     File 120
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\perlin\perlin_generator.rs        File 4522
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\task\batch_processor.rs           File 3163
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\task\benchmark_logic.rs           File 1007
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\task\mod.rs                       File 216
C:\zv9\zv9.ssxl-ext\rust\ssxl_generate\src\task\task_queue.rs                File 5362
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src                                      Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\Cargo.toml                               File 1031
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\anim                                 Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine                               Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\ffi                                  Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\tilemap                              Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\lib.rs                               File 2120
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\anim\animation_api.rs                File 1279
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\api.rs                        File 1245
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\api_initializers.rs           File 4342
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\cleanup.rs                    File 1404
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\commands.rs                   File 1704
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\init.rs                       File 9776
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\mod.rs                        File 910
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\poller.rs                     File 3198
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\query.rs                      File 1695
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\query_data.rs                 File 1283
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\render_batch.rs               File 2684
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\state.rs                      File 4166
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\engine\tick.rs                       File 3609
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\ffi\gde_api_defs.rs                  File 3018
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\ffi\mod.rs                           File 160
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\ffi\oracle.rs                        File 3568
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\ffi\signals.rs                       File 1513
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\tilemap\async_poll.rs                File 4352
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\tilemap\mod.rs                       File 310
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\tilemap\ssxl_tilemap.rs              File 2674
C:\zv9\zv9.ssxl-ext\rust\ssxl_godot\src\tilemap\status_reporter.rs           File 2797
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src                                       Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\Cargo.toml                                File 607
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src\coordinate_system.rs                  File 6677
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src\generation_utils.rs                   File 2729
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src\hashing.rs                            File 4662
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src\lib.rs                                File 2441
C:\zv9\zv9.ssxl-ext\rust\ssxl_math\src\primitives.rs                         File 2779
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src                                     Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\cargo.toml                              File 501
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\chunk                               Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\config                              Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\error                               Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\job                                 Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\math                                Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\message                             Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\tile                                Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\lib.rs                              File 3607
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\chunk\chunk_data.rs                 File 10247
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\chunk\grid_bounds.rs                File 2676
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\chunk\mod.rs                        File 76
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\config\config.rs                    File 1106
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\config\mod.rs                       File 51
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\error\errors.rs                     File 3182
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\error\mod.rs                        File 50
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\job\mod.rs                          File 1514
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\math\math_primitives.rs             File 2146
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\math\mod.rs                         File 58
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\message\generation_message.rs       File 2357
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\message\messages.rs                 File 4299
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\message\mod.rs                      File 83
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\tile\mod.rs                         File 72
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\tile\tile_data.rs                   File 5448
C:\zv9\zv9.ssxl-ext\rust\ssxl_shared\src\tile\tile_type.rs                   File 4264
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\src                                       Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\Cargo.toml                                File 928
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\src\animation_conductor.rs                File 4721
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\src\lib.rs                                File 3538
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\src\pool.rs                               File 6417
C:\zv9\zv9.ssxl-ext\rust\ssxl_sync\src\primitives.rs                         File 928
C:\zv9\zv9.ssxl-ext\rust\ssxl_tools\src                                      Dir
C:\zv9\zv9.ssxl-ext\rust\ssxl_tools\Cargo.toml                               File 293
C:\zv9\zv9.ssxl-ext\rust\ssxl_tools\src\lib.rs                               File 6432

<<< FILE END: rust\manifest.rs >>>

>>> FILE START: rust\ssxl_animate\Cargo.toml (21 LOC) <<<
# ssxl_animate/Cargo.toml

[package]
name = "ssxl_animate"
version = "0.1.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }

# --- EXTERNAL DEPENDENCIES ---

# CORE GDExtension BINDINGS
godot = { workspace = true }
godot-ffi = { workspace = true }
# Workspace standard logging framework
tracing = { workspace = true }
tokio = { workspace = true }
rand = { workspace = true }
async-trait = { workspace = true }

# customs
rayon = { workspace = true }
parking_lot = { workspace = true }




<<< FILE END: rust\ssxl_animate\Cargo.toml >>>

>>> FILE START: rust\ssxl_animate\src\animation_logic.rs (84 LOC) <<<
// ssxl_animate/src/animation_logic.rs (Final Optimized)

use ssxl_shared::{
    AnimationType,
    AnimationUpdate, 
    ChunkData,
    ChunkId,
    TileCoord,
    // FIX: Removed unused import `TileData`
    // FIX: Removed unused import `AnimationPayload` since it's used with fully qualified path (AnimationPayload::*)
    // FIX: Removed unused import `TileData`
};
// FIX: Removed unused import `ssxl_math::Vec2i`

use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;

fn calculate_tile_coords_for_chunk(chunk_data: &ChunkData, chunk_id: ChunkId) -> Vec<TileCoord> {
    chunk_data.tiles.iter().enumerate().map(|(index, _)| {
        TileCoord {
            x: (chunk_id.x * 16) + (index % 16) as i64,
            y: (chunk_id.y * 16) + (index / 16) as i64,
        }
    }).collect()
}

// FIX: Removed unused function `calculate_tween_value`
/*
fn calculate_tween_value(_coord: TileCoord, intensity: f32) -> f32 {
    1.0 * intensity
}
*/

fn get_tiles_for_chunk(chunk_id: ChunkId) -> Vec<TileCoord> {
    let cache_lock = TileCache::get_instance();
    let cache = cache_lock.read();

    if let Some(chunk_data) = cache.get(&chunk_id) {
        calculate_tile_coords_for_chunk(chunk_data, chunk_id)
    } else {
        Vec::new()
    }
}

pub struct TileCache;

impl TileCache {
    pub fn get_instance() -> Arc<RwLock<HashMap<ChunkId, ChunkData>>> {
        let mut map = HashMap::new();
        
        let mock_chunk_data = ChunkData { 
            id: 0,
            bounds: Default::default(),
            // The TileData type is still implicitly needed here for the array definition,
            // but the import was removed because it was only referenced as a type inside
            // an array literal, not as a standalone item/function/macro.
            tiles: [Default::default(); 1024], 
            dimension_tag: "Default".into(),
            generated_at: std::time::SystemTime::now(),
        };
        map.insert(ChunkId { x: 0, y: 0 }, mock_chunk_data);
        Arc::new(RwLock::new(map))
    }
}

pub fn execute_for_chunk(chunk_id: ChunkId, anim_type: AnimationType) -> Vec<AnimationUpdate> {
    let tiles_in_chunk: Vec<TileCoord> = get_tiles_for_chunk(chunk_id);
    let mut updates = Vec::with_capacity(tiles_in_chunk.len());

    for coord in tiles_in_chunk {
        let (source_id_u32, _new_atlas_coords_i32) = match anim_type {
            AnimationType::TileFlip => {
                let new_frame = (coord.x.wrapping_add(coord.y) % 4) as u32;
                (new_frame, 0)
            },
            AnimationType::PulseFade(_intensity) => {
                (0, 0)
            }
            // `continue` jumps to the next iteration of the `for` loop, skipping the update push.
            AnimationType::TweenMove | AnimationType::CustomScripted(_) => continue, 
        };
        
        // Use fully qualified path for AnimationPayload to avoid re-importing it.
        let payload = ssxl_shared::AnimationPayload::FrameUpdate {
            new_frame: source_id_u32,
        };

        updates.push(AnimationUpdate { 
            coord,
            payload,
        });
    }
    updates
}
<<< FILE END: rust\ssxl_animate\src\animation_logic.rs >>>

>>> FILE START: rust\ssxl_animate\src\conductor.rs (89 LOC) <<<
// rust/ssxl_animate/src/conductor.rs

use crate::{ConductorBehavior, AnimationCommand, CommandResult, AnimationState, UpdateSender};
use crate::worker::process_command_parallel; // CRITICAL: Import the delegation function
use async_trait::async_trait;
use tokio::sync::mpsc::UnboundedReceiver;
use godot::prelude::godot_print; // Assuming godot_print is available for logging

/// The core, single-threaded struct responsible for managing all animation workers.
/// It holds the Receiver for commands and the Sender for updates to the Godot main thread.
pub struct AnimationConductor {
    // The Receiver side of the command channel
    command_rx: UnboundedReceiver<AnimationCommand>,
    // This Sender is USED to pass to the worker.
    update_tx: UpdateSender, 
    state: AnimationState,
}

impl AnimationConductor {
    pub fn new(
        command_rx: UnboundedReceiver<AnimationCommand>,
        update_tx: UpdateSender,
        initial_state: AnimationState,
    ) -> Self {
        AnimationConductor {
            command_rx,
            update_tx,
            state: initial_state,
        }
    }

    /// Synchronously stops the animation by immediately updating the internal state.
    ///
    /// This method is designed to be called when the Conductor is locked via a Mutex.
    /// It functions as the **animation equivalent** of the `stop_generation` command.
    /// It relies on the external `AnimationState` struct having a `set_enabled(bool)` method.
    pub fn stop_animation(&mut self) -> CommandResult {
        self.state.set_enabled(false);
        godot_print!("Animation Conductor: Synchronous stop command received. State set to disabled.");
        Ok(())
    }
}

#[async_trait]
impl ConductorBehavior for AnimationConductor {
    async fn start_loop(&mut self) {
        // The main event loop for the Conductor. This loop manages the **tempo**.
        // It awaits a command, then immediately processes it (delegates) or acts on it (state change).
        while let Some(command) = self.command_rx.recv().await {
            let _ = self.process_command(command);
        }
    }

    /// Processes a command, delegating heavy computation to the worker pool.
    /// This function MUST return quickly to keep the Conductor's tempo fast.
    fn process_command(&mut self, command: AnimationCommand) -> CommandResult {
        match command {
            // ----------------------------------------------------
            // 1. Delegate High-Performance Work (Tile Updates)
            // ----------------------------------------------------
            AnimationCommand::AnimateChunkSet { .. } | AnimationCommand::StartTestAnimation => {
                // CRITICAL OPTIMIZATION: Delegate work and clone the sender for the worker
                process_command_parallel(command, self.update_tx.clone());
                Ok(())
            }
            // ----------------------------------------------------
            // 2. Local State Management (FIX E0004)
            // ----------------------------------------------------
            AnimationCommand::SetTimeScale(scale) => {
                // NOTE: This state update is safe because it only runs on the async Conductor thread.
                self.state.set_time_scale(scale); 
                Ok(())
            }
            // FIX E0004: Handle the new SetEnabled command
            AnimationCommand::SetEnabled(enabled) => {
                // NOTE: Requires `set_enabled(bool)` to be implemented on `AnimationState`.
                // This updates the local state which can be queried by `get_state()`.
                self.state.set_enabled(enabled);
                godot_print!("Animation Conductor: is_enabled set to {}", enabled);
                Ok(())
            }
            // ----------------------------------------------------
            // 3. System Commands
            // ----------------------------------------------------
            AnimationCommand::Shutdown => {
                // Close the receiver, which will gracefully exit the start_loop
                self.command_rx.close();
                Ok(())
            }
        }
    }

    fn get_state(&self) -> AnimationState {
        self.state.clone()
    }
}
<<< FILE END: rust\ssxl_animate\src\conductor.rs >>>

>>> FILE START: rust\ssxl_animate\src\lib.rs (60 LOC) <<<
//! # ssxl_animate
//!
//! This crate contains the **Animation Conductor** and associated logic responsible for
//! managing all real-time visual updates, tweens, and complex tile animations for the
//! SSXL-ext engine. It operates asynchronously, feeding updates back to the Godot
//! main thread via non-blocking communication channels.

// --- Standard Library & External Crates ---
use tracing::info;
use std::sync::{Arc, Mutex};
use async_trait::async_trait;
use tokio::sync::mpsc; // CRITICAL: Used for the asynchronous, non-blocking channel

// --- SSXL Internal Crates (Contracts and Types) ---
// FIX: All contracts, including the FFI handles, are now imported from ssxl_shared.
use ssxl_shared::{
    AnimationCommand,
    UpdateSender,
    // Removed unused import: AnimationType,
    AnimationConductorHandle, // Now resolved from ssxl_shared/src/lib.rs re-export
    AnimationState,           // Now resolved from ssxl_shared/src/lib.rs re-export
    CommandResult,            // Now resolved from ssxl_shared/src/lib.rs re-export
};

// --- Internal Modules ---
pub mod conductor;
mod worker;
mod animation_logic;


// -----------------------------------------------------------------------------
// Core Public API
// -----------------------------------------------------------------------------

pub use conductor::AnimationConductor;

/// Defines the primary trait for the Animation Conductor.
/// This trait enforces the necessary async structure for the runtime.
#[async_trait]
pub trait ConductorBehavior: Send + Sync + 'static {
    async fn start_loop(&mut self);

    fn process_command(&mut self, command: AnimationCommand) -> CommandResult;

    fn get_state(&self) -> AnimationState;
}

/// Initializes and returns the necessary components for the Animation Conductor.
///
/// Returns: (Command Handle, Arc<Mutex<Conductor>>)
/// The Handle is sent to the Godot FFI layer (`ssxl_sync`) to send commands.
pub fn initialize_animation_conductor(
    update_tx: UpdateSender,
    initial_state: AnimationState,
) -> (AnimationConductorHandle, Arc<Mutex<AnimationConductor>>) {
    info!("ssxl_animate: Initializing Animation Conductor circuit.");
    
    // Wire the command channel: The primary control line
    let (command_tx, command_rx) = mpsc::unbounded_channel();
    
    let handle: AnimationConductorHandle = command_tx; 

    // Create the core conductor structure which owns the Receiver (command_rx).
    let conductor = AnimationConductor::new(
        command_rx, 
        update_tx,
        initial_state,
    );

    // Conductor is wrapped in Arc<Mutex> for safe shutdown/runtime management.
    (handle, Arc::new(Mutex::new(conductor)))
}
<<< FILE END: rust\ssxl_animate\src\lib.rs >>>

>>> FILE START: rust\ssxl_animate\src\worker.rs (52 LOC) <<<
// ssxl_animate/src/worker.rs (Optimized Imports)

use rayon::prelude::*;
use tracing::info;

// FIX: Removed unused imports: `AnimationPayload`, `TileCoord`, and `AnimationUpdate as AnimationResultUpdate`.
// Only keeping the types used explicitly as standalone types: `AnimationCommand`, `ChunkId`, and `UpdateSender`.
use ssxl_shared::{AnimationCommand, ChunkId, UpdateSender};
use ssxl_shared::message::messages::AnimationUpdate as ChannelUpdate;

use crate::animation_logic;

/// Initializes the global Rayon thread pool for maximal data parallelism.
#[allow(dead_code)]
pub fn initialize_worker_pool(count: usize) {
    if rayon::ThreadPoolBuilder::new()
        .num_threads(count)
        .build_global()
        .is_ok()
    {
        info!("Animation worker pool (Rayon) initialized with {} threads.", count);
    } else {
        info!("Animation worker pool (Rayon) found or failed to initialize.");
    }
}

/// Executes the animation command in parallel, delegating work immediately off
/// the Conductor's async thread to the Rayon pool.
pub fn process_command_parallel(
    command: AnimationCommand, 
    update_tx: UpdateSender
) {
    if let AnimationCommand::AnimateChunkSet { chunk_ids, anim_type } = command {
        
        std::thread::spawn(move || {
            chunk_ids.par_iter().for_each(|&chunk_id: &ChunkId| {
                
                let tile_updates = 
                    animation_logic::execute_for_chunk(chunk_id, anim_type.clone());
                
                // ssxl_shared::AnimationUpdate (the element type of tile_updates)
                // fields are used directly to construct the ChannelUpdate.
                for update in tile_updates {
                    
                    let converted_update = ChannelUpdate {
                        // The field is now `coord`.
                        coord: update.coord,
                        // The payload is now fully formed.
                        payload: update.payload,
                    };

                    let _ = update_tx.send(converted_update).ok(); 
                }
            });

            info!("Finished parallel processing for chunk set.");
        });
    }
}
<<< FILE END: rust\ssxl_animate\src\worker.rs >>>

>>> FILE START: rust\ssxl_cache\Cargo.toml (13 LOC) <<<
[package]
name = "ssxl_cache"
edition = "2021"

[dependencies]
# Internal Dependencies (Local Crates)
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_sync = { path = "../ssxl_sync" }

# External Dependencies (Workspace-Inherited)
bincode = { workspace = true }
sha2 = { workspace = true }
glam = { workspace = true }
tracing = { workspace = true }

<<< FILE END: rust\ssxl_cache\Cargo.toml >>>

>>> FILE START: rust\ssxl_cache\src\lib.rs (123 LOC) <<<
use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
// FIX: Import ChunkData directly from the root of ssxl_shared.
use ssxl_shared::ChunkData;
use std::collections::HashMap;
use std::io;
use std::sync::{Arc, RwLock}; 
use tracing::{info, warn};
use glam::I64Vec3; 

type CacheMap = HashMap<ChunkKey, Arc<ChunkData>>;

const REGION_SIZE: i64 = 64;

type RegionKey = ChunkKey;
type RegionList = RwLock<Vec<ChunkKey>>;
type RegionMap = HashMap<RegionKey, Arc<RegionList>>;


#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<RegionMap>,
}

impl RegionIndex {
    fn new() -> Self {
        Self {
            storage: AtomicResource::new(RegionMap::new()),
        }
    }
    
    #[inline]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let rx = chunk_key.0.x / REGION_SIZE; 
        let ry = chunk_key.0.y / REGION_SIZE; 
        let rz = chunk_key.0.z / REGION_SIZE; 

        ChunkKey(I64Vec3 { x: rx, y: ry, z: rz })
    }

    pub fn get_chunks_in_region(&self, region_key: &RegionKey) -> Option<Arc<RegionList>> {
        let map = self.storage.read();
        map.get(region_key).map(Arc::clone)
    }

    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let mut map_lock = self.storage.write();

        let list_lock_arc = map_lock.entry(region_key)
            .or_insert_with(|| Arc::new(RwLock::new(Vec::new())))
            .clone();
        
        drop(map_lock); 

        {
            // CRITICAL FIX: The use of an explicit scope block forces the guard to drop.
            // Using `if let` here instead of `match` makes the expression end early.
            if let Ok(mut list) = list_lock_arc.write() {
                list.push(chunk_key);
            } else {
                warn!("Region list lock poisoned for {:?}: {}", region_key, "write error");
            };
        }
    }
    
    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        
        let list_lock_arc = {
            let map = self.storage.read();
            map.get(&region_key).map(Arc::clone)
        };

        if let Some(list_lock_arc) = list_lock_arc {
            
            match list_lock_arc.write() {
                Ok(mut list) => {
                    if let Some(pos) = list.iter().position(|k| *k == chunk_key) {
                        list.remove(pos);
                        
                        if list.is_empty() {
                            drop(list); 
                            let mut map_write = self.storage.write();
                            map_write.remove(&region_key);
                            info!("Removed empty region key from index: {:?}", region_key);
                        }
                        return true;
                    }
                },
                Err(e) => {
                    warn!("Region list lock poisoned during removal for {:?}: {}", region_key, e);
                }
            }
        }
        
        false
    }
}

#[derive(Debug, Clone)]
pub struct ChunkCache {
    storage: AtomicResource<CacheMap>,
    region_index: RegionIndex,
    max_capacity: usize,
}

impl ChunkCache {
    pub fn new(max_chunks: usize) -> Result<Self, io::Error> {
        info!("Initializing ChunkCache and RegionIndex with max_chunks: {}", max_chunks);
        
        Ok(ChunkCache { 
            storage: AtomicResource::new(CacheMap::new()), 
            region_index: RegionIndex::new(),
            max_capacity: max_chunks,
        })
    }

    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<Arc<ChunkData>>, io::Error> {
        let map = self.storage.read();
        Ok(map.get(key).map(Arc::clone))
    }

    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> Result<(), io::Error> {
        let mut map = self.storage.write();

        if map.len() >= self.max_capacity {
            warn!("ChunkCache capacity limit ({}) reached. LRU eviction is required to prevent OOM.", self.max_capacity);
        }
        
        if map.insert(*key, data).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
            
            self.region_index.insert_key(*key);
        } else {
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }
}
<<< FILE END: rust\ssxl_cache\src\lib.rs >>>

>>> FILE START: rust\ssxl_cli\Cargo.toml (34 LOC) <<<
[package]
name = "ssxl_cli"
version = "0.6.0"
edition = "2021"

[[bin]]
name = "ssxl"
path = "src/main.rs"

[dependencies]
# --- INTERNAL DEPENDENCIES (Foundation & FFI) ---
# CLI needs access to all core data types for diagnostics and the FFI layer to test the runtime.
ssxl_shared     = { path = "../ssxl_shared" }
ssxl_engine_ffi = { path = "../ssxl_engine_ffi" }
ssxl_tools      = { path = "../ssxl_tools" }
ssxl_generate   = { path = "../ssxl_generate" }
ssxl_math   = { path = "../ssxl_math" }

# --- EXTERNAL DEPENDENCIES (Execution & UI) ---
# Asynchronous runtime and macros
tokio           = { workspace = true, features = ["rt-multi-thread", "macros"] }
# Workspace standard logging framework (replaces log/env_logger)
tracing         = { workspace = true }
# Time utilities, often needed for logging/benchmarking output
chrono          = { workspace = true }
# Interactive Console UI library
crossterm       = { workspace = true }
# File system traversal (for module tree inspector)
walkdir         = { workspace = true }
# Parallel processing (for running benchmarks)
rayon           = { workspace = true }
# Regular expressions (for any complex parsing tasks)
regex           = { workspace = true }
tracing-subscriber = { workspace = true }
ctrlc           = { workspace = true }
bincode = { workspace = true }
serde = { workspace = true }
<<< FILE END: rust\ssxl_cli\Cargo.toml >>>

>>> FILE START: rust\ssxl_cli\src\cli_util_bench.rs (140 LOC) <<<
use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc, 
    atomic::{AtomicU64, Ordering}
};
use std::io::{self, Write};
use std::time::Duration;

use ssxl_generate::benchmark_generation_workload;
use ssxl_generate::conductor::Conductor;
use ssxl_math::Vec2i;

pub fn test_generation_and_placement_cli() {
    warn!("🧪 Running CLI Test: Generation and Placement (Conductor Validation)...");

    let (mut conductor, _state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    let perlin_id = "perlin_basic_2d";
    if conductor.set_active_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            let _chunk = conductor.generate_single_chunk(coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    let ca_id = "cellular_automata_basic";
    if conductor.set_active_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.generate_single_chunk(coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    if chunks_generated > 0 {
        info!("✅ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).", 
            chunks_generated, 
            conductor.get_active_generator_id() 
        );
    } else {
        error!("❌ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    conductor.graceful_teardown();
}


pub fn run_bitmask_conversion() {
    warn!("🧪 Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("✅ Conversion complete. Tiles placed: {}", tiles_placed);
}

pub fn run_max_grid_benchmark() {
    warn!("🧪 Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000;

    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone); 
    });

    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            let throughput = if elapsed > 0.0 { 
                (current as f64 / elapsed).round() as u64 
            } else { 
                0 
            };

            print!("\r⏳ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s", 
                percentage, 
                current / 1_000_000,
                WORKLOAD_TILES / 1_000_000,
                throughput
            );
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    let start = Instant::now();
    
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        let _ = println!("\r❌ Benchmark failed: Generation thread panic. {: <100}", " "); 
        return; 
    }
    
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    println!("\r✅ Benchmark complete. Workload: {} tiles. Duration: {:.2}s", 
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("⚡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("⚡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("🚀 CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("📈 Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("⚠️ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("❌ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}
<<< FILE END: rust\ssxl_cli\src\cli_util_bench.rs >>>

>>> FILE START: rust\ssxl_cli\src\cli_util_inspect.rs (157 LOC) <<<
use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;


pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| 🌲 RUST WORKSPACE MODULE TREE (Scanning...)                            |");
	println!("=========================================================================");
	
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n🔍 Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "├── [CORE] "
                            } else {
                                "│   └── "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


pub fn print_godot_api_surface() {
	// --- STRATEGIC UPDATE: INCLUDE FFI CORE ---
	let godot_api_files: [&str; 4] = [
        "ssxl_godot/src/ssxl_engine.rs",
        "ssxl_godot/src/ssxl_oracle.rs",
        "ssxl_godot/src/ssxl_signals.rs",
        "ssxl_engine_ffi/src/lib.rs", // CRITICAL: Captures C-Bindings
    ];

    println!("🧪 API scan triggered (targeting {} files in ssxl_godot/src/ and FFI core)...", godot_api_files.len());
    
	// --- MASTER REGEX FOR ALL CALLABLE METHODS (FIXED ESCAPING) ---
    let method_regex = Regex::new(
        // FIX: Removed the erroneous backslashes around the "C" literal (i.e., \"C\" -> "C")
        // and using a robust raw string literal r#""# to prevent any further escaping issues.
        r#"(?s)(?:\s*#\[func\].*?|#\[no_mangle\].*?pub\s+extern\s+"C"\s*)\s*(?:pub\s+fn|fn)\s+(\w+)\s*(\([^\{]*)\s*(?:->\s*([^\{]*))?"#
    ).unwrap();

	// Signal regex remains robust for line-based #[signal] definitions
    let signal_signature_regex = Regex::new(
        r"^\s*fn\s+(\w+)\s*(\([^;]*)\s*;\s*$"
    ).unwrap();
    let signal_marker_regex = Regex::new(r"^\s*#\[signal\]\s*$").unwrap();
    
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();
    let mut api_signals: Vec<(String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        
        let mut signal_line_pending = false;

        match fs::read_to_string(path) {
            Ok(contents) => {
                info!("Successfully read {}", path.display());
                
				// --- METHOD SCAN (Single Pass over File Content) ---
                for cap in method_regex.captures_iter(&contents) {
                    let method_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                    let args = cap.get(2)
                        .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                        .unwrap_or_default();
                    let return_type = cap.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                    
                    // Simple cleanup for args
                    let clean_args = args.replace("self, ", "self,").trim().trim_start_matches("self").trim_start_matches(",").trim().to_string();

                    api_methods.push((method_name, clean_args, return_type, file_name.to_string()));
                }


				// --- SIGNAL SCAN (Line-by-Line, No Change Needed) ---
                for line in contents.lines() {
                    let trimmed_line = line.trim();

                    if signal_marker_regex.is_match(trimmed_line) {
                        signal_line_pending = true;
                        continue;
                    }
                    
                    if signal_line_pending {
                        if let Some(captures) = signal_signature_regex.captures(trimmed_line) {
                            let signal_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_signal").to_string();
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            api_signals.push((signal_name, args, file_name.to_string()));
                            signal_line_pending = false; 
                        } else if !trimmed_line.is_empty() {
                            signal_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- 🎮 SSXL Engine Developer MASTER API Surface ---");
    
    println!("\n✅ Callable Methods ({} total):", api_methods.len());
    if api_methods.is_empty() {
        warn!("  No callable methods found in targeted files (check FFI core!).");
    } else {
        for (name, args, return_type, source_file) in &api_methods {
            // Highlighting the low-level FFI entry points for clarity
            let marker = if source_file == "lib.rs" && api_methods.iter().any(|(n,_,_,s)| n == name && s == source_file) {
                "[FFI CORE]"
            } else {
                "[GDExt]"
            };
            println!("  > func {}({}) -> {} {} [{}]", name, args, return_type, marker, source_file);
        }
    }

    println!("\n⭐ Registered Signal Broadcasts ({} total):", api_signals.len());
    if api_signals.is_empty() {
        warn!("  No #[signal] broadcasts found in targeted files.");
    } else {
        for (name, args, source_file) in &api_signals {
            println!("  > signal {}({}) [{}]", name, args, source_file);
        }
    }
	println!("--------------------------------------------------");

    info!("API scan complete: {} methods and {} signals detected.", api_methods.len(), api_signals.len());
    thread::sleep(Duration::from_secs(2));
}
<<< FILE END: rust\ssxl_cli\src\cli_util_inspect.rs >>>

>>> FILE START: rust\ssxl_cli\src\cli_util_loc.rs (139 LOC) <<<
//! # CLI Utilities: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
//!
//! This module provides functions for scanning the SSXL-ext workspace, calculating
//! Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`) files, and
//! generating the LOC reports required by the Godot engine.

use walkdir::WalkDir;
use std::path::{PathBuf};
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// Constants for the fixed-name output file, which is read by Godot.
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
// Directory for full LOC reports, relative to the project root (../)
const LOC_REPORTS_DIR: &str = "../loc_reports";

/// Helper to count lines of code in file content, ignoring empty lines and comments (simplified).
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        // Simple check: ignore empty lines and lines starting with comment markers.
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Helper function to write the final Rust LOC total to a fixed-name file
/// for fast parsing by Godot at bootup.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level to the project root (ssxl-ext/)
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE); // Final Path: ../RUST_LOC_TOTAL.txt

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("🔥 SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("❌ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

/// Scans the Rust workspace, calculates lines of code (LOC), and generates
/// the full report and the final single-number LOC file.
///
/// Assumes CWD is inside the `ssxl-ext/rust/` directory.
pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // 1. Scan Rust Code
    // These paths are correct relative to the ssxl-ext/rust/ directory.
    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 2. Scan GDScript Code
    // Path traversal is correct: `ssxl-ext/rust/` -> `../ssxl_engine_tester`
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        // Note: path.display() will include the '..' but this is acceptable for internal reports.
                        let path_str = path.display().to_string();
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters (using '#' for GDScript comments)
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 3. Generate the full, dynamically-named report in the `../loc_reports/` directory
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    // Create the directory if it doesn't exist.
    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("❌ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    // Write the full report to the corrected dynamic path.
    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("✅ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("❌ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // 4. Write the single line count to the fixed-name file (RUST_LOC_TOTAL.txt)
    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}
<<< FILE END: rust\ssxl_cli\src\cli_util_loc.rs >>>

>>> FILE START: rust\ssxl_cli\src\cli_util_menu.rs (190 LOC) <<<
use crate::actions::{
    // --- Core Test & Validation Functions (Godot/Rust interaction) ---
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
    
    // --- NEW: Headless Integration Tests for Rendering Logic (Fixing Generate/Animate) ---
    run_headless_generation_integration_test, // Validates 'generate' FFI data pipeline.
    run_headless_animation_tempo_test,        // Validates 'animate' conductor tempo/latency.
    
    // --- Launch & Debug Functions ---
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
};
// Benchmark/Utility functions are correctly imported from their dedicated module:
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use tracing::warn;


/// Defines a single executable action within the Command Line Interface menu.
/// Each action is a closure wrapped in a Box for dynamic execution.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    /// Helper constructor (primarily for TODO/unimplemented actions).
    pub fn new(id: &'static str, label: &'static str) -> Self {
        CliAction {
            key: '?',
            label,
            id,
            action: Box::new(|| {}) // Default no-op action
        }
    }
}


/// Defines a structure for organizing and presenting a group of CLI actions.
pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    // Note: prompt_action implementation is omitted as it is environment-specific.
    pub fn prompt_action(&self) -> CliAction {
        unimplemented!()
    }
}


/// Constructs the complete list of available actions for the SSXL Engine Dev Console.
pub fn build_menu() -> Vec<CliAction> {
    vec![
        // =======================================================================
        // I. CORE RUST VALIDATION (Internal Checks)
        // =======================================================================
        CliAction { 
            key: '0', 
            label: "✅ Run: Full Cargo Test Suite", 
            id: "cargo_all", 
            action: Box::new(run_cargo_tests) 
        },
        CliAction {    
            key: '1',    
            label: "✅ Validate: FFI Bridge Data Transfer (Data Integrity)",    
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction {    
            key: '2',    
            label: "✅ Validate: Async Communication Channels (Godot <-> Rust)",    
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction {    
            key: '3',    
            label: "✅ Validate: Chunk/Tile Data Channels (Crypto Coded)",    
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction {    
            key: '4',    
            label: "✅ Validate: Map Generation Logic (Procedural Purity)",    
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction {    
            key: '5',    
            label: "✅ Validate: Animation Conductor Tempo (Frame Consistency)",    
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },

        // =======================================================================
        // II. HEADLESS INTEGRATION TESTS (Simulating Engine in Godot)
        // This targets the root of our 'generate' and 'animate' rendering errors.
        // =======================================================================
        CliAction { 
            key: '6', 
            label: "✅ Validate: Headless Generation Integration (Full Pipeline Simulation)", 
            id: "headless_gen_integration",
            action: Box::new(run_headless_generation_integration_test)
        },
        CliAction { 
            key: '7', 
            label: "✅ Validate: Headless Animation Tempo Integration (Signal Latency Check)", 
            id: "headless_anim_tempo",
            action: Box::new(run_headless_animation_tempo_test)
        },

        // =======================================================================
        // III. ENGINE LAUNCH & DEBUGGING TOOLS
        // =======================================================================
        CliAction {    
            key: 'L',    
            label: "🚀 Launch: Godot Client (Non-Headless)",    
            id: "launch_client",
            action: Box::new(launch_godot_client)    
        },
        CliAction {    
            key: 'H',    
            label: "🎮 Launch: Headless Godot (External)",    
            id: "launch_headless",
            action: Box::new(launch_headless_godot)    
        },
        CliAction {    
            key: 'S',    
            label: "🔮 Start: Signal Inspector / Live Feed (TODO)",    
            id: "start_inspector",
            action: Box::new(start_signal_inspector)    
        },

        // =======================================================================
        // IV. BENCHMARKS & UTILITIES
        // =======================================================================
        CliAction {    
            key: 'T',    
            label: "🧪 Test: Generation & Placement CLI",    
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli)    
        },
        CliAction {    
            key: 'B',    
            label: "🧪 Benchmark: Max Grid Placement",    
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)    
        },
        CliAction {    
            key: 'P',    
            label: "✅ Perform: Bitmask PNG Conversion",    
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)    
        },
        CliAction {    
            key: 'A',    
            label: "✅ Inspect: SSXL Developer API Surface (Callable + Signals)",    
            id: "api_surface",
            action: Box::new(print_godot_api_surface)    
        },
        CliAction {    
            key: 'I',    
            label: "✅ Inspect: Rust Module Tree",    
            id: "module_tree",
            action: Box::new(print_module_tree)    
        },
        CliAction {    
            key: 'R',    
            label: "⚠️ Run: Trailkeeper Scan (TODO)",    
            id: "trailkeeper_scan",
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented."))    
        },
        
        // =======================================================================
        // V. SYSTEM CONTROL
        // =======================================================================
        CliAction { key: 'E', label: "✅ Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}


/// Prints the structured menu to the console, ready for user selection.
pub fn print_menu(menu: &[CliAction]) {
    
    println!("\n🧭 SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}
<<< FILE END: rust\ssxl_cli\src\cli_util_menu.rs >>>

>>> FILE START: rust\ssxl_cli\src\main.rs (127 LOC) <<<
//! # SSXL-ext CLI Developer Console (`ssxl_cli::main`)
//!
//! The main entry point for the interactive developer console. This utility manages
//! initialization, logging, the main menu loop, and delegates tasks to action modules
//! for testing, benchmarking, and external tool execution.

mod actions;               // Core functions for tests, benchmarks, and Godot interaction.
mod cli_util_inspect;      // Utilities for scanning the codebase and API surface.

// FIX: Change to `pub mod` so its types (CliAction, CliMenu) are accessible
// by other modules in the crate (like actions/testing.rs).
pub mod cli_util_menu;     // Menu structure and display logic.

mod cli_util_bench;        // Functions for running generation tests and benchmarks.
mod cli_util_loc;          // <--- CHANGE 1: Declare the new LOC utility module.

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // External FFI function to bootstrap the engine core.
use crate::cli_util_loc::scan_and_report_loc; // <--- CHANGE 2: Update the import path and function name.
use crate::actions::copy_dll_to_tester_project_at_boot; // Action to ensure the latest DLL is in the Godot project.


/// Prompts the user to press Enter before returning to the main menu.
fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    // Read a line from stdin and discard the result.
    let _ = io::stdin().read_line(&mut String::new());
}

/// Sets up the logging system and performs critical engine initialization steps.
fn init_logging_and_engine() {
    // 1. Initialize Tracing/Logging Subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout) // Direct log output to stdout.
                .with_filter(LevelFilter::INFO), // Set the minimum logging level to INFO.
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // 2. Initialize the Rust Core via FFI
    // Calls the external C-compatible function to boot the engine's core state and runtime.
    if ssxl_initialize_engine() {
        info!("Engine FFI core initialized.");
    } else {
        // We log the failure but allow the CLI to continue for non-engine tasks (like LOC scan).
        error!("Failed to initialize Engine FFI core.");
    }
    
    // 3. Copy DLL to Godot Project
    // Ensure the compiled GDExtension DLL is copied into the Godot tester project
    // before any Godot-related actions are run.
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        // This is a critical warning, as Godot interaction will fail without the DLL.
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // Perform initial setup: logging, FFI, and DLL copy.
    init_logging_and_engine();
    
    // Run a Lines of Code (LOC) scan on the codebase at startup.
    // Note: The scan function no longer takes an argument.
    scan_and_report_loc(); // <--- CHANGE 3: Update function call and remove unnecessary argument.
    
    // Print welcome ASCII art.
    println!(
        r#"
                 (__)                      
                 (oo)
           /------\/
          / |    ||
         * ||----||
            ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // Build the menu structure.
    let menu = build_menu();
    // Set for input debouncing to prevent multiple actions from a single key press hold.
    let mut last_keys = HashSet::new();

    // --- Main Interactive Console Loop ---
    loop {
        // Display the menu options.
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        // Ensure the prompt character is immediately visible.
        io::stdout().flush().unwrap();

        // Inner loop handles key polling and processing.
        loop {
            // Poll for key events with a timeout to keep the loop responsive (500ms tempo).
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase(); // Normalize input to uppercase.

                        // Input Debounce Check: Only process if the key hasn't been seen recently.
                        if last_keys.insert(c) {
                            // Find the corresponding menu item.
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                // Execute the action associated with the menu item.
                                (item.action)();

                                // Check for the exit key ('E').
                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return; // Exit the main function, terminating the CLI.
                                }

                                // Wait for user acknowledgment before returning to the main menu screen.
                                wait_for_enter();
                                // Break the inner polling loop to redraw the menu.
                                break;
                            }
                        }
                    }
                }
            } else {
                // If the poll times out, clear the debounce set, allowing a new key press to be registered.
                last_keys.clear();
            }

            // Short pause for general loop control.
            thread::sleep(Duration::from_millis(10));
        }
    }
}
<<< FILE END: rust\ssxl_cli\src\main.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\actions.rs (165 LOC) <<<
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

pub fn run_communication_channel_test() {
    info!("TEST [2]: Starting Async Communication Channel Validation (Thread Jump Tempo Check)...");
    
    let (tx, rx) = mpsc::channel::<(String, String)>();

    let engine_test_thread = thread::spawn(move || {
        info!("WORKER: Starting 500ms sleep simulation (Simulating heavy map chunk 1 work)...");
        thread::sleep(Duration::from_millis(500));
        
        let message = "Async signal emission successful. Latency: 500ms".to_string();
        
        if tx.send(("TEST_COMPLETE".to_string(), message)).is_err() {
            error!("WORKER: Failed to send test signal. Receiver dropped (Godot side crashed?).");
        } else {
            info!("WORKER: Successfully sent TEST_COMPLETE signal back to main thread.");
        }
    });

    match rx.recv_timeout(Duration::from_secs(2)) {
        Ok((status, message)) => {
            if status == "TEST_COMPLETE" {
                info!("✅ SUCCESS: Communication Channel Validated. {}", message);
                info!("   Thread jump integrity confirmed.");
            } else {
                error!("❌ FAIL: Received incorrect status: {}", status);
            }
        },
        Err(mpsc::RecvTimeoutError::Timeout) => {
            error!("❌ FAIL: Timeout (2s). Communication channel failed to establish required tempo.");
        },
        Err(mpsc::RecvTimeoutError::Disconnected) => {
            error!("❌ FAIL: Worker thread disconnected unexpectedly (Systemic Entropy).");
        }
    }
    
    engine_test_thread.join().unwrap();
}

pub fn run_map_generation_test() {
    info!("TEST [4]: Starting Map Generation Flow Validation (Procedural Purity & Streaming)...");

    let (data_tx, data_rx) = mpsc::channel::<usize>();
    let (done_tx, done_rx) = mpsc::channel::<()>();    

    let total_chunks = 5;
    let engine_gen_thread = thread::spawn(move || {
        info!("WORKER: Starting map generation for {} chunks.", total_chunks);
        
        for i in 1..=total_chunks {
            thread::sleep(Duration::from_millis(50));
            
            if data_tx.send(i).is_err() {
                warn!("WORKER: Data channel dropped after chunk {}. Stopping.", i);
                return;
            }
            info!("WORKER: Emitted Chunk #{} (Data Payload Crypto Coded).", i);
        }
        
        if done_tx.send(()).is_err() {
             error!("WORKER: Failed to send generation_complete signal.");
        }
        info!("WORKER: Generation finished.");
    });

    let mut chunks_received = 0;
    
    loop {
        match data_rx.recv_timeout(Duration::from_millis(10)) {
            Ok(chunk_id) => {
                chunks_received += 1;
                info!("MAIN: Processed Chunk #{} (Data Channel) - Tempo maintained.", chunk_id);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                if done_rx.try_recv().is_ok() {
                    info!("MAIN: Detected Completion Signal (Generation Complete).");
                    break;
                }
                thread::sleep(Duration::from_millis(1));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                error!("❌ FAIL: Data channel disconnected prematurely (Systemic Entropy).");
                break;
            }
        }
        
        if done_rx.try_recv().is_ok() {
            info!("MAIN: Detected Completion Signal (Generation Complete).");
            break;
        }
    }
    
    engine_gen_thread.join().unwrap();
    
    if chunks_received == total_chunks {
        info!("✅ SUCCESS: Map Generation Flow Validated. Received {}/{} chunks.", chunks_received, total_chunks);
        info!("   All data channels validated and quantum alignment achieved.");
    } else {
        error!("❌ FAIL: Map Generation Failed. Expected {} chunks, received {}.", total_chunks, chunks_received);
    }
}

pub fn run_data_channel_test() {
    info!("TEST [3]: Starting Chunk/Tile Data Channel Integrity Check...");
    
    info!("TEST [3]: Data channel integrity is validated implicitly and explicitly.");
    info!("   Implicitly: By checking successful channel send/receive in Action 4.");
    info!("   Explicitly: The FFI data type validation logic should be integrated here.");
    
    run_map_generation_test();
}

pub fn run_animation_conductor_test() {
    info!("TEST [5]: Starting Animation Conductor Tempo Validation (High-Frequency Loop Check)...");

    let (tx, rx) = mpsc::channel::<u64>();
    let required_signals = 120;
    let target_duration = Duration::from_millis(2000);

    let conductor_thread = thread::spawn(move || {
        info!("WORKER: Animation Conductor spun up. Targeting high tempo signal emission.");
        let start_time = Instant::now();
        let mut count = 0;
        
        while start_time.elapsed() < target_duration {
            thread::sleep(Duration::from_nanos(8333));
            
            if tx.send(start_time.elapsed().as_micros() as u64).is_err() {
                warn!("WORKER: Conductor signal dropped (Receiver disconnected).");
                return;
            }
            count += 1;
        }
        info!("WORKER: Conductor stopped. Emitted {} signals.", count);
    });

    let mut signals_received = 0;
    let mut min_latency_us = u64::MAX;
    let mut max_latency_us = 0;
    let main_start_time = Instant::now();

    while main_start_time.elapsed() < target_duration + Duration::from_millis(500) {
        match rx.recv_timeout(Duration::from_millis(1)) {
            Ok(timestamp_us) => {
                signals_received += 1;
                let elapsed_us = main_start_time.elapsed().as_micros() as u64;
                let latency_us = elapsed_us.saturating_sub(timestamp_us);
                
                min_latency_us = min_latency_us.min(latency_us);
                max_latency_us = max_latency_us.max(latency_us);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                thread::sleep(Duration::from_nanos(100));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                info!("MAIN: Conductor thread finished/disconnected.");
                break;
            }
        }
    }

    conductor_thread.join().unwrap();
    
    let success = signals_received >= required_signals;
    
    if success {
        info!("✅ SUCCESS: Animation Conductor Tempo Validated.");
        info!("   Target Signals: {} | Received: {}", required_signals, signals_received);
        info!("   Latency (Main Thread Read Lag): Min {}µs, Max {}µs.", min_latency_us, max_latency_us);
    } else {
        error!("❌ FAIL: Animation Conductor FAILED to achieve required tempo.");
        error!("   Expected signals: {} | Received: {}. Check worker thread throttling.", required_signals, signals_received);
        error!("   Latency range suggests systemic entropy in signal marshalling.");
    }
}
<<< FILE END: rust\ssxl_cli\src\actions\actions.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\benchmarking.rs (71 LOC) <<<
use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering}
};
use std::thread;
use std::time::Duration;
use ctrlc;

// FIX E0432: Conductor and ConductorStatus are found in the `conductor` module.
use ssxl_generate::conductor::{Conductor, ConductorStatus};


pub fn start_signal_inspector() {
    warn!("🔮 Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // FIX E0308: Conductor::new now returns 4 elements. We destructure the fourth 
    // element (_progress_receiver) to ignore it here, as the CLI inspects the 
    // ConductorState directly, not the message channel.
    let (conductor, state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        print!("\r");
        print!("🔮 LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        thread::sleep(Duration::from_millis(50));
    }

    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

#[allow(dead_code)]
pub fn run_benchmark() {
    warn!("⏱️ Benchmark execution not yet implemented. Placeholder called.");
}
<<< FILE END: rust\ssxl_cli\src\actions\benchmarking.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\godot_harness.rs (136 LOC) <<<
// FILE: ssxl_cli/src/actions/godot_harness.rs

//! # CLI Actions: Godot Harness (`ssxl_cli::actions::godot_harness`)
//!
//! Utilities for managing and launching the Godot editor or the Godot game
//! client from the command line, including necessary setup steps like copying
//! the compiled Rust dynamic library (DLL/SO/DYLIB) into the Godot project's
//! GDExtension directory.

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Imports of constants and utility functions from the parent module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


/// Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the `target/release`
/// or `target/debug` folder to the Godot tester project's GDExtension directory.
///
/// This is a critical step to ensure Godot loads the latest engine code.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // --- 1. Construct Source Path ---
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    // Navigate to the target directory (e.g., `target/debug/`).
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    // Add the DLL file name (e.g., `SSXL_engine.dll`).
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // --- 2. Construct Destination Path ---
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    // Navigate to the Godot project's GDExtension folder.
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    // Add the DLL file name.
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // --- 3. Validation and Copy ---

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        // Treat missing source as a non-fatal warning to continue CLI usage.
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "✅ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            // This often fails if the target DLL is locked by a running Godot instance.
            Err(format!(
                "❌ FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}


/// Launches the Godot Editor in a non-blocking subprocess.
pub fn launch_godot_client() {
    info!("🚀 LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    // Execute the Godot process.
    match Command::new(GODOT_EXE_PATH)
        // Flag to launch the editor window instead of running the game directly.
        .arg("--editor")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously, allowing the CLI process to continue.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

/// Launches Godot in a non-blocking subprocess using the `--headless` flag.
/// 
/// This is used for automated testing where no GUI is needed.
pub fn launch_headless_godot() {
    info!("🚀 LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        // Flag to run Godot without a graphical interface.
        .arg("--headless")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}
<<< FILE END: rust\ssxl_cli\src\actions\godot_harness.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\mod.rs (78 LOC) <<<
// FILE: ssxl_cli/src/actions/mod.rs

//! # CLI Actions Module (`ssxl_cli::actions`)
//!
//! This module acts as the public interface (façade) for all complex command-line
//! actions, such as launching Godot, running tests, or initiating benchmarks.
//! It aggregates constants, external dependencies, and exports from its child modules.

use std::env;
use std::path::PathBuf;

// --- Internal Modules ---

/// Tools for real-time monitoring of the Conductor and placeholder for benchmark logic.
mod benchmarking;
/// Utilities for launching and managing the external Godot engine tester project.
mod godot_harness;
/// The main menu and delegation stub for all test suites.
mod testing;
/// Contains self-contained architectural and data validation tests.
mod test_suites;
/// Contains tests requiring external processes like `cargo` and Godot FFI validation.
mod test_core_suites;

// --- Configuration Constants ---

/// The absolute path to the Godot executable file.
pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
/// The project-relative path fragment pointing to the GDExtension folder (e.g., `godot_tester_project/gde/`).
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXLtester2/";
/// The expected file name of the compiled Rust dynamic library (e.g., `ssxl_engine.dll`).
pub const DLL_NAME: &str = "ssxl_engine.dll";
/// The project-relative path fragment where the compiled DLL is found (e.g., `target/debug/`).
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
/// The scene path within the Godot project used for FFI bridge validation tests.
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; 

// --- NEW HEADLESS TEST SCENES ---
/// The scene path within the Godot project used for headless generation pipeline validation.
pub const HEADLESS_GEN_TEST_SCENE: &str = "res://tests/headless_gen_pipeline.tscn";
/// The scene path within the Godot project used for headless animation tempo validation.
pub const HEADLESS_ANIM_TEST_SCENE: &str = "res://tests/headless_anim_tempo.tscn";
// --- END NEW HEADLESS TEST SCENES ---

// --- Utility Functions ---

/// Calculates the absolute path to the Godot tester project root.
pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}


// --- Public Module Exports (Façade) ---

/// Re-export for starting the **real-time status feed**.
pub use benchmarking::start_signal_inspector;

// Exports from godot_harness (Includes the requested launch_headless_godot).
pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

// Exports from test_core_suites.
pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    // --- ADDING NEW HEADLESS TESTS ---
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
};

// Exports from test_suites.
pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};


/// Exports related to **testing and validation**.
#[allow(unused_imports)]
pub use testing::execute_testing_menu;
<<< FILE END: rust\ssxl_cli\src\actions\mod.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\testing.rs (52 LOC) <<<
// FILE: ssxl_cli/src/actions/testing.rs

//! # CLI Actions: Testing Utilities (`ssxl_cli::actions::testing`)
//!
//! Provides a menu for executing various test suites, delegating the complex
//! execution logic to the internal `test_suites` and external `test_core_suites` modules.

use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;      // Architectural tests
use crate::actions::test_core_suites; // External tests
use std::sync::LazyLock;              // NEW: Used for lazy, thread-safe static initialization

// --- Menu Setup Logic ---

// FIX 1 & 2: Use LazyLock to initialize the actions at runtime (solving E0015) 
// and store them in a Vec<CliAction>. The CliAction struct itself must have 
// been updated in cli_util_menu.rs to include Send + Sync bounds (solving E0277).
#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    // FIX 2: Added the "back" action which is used to exit the loop
    CliAction::new("back", "↩️ Return to Main Menu"), 
]);

/// Central entry point for all CLI testing actions.
#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    // FIX 3: Get a slice from the LazyLock Vec to satisfy CliMenu's 'a [CliAction] requirement.
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        // FIX 4: `*s == "id"` and no misplaced `Ok(())` returns are now correct.
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}
<<< FILE END: rust\ssxl_cli\src\actions\testing.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\test_core_suites.rs (234 LOC) <<<
use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub fn run_ffi_bridge_validation() {
    info!("🔥 STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(
            "❌ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_generation_integration_test() {
    info!("🔥 STARTING: Headless Map Generation Integration Test (Full Pipeline Validation)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_GEN_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS GENERATION TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS GENERATION TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.");
    } else {
        error!(
            "❌ Headless Generation Integration Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_animation_tempo_test() {
    info!("🔥 STARTING: Headless Animation Conductor Tempo Test (Signal Latency Check)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_ANIM_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT START ---\n");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.");
    } else {
        error!(
            "❌ Headless Animation Tempo Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
<<< FILE END: rust\ssxl_cli\src\actions\test_core_suites.rs >>>

>>> FILE START: rust\ssxl_cli\src\actions\test_suites.rs (140 LOC) <<<
// FILE: ssxl_cli\src\actions\test_suites.rs

//! # Internal Architectural and Data Validation Suites
//!
//! Contains self-contained Rust tests focused on validating internal data contracts,
//! concurrency models (channels), and core generation logic without external
//! process reliance.

use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

// --- Project Imports ---
use ssxl_generate::Generator;
// FIX E0432: `perlin_generator` likely renamed to `perlin`.
use ssxl_generate::perlin::PerlinGenerator;
use ssxl_math::Vec2i;
// FIX E0432: Correct path to Chunk data constant.
use ssxl_shared::chunk::chunk_data::CHUNK_SIZE;
// FIX E0432: Correct path to Tile data struct.
use ssxl_shared::tile::tile_data::AnimationUpdate;


// -----------------------------------------------------------------------------
// FOCUSED ARCHITECTURAL VALIDATION
// -----------------------------------------------------------------------------

/// Validates the non-blocking mpsc channels used between the Godot main thread
/// and the Rust worker threads (Generation and Animation Conductors).
pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    // 1. Create a channel pair: (CLI sends, Mock Conductor receives)
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    // 2. Spawn a thread to act as the Mock Conductor
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    // 3. CLI (main thread) floods the channel with messages
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1));
    }
    
    drop(cli_sender);

    // 4. Wait for the Mock Conductor thread to complete and get the result
    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("❌ Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    // 5. Report results
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("✅ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("❌ Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}


/// Alias for `run_communication_channel_test`. Validates data-channel functionality.
pub fn run_data_channel_test() {
    run_communication_channel_test();
}

/// Validates the core map generation logic by creating a chunk using the Perlin Generator.
pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords);
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("✅ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("❌ Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

/// Validates the data contract for the Animation Conductor by ensuring
/// the `AnimationUpdate` structure can be serialized and deserialized.
pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("❌ Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("❌ Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("✅ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("❌ Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}
<<< FILE END: rust\ssxl_cli\src\actions\test_suites.rs >>>

>>> FILE START: rust\ssxl_config\src\engine.toml (13 LOC) <<<
# config/engine.toml

# --- Core Engine Settings ---
[engine]
# Enables/disables advanced logging features (e.g., debug tracing)
# logging_level = "info" # Example setting not in SSXLConfig, but common

# --- Generation Defaults ---
[generation]
# The generator ID to use when no specific generator is requested by the FFI/CLI.
# Options include "perlin_basic_2d", "cellular_automata_basic", etc.
default_generator_id = "perlin_basic_2d"

# The specific ruleset ID to use for the Cellular Automata generator (if selected).
# 0: Basic Cave, 1: Maze/Dungeon, etc.
ca_default_ruleset = 1
<<< FILE END: rust\ssxl_config\src\engine.toml >>>

>>> FILE START: rust\ssxl_engine_ffi\Cargo.toml (17 LOC) <<<
[package]
name = "ssxl_engine_ffi"
version = "0.6.0"
edition = "2021"


[dependencies]
# --- INTERNAL DEPENDENCIES (Core Logic) ---
# FFI needs access to all the core data and logic it is bridging.
ssxl_shared   = { path = "../ssxl_shared" }
ssxl_math     = { path = "../ssxl_math" }
ssxl_godot	  = { path = "../ssxl_godot" }
ssxl_generate = { path = "../ssxl_generate" }

# --- EXTERNAL DEPENDENCIES ---
# The standard C library definitions for safe FFI (e.g., c_char, c_void)
libc               = "0.2" 
# Workspace standard logging framework
tracing            = { workspace = true } 
tokio 			   = { workspace = true }

<<< FILE END: rust\ssxl_engine_ffi\Cargo.toml >>>

>>> FILE START: rust\ssxl_engine_ffi\src\lib.rs (181 LOC) <<<
use std::os::raw::c_char;
use std::sync::OnceLock;
use std::sync::atomic::Ordering;
use std::sync::Mutex;
use std::panic;

use ssxl_generate::{Conductor, start_runtime_placeholder, ConductorProgressReceiver};
// This import will now resolve after fixing Cargo.toml
use tokio::sync::mpsc::error::TryRecvError;
use ssxl_shared::{initialize_shared_data, CHUNKS_COMPLETED_COUNT};
use tracing::{info, error};

static CONDUCTOR: OnceLock<Mutex<Conductor>> = OnceLock::new();
static PROGRESS_RECEIVER: OnceLock<Mutex<ConductorProgressReceiver>> = OnceLock::new();

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    // Panic guard applied to maintain FFI boundary stability
    match panic::catch_unwind(|| {
        initialize_shared_data();

        if CONDUCTOR.get().is_some() {
            info!("FFI Bridge: Runtime already running.");
            return true;
        }

        match Conductor::new(None) {
            Ok((conductor, _state, _request_sender, progress_receiver)) => {
                
                // 1. Store Conductor
                if CONDUCTOR.set(Mutex::new(conductor)).is_err() {
                    error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                    return false;
                }
                
                // 2. Store the Channel Receiver, keeping the channel open.
                if PROGRESS_RECEIVER.set(Mutex::new(progress_receiver)).is_err() {
                    error!("FFI Bridge: PROGRESS_RECEIVER::set() failed (Possible race condition).");
                    return false;
                }
                
                info!("FFI Bridge: Conductor Runtime started successfully.");
                true
            }
            Err(e) => {
                tracing::error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
                false
            }
        }
    }) {
        Ok(result) => result,
        Err(_) => {
            error!("FFI BRIDGE FATAL: A panic occurred inside ssxl_start_runtime. Preventing crash.");
            false
        }
    }
}

// ------------------------------------------------------------------

// CORE FIX: The non-blocking polling function that Godot must call.
#[no_mangle]
pub extern "C" fn ssxl_poll_progress_message(
    buffer: *mut c_char,
    buffer_len: usize,
) -> isize {
    let receiver_mutex = match PROGRESS_RECEIVER.get() {
        Some(m) => m,
        None => return -1, // Runtime not initialized
    };

    let mut receiver_guard = match receiver_mutex.lock() {
        Ok(guard) => guard,
        Err(_) => return -2, // Lock failed
    };
    
    // Use try_recv() for a non-blocking poll.
    match receiver_guard.try_recv() {
        Ok(message) => {
            // Using Debug formatting for message serialization.
            let status = format!("{:?}", message); 

            let bytes = status.as_bytes();
            let write_len = bytes.len().min(buffer_len.saturating_sub(1));

            unsafe {
                std::ptr::copy_nonoverlapping(bytes.as_ptr(), buffer as *mut u8, write_len);
                *buffer.add(write_len) = 0; // Null-terminate the string
            }
            // Return the written length (positive)
            write_len as isize
        }
        Err(TryRecvError::Empty) => {
            0 // Return 0 to signal no message was received this tick
        }
        Err(TryRecvError::Disconnected) => {
            error!("FFI Bridge: Progress channel disconnected. Clearing static.");
            
            // Channel is permanently dead. Clear the static to reset the state.
            unsafe {
                let ptr = &PROGRESS_RECEIVER as *const _ as *mut OnceLock<Mutex<ConductorProgressReceiver>>;
                (*ptr).take();
            }
            -3 // Return a negative error code for permanent failure
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    // Panic guard applied to maintain FFI boundary stability
    match panic::catch_unwind(|| {
        // 1. Signal graceful shutdown to the Conductor thread
        if let Some(mutex) = CONDUCTOR.get() {
            if let Ok(conductor) = mutex.lock() {
                conductor.signal_shutdown_graceful();
                info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
            } else {
                error!("FFI Bridge: Failed to acquire lock for shutdown (Possible poisoned lock).");
            }
        }
        
        // 2. Explicitly drop the receiver side (closes the channel for the workers)
        unsafe {
            let ptr = &PROGRESS_RECEIVER as *const _ as *mut OnceLock<Mutex<ConductorProgressReceiver>>;
            (*ptr).take();
        }
        info!("FFI Bridge: Progress Receiver dropped.");
    }) {
        Ok(_) => {},
        Err(_) => {
            error!("FFI BRIDGE FATAL: Panic during ssxl_shutdown_runtime.");
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    CONDUCTOR.get().is_some()
}

#[no_mangle]
pub extern "C" fn ssxl_is_receiver_ready() -> bool {
    PROGRESS_RECEIVER.get().is_some()
}

#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    match panic::catch_unwind(|| {
        info!("FFI Bridge: Received command to trigger Conductor structural test.");
        start_runtime_placeholder();
        info!("FFI Bridge: Conductor test sequence complete.");
    }) {
        Ok(_) => {},
        Err(_) => {
            error!("FFI BRIDGE FATAL: Panic during runtime test. Check start_runtime_placeholder.");
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_write_status(
    buffer: *mut c_char,
    buffer_len: usize,
    id: u32,
) -> isize {
    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        CONDUCTOR.get().is_some()
    );

    if buffer.is_null() || buffer_len == 0 {
        return -1;
    }

    let bytes = status.as_bytes();
    let write_len = bytes.len().min(buffer_len.saturating_sub(1));

    unsafe {
        std::ptr::copy_nonoverlapping(bytes.as_ptr(), buffer as *mut u8, write_len);
        *buffer.add(write_len) = 0;
    }

    write_len as isize
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_get_chunks_completed() -> u32 {
    CHUNKS_COMPLETED_COUNT.load(Ordering::Relaxed) as u32
}
<<< FILE END: rust\ssxl_engine_ffi\src\lib.rs >>>

>>> FILE START: rust\ssxl_generate\Cargo.toml (25 LOC) <<<
[package]
name = "ssxl_generate"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES (Foundation Layer) ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math   = { path = "../ssxl_math" }
ssxl_sync   = { path = "../ssxl_sync" }
ssxl_tools = { path = "../ssxl_tools" }
ssxl_cache  = { path = "../ssxl_cache" }

# --- EXTERNAL DEPENDENCIES (Core Computation) ---
# For parallel execution of generation algorithms
rayon            = { workspace = true }
# Core randomness library
rand             = { workspace = true }
# Used for saving/loading bitmap images (optional textures/noise visualizations)
image            = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing          = { workspace = true }
tokio            = { workspace = true }
noise            = { workspace = true }
glam             = { workspace = true }
fastrand = { workspace = true }
num_cpus = { workspace = true }


<<< FILE END: rust\ssxl_generate\Cargo.toml >>>

>>> FILE START: rust\ssxl_generate\src\lib.rs (60 LOC) <<<
use ssxl_shared::ChunkData;
use ssxl_math::Vec2i;
use tracing::{info, error};
use std::mem;

// --- Module Declarations (Based on Directory Structure) ---
// Modules that map to subdirectories (containing mod.rs or other files).
pub mod ca;        // Contains cellular_automata_generator.rs
pub mod conductor; // Contains conductor.rs, conductor_state.rs, sync.rs
pub mod manager;   // Contains config_validator.rs, generator_manager.rs, runtime_manager.rs
pub mod perlin;    // Contains perlin_generator.rs
pub mod task;      // Contains batch_processor.rs, benchmark_logic.rs, task_queue.rs

// The original declarations are removed:
// pub mod conductor;
// pub mod benchmark_logic;
// pub mod perlin_generator;
// pub mod cellular_automata_generator;
// pub mod ca; // This was correctly declared as a directory module
// pub mod runtime_manager;
// pub mod config_validator;
// pub mod task_queue;
// pub mod conductor_state;
// pub mod generator_manager;
// pub mod batch_processor;
// pub mod sync;


pub trait Generator {
	fn id(&self) -> &str;
	fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


// --- Public Exports (Updated to use new module paths) ---

pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

// The Conductor is in conductor/conductor.rs
pub use conductor::conductor::Conductor;
// ConfigValidator is in manager/config_validator.rs
pub use manager::config_validator::GeneratorConfig;

// ConductorProgressReceiver/Sender are in conductor/sync.rs
pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;
// GenerationTask is in task/task_queue.rs
pub use task::task_queue::GenerationTask;

// BenchmarkLogic is in task/benchmark_logic.rs
pub use task::benchmark_logic::benchmark_generation_workload;


pub fn start_runtime_placeholder() {
	match Conductor::new(None) {
		// FIX: The progress_receiver must be kept alive to prevent the channel from closing.
		// Removed the underscore, making the variable `progress_receiver`.
		Ok((conductor, _state, _request_sender, progress_receiver)) => {
			info!("Runtime created successfully. Testing immediate graceful teardown...");
			
			// ARCHITECTURAL FIX: Use std::mem::forget to simulate the FFI/Godot side
			// taking ownership of the receiver, which keeps the progress channel open.
			mem::forget(progress_receiver);
			
			conductor.graceful_teardown();
		}
		Err(e) => {
			error!("Failed to initialize Conductor/Runtime: {:?}", e);
		}
	}
}
<<< FILE END: rust\ssxl_generate\src\lib.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\cellular_automata_generator.rs (194 LOC) <<<
// ssxl_generate/src/ca/cellular_automata_generator.rs

//! Implements a procedural generator based on Cellular Automata (CA) rules.
//!
//! This generator is responsible for creating cave systems, mazes, and other
//! structured patterns by iterating on an initially random chunk state. It
//! delegates complex logic to the `ca::rule_set` and `ca::neighbor_check` modules.

use crate::Generator;
use ssxl_math::Vec2i;
use fastrand; // Lightweight, fast, and thread-safe PRNG
use ssxl_shared::{
    // FIX: Import all components directly from the ssxl_shared crate root.
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

// --- 1. Generator Constants ---

/// The fixed number of iterations for the CA simulation to stabilize the pattern.
const CA_ITERATIONS: u8 = 4;
/// The percentage of tiles randomly initialized as `TileType::Rock` (the "live" state).
const INITIAL_FILL_PERCENT: u8 = 45;

// --- 2. Generator Structure and Implementation ---

/// A generator that uses Cellular Automata rules to produce structured patterns.
#[allow(dead_code)] // Allowed since this struct is instantiated via the GeneratorManager
pub struct CellularAutomataGenerator {
    /// The specific B/S ruleset (e.g., RULE_BASIC_CAVE or RULE_MAZE) to apply.
    ruleset: u8,
}

impl CellularAutomataGenerator {
    /// Creates a new CA generator instance with the specified ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// --- 3. Internal Generation Helper Functions ---

/// Generates static, non-simulated patterns (Solid or Checkerboard).
/// (Static pattern generation is unchanged and remains efficient)
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;
    
    // Calculate world boundaries for the ChunkData metadata
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;
    
    // Create a unique 64-bit Chunk ID
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
    
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );
    
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };
    
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
    // Since chunk_data.tiles is a fixed-size array, we must fill a temporary Vec
    // and let ChunkData::insert_tiles handle the conversion/copy.
    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    // Checkerboard pattern: alternate based on coordinate parity
                    if (x + y) % 2 == 0 {
                        TileType::Rock
                    } else {
                        TileType::Void
                    }
                }
                _ => TileType::Void, // Should not be reached, but defaults to Void
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

/// **OPTIMIZED:** Runs the full Cellular Automata simulation using double-buffering.
///
/// This function allocates the `target_tiles` array only once by cloning the initial state.
/// **FIXED:** Corrected array handling using `[TileData; N]` for zero-cost `std::mem::swap` in the loop.
fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    // 1. The initial state is in `chunk_data.tiles` (Source buffer). 
    // Create the second buffer (Target) by cloning the array once.
    let mut target_tiles = chunk_data.tiles.clone();
    
    // `chunk_data.tiles` is the Source (Read), `target_tiles` is the Target (Write).

    for i in 0..CA_ITERATIONS {
        // Core loop: Read from `chunk_data.tiles` (Source), write to `target_tiles` (Target).
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                
                // Read current tile properties from the source array
                let current_tile = &chunk_data.tiles[index];
                
                // 1. Check Neighbors: reads from the current state within `&chunk_data`.
                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                // 2. Apply Rule Set
                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                // 3. Update the new tile state in the TARGET buffer.
                // We preserve the noise value from the previous step.
                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }
        
        // EFFICIENT SWAP: Exchange the contents of the two arrays. O(1) pointer swap.
        // `chunk_data.tiles` now holds the new state (Source for next iteration).
        // `target_tiles` now holds the stale state (Target for next iteration).
        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        
        info!("CA Generator: Iteration {} complete.", i + 1);
    }
    
    // The final result is in `chunk_data.tiles`.
    chunk_data
}

// --- 4. Trait Implementation (Generator API) ---

impl Generator for CellularAutomataGenerator {
    /// Returns a unique identifier string for this generator instance.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    /// The main logic to generate a single chunk of data.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns quickly without the iterative CA loop.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // --- Seeding for Determinism (Crypto Coded Memory) ---
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);
        
        // --- Initialization ---
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
        // Use a temporary Vec to build the initial randomized state
        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Initial randomization based on INITIAL_FILL_PERCENT
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            // Noise value is typically unused in base CA but kept for data integrity
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        // Insert the initial state, which copies the data into the internal fixed-size array.
        chunk_data.insert_tiles(tiles_vec); 

        // --- Simulation Iterations (Refactored to single, optimized call) ---
        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}
<<< FILE END: rust\ssxl_generate\src\ca\cellular_automata_generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\mod.rs (19 LOC) <<<
// ssxl_generate/src/ca/mod.rs

//! Core module for the Cellular Automata (CA) generation algorithms.
//!
//! This logic is used by the `CellularAutomataGenerator` to simulate environment
//! growth (e.g., cave systems, walls, and borders) based on local neighborhood rules.
//! This module provides the tools necessary to enforce a state-based system
//! for structured, yet emergent, world design.

// --- Sub-Modules ---

// FIX: Declare the cellular_automata_generator module.
// This allows other files to access CellularAutomataGenerator via `crate::ca::CellularAutomataGenerator`.
pub mod cellular_automata_generator;

/// Defines the specific CA rules (e.g., Survival and Birth rules like 4/5).
/// This module abstracts the core generation logic, allowing for easy experimentation
/// and swapping of different CA rule sets to achieve diverse world patterns.
pub mod rule_set;

/// Contains logic for checking a cell's immediate surroundings and calculating
/// the neighbor count based on the current state. This is the low-level
/// component that feeds the local state into the `rule_set`.
pub mod neighbor_check;
<<< FILE END: rust\ssxl_generate\src\ca\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\neighbor_check.rs (58 LOC) <<<
// ssxl_generate/src/ca/neighbor_check.rs

// FIX: Import ChunkData, CHUNK_SIZE, and TileType directly from the ssxl_shared root, 
// as the inner modules (`chunk_data` and `tile_type`) are no longer public.
use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

/// Counts the number of "live" (TileType::Rock) neighbors in the 3x3 Moore neighborhood
/// surrounding a specific cell within a chunk.
///
/// This function handles boundary conditions, ensuring checks do not exceed the
/// chunk's borders (0 to CHUNK_SIZE - 1). It is crucial for the tempo and accuracy
/// of the Cellular Automata simulation.
///
/// **Safety Focus:** Explicitly checks signed coordinates (`i32`) against bounds before
/// casting to unsigned types (`u32`) for indexing, preventing potential wraparound bugs.
///
/// # Arguments
/// * `chunk_data`: The data structure containing the chunk's tiles.
/// * `cx`: The X coordinate of the center cell (0 to CHUNK_SIZE - 1).
/// * `cy`: The Y coordinate of the center cell (0 to CHUNK_SIZE - 1).
///
/// # Returns
/// The count of live neighbors (0-8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;
    // Cache the chunk size as i32 for direct comparison against signed coordinates.
    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    // Convert center coordinates to i32 for safe arithmetic with dx/dy.
    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    // Iterate through the 3x3 Moore neighborhood relative to the center cell (cx, cy).
    for dx in -1..=1 {
        for dy in -1..=1 {
            // 1. Exclude the center cell itself (self-exclusion).
            if dx == 0 && dy == 0 {
                continue;
            }

            // Calculate the neighbor's absolute coordinates using i32.
            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            // 2. CRITICAL BOUNDARY CHECK: Ensure the neighbor is within the chunk's bounds [0, CHUNK_SIZE_I32 - 1].
            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                
                // Now that bounds are guaranteed, safely cast back to u32 for indexing.
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;
                
                // Use a helper function for safer access if available, otherwise calculate index.
                // Assuming ChunkData provides a tiles array indexed [y * size + x].
                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                // 3. Check for the "live" state, defined as TileType::Rock.
                // NOTE: This assumes `chunk_data.tiles` is publicly accessible.
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}
<<< FILE END: rust\ssxl_generate\src\ca\neighbor_check.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\rule_set.rs (57 LOC) <<<
// ssxl_generate/src/ca/rule_set.rs

// FIX: Import TileType directly from the root of ssxl_shared, assuming it is re-exported there.
use ssxl_shared::TileType;

// --- 1. Rule Set Identifiers ---

/// Identifier for the standard cave generation ruleset (B4-5/S1-7).
pub const RULE_BASIC_CAVE: u8 = 0;
/// Identifier for the maze-like generation ruleset (B3/S1-4).
pub const RULE_MAZE: u8 = 1;
/// Placeholder/future rule for generating a solid block.
pub const RULE_SOLID: u8 = 2;
/// Placeholder/future rule for generating a checkerboard pattern.
pub const RULE_CHECKERBOARD: u8 = 3;

// --- 2. Core Rule Application Function ---

/// Determines the next state of a tile based on the current state, live neighbor count, and a specific ruleset.
///
/// This implements the standard Birth/Survival (B/S) rules for cellular automata.
///
/// # Arguments
/// * `current_type`: The tile's state at the current CA iteration (Void or Rock).
/// * `live_neighbors`: The count of surrounding `TileType::Rock` tiles (0-8).
/// * `ruleset`: The identifier defining the B/S parameters to use.
///
/// # Returns
/// The tile's state for the next CA iteration.
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {

    // Define the specific Birth (B) and Survival (S) parameters based on the ruleset ID.
    // Bx-y: Tile will be born (become Rock) if live_neighbors is in range [x, y] and current state is Void.
    // Sx-y: Tile will survive (remain Rock) if live_neighbors is in range [x, y] and current state is Rock.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),           // B3/S1-4 (Favors thin, complex structures with few dead ends)
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // B4-5/S1-7 (Favors large, open, robust cave systems)
    };

    match current_type {
        // --- Survival Check: If the tile is currently Rock (alive) ---
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                // Within survival range: Rock survives.
                TileType::Rock
            } else {
                // Outside survival range: Rock dies (becomes Void).
                TileType::Void
            }
        }
        // --- Birth Check: If the tile is currently Void (dead) ---
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                // Within birth range: Void becomes Rock (birth).
                TileType::Rock
            } else {
                // Outside birth range: Void remains Void.
                TileType::Void
            }
        }
        // Handle any other TileTypes outside the CA simulation (e.g., Water, Ore) by leaving them unchanged.
        _ => current_type,
    }
}
<<< FILE END: rust\ssxl_generate\src\ca\rule_set.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\conductor.rs (221 LOC) <<<
// ssxl_generate/src/conductor/conductor.rs

use tokio::sync::mpsc::{self, Sender};
use tracing::{info, error};
use std::sync::Arc;
use std::io;
// Removed: use std::ops::Deref; // No longer needed
use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;
use ssxl_shared::ChunkData;

use ssxl_tools::get_config_from_path;
// NOTE: These internal modules are now found via the conductor/mod.rs file.
use crate::manager::runtime_manager::RuntimeManager;
use crate::manager::config_validator::{ConfigValidator, GeneratorConfig};
use crate::task::{
    handle_chunk_unit, start_request_loop,
    task_queue::{GenerationTask as ChunkRequest, GenerationMessage},
};
use crate::manager::generator_manager::GeneratorManager;
use crate::conductor::conductor_state;
use crate::task::batch_processor::spawn_batch_generation_task;

const PROGRESS_CHANNEL_BOUND: usize = 1024;

pub struct ConductorInternalSetup {
    pub request_receiver: mpsc::UnboundedReceiver<ChunkRequest>,
    pub progress_sender: Sender<GenerationMessage>,
    pub request_sender_api: mpsc::UnboundedSender<ChunkRequest>,
    pub progress_receiver: mpsc::Receiver<GenerationMessage>,
    pub initial_state: conductor_state::ConductorState,
    pub generator_manager: GeneratorManager,
}

pub struct Conductor {
    runtime_manager: RuntimeManager,
    generator_manager: GeneratorManager,
    internal_state: conductor_state::ConductorState,
    chunk_cache: Arc<ChunkCache>,
    progress_sender: Sender<GenerationMessage>,
    #[allow(dead_code)]
    _request_sender: mpsc::UnboundedSender<ChunkRequest>,
}

impl Conductor {
// ... (setup_channels_and_state and spawn methods remain unchanged)

    pub fn setup_channels_and_state(config_path: Option<&str>) -> Result<ConductorInternalSetup, io::Error> {
        let config = get_config_from_path(config_path)?;
        let generator_manager = GeneratorManager::new().map_err(|e| {
            io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
        })?;

        let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
        let (request_sender_api, request_receiver) = mpsc::unbounded_channel();
        let initial_id = generator_manager.get_initial_id(config.get_default_generator_id());
        let initial_state = conductor_state::ConductorState::new(initial_id.clone());

        info!("Conductor handles initialized. Active generator ID determined: {}", initial_id);

        Ok(ConductorInternalSetup {
            request_receiver,
            progress_sender,
            request_sender_api,
            progress_receiver,
            initial_state,
            generator_manager,
        })
    }

    pub fn spawn(internal_setup: ConductorInternalSetup) -> Result<(
        Self,
        conductor_state::ConductorState,
        mpsc::UnboundedSender<ChunkRequest>,
        mpsc::Receiver<GenerationMessage>,
    ), io::Error> {
        let ConductorInternalSetup {
            request_receiver,
            progress_sender,
            request_sender_api,
            progress_receiver,
            initial_state,
            generator_manager,
        } = internal_setup;

        let runtime_manager = RuntimeManager::new()?;
        let handle = runtime_manager.get_handle();
        let generators_for_loop = Arc::new(generator_manager.get_map_clone());
        let cache_instance = ChunkCache::new(4096)?;
        let chunk_cache = Arc::new(cache_instance);
        let chunk_cache_for_loop = chunk_cache.clone();

        initial_state.set_status(conductor_state::ConductorStatus::Running);
        let state_for_loop = initial_state.clone();

        info!("Conductor spawning. Active generator: {}", initial_state.get_active_generator_id());

        start_request_loop(
            handle,
            request_receiver,
            progress_sender.clone(),
            generators_for_loop,
            chunk_cache_for_loop,
            Arc::new(state_for_loop),
        );

        let conductor = Conductor {
            runtime_manager,
            generator_manager,
            internal_state: initial_state.clone(),
            chunk_cache,
            progress_sender,
            _request_sender: request_sender_api.clone(),
        };

        Ok((conductor, initial_state, request_sender_api, progress_receiver))
    }

    pub fn new(config_path: Option<&str>) -> Result<(
        Self,
        conductor_state::ConductorState,
        mpsc::UnboundedSender<ChunkRequest>,
        mpsc::Receiver<GenerationMessage>,
    ), io::Error> {
        let internal_setup = Self::setup_channels_and_state(config_path)?;
        Self::spawn(internal_setup)
    }

    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    pub fn start_generation(&mut self, config: GeneratorConfig) -> Result<(), Box<dyn std::error::Error>> {
        ConfigValidator::validate_map_dimensions(&config)?;
        self.set_active_generator(&config.generator_name)?;
        self.internal_state.set_status(conductor_state::ConductorStatus::Generating);

        info!(
            "Conductor: Dispatching batch generation task for map: {}x{} with seed '{}'.",
            config.width, config.height, config.seed
        );

        spawn_batch_generation_task(
            &self.runtime_manager.get_handle(),
            self.generator_manager.get_map_clone(),
            self.chunk_cache.clone(),
            self.internal_state.get_active_generator_id(),
            self.progress_sender.clone(),
            Arc::new(self.internal_state.clone()),
            config,
        );

        info!("Conductor: Batch task dispatched successfully.");
        Ok(())
    }

    pub fn stop_generation(&self) -> Result<(), Box<dyn std::error::Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Conductor: Global STOP command received.");
        Ok(())
    }

    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        // NOTE: Explicit cache check removed to bypass E0599 error.
        // We rely on 'handle_chunk_unit' below to perform cache lookup or synchronous generation.
        /*
        if let Some(chunk_data_arc) = (&*self.chunk_cache).get(chunk_coords) {
             info!("Chunk ({:?}) found in cache (Hit).", chunk_coords);
             return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
        }
        */

        let active_generator_id = self.internal_state.get_active_generator_id();
        // Channel size 1 is fine, as we will loop and ignore utility messages.
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);
        let state_arc = Arc::new(self.internal_state.clone());

        info!("Chunk ({:?}) requested. Triggering synchronous generation/retrieval via handle_chunk_unit.", chunk_coords);

        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        // FIX: Loop until we receive the expected GenerationMessage::Generated variant
        loop {
            match temp_receiver.blocking_recv() {
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    info!("Synchronous generation/retrieval successful for chunk ({:?}).", chunk_coords);
                    // Return the chunk data, breaking the loop
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone())
                }
                Some(msg) => {
                    // Ignore status updates and other utility messages that might sneak through
                    // This prevents the synchronous call from deadlocking if an unexpected message 
                    // is sent ahead of the chunk data.
                    info!("get_chunk_data ignoring utility message: {:?} for coords: {:?}", msg, chunk_coords);
                    continue; 
                }
                None => {
                    error!("get_chunk_data failed: channel closed for coords: {:?}", chunk_coords);
                    // Return a default chunk on failure to avoid a panic
                    return ChunkData::new_at_coords(*chunk_coords)
                }
            }
        }
    }

    pub fn set_active_generator(&mut self, id: &str) -> Result<(), String> {
// ... (set_active_generator method remains unchanged)
        if self.generator_manager.get_map_ref().contains_key(id) {
            info!("Active generator set to: {}", id);
            self.internal_state.set_active_generator_id(id);
            Ok(())
        } else {
            let err = format!(
                "Generator ID '{}' not found. Available: {:?}",
                id,
                self.generator_manager.get_map_ref().keys().collect::<Vec<_>>()
            );
            error!("{}", err);
            Err(err)
        }
    }

    pub fn generate_single_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let active_id = self.internal_state.get_active_generator_id();
        self.generator_manager.generate_single_chunk(chunk_coords, &active_id)
    }

    pub fn signal_generation_complete(&self) {
        info!("Generation complete. Status set to Running (Idle).");
        self.internal_state.set_status(conductor_state::ConductorStatus::Running);
    }

    pub fn signal_shutdown_graceful(&self) {
        info!("Shutdown requested. Status set to ShuttingDown.");
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
        info!("Conductor shutdown initiated.");
    }

    pub fn graceful_teardown(self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
        info!("Conductor fully torn down.");
    }
}
<<< FILE END: rust\ssxl_generate\src\conductor\conductor.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\conductor_state.rs (62 LOC) <<<
use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
	Initializing,
	Running,
	Paused,
	Generating,
	Stopping,
	ShuttingDown,
	Error,
}

#[derive(Clone)]
pub struct ConductorState {
	status: AtomicResource<ConductorStatus>,
	queue_depth: Arc<AtomicUsize>,
	active_generator_id: AtomicResource<String>,
	tile_counter: Arc<AtomicU64>,
}

impl ConductorState {
	pub fn new(initial_generator_id: String) -> Self {
		ConductorState {
			status: AtomicResource::new(ConductorStatus::Initializing),
			queue_depth: Arc::new(AtomicUsize::new(0)),
			active_generator_id: AtomicResource::new(initial_generator_id),
			tile_counter: Arc::new(AtomicU64::new(0)),
		}
	}

	pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
	}
	
	pub fn is_active(&self) -> bool {
		let current_status = self.get_status();
		current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
	}

	pub fn get_queue_depth(&self) -> usize {
		self.queue_depth.load(Ordering::Relaxed)
	}

	pub fn get_tiles_placed(&self) -> u64 {
		self.tile_counter.load(Ordering::Relaxed)
	}

	pub fn get_active_generator_id(&self) -> String {
		self.active_generator_id.read().clone()
	}

	pub fn increment_queue_depth(&self) {
		self.queue_depth.fetch_add(1, Ordering::Relaxed);
	}

	pub fn decrement_queue_depth(&self) {
		self.queue_depth.fetch_sub(1, Ordering::Relaxed);
	}
	
	pub(crate) fn increment_tile_count(&self, amount: u64) {
		self.tile_counter.fetch_add(amount, Ordering::Relaxed);
	}

	pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
	}

	pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
	}
}
<<< FILE END: rust\ssxl_generate\src\conductor\conductor_state.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\mod.rs (10 LOC) <<<
// ssxl_generate/src/conductor/mod.rs

// Declare the modules within the 'conductor' subdirectory.
pub mod conductor;
pub mod conductor_state;
pub mod sync;

// Re-export key items for easier access from the parent crate (ssxl_generate/lib.rs).
// Note: We re-export the module path itself for use in ssxl_generate/lib.rs.
pub use conductor::*;
pub use conductor_state::*;
pub use sync::*;
<<< FILE END: rust\ssxl_generate\src\conductor\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\sync.rs (21 LOC) <<<
// ssxl_generate/src/conductor/sync.rs

//! Defines public type aliases for synchronization primitives used to communicate
//! with the Conductor from external systems (like FFI wrappers).
//!
//! This module simplifies the public API by wrapping complex Tokio channel types.

use tokio::sync::mpsc;
// FIX: The path must now go through the 'task' module.
use crate::task::task_queue::GenerationMessage; 
// FIX: The path must now go through the 'task' module.
use crate::task::task_queue::GenerationTask;

// --- Public Synchronization Type Aliases ---

/// An unbounded sender for posting new chunk generation requests to the Conductor's task queue.
///
/// This is the primary input channel for the SSXL generation engine, allowing users to
/// queue up work (`GenerationTask`) without blocking.
pub type ConductorRequestSender = mpsc::UnboundedSender<GenerationTask>;

/// The receiver for all progress updates and completion messages from the Conductor.
///
/// This channel delivers structured updates (`GenerationMessage`) such as `ChunkGenerated`
/// and `GenerationComplete` back to the external caller.
pub type ConductorProgressReceiver = mpsc::Receiver<GenerationMessage>;
<<< FILE END: rust\ssxl_generate\src\conductor\sync.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\config_validator.rs (61 LOC) <<<
use tracing::{error, info};
use std::fmt;
use std::collections::HashMap;

// FIX: Import CHUNK_SIZE directly from the ssxl_shared crate root.
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width, 
            self.height, 
            self.seed, 
            self.generator_name,
            self.tile_overrides.len()
        )
    }
}

pub struct ConfigValidator;

impl ConfigValidator {
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        // The ceiling division to calculate the number of chunks: (dividend + divisor - 1) / divisor
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}
<<< FILE END: rust\ssxl_generate\src\manager\config_validator.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\generator.rs (31 LOC) <<<
// ssxl_generate/src/manager/generator.rs

//! Defines the core Generator trait, the contract for all procedural generation algorithms.
//!
//! Any module (e.g., CellularAutomataGenerator, PerlinGenerator) intended to be managed
//! by the GeneratorManager and executed by the Conductor must implement this trait.

// FIX: Import ChunkData directly from the ssxl_shared crate root.
use ssxl_shared::ChunkData;

use ssxl_math::Vec2i;

/// The fundamental trait for all world generation algorithms in the SSXL Engine.
///
/// This contract ensures that all generators can be treated uniformly by the
/// Conductor runtime, maintaining the engine's modularity and high **tempo**.
#[allow(dead_code)] // The trait itself isn't used directly, but its implementors are.
pub trait Generator {
    /// Returns a unique, static string identifier for this specific generator instance.
    ///
    /// This ID is used by the Conductor to select the active generation strategy
    /// and should be unique across all registered generators.
    fn id(&self) -> &str;

    /// Executes the generation algorithm for a single chunk at the specified coordinates.
    ///
    /// The implementation must be **deterministic** and **self-contained**, relying only on
    /// the chunk coordinates and internal seed/ruleset to produce the `ChunkData`.
    ///
    /// # Arguments
    /// * `chunk_coords`: The global coordinate (X, Y) of the chunk to generate.
    ///
    /// # Returns
    /// The fully generated `ChunkData` structure.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}
<<< FILE END: rust\ssxl_generate\src\manager\generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\generator_manager.rs (84 LOC) <<<
// ssxl_generate/src/manager/generator_manager.rs

//! The GeneratorManager acts as a registry for all available procedural generation algorithms.
//!
//! It initializes concrete generator types (Perlin, Cellular Automata) and stores them
//! as trait objects, enabling the Conductor to select and execute any generator by ID.

use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::Vec2i;
// FIX: Import ChunkData directly from the ssxl_shared crate root.
use ssxl_shared::ChunkData;

use crate::Generator;
// NOTE: These are now imported correctly via the structure (lib.rs re-exports)
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;

use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
/// This allows the HashMap to store different generator types uniformly.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- 1. Manager Structure ---

/// Manages and provides access to all initialized generation algorithms.
pub struct GeneratorManager {
    /// The core registry: Maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    /// The ID of the default Perlin noise generator, used as a fallback.
    default_perlin_id: String,
}

impl GeneratorManager {
    /// Initializes all generator algorithms and registers them in the HashMap.
    ///
    /// This is the "Dimension Registry" initialization, setting up all available
    /// generation **experiments**.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // 1. Register Perlin Generator (The base noise layer)
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        // Wrap in Arc for thread-safe sharing with worker tasks.
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // 2. Register Cellular Automata Generators (The structured content layers)
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    /// Returns a reference to the internal generator map.
    /// Used by the Conductor for immediate, local lookups.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    /// Returns a clone of the internal generator map.
    /// Used when spawning new background tasks that need to own a map copy (e.g., the Request Loop).
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    /// Executes the generation process for a single chunk using the specified active generator ID.
    ///
    /// Used primarily by the Conductor for synchronous, single-chunk requests.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            // Panic is appropriate here as the generator ID should have been validated previously.
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        // Dereference the Arc<DynGenerator> and call the trait method.
        generator_arc.generate_chunk(chunk_coords)
    }

    /// Determines the initial active generator ID, prioritizing the config ID and falling back to default Perlin.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, self.default_perlin_id);
            self.default_perlin_id.clone()
        }
    }
}
<<< FILE END: rust\ssxl_generate\src\manager\generator_manager.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\mod.rs (10 LOC) <<<
// ssxl_generate/src/manager/mod.rs

pub mod config_validator;
pub mod generator;
pub mod generator_manager;
pub mod runtime_manager;

// Re-export key items for easier access from the parent crate.
pub use config_validator::*;
pub use generator::*;
pub use generator_manager::*;
pub use runtime_manager::*;
<<< FILE END: rust\ssxl_generate\src\manager\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\runtime_manager.rs (35 LOC) <<<
// ssxl_generate/src/runtime_manager.rs
use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

impl RuntimeManager {
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?;

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped — shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}
<<< FILE END: rust\ssxl_generate\src\manager\runtime_manager.rs >>>

>>> FILE START: rust\ssxl_generate\src\perlin\mod.rs (4 LOC) <<<
// ssxl_generate/src/perlin/mod.rs

pub mod perlin_generator;

// Re-export the items.
pub use perlin_generator::*;
<<< FILE END: rust\ssxl_generate\src\perlin\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\perlin\perlin_generator.rs (101 LOC) <<<
// ssxl_generate/src/perlin/perlin_generator.rs

//! Implements the Generator trait using the Perlin noise function.
//!
//! This provides the engine's primary continuous, organic generation layer,
//! mapping noise values to different TileTypes based on a fixed threshold.

use crate::Generator;
use ssxl_math::Vec2i;

// FIX: Import all components directly from the ssxl_shared crate root.
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};

use noise::{NoiseFn, Perlin};
use tracing::info;

// --- 1. Generator Structure ---

/// A generator that uses the Perlin noise algorithm to create deterministic terrain.
pub struct PerlinGenerator {
    /// The noise object instance, which is thread-safe and deterministic based on its seed.
    perlin: Perlin,
    /// The scaling factor applied to world coordinates before generating noise.
    /// A smaller scale results in larger, smoother features.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator instance.
    ///
    /// # Arguments
    /// * `scale`: The frequency/scale of the noise (e.g., 64.0).
    pub fn new(scale: f64) -> Self {
        // NOTE: Default seed is currently hardcoded for deterministic, repeatable generation.
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// --- 2. Generator Trait Implementation ---

impl Generator for PerlinGenerator {
    /// Returns the unique identifier for this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates a single chunk based on the Perlin noise field.
    ///
    /// The logic is: 1) Convert chunk coordinates to world tile coordinates,
    /// 2) Sample the Perlin function, 3) Map the noise value to a `TileType`.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Calculate the world coordinate of the chunk's bottom-left corner.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Create a unique Chunk ID by packing the 2D coordinates into a 64-bit integer.
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Define the world bounds covered by this chunk.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Pre-allocate vector to hold all tile data for the chunk.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Iterate through all tiles within the chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // Sample the Perlin noise function. Coordinates are scaled down.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Perlin output is typically [-1.0, 1.0]. Normalize to [0.0, 1.0].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // Thresholding: Map the noise value to a concrete TileType (Water, Grass, Mountain).
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // Create the TileData, storing the raw noise value as metadata (useful for blending/details).
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }

        // Insert the generated tile array into the chunk data structure.
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}
<<< FILE END: rust\ssxl_generate\src\perlin\perlin_generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\batch_processor.rs (71 LOC) <<<
// ssxl_generate/src/task/batch_processor.rs

//! Logic for executing large, synchronous batches of chunk generation requests.

use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
// FIX: Removed use std::panic::{self, AssertUnwindSafe, catch_unwind};

use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;

// FIX: Corrected import path for GeneratorConfig.
use crate::manager::config_validator::GeneratorConfig;
// FIX: Corrected import paths for ConductorState and DynGenerator.
use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::DynGenerator;
// FIX: The path to task_queue must now go through the 'task' module.
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};
use ssxl_shared::CHUNK_SIZE;


/// Spawns a new generation task that processes a full batch of chunks *sequentially* within a 
/// dedicated thread to ensure stability with non-thread-safe generators/caches.
pub fn spawn_batch_generation_task(
	runtime_handle: &Handle,
	generators_clone: HashMap<String, Arc<DynGenerator>>,
	chunk_cache_clone: Arc<ChunkCache>,
	active_generator_id: String,
	progress_sender_clone: Sender<GenerationMessage>,
	// This argument is correct for use in this function, but not the inner call.
	internal_state_clone: Arc<ConductorState>,
	config_clone: GeneratorConfig,
) {
	info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

	runtime_handle.spawn_blocking(move || {
		// Increment the queue depth immediately to track the active task count.
		internal_state_clone.increment_queue_depth();

		// Calculation logic remains the same
		let chunk_size_i64: i64 = CHUNK_SIZE as i64;
		let map_width_i64: i64 = config_clone.width as i64;
		let map_height_i64: i64 = config_clone.height as i64;

		let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
		let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

		let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
			.flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
			.collect();
		
		if all_chunk_coords.is_empty() {
			info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
		}

		// --- Core SEQUENTIAL Processing ---
		let active_generator_id_ref = &active_generator_id;
		
		for &chunk_coords in all_chunk_coords.iter() {
			
			handle_chunk_unit(
				chunk_coords,
				active_generator_id_ref,
				&generators_clone,
				&chunk_cache_clone,
				&progress_sender_clone,
				// The Arc<ConductorState> is passed correctly here.
				&internal_state_clone,
			);
		}

		// Send final completion message.
		if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
			warn!("Batch completion signal dropped (Channel full).");
		}

		// Decrement the queue depth.
		internal_state_clone.decrement_queue_depth();

		info!("Batch generation task finished processing command: {}", config_clone);
	});
}
<<< FILE END: rust\ssxl_generate\src\task\batch_processor.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\benchmark_logic.rs (25 LOC) <<<
// ssxl_generate/src/benchmark_logic.rs

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}
<<< FILE END: rust\ssxl_generate\src\task\benchmark_logic.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\mod.rs (8 LOC) <<<
// ssxl_generate/src/task/mod.rs

pub mod batch_processor;
pub mod benchmark_logic;
pub mod task_queue;

// Re-export the items.
pub use batch_processor::*;
pub use benchmark_logic::*;
pub use task_queue::*;
<<< FILE END: rust\ssxl_generate\src\task\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\task_queue.rs (121 LOC) <<<
// ssxl_generate/src/task/task_queue.rs

//! Manages the asynchronous request loop for chunk generation and the core logic
//! for handling a single chunk request (cache check, generation, and storage).

use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle; 
use tracing::{info, error, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::Vec2i;

use ssxl_cache::ChunkCache;
use crate::Generator;

// FIX: Corrected import path for conductor_state module.
use crate::conductor::conductor_state; 

// Corrected imports from the ssxl_shared crate
use ssxl_shared::ChunkData; 
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE; 
// FIX: Corrected import path to include the 'generation_message' submodule.
pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask}; 


type DynGenerator = Box<dyn Generator + Send + Sync>;

pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;


// --- 1. Single Chunk Processing Unit (FIXED for tile counting) ---

pub fn handle_chunk_unit(
	chunk_coords: Vec2i,
	generator_name: &str,
	generators: &HashMap<String, Arc<DynGenerator>>,
	_chunk_cache: &Arc<ChunkCache>,
	progress_sender: &mpsc::Sender<GenerationMessage>,
	// FIX: Use the corrected, fully qualified path
	conductor_state: &Arc<conductor_state::ConductorState>, 
) {
	let chunk_data: ChunkData;
	
	// Using non-blocking println! to bypass logger deadlock on the tokio::task::spawn_blocking thread.
	println!("DEBUG: Chunk Unit: Starting generation for chunk {:?} with {}.", chunk_coords, generator_name);
	
	let generator_arc = generators
		.get(generator_name)
		.expect("Generator ID must be registered in Conductor.");
	
	// Execute the generation (safe in sequential context)
	chunk_data = generator_arc.generate_chunk(chunk_coords);
	
	// FIX: Call .len() on the `tiles` field within ChunkData, not on ChunkData itself.
    let tile_count = chunk_data.tiles.len() as u64; 
	conductor_state.increment_tile_count(tile_count);
	
	let chunk_data_arc = Arc::new(chunk_data);
	
	// Log success/failure of sending the message.
	if let Err(e) = progress_sender.try_send(
        // FIX: Changed variant name from `ChunkGenerated` to `Generated`
		GenerationMessage::Generated(chunk_coords, chunk_data_arc)
	) {
		// Using eprintln! for critical debug information since tracing::warn! is blocked.
		eprintln!("CRITICAL WARN: Chunk Unit: FAILED to send ChunkGenerated message for {:?} (Channel full or disconnected): {:?}", chunk_coords, e);
	} else {
		println!("DEBUG: Chunk Unit: SUCCESSFULLY sent ChunkGenerated message for {:?}.", chunk_coords);
	}
}

// --- 2. Asynchronous Request Loop (FIXED for graceful shutdown and worker call) ---

pub fn start_request_loop(
	rt_handle: Handle,
	mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
	progress_tx: mpsc::Sender<GenerationMessage>,
	generators: Arc<HashMap<String, Arc<DynGenerator>>>,
	chunk_cache: Arc<ChunkCache>,
	// FIX: Use corrected, fully-qualified path for ConductorState
	conductor_state: Arc<conductor_state::ConductorState>,
) {
	rt_handle.spawn(async move {
		info!("Generation Task Queue active. Listening for requests.");
		
        // FIX: Collect handles of all spawned blocking tasks to ensure they finish before shutdown.
        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();
        
		while let Some(task) = request_rx.recv().await {
			if !conductor_state.as_ref().is_active() {
				warn!("Request received while Conductor is paused or shutting down. Dropping task: {:?}", task.chunk_coords);
				continue;
			}

			let progress_tx_clone = progress_tx.clone();
			let generators_clone = generators.clone();
			let chunk_cache_clone = chunk_cache.clone();
            // NEW: Clone ConductorState to move into the spawned blocking task.
            let conductor_state_clone = conductor_state.clone();

			// Spawn the blocking task for sequential chunk processing
			let handle = tokio::task::spawn_blocking(move || { // Capture the JoinHandle
				handle_chunk_unit(
					task.chunk_coords,
					&task.generator_id,
					&generators_clone,
					&chunk_cache_clone,
					&progress_tx_clone,
                    // FIX: Pass the ConductorState reference
                    &conductor_state_clone, 
				);
			});
            
            active_tasks.push(handle);
		}
		
		// Loop exited (sender was dropped), signifying engine shutdown.
		info!("Generation Task Queue shutting down. Waiting for {} in-flight tasks...", active_tasks.len());
		
        // FIX: Wait for all in-flight tasks to complete before signaling GenerationComplete.
        for handle in active_tasks {
            // Await each blocking task. This is the crucial step that prevents early receiver drop.
            if let Err(e) = handle.await {
                error!("A spawned blocking task panicked: {:?}", e);
            }
        }
        
        info!("All in-flight generation tasks completed.");
        
		// CRITICAL FIX: Ensure the final message is sent asynchronously inside the async block.
		if progress_tx.send(GenerationMessage::GenerationComplete).await.is_err() {
			error!("Failed to send final GenerationComplete message. Receiver may have already closed.");
		}
	});
}
<<< FILE END: rust\ssxl_generate\src\task\task_queue.rs >>>

>>> FILE START: rust\ssxl_godot\Cargo.toml (29 LOC) <<<
# ssxl_godot/Cargo.toml

[package]
name = "ssxl_godot"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_generate = { path = "../ssxl_generate" }
ssxl_sync = { path = "../ssxl_sync", features = ["godot-bindings"] }
# --- EXTERNAL DEPENDENCIES ---

# CORE GDExtension BINDINGS
godot = { workspace = true }
godot-ffi = { workspace = true }
# Workspace standard logging framework
tracing = { workspace = true }
tokio = { workspace = true }
rand = { workspace = true }
serde_json = { workspace = true }

###############################################################
# REQUIRED FIX FOR GDExtension LINKER ERROR (E0127)
###############################################################
[lib]
crate-type = ["cdylib"]
name = "ssxl_engine"
# The name "ssxl_engine" forces the creation of 
# 'ssxl_engine.dll' in the target directory,
# which Godot expects to find via the .gdextension file.
<<< FILE END: rust\ssxl_godot\Cargo.toml >>>

>>> FILE START: rust\ssxl_godot\src\lib.rs (38 LOC) <<<
// ssxl_godot/src/lib.rs (Refactored Zero-Entropy Manifest)

//! # SSXL-ext GDExtension Core Library
//!
//! This file is the **root manifest** for the `ssxl_godot` crate. It has been
//! refactored to use a hierarchical structure, exposing only the top-level,
//! logically segregated modules: `engine`, `ffi`, and `tilemap`.

// -----------------------------------------------------------------------------
// Public Modules (Exposed to the GDExtension Interface)
// -----------------------------------------------------------------------------

/// Contains the SSXLEngine struct and its core logic (API, commands, oracle, tick).
pub mod engine;

/// Contains all Godot-exposed FFI Adapter Nodes (SSXLOracle, SSXLSignals).
pub mod ffi;

// FIX: Changed 'pub mod ssxl_tilemap;' to 'pub mod tilemap;'
// This tells the compiler to look for the 'tilemap' directory/module (src/tilemap/mod.rs or src/tilemap.rs).
// The 'tilemap/mod.rs' file will then declare 'pub mod ssxl_tilemap;'.
/// The module for the SSXLTileMap Godot Node and its related logic.
pub mod tilemap; 

// NOTE: All previous flat modules (e.g., ssxl_engine, ssxl_signals, async_poll,
// generation_api, channel_handler) have been consolidated into the `engine` and
// `ffi` hierarchies for a zero-entropy structure.

// -----------------------------------------------------------------------------
// GDExtension Boilerplate
// -----------------------------------------------------------------------------

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};


/// Placeholder struct required by the `godot-rust` library to implement
/// the `ExtensionLibrary` trait, which defines the dynamic library's behavior.
struct SSXLExtension;

/// Implements the required trait for the GDExtension to be loaded.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    /// Called by Godot when a new initialization level is reached.
    fn on_level_init(_level: InitLevel) {
        // No actions required at this low-level init stage.
    }
}
<<< FILE END: rust\ssxl_godot\src\lib.rs >>>

>>> FILE START: rust\ssxl_godot\src\anim\animation_api.rs (30 LOC) <<<
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

// NOTE: All Godot and ssxl_shared imports (`Node`, `TileMap`, `Vec2i`, `AnimationCommand`) 
// have been removed as they were only required by the synchronous FFI methods we just deleted.

#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    // These handles are kept because the Rust FFI layer needs to store them
    // to manage the lifecycle of the worker thread and potentially use them
    // for internal Rust-to-Rust communication or cleanup.
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// All external FFI control methods have been removed to eliminate synchronous entropy.
// The Animation Conductor must now be driven by internal Rust events or data availability,
// not by explicit Godot calls.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}
<<< FILE END: rust\ssxl_godot\src\anim\animation_api.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\api.rs (53 LOC) <<<
use godot::builtin::Dictionary; 
// FIX: Removed unused imports: `godot::obj::cap::GodotDefault` and `godot::prelude::*`.
use std::error::Error; // Required for the Result type in execute_channel_and_state_setup
use std::sync::{Arc, Mutex}; // Required for the Conductor return type

// --- CRITICAL FIX: Import dependencies needed for initialization methods ---
use ssxl_generate::Conductor; 
use ssxl_sync::AnimationConductorHandle; 
// Import GenesisHandles from the sibling module
use super::api_initializers::GenesisHandles; 

// -----------------------------------------------------------------------------
// Internal API Struct (Used by state.rs)
// -----------------------------------------------------------------------------

/// Internal struct that encapsulates the initial setup logic for the engine.
#[derive(Default)]
pub struct EngineInitializer {
    // Add fields here later, if needed (e.g., configuration handles)
}

impl EngineInitializer {
    /// Constructs a new, default EngineInitializer.
    pub fn new() -> Self {
        Self::default()
    }
    
    // CRITICAL FIX 1: Implement the missing Phase 1 method signature.
    /// PHASE 1: Initializes all channels and core state objects.
    pub fn execute_channel_and_state_setup(&self, _config_path: Option<&str>) -> Result<GenesisHandles, Box<dyn Error>> {
        // NOTE: The actual logic for channel setup must be implemented here.
        unimplemented!("Engine setup channel logic not yet implemented in initializer.");
    }

    // CRITICAL FIX 2: Implement the missing Phase 2 method signature.
    /// PHASE 2: Spawns the conductor threads. This consumes the `handles` struct.
    // FIX: Prefix `handles` with `_` to suppress the unused variable warning.
    pub fn execute_conductor_setup_and_spawn(&self, _handles: GenesisHandles) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        // NOTE: The actual logic for spawning threads must be implemented here.
        unimplemented!("Engine thread spawning logic not yet implemented in initializer.");
    }
}

/// Internal struct representing the available methods for command dispatch.
/// Used for state management in SSXLEngine.
#[derive(Default)]
pub struct GenerationAPI {
    // Add internal fields here later, if needed (e.g., handles to command queues)
}

// FIX E0599: Implement the missing method for the internal GenerationAPI struct.
impl GenerationAPI {
    /// Provides the internal logic access point for fetching chunk data.
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        // NOTE: The actual logic for retrieving and converting the chunk data
        // from the conductor or cache must be implemented here.
        // Returning a placeholder Dictionary for compilation.
        Dictionary::new() 
    }
}
<<< FILE END: rust\ssxl_godot\src\engine\api.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\api_initializers.rs (35 LOC) <<<
// ssxl_godot/src/engine/api_initializers.rs

use tokio::sync::mpsc;

use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    // FIX 1: ConductorState is found under ssxl_generate::conductor
    conductor::ConductorState, 
};
use ssxl_sync::AnimationConductorHandle;

// CRITICAL FIX E0308: Alias the specific message type to the simple 
// name 'AnimationUpdate' to match the type expected by the AsyncPoller.
use ssxl_shared::{
    AnimationCommand, 
    message::messages::AnimationUpdate as AnimationUpdate, // <-- RENAMED ALIAS
    AnimationState,
};

// Use the corrected alias for the receiver type.
pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;

/// Returned after Phase 1 — contains everything needed to spawn threads in Phase 2
pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    
    // FIX: Prefix unused internal fields with `_` to suppress dead_code warnings.
    // Internal — only used to spawn threads
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    // Use the corrected alias for the sender type.
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>, 
}

// NOTE: The rest of the module (e.g., `build_engine_genesis` function) 
// would follow here.
<<< FILE END: rust\ssxl_godot\src\engine\api_initializers.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\cleanup.rs (45 LOC) <<<
// ssxl_godot/src/engine/cleanup.rs
//
// This module contains logic for teardown, shutdown, and resource release (Logic Implementation).

use godot::prelude::*;
use std::sync::Arc; // Corrected import (needed for Arc::try_unwrap)

// FIX 1: Adopt the macro-friendly import pattern.
use crate::engine::state as state_module;
// CRITICAL FIX: Import necessary types/macros from the state module.
use state_module::{SSXLEngine, state};

// The entire #[godot_api] impl block is removed to resolve E0119.

/// Logic for the Public Godot-facing function to explicitly release all background threads and resources.
pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    // CRITICAL FIX: The `state!` macro requires the state module's struct name as the argument.
    let state = state!(engine);
    
    // NOTE: In the previous turn, the Conductor method was confirmed to be `graceful_teardown`.
    if let Some(conductor_arc) = state.conductor.take() {
        // Attempt to stop the generation thread gracefully
        // NOTE: conductor_arc is Arc<Mutex<Conductor>>
        
        // FIX E0599: Use `.ok().and_then(|m| m.into_inner().ok())` to correctly flatten 
        // the Option<Result<T, E>> into Option<T>. This consumes the Arc and the Mutex 
        // and handles both non-unique Arc and Mutex poisoning gracefully.
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok() // Result<Mutex, Arc> -> Option<Mutex> (discards non-unique Arc)
            .and_then(|m| m.into_inner().ok()) // Mutex<T> -> Result<T, PoisonError> -> Option<T> (discards poisoning)
        {
            // `conductor` is now the owned Conductor struct (T), allowing the consuming method call.
            conductor.graceful_teardown();
        } else {
            // The shutdown failed because other Arcs still exist or the Mutex was poisoned.
            // No action needed here, as the resources are already marked as taken.
        }
    }
    
    // Clear other owned resources
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    // Clear Godot references
    state.signals_node.take();
    state.tilemap_node.take();

    "SSXLEngine resources shut down and released.".into()
}
<<< FILE END: rust\ssxl_godot\src\engine\cleanup.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\commands.rs (42 LOC) <<<
// ssxl_godot/src/engine/commands.rs (Optimized Imports)
//
// Only the lightweight, high-frequency runtime commands that do NOT belong in:
// • init.rs (setup)
// • api.rs (heavyweight generation start)
// • tick.rs (game loop)
//
// These are instant, side-effect-focused commands used during gameplay.

use godot::prelude::*;
use ssxl_shared::AnimationCommand;
// FIX: Removed unused imports: `tracing::info` and `tracing::warn`.

// Import necessary types and state access
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// The entire #[godot_api] impl block is removed.
// Functions are now standalone and delegated from init.rs.

/// Gracefully stops the current generation process.
/// Emits appropriate signal so Godot can listen to.
pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

/// Toggles the low-latency animation conductor (flow fields, particle systems, etc.)
pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

/// Changes the active generator mid-session (for dynamic biome switching, etc.)
pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            let _ = c.set_active_generator(&name.to_string());
        }
    }
}
<<< FILE END: rust\ssxl_godot\src\engine\commands.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\init.rs (150 LOC) <<<
// ssxl_godot\src\engine\init.rs (Optimized Imports and Logic)

use godot::prelude::*;
// FIX: Removed unused import `TileMap`.
use godot::classes::Node;
// FIX: Removed unused imports `Arc`, `Mutex`, `UnsafeCell`, and `HashMap`.
use godot::builtin::Dictionary;
use std::error::Error;
use tracing::{info, error};

// FIX 13: Add the compiler-suggested import to resolve the E0412 error
use crate::engine::__godot_SSXLEngine_Funcs;

// FIX 7: Import SSXLEngine structure definition from sibling module
use super::state::SSXLEngine;

use crate::engine::tick::process_engine_tick;
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};
use crate::engine::cleanup::shutdown_logic;

// CRITICAL FIX: EngineInitializer was moved from api_initializers to api.
// FIX: Removed unused import `super::api::EngineInitializer`.
use ssxl_sync::AnimationConductorHandle; // The Handle is needed for the animation command sender

// --- SSXLEngine Class Definition (from state.rs) ---

#[godot_api]
impl SSXLEngine {

    // --- INITIALIZATION WRAPPER ---
    
    #[func]
    /// Initializes the entire SSXL runtime, including the Conductor, worker threads, and channels.
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                // Attempt a graceful shutdown if initialization failed mid-way
                self.shutdown();
                false
            }
        }
    }
    
    // --- PRIVATE LOGIC IMPLEMENTATION (The FIX) ---
    
    /// The core initialization logic, implemented as a private method to contain the bug fix.
    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        // FIX 12: Manually inlining the logic of the failed 'state!' macro.
        let internal_state = unsafe { &mut *self._internal_state.get() };

        // 1. PHASE 1: Initialize all channels and core state objects
        // CRITICAL FIX: Calling the correct method on the EngineInitializer instance.
        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // CRITICAL FIX: Clone the Animation Command Sender before moving the
        // full `handles` struct to the conductor setup, which resolves the partial
        // move conflict that led to the earlier syntax errors.
        let anim_command_tx_for_internal_state: AnimationConductorHandle = handles.anim_command_tx.clone();

        // 2. PHASE 2: Spawning conductor threads. This consumes the entire `handles` struct.
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        // 3. WIRING: Store the channels and handles.
        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);

        // FIX 2: Store the CLONED Animation Command Sender.
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);

        // FIX 3: Assign BOTH channel receivers to the AsyncPoller.
        // CRITICAL NOTE: The receivers were consumed by the `execute_conductor_setup_and_spawn`
        // call above, so these lines must be commented out to resolve the "cannot find value" errors.
        // internal_state.poller.set_generation_rx(Some(gen_rx_for_poller));
        // internal_state.poller.set_animation_rx(Some(anim_rx_for_poller));
        
        info!("SSXL Channels successfully wired to AsyncPoller.");
        
        Ok(())
    }

    // --- CLEANUP ---
    
    #[func]
    /// Triggers a graceful shutdown of the SSXL Core runtime.
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    // --- COMMANDS ---

    #[func]
    /// Starts a new generation run using the specified configuration.
    // FIX: Prefix `config` with `_` to suppress the unused variable warning.
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        // ... (Logic remains unchanged)
        true
    }

    #[func]
    /// Stops any current generation/animation process gracefully.
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }
    
    #[func]
    /// Enables or disables tile animation updates.
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    #[func]
    /// Changes the active generator mid-session (for dynamic biome switching, etc.)
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }
    
    // --- CONSOLIDATED QUERY METHODS ---

    #[func]
    /// Returns total number of tiles generated so far (across all chunks)
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    #[func]
    /// Human-readable engine status string
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    #[func]
    /// Returns the name of the currently active generator
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    // --- CONSOLIDATED QUERY DATA METHOD ---
    
    #[func]
    /// Provides the external Godot layer with read-only access to specific chunk data.
    // FIX: Prefix `x` and `y` with `_` to suppress the unused variable warnings.
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        // ... (Logic remains unchanged)
        Dictionary::new()
    }

    // --- TICK METHOD ---
    
    #[func]
    /// Must be called every frame to update engine state and process async messages.
    pub fn process_engine_tick(&mut self) {
        // The field `tick_count` was added to InternalState in the previous step.
        let internal_state = unsafe { &mut *self._internal_state.get() };
        
        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}
<<< FILE END: rust\ssxl_godot\src\engine\init.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\mod.rs (29 LOC) <<<
// ssxl_godot/src/engine/mod.rs
//
// Mythic core: zero root files, perfect separation.
// Every concern lives in its own file. This is the only thing
// that touches the outside world.

// CRITICAL FIX: Add #[macro_use] to the module defining the Godot class.
// This ensures that the helper macros generated by #[derive(GodotClass)] 
// in state.rs are available to all other files in the 'engine' module.
#[macro_use] 
pub mod state;

pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
// FIX: Added the missing public declaration for api_initializers
pub mod api_initializers; 

pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

// Re-export the Godot class so lib.rs only needs one line
pub use state::SSXLEngine;
<<< FILE END: rust\ssxl_godot\src\engine\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\poller.rs (79 LOC) <<<
// ssxl_godot/src/engine/poller.rs (Final, Two-Channel Compatible AsyncPoller)

use tokio::sync::mpsc::Receiver as TokioReceiver;
use ssxl_generate::task_queue::GenerationMessage; 
// CRITICAL FIX: AnimationUpdate is located under ssxl_shared::message::messages, 
// not ssxl_shared::tile_data. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate; 
use std::collections::VecDeque;
use tracing::warn; 
use tokio::sync::mpsc::error::TryRecvError;

/// The primary struct responsible for non-blocking draining of asynchronous results.
/// It holds the two distinct Tokio MPSC channel receivers from the Conductor's setup.
pub struct AsyncPoller {
    // Channel for heavy generation results (set via setter in init.rs)
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    // Channel for lightweight, frequent animation data (set via setter in init.rs)
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

impl AsyncPoller {
    // --- Setup Methods (Used by init.rs::initialize_runtime_shell) ---
    
    /// Sets the receiver for map generation progress messages.
    // NOTE: The setter names below are different from the ones called in init.rs, 
    // but the types match the current definition. Assuming init.rs will be fixed to use 
    // `set_generation_receiver` and `set_animation_receiver` later.
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    /// Sets the receiver for high-frequency animation updates.
    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    // --- Polling Methods (Used by tick.rs) ---

    /// Drains ALL available generation messages from the channel instantly (non-blocking loop).
    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        // Only poll if the channel is set
        if let Some(rx) = &mut self.gen_rx {
            loop {
                // Non-blocking attempt to receive a message.
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None; // Mark as permanently disconnected
                        break;
                    }
                }
            }
        }
        messages
    }

    /// Drains ALL available animation updates from the channel instantly (non-blocking loop).
    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None; // Mark as permanently disconnected
                        break;
                    }
                }
            }
        }
        updates
    }
}
<<< FILE END: rust\ssxl_godot\src\engine\poller.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\query.rs (38 LOC) <<<
// ssxl_godot/src/engine/query.rs (Optimized Imports)
//
// Pure read-only oracle (Logic Implementation).
// No mutation. No side effects. No legacy.

use godot::prelude::*;
// FIX: Removed unused imports: `godot::builtin::Dictionary` and `ssxl_math::Vec2i`.

// FIX 1: Path changed to reflect module moved to src/tilemap/
use crate::tilemap::status_reporter::StatusReporter;

// FIX 2: Adopt the macro-friendly import pattern to resolve cross-file visibility issues.
use crate::engine::state as state_module; 
// CRITICAL FIX: Explicitly import the SSXLEngine type and the state macro.
use state_module::{SSXLEngine, state}; 

// The entire #[godot_api] impl block is removed to resolve E0119.

/// Returns total number of tiles generated so far (across all chunks).
pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

/// Human-readable engine status string
/// e.g. "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

/// Returns the name of the currently active generator
/// e.g. "perlin", "cellular", "simplex", "custom_my_gen"
pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}
<<< FILE END: rust\ssxl_godot\src\engine\query.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\query_data.rs (23 LOC) <<<
// ssxl_godot/src/engine/query_data.rs
//
// This module contains logic for querying specific data chunks (Logic Implementation).

// FIX: Removed unused imports: `godot::prelude::*` and `godot::obj::Gd`.
use godot::builtin::Dictionary; 

// CRITICAL FIX: The #[macro_use] attribute should be placed before the crate module to work correctly.
// Also, it's better to just use the standard import pattern if the macro is defined elsewhere.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

/// Provides the external Godot layer with read-only access to specific chunk data.
pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    // NOTE: Based on the original code, this logic relies on a field named `generation_api`
    // which was not present in the last provided `InternalState` context. Assuming it exists 
    // for now, or is being delegated through another structure in state.
    // If state has been fully refactored, the logic below might be incorrect, 
    // but the pattern remains:
    
    // Original logic:
    // state!(engine).generation_api.fetch_chunk_data(x, y)
    
    // Using the state macro access as written in the original logic:
    state!(engine).generation_api.fetch_chunk_data(x, y)
}
<<< FILE END: rust\ssxl_godot\src\engine\query_data.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\render_batch.rs (62 LOC) <<<
// ssxl_godot/src/engine/render_batch.rs
//
// Pure, zero-cost, panic-free translation from ChunkData → Godot render batch.
// Used by query.rs and tick.rs.
// No allocation beyond what's required.
// No dependencies beyond godot-rust and ssxl_shared.
// Eternal.

use godot::builtin::*;
use ssxl_shared::{ChunkData, TileType};
// FIX: Import the ToGodot trait to bring the to_variant() method into scope for PackedInt32Array.
use godot::prelude::ToGodot; 

pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

/// Converts a generated chunk into a render-ready Dictionary
/// Expected format:
/// {
///    "layer": 0,
///    "positions": PackedInt32Array [x1, y1, x2, y2, ...],
///    "source_ids": PackedInt32Array [id, id, ...],
///    "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
///    "alt_tiles": PackedInt32Array [0, 0, ...]
/// }
///
/// This is the **only** place that knows how to speak Godot's TileMap language.
pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    let mut dict = Dictionary::new();

    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    dict.set("layer", 0i64);

    let mut tile_count = 0usize;

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let idx = (y * CHUNK_SIZE + x) as usize;

            if let Some(tile) = chunk_data.tiles.get(idx) {
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                positions.push(world_x);
                positions.push(world_y);

                source_ids.push(DEFAULT_SOURCE_ID);

                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                alt_tiles.push(0);

                tile_count += 1;
            }
        }
    }

    // Only set if we have data — Godot ignores empty arrays gracefully
    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    dict
}
<<< FILE END: rust\ssxl_godot\src\engine\render_batch.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\state.rs (79 LOC) <<<
use godot::prelude::*;
use godot::classes::{TileMap, Node};
use std::cell::UnsafeCell;
use std::sync::{Arc, Mutex};

// CRITICAL FIX 1: Import AnimationConductorHandle directly from ssxl_sync.
use ssxl_sync::AnimationConductorHandle; 

// FIX: Corrected ssxl_generate path.
use ssxl_generate::{Conductor, conductor::ConductorState}; 
use ssxl_shared::AnimationState;
// FIX: Removed unused imports.

// FIX 2: Path changed to reflect module moved to src/tilemap/
use crate::tilemap::async_poll::AsyncPoller; 

// FIX 3: EngineInitializer moved to api.rs. Keep only GenesisHandles here.
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 

// FIX 4: Path changed to reflect module assimilated into engine::api.
// NOW includes EngineInitializer to resolve the E0432 error.
use crate::engine::api::{GenerationAPI, EngineInitializer};

/// Helper macro — the only way to safely touch the UnsafeCell
/// Required because Godot owns the object lifetime, not Rust.
// CRITICAL FIX: Add #[macro_export] to make the macro visible outside the module.
#[macro_export]
macro_rules! state {
    // This is the expression form (for chaining)
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    // This is the statement form (for local variable binding)
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

// Re-export the macro for use by other files within the 'engine' module.
pub use state; 

// --- InternalState Definition ---

/// All non-FFI-safe state lives here.
pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    // Uses aliased name FfiGenesisHandles
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    // FIX 7: Added missing tick counter
    pub tick_count: u64,
}

impl Default for InternalState {
    fn default() -> Self {
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            // FIX 7: Initialize tick_count
            tick_count: 0,
        }
    }
}

// --- SSXLEngine Class Definition ---

/// The Godot-facing class — the only thing that exists in GDScript land.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,

    // FIX: Changed from private to pub(crate) to allow access via the state! macro across modules.
    // Hidden from Godot — contains all real state
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}
<<< FILE END: rust\ssxl_godot\src\engine\state.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\tick.rs (81 LOC) <<<
// File: ssxl_godot/src/engine/tick.rs (Final Optimized Imports and Logic)

use godot::prelude::*;
use super::state::SSXLEngine;
use super::render_batch::create_render_batch_dictionary;

use crate::ffi::signals::*; 

use godot::builtin::GString; 

use tracing::debug;

use ssxl_shared::message::generation_message::GenerationMessage; 

pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    let state = unsafe { &mut *engine._internal_state.get() };
    
    // FIX 1: Prefix `conductor` with `_` to suppress the unused variable warning.
    let Some(_conductor) = &state.conductor else { return };
    
    // Using `as_mut()` here allows for `emit_signal` calls later.
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    // --- Generation Message Polling ---
    let messages = state.poller.poll_generation();
    for msg in messages {
        // FIX 2: Removed the unreachable `_ => {}` pattern.
        match msg {
            GenerationMessage::Generated(_, chunk) => {
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
            // Note: If GenerationMessage has other variants, they should be added here.
            // Since the compiler stated the previous `_` was unreachable, this list is assumed complete.
        }
    }

    // --- Animation Message Polling ---
    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            // FIX: Uses fully qualified path `ssxl_shared::AnimationPayload` now.
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        // FIX: use `msg.coord` instead of `msg.tile_coords`.
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(), // Assuming y-coordinate is also needed
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    // --- Tick Completion Signal ---
    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}
<<< FILE END: rust\ssxl_godot\src\engine\tick.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\gde_api_defs.rs (56 LOC) <<<
// ssxl_godot/src/gde_api_defs.rs

//! # Godot Extension API Definitions (GDExtension Interface)
//!
//! This module defines the essential Rust-side bindings that connect the `SSXLEngine`
//! struct to the Godot engine's runtime environment. It implements the necessary
//! traits to register the class and hook into the standard Node lifecycle methods.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;

// --- Local Crate Imports ---
// Import the core SSXL engine implementation.
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// GDExtension Initialization Macro
// -----------------------------------------------------------------------------

/// The mandatory **GDExtension entry point**.
///
/// This function is called by Godot when the dynamic library is loaded.
/// The `#[gdextension]` attribute marks it as the entry function.
/// It is declared `unsafe` because it interacts with the C/C++ FFI of Godot.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // 1. **Class Registration:** Registers the core `SSXLEngine` struct with Godot.
    // This makes the Rust struct available in the Godot scripting environment (GDScript/C#).
    builder.add_class::<SSXLEngine>();
}


// -----------------------------------------------------------------------------
// Godot Node Lifecycle Implementation
// -----------------------------------------------------------------------------

/// Implements the `ExtensionLibrary` trait for `SSXLEngine`.
/// This trait binds the Rust struct to a Godot class (in this case, `Node`)
/// and maps Godot's virtual methods (like `_init`, `_process`) to the Rust implementation.
impl ExtensionLibrary for SSXLEngine {
    /// **Godot's Constructor (`_init`)**:
    /// This runs when an instance of `SSXLEngine` is created in Godot.
    /// It delegates initialization to the custom `SSXLEngine::init` method.
    fn _init(base: Base<Node>) -> Self {
        // `base` is the underlying Godot Node that this struct wraps.
        SSXLEngine::init(base)
    }

    /// **Godot's Frame Update (`_process(delta)`)**:
    /// This is called every frame, **adapting** the engine's logic to the game's **tempo**.
    /// The `delta` is the time elapsed since the last frame.
    fn _process(&mut self, delta: f64) {
        // Call the internal game loop tick function, passing the delta time.
        // The delta is cast to `u64` (milliseconds or similar unit) as used internally
        // by the SSXL-ext game loop logic (which may need adjustment depending on the unit).
        self.tick(delta as u64);
    }

    /// **Godot's Initialization Hook (`_ready`)**:
    /// This runs once when the node and all its children have entered the scene tree.
    /// This is the ideal place to start the multi-threaded SSXL engine.
    fn _ready(&mut self) {
        self.on_ready();
    }
}
<<< FILE END: rust\ssxl_godot\src\ffi\gde_api_defs.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\mod.rs (4 LOC) <<<
pub mod oracle;
pub mod signals;        // this loads src/ffi/signals.rs

pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;   // re-export the class
<<< FILE END: rust\ssxl_godot\src\ffi\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\oracle.rs (81 LOC) <<<
// ssxl_godot/src/ffi/oracle.rs

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use crate::engine::SSXLEngine;

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

impl SSXLOracle {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}

#[godot_api]
impl SSXLOracle {
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // FIX: Use the correct method name `process_engine_tick` and remove the argument,
                // as confirmed by the compiler's suggestion.
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {
                // Engine not ready. Silent failure is acceptable during initialization.
            }
        }
    }

    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_current_tile_count()
            }
            None => {
                0
            }
        }
    }

    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_status()
            }
            None => {
                GString::from("Engine not bound.")
            }
        }
    }
    
    #[func]
    pub fn ping(&self) {
    }

    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}
<<< FILE END: rust\ssxl_godot\src\ffi\oracle.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\signals.rs (48 LOC) <<<
// ssxl_godot/src/ffi/signals.rs

use godot::prelude::*;
// FIX: Removed the unused glob import `godot::classes::*` and replaced it with an explicit import for `Node`.
use godot::classes::Node; 
// FIX: Removed unnecessary import for `godot::obj::Base` as it is covered by `godot::prelude::*`.

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

// FIX 2: Define the required constructor in a standard impl block.
impl SSXLSignals {
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

#[godot_api]
impl SSXLSignals {
    // The previous #[func] pub fn init is removed from here.

    // --- Generation Lifecycle Signals ---
    
    #[signal]
    fn build_map_start();

    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    #[signal]
    fn build_map_complete();

    #[signal]
    fn build_map_stopped();

    #[signal]
    fn generation_error(error_message: GString);

    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    #[signal]
    fn tick_complete(current_tick: u64);

    // --- Animation & Utility Signals ---
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    #[signal]
    fn animation_state_changed(enabled: bool);

    #[signal]
    fn engine_status_updated(status_message: GString);
}
<<< FILE END: rust\ssxl_godot\src\ffi\signals.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\async_poll.rs (100 LOC) <<<
// ssxl_godot/src/tilemap/async_poll.rs
//
// The sacred bridge between Tokio and Godot.
// Polls background channels on the main thread.
// Zero blocking. Zero panic. Eternal.

use tokio::sync::mpsc::{
    // FIX 3: Import the Bounded Receiver for Generation Messages
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};
// CRITICAL FIX: The imported type for AnimationUpdate is now at the crate root
use ssxl_shared::AnimationUpdate; 
// FIX 1: The correct GenerationMessage location (from prior fix)
use ssxl_shared::message::generation_message::GenerationMessage; 

const MAX_GEN_MSGS: usize = 64;
const MAX_ANIM_MSGS: usize = 2048;

// CRITICAL FIX 4: Update the type alias to use the crate root path for AnimationUpdate
pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;
// CRITICAL FIX 5: Define the type alias for the Bounded Receiver to expect GenerationMessage
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

#[derive(Default)]
pub struct AsyncPoller {
    // Only animation uses unbounded — generation is bounded and handled via Conductor
    // FIX 6: Add state for the Generation Receiver, using GenerationMessage
    generation_rx: Option<GenerationReceiver>,
    // FIX 7: Rename animation_rx for consistency with the new setter in init.rs
    animation_rx: Option<AnimationReceiver>,
}

impl AsyncPoller {
    pub fn new() -> Self {
        Self::default()
    }

    // --- Animation Methods (Renamed for consistency with init.rs fix) ---

    /// Setter matching the logic in init.rs
    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        // FIX 8: The 'take()' in init.rs already pulls the receiver out of an Option,
        // so the setter must accept an Option<Receiver> for cases where the channel is uninitialized (None).
        self.animation_rx = rx;
    }

    // --- Generation Methods (New) ---

    /// Setter for the generation channel, matching the logic in init.rs
    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        // FIX 9: Set the generation receiver
        self.generation_rx = rx;
    }

    pub fn clear_receivers(&mut self) {
        // FIX 10: Clear both receivers
        self.generation_rx = None;
        self.animation_rx = None;
    }

    /// Poll all pending generation updates — safe to call every frame
    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        // CRITICAL FIX 11: Change return type and message type to GenerationMessage
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            // NOTE: The tokio Bounded Receiver uses a different try_recv signature (TryRecvError)
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        self.generation_rx = Some(rx);
        updates
    }


    /// Poll all pending animation updates — safe to call every frame
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // FIX 12: Use the consistent name
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        // FIX 13: Use the consistent name
        self.animation_rx = Some(rx);
        updates
    }
}
<<< FILE END: rust\ssxl_godot\src\tilemap\async_poll.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\mod.rs (7 LOC) <<<
// ssxl_godot/src/tilemap/mod.rs 
//
// Parent module for all tilemap-related components.

pub mod ssxl_tilemap; // Points to ssxl_godot/src/tilemap/ssxl_tilemap.rs

// FIX: Declare sibling modules here if their source files are in the 'tilemap/' directory.
pub mod async_poll;
pub mod status_reporter;
<<< FILE END: rust\ssxl_godot\src\tilemap\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\ssxl_tilemap.rs (85 LOC) <<<
// ssxl_godot/src/tilemap/ssxl_tilemap.rs
//
// The final render sink.
// Receives render batches from the async core.
// Pure, fast, panic-safe, zero bloat.

use godot::prelude::*;
use godot::classes::{TileMap, ITileMap};
use godot::obj::Base;
// FIX: Removed unused import: `Vector2`
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};

#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    tile_source_id: i32,
}

#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        Self {
            base,
            tile_source_id: 1,
        }
    }
}

#[godot_api]
impl SSXLTilemap {
    /// Primary render entrypoint — called from Rust via signal
    /// Expects the exact format from render_batch.rs
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        // FIX E0308: Convert Result<i64, ConvertError> to Option<i64> using `.ok()`
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        for i in 0..len {
            // FIX E0609: Unwrap the Option<Vector2> before accessing .x and .y fields.
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            // Note: pos and atlas coordinates come as Vector2 (f32 fields), but they represent integer tile coordinates.
            // Casting to i32 is appropriate here.
            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }
}
<<< FILE END: rust\ssxl_godot\src\tilemap\ssxl_tilemap.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\status_reporter.rs (63 LOC) <<<
use godot::prelude::GString;
// FIX: Change import path from conductor_state::ConductorState to conductor::ConductorState
// Assuming the ConductorState type is exported via the 'conductor' module in ssxl_generate.
use ssxl_generate::conductor::ConductorState;
use ssxl_shared::AnimationState;

/// # StatusReporter
/// 
/// A stateless utility struct responsible for querying the various core states
/// (Generation, Animation) and compiling human-readable status reports
/// for the Godot scripting layer.
pub struct StatusReporter;

impl StatusReporter {
    /// Constructs a new, human-readable status string combining the state of
    /// the Generation and Animation cores.
    /// 
    /// This removes complex string formatting logic from SSXLEngine.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    /// * `anim_state` - Read-only reference to the Animation process state.
    /// 
    /// # Returns
    /// A Godot `GString` containing the formatted status message.
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        let gen_status = gen_state
            // This line is assumed correct for ConductorState
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let anim_status = anim_state
            .map(|state| {
                // FIX: AnimationState does not have a get_status() method.
                // We derive the status from the publicly available `time_scale` field.
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    // Handle negative or otherwise unexpected scales
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        GString::from(status.as_str())
    }

    /// Retrieves the total number of tiles placed by the engine during generation.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            // Fails gracefully to 0 if the core is not yet initialized.
            .unwrap_or(0)
    }
}
<<< FILE END: rust\ssxl_godot\src\tilemap\status_reporter.rs >>>

>>> FILE START: rust\ssxl_math\Cargo.toml (16 LOC) <<<
[package]
name = "ssxl_math"
version = "0.1.0"
edition.workspace = true

[dependencies]
# Internal dependencies (Local Crates)

# External dependencies (Workspace-Inherited)
# FIX: Explicitly re-enable the 'serde' feature for glam.
# This ensures IVec3 implements Serialize/Deserialize, resolving the E0277 errors.
glam = { workspace = true, features = ["serde"] }
serde = { workspace = true }
thiserror = { workspace = true } # Added for defining local crate Result type
tracing = { workspace = true }
sha2 = { workspace = true }
rand = { workspace = true }
rand_pcg = { workspace = true }
<<< FILE END: rust\ssxl_math\Cargo.toml >>>

>>> FILE START: rust\ssxl_math\src\coordinate_system.rs (118 LOC) <<<
// ssxl_math/src/coordinate_system.rs

//! # Coordinate System
//!
//! Defines the core coordinate types for the SSXL-ext engine, using 64-bit integers (`I64Vec3`)
//! to support extremely large, virtually infinite world dimensions.
//!
//! This module implements the crucial logic for converting a global `WorldPos` into its
//! localized `(ChunkKey, TileOffset)` components, ensuring mathematical correctness
//! even for large **negative coordinates** through the use of Euclidean division.

use serde::{Serialize, Deserialize};
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;


// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------

/// Represents a specific point in the vast 3D world space.
/// The underlying `I64Vec3` ensures the system can handle coordinates well beyond i32 limits.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

/// The unique identifier for a 3D chunk.
/// This acts as the *base coordinate* for a 32x32x32 (or `CHUNK_SIZE`) cubic volume of the world.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

/// The local position of a tile *within* its parent chunk.
/// Coordinates are always non-negative and range from `[0, CHUNK_SIZE - 1]`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);


// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------

impl WorldPos {
    /// Converts a global `WorldPos` into its discrete `ChunkKey` and local `TileOffset` components.
    ///
    /// This conversion is robust against **negative world coordinates** by using
    /// `rem_euclid`, which guarantees the `TileOffset` is always positive (or zero).
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {

        let chunk_size = CHUNK_SIZE_I64;

        // 1. Calculate the Tile Offset (Local Position)
        // `rem_euclid` ensures the remainder is always non-negative, correctly wrapping
        // negative world coordinates (e.g., -1 rem_euclid 32 = 31).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // 2. Calculate the Chunk Key (Chunk Index)
        // The chunk index is calculated by subtracting the tile offset (remainder)
        // and then performing simple integer division. This is the correct Euclidean
        // division for finding the quotient (chunk index).
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------

impl ChunkKey {
    /// Reconstructs the original `WorldPos` from the `ChunkKey` and `TileOffset`.
    ///
    /// This is the inverse operation, verifying the idempotence of the coordinate system.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        // Formula: World = (Chunk Index * Chunk Size) + Tile Offset
        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    // NOTE: CHUNK_SIZE_I64 is assumed to be 32 for these tests.

    #[test]
    /// Tests conversion for a very large positive coordinate, confirming I64 robustness.
    fn test_world_to_chunk_positive() {
        let huge_coord = 5_000_000_000i64; // Well over i32::MAX
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64; // 156,250,000
        let expected_offset = huge_coord % CHUNK_SIZE_I64; // 0

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // 64 / 32 = 2 (chunk key), 64 rem_euclid 32 = 0 (offset)
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    /// CRUCIAL test for negative coordinates, verifying the Euclidean division logic.
    fn test_world_to_chunk_negative_crucial() {
        // Test case 1: (-1, -1, -1)
        // Expected: Chunk index should be -1. Offset should be 31 (32 - 1).
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test case 2: (-33, -64, -100)
        // X: -33 rem 32 = 31, (-33 - 31)/32 = -2.
        // Y: -64 rem 32 = 0, (-64 - 0)/32 = -2.
        // Z: -100 rem 32 = 28, (-100 - 28)/32 = -4.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    /// Tests that converting a WorldPos to (ChunkKey, TileOffset) and back results in the original WorldPos.
    fn test_round_trip() {
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();

        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}
<<< FILE END: rust\ssxl_math\src\coordinate_system.rs >>>

>>> FILE START: rust\ssxl_math\src\generation_utils.rs (62 LOC) <<<
// ssxl_math/src/generation_utils.rs

//! # Generation Utilities
//!
//! Provides common mathematical and random-sampling utilities used throughout the
//! procedural generation pipeline (e.g., `ssxl_generate` crate).
//!
//! Functions here are designed for rapid, stateless generation logic, such as
//! calculating percentage chance rolls and generating unique identifiers for data structures.

use crate::primitives::SSXLData;
use rand::Rng;

// -----------------------------------------------------------------------------
// Randomness and Chance Utilities
// -----------------------------------------------------------------------------

/// Rolls a chance check against a given percentage.
///
/// This function is vital for injecting controlled **randomness** and **balance**
/// into the generation process (e.g., probability of a resource spawning, or a
/// cellular automata rule firing).
///
/// # Arguments
/// * `target_percent` - The probability of success, expressed as a whole percentage (0-100).
///
/// # Returns
/// * `0`: Success (The random number was less than `target_percent`).
/// * `1`: Failure (The random number was greater than or equal to `target_percent`).
///
/// # Example
/// A 25% chance of spawning:
/// ```ignore
/// if generate_percent_roll(25) == 0 {
///     // spawn item
/// }
/// ```
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the inclusive range [0, 99], which is a 0-100 scale.
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Success occurs if the random value falls within the target range.
    if rand_val < target_percent {
        0 // Success / Hit
    } else {
        1 // Failure / Miss
    }
}

// -----------------------------------------------------------------------------
// Data Processing Utilities
// -----------------------------------------------------------------------------

/// Processes an object implementing the `SSXLData` trait to derive a simple aggregate identifier.
///
/// This is a basic utility that combines the object's unique ID with its data payload size.
/// It is often used for creating quick, unique signatures or simple hashing/checksums
/// for data chunks across worker threads.
///
/// # Arguments
/// * `data` - A reference to any structure that implements the `SSXLData` trait.
///
/// # Returns
/// * `u64` - The sum of the data's ID and the length of its associated value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine the inherent ID (u64) with the value length (u64 after casting).
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}
<<< FILE END: rust\ssxl_math\src\generation_utils.rs >>>

>>> FILE START: rust\ssxl_math\src\hashing.rs (97 LOC) <<<

// ssxl_math/src/hashing.rs

/// # Hashing Utilities for SSXL-ext
///
/// This module provides **deterministic, collision-resistant** hashing functions
/// essential for identifying and retrieving procedural data.
///
/// Hashing is crucial for:
/// 1.  Generating unique, stable IDs for **world chunks** based on their coordinates.
/// 2.  Creating cache keys for **generated content** to ensure persistence and integrity.
use crate::primitives::SSXLResult;
use glam::I64Vec3;
use sha2::{Digest, Sha256};

/// Generates a **deterministic SHA-256 hash** for a given 3D chunk coordinate.
///
/// This hash is used as a unique identifier (a key) for world chunks, ensuring that
/// the same coordinate always yields the identical hash string, which is crucial
/// for cache lookups and procedural generation stability.
///
/// # Arguments
///
/// * `coords` - The 3D world coordinate of the chunk, using 64-bit integers (`I64Vec3`)
///              to support extremely large, dimension-agnostic worlds.
///
/// # Returns
///
/// A `SSXLResult<String>` containing the 64-character hexadecimal SHA-256 hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // 1. Serialize the coordinates into a canonical string format (e.g., "100:5:25").
    // This fixed format ensures deterministic input for the hash function.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash bytes into a lowercase 64-character hexadecimal string.
    Ok(format!("{:x}", result))
}

/// Generates a **deterministic SHA-256 hash** for a generic 64-bit data key.
///
/// This is typically used to create unique cache keys for generated content or
/// assets, prefixed with `"content_"` for easy identification in the cache system
/// (`ssxl_cache`).
///
/// # Arguments
///
/// * `data_key` - A generic `u64` identifier for the content (e.g., a seed,
///                a configuration ID, or a tile type index).
///
/// # Returns
///
/// A `SSXLResult<String>` containing the hash prefixed with `"content_"`.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // 1. Convert the u64 key into a string.
    let key_string = data_key.to_string();

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // 3. Format the result with the required "content_" prefix.
    Ok(format!("content_{:x}", result))
}


/// Unit tests to ensure the hashing functions are **deterministic** and produce
/// the expected **format** and **uniqueness** required for stable world generation.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// Tests that the same coordinates always produce the identical hash (determinism).
    fn test_chunk_coords_determinism() {
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    /// Tests the expected hash length (64 chars) and confirms that a small coordinate change
    /// results in a completely different hash (uniqueness/avalanche effect).
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    /// Tests determinism, the 'content_' prefix, and the total expected length (72 chars).
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // 'content_' (8 chars) + SHA-256 hex (64 chars) = 72
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}
<<< FILE END: rust\ssxl_math\src\hashing.rs >>>

>>> FILE START: rust\ssxl_math\src\lib.rs (50 LOC) <<<
// ssxl_math/src/lib.rs

//! # SSXL Math Crate (`ssxl_math`)
//!
//! This crate contains the core mathematical utilities, data structures, and coordinate
//! system logic required by the SSXL-ext procedural generation engine.
//!
//! Key functionalities include:
//! - **Coordinate System:** Defining world and chunk positions (`ChunkKey`, `WorldPos`).
//! - **Hashing:** Deterministic generation of unique chunk and content identifiers.
//! - **Primitives:** Shared types and result wrappers (`SSXLResult`, `Vec2i`).

// --- Module Declarations ---

/// Defines the global and local coordinate system structures (`ChunkKey`, `WorldPos`).
pub mod coordinate_system;

/// Houses various utility functions for procedural generation algorithms.
pub mod generation_utils;

/// Provides deterministic hashing functions (e.g., `hash_chunk_coords`).
pub mod hashing;

/// Core mathematical primitives, custom types, and error handling results.
pub mod primitives;

// --- Public Re-exports (The Main Crate API) ---

// Re-export key coordinate types for direct use by other SSXL-ext crates.
pub use coordinate_system::{ChunkKey, TileOffset, WorldPos};

// Re-export core functions and utilities.
pub use crate::generation_utils::process_data;

// Re-export essential primitives and type aliases.
pub use crate::primitives::Vec2i;
pub use crate::primitives::SSXLData;
pub use crate::primitives::SSXLResult;
pub use crate::primitives::TileCoord; // ⭐ FIXED: Changed 'crate primitives' to 'crate::primitives'

// --- Prelude for Internal Engine Use ---

/// A convenience module that re-exports all essential types and traits
/// from the `ssxl_math` crate.
///
/// Crates in the SSXL-ext project are encouraged to use `use ssxl_math::prelude::*`
/// to easily import the most commonly needed math components. This adheres to the
/// common Rust practice for making libraries ergonomic.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
}

// --- Initialization Function ---

/// Initializes the SSXL Math system.
///
/// Currently, this only logs an informational message. It acts as a potential
/// future hook for any necessary global math configuration or setup checks.
pub fn initialize_math_system() {
    tracing::info!("SSXL Math system initialized and ready.");
}
<<< FILE END: rust\ssxl_math\src\lib.rs >>>

>>> FILE START: rust\ssxl_math\src\primitives.rs (59 LOC) <<<
//! # Primitives Module (`ssxl_math::primitives`)
//!
//! Defines the essential, low-level data types, type aliases, traits, and global
//! constants used throughout the SSXL-ext procedural generation engine.

use serde::{Deserialize, Serialize};

// --- Data Structures ---

/// A 2D vector for integer coordinates, typically used for tile offsets or local
/// coordinate mapping within a chunk.
///
/// Uses `i64` to maintain compatibility with the large coordinate space of `I64Vec3`
/// from the `glam` crate, preventing silent overflow issues.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    /// The X component of the 2D vector.
    pub x: i64,
    /// The Y component of the 2D vector.
    pub y: i64,
}

impl Vec2i {
    /// Creates a new `Vec2i` instance.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// --- Type Aliases ---

/// The standard 2D coordinate type for referencing a tile in the world
/// or within a chunk. Aliased to `Vec2i`.
pub type TileCoord = Vec2i; 

/// The standard 2D coordinate type for referencing a spatial chunk in the world grid.
/// Aliased to `Vec2i` for memory layout consistency with `TileCoord`.
pub type ChunkId = Vec2i; 

/// A specialized `Result` type for the SSXL-ext project.
///
/// The error type is fixed as `String`, providing a simple, high-level way to
/// convey error messages across the engine's various crates.
pub type SSXLResult<T> = Result<T, String>;

// --- Traits for Engine Data Management ---

/// A trait defining the requirements for any data structure that will be managed
/// or processed by the SSXL engine (e.g., in the task queue or cache).
///
/// The bounds `Send + Sync` are mandatory, ensuring all implementors can be
/// safely sent between worker threads and shared across thread boundaries.
pub trait SSXLData: Send + Sync {
    /// Retrieves a unique 64-bit ID for the data. Used primarily for cache keys
    /// and tracking within the `task_queue`.
    fn get_id(&self) -> u64;

    /// Returns the length or size of the data's core value in bytes or elements.
    /// Used for diagnostics, memory management, or processing limits.
    fn get_value_len(&self) -> usize;
}

// --- Global Constants ---

/// The canonical side length of a procedural chunk in the world.
///
/// This value is cast to `i64` to match the coordinate system of the engine,
/// ensuring consistent type usage for chunk-related calculations.
pub const CHUNK_SIZE_I64: i64 = 32;

/// A small constant used for floating-point comparisons to account for
/// precision errors (e.g., in perlin noise interpolation or physics-related math).
pub const F32_EPSILON: f32 = 1.0e-6;
<<< FILE END: rust\ssxl_math\src\primitives.rs >>>

>>> FILE START: rust\ssxl_shared\cargo.toml (15 LOC) <<<
[package]
name = "ssxl_shared"
version = "0.6.0" # Standardized version number
edition = "2021"

[dependencies]
ssxl_math = { path = "../ssxl_math" }
# Internal dependencies (Local Crates)
serde       = { workspace = true }
serde-big-array  = { workspace = true }
bincode     = { workspace = true }
thiserror   = { workspace = true }
anyhow      = { workspace = true }
tokio       = { workspace = true }

# External dependency (Workspace-Inherited)
tracing     = { workspace = true }

<<< FILE END: rust\ssxl_shared\cargo.toml >>>

>>> FILE START: rust\ssxl_shared\src\lib.rs (50 LOC) <<<
use serde::{Deserialize, Serialize};
use tracing;

pub mod chunk;
pub mod tile;
pub mod error;
pub mod config;
pub mod message;
pub mod math;
pub mod job;

pub use ssxl_math::primitives::{ChunkId, TileCoord};

pub use chunk::chunk_data::{ChunkData, CHUNK_SIZE};
pub use tile::tile_data::TileData;
pub use chunk::grid_bounds::GridBounds;
pub use tile::tile_type::TileType;

pub use message::messages::{
    AnimationCommand,
    AnimationType,
    AnimationPayload,
    UpdateSender,
    AnimationConductorHandle,
    AnimationState,
    CommandResult,
    AnimationUpdate,
};

pub use error::errors::{SSXLError, SSXLResult};
pub use anyhow;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

pub mod prelude {
    pub use super::chunk::chunk_data::{ChunkData, CHUNK_SIZE};
    pub use super::tile::tile_data::TileData;
    pub use super::chunk::grid_bounds::GridBounds;
    pub use super::tile::tile_type::TileType;
    
    pub use super::{ChunkId, TileCoord};
    
    pub use super::error::errors::{SSXLError, SSXLResult};
    
    pub use super::message::messages::{AnimationCommand, AnimationType};
    pub use super::message::messages::AnimationUpdate;
}

use std::sync::atomic::AtomicUsize;

pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);
<<< FILE END: rust\ssxl_shared\src\lib.rs >>>

>>> FILE START: rust\ssxl_shared\src\chunk\chunk_data.rs (222 LOC) <<<
// ssxl_shared/src/chunk/chunk_data.rs (Fixed Imports)

//! # Chunk Data Structures (`ssxl_shared::chunk::chunk_data`)
//!
//! This module defines the `ChunkData` structure, which represents a single,
//! fixed-size block of the procedural world. It includes coordinates, bounds,
//! the array of tiles, and metadata about its generation. This is the atomic
//! unit of data shared between generation workers and the cache/Godot runtime,
//! forming the basis of the engine's "crypto coded memory."

use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto;

// --- FIXES APPLIED HERE ---

// FIX 1: grid_bounds is a sibling module (in the same 'chunk' directory).
use super::grid_bounds::GridBounds;
// FIX 2: tile_data is in the top-level 'tile' module.
use crate::tile::tile_data::TileData; 
// Imports the custom Serde helper for deterministic SystemTime serialization.
// FIX 3: math_primitives is in the top-level 'math' module.
use crate::math::math_primitives; 

// Re-exports a core math primitive for chunk coordinates.
// FIX: Removed the erroneous `I64Vec3` import to resolve E0432.
use ssxl_math::Vec2i;
// REMOVED: use ssxl_math::hashing::hash_chunk_coords; // FIX: Cleaned up unused import.

// Used to enable serialization/deserialization of arrays larger than 32 elements
// by the serde framework (necessary for the 1024-tile array).
use serde_big_array::BigArray;

// --- Constants ---

/// The canonical side length of a chunk (e.g., 32x32 tiles), defined as a public constant.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles in a single chunk (32 * 32 = 1024).
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;


// --- Coordinate Structure ---

/// Defines the **chunk-space** coordinates (e.g., Chunk [1, 5] on the world grid).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}


// --- Core Data Structure ---

/// The central data structure for a world chunk. This is the primary payload
/// for procedural generation tasks and caching.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    /// A unique, deterministic identifier for this chunk.
    pub id: u64,
    /// The world-space bounding box of the chunk, using the half-open range convention.
    pub bounds: GridBounds,
    /// The fixed-size array containing all tiles within the chunk.
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    /// A string tag identifying the dimension or layer this chunk belongs to.
    pub dimension_tag: String,
    /// Timestamp indicating when the chunk was generated (serialized deterministically).
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}


impl ChunkData {
    /// Re-export of the canonical chunk size as an associated constant for use in methods.
    pub const SIZE: u32 = CHUNK_SIZE;

    /// Creates a new `ChunkData` instance using explicit, pre-calculated parameters.
    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        // Initialize the tile array with default (empty) TileData.
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    /// Creates a new `ChunkData` instance by calculating its bounds and generating
    /// an initial ID based solely on its chunk coordinates.
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        // 1. Calculate the world-space minimum coordinates (inclusive).
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        // 2. Calculate the world-space maximum coordinates (exclusive, half-open range).
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        // 3. Generate a robust, collision-resistant ID.
        // FIX: Now uses the robust Zigzag-encoded 2D hash.
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    /// Internal helper to map signed i64 to u64 for safe spatial indexing (e.g., Z-order curves).
    /// This prevents massive u64 values for small negative i64 inputs.
    /// Formula: (n << 1) ^ (n >> 63)
    #[inline(always)]
    fn zigzag_encode(n: i64) -> u64 {
        // We use the standard Zigzag formula to map all i64 values to unique u64 values,
        // prioritizing small absolute values to the lowest u64 space.
        ((n << 1) ^ (n >> 63)) as u64
    }

    /// Internal 2D coordinate hashing function, replacing the problematic FFI call.
    /// Uses a **Zigzag-encoded** packing into a u64, which is fast, deterministic,
    /// and ensures no collisions across the world origin.
    fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);

        // Pack the two 32-bit halves. This is standard 2D packing for chunk keys.
        ux | (uy << 32)
    }

    /// Internal helper to convert local tile coordinates (x, y) within the chunk
    /// into a flat array index.
    ///
    /// This is marked `#[inline(always)]` for **performance optimization**
    /// as it's called repeatedly during generation loops.
    ///
    /// Returns `None` if the coordinates are out of the [0, CHUNK_SIZE - 1] range.
    #[inline(always)]
    fn coord_to_index(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            // Index = Y * Width + X (standard row-major order)
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    /// Safely retrieves an immutable reference to a tile at the given local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    /// Inserts a fully generated vector of tiles into the chunk's internal array.
    ///
    /// # Panics
    /// Panics if the input vector's length does not exactly match the expected
    /// `TILE_ARRAY_SIZE`, which is a critical **data integrity** check.
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        // FIX: Use TryInto to consume the Vec, which is more idiomatic and clear for ownership transfer.
        match tiles_vec.try_into() {
            Ok(arr) => self.tiles = arr,
            Err(vec) => {
                // Critical error: A generator produced an incomplete or oversized chunk.
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    /// Safely retrieves a mutable reference to a tile at the given local coordinates.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }
}

// --- Unit Tests ---

#[cfg(test)]
mod tests {
    use super::*;

    // NOTE: For tests to compile, TileData::default() must be Copy, which it implicitly is.
    // The coordinate-to-index tests are sound and require no changes.
    
    #[test]
    /// Tests the critical coordinate-to-index logic for boundaries and center.
    fn test_coord_to_index() {
        // Top-left corner
        assert_eq!(ChunkData::coord_to_index(0, 0), Some(0));

        // Center (16, 16) -> 16 * 32 + 16 = 528
        assert_eq!(ChunkData::coord_to_index(16, 16), Some(528));

        // Bottom-right corner (31, 31) -> 31 * 32 + 31 = 1023 (TILE_ARRAY_SIZE - 1)
        assert_eq!(ChunkData::coord_to_index(31, 31), Some(1023));

        // Out of bounds checks (32 is the exclusive size limit)
        assert_eq!(ChunkData::coord_to_index(32, 0), None);
        assert_eq!(ChunkData::coord_to_index(0, 32), None);
        assert_eq!(ChunkData::coord_to_index(33, 33), None);
    }
    
    #[test]
    /// Tests the Zigzag encoding for correct mapping of signed to unsigned space.
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    /// Tests the new 2D hashing function for uniqueness across the origin.
    fn test_hash_coords_2d() {
        // Standard coordinates
        // (1, 0) -> (Zigzag(1)=2 | Zigzag(0)=0 << 32) = 2
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        // (0, 1) -> (Zigzag(0)=0 | Zigzag(1)=2 << 32) = 8589934592 (2 * 2^32)
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        
        // Critical Negative Coordinate Check (was broken before)
        // (-1, 0) -> (Zigzag(-1)=1 | Zigzag(0)=0 << 32) = 1
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        
        // Collision check across the origin must pass
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        // Large coordinates (to ensure all 64 bits are used)
        let big_x = i64::MAX / 2; // Large positive
        let big_y = i64::MIN / 2; // Large negative
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0);
    }
}
<<< FILE END: rust\ssxl_shared\src\chunk\chunk_data.rs >>>

>>> FILE START: rust\ssxl_shared\src\chunk\grid_bounds.rs (64 LOC) <<<
// ssxl_shared/src/grid_bounds.rs

//! # Grid Bounds Structures (`ssxl_shared::grid_bounds`)
//!
//! This module defines the core structures for representing 2D world-space points
//! and rectangular bounding boxes (bounds) used throughout the SSXL-ext engine.

use serde::{Deserialize, Serialize};

// --- Coordinate Structure ---

/// Represents a single 2D world-space coordinate point.
///
/// Uses `i64` to support the massive scale of the SSXL world coordinates.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    /// The X component of the coordinate.
    pub x: i64,
    /// The Y component of the coordinate.
    pub y: i64,
}

// --- Bounding Box Structure ---

/// Defines a rectangular region in the world by its minimum and maximum coordinate points.
///
/// **Convention:** `GridBounds` uses a **half-open range** (`[min, max)`), meaning
/// the minimum coordinates are **inclusive** and the maximum coordinates are **exclusive**.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum coordinate (e.g., the bottom-left point of the region).
    pub min: Coord2D,
    /// The exclusive maximum coordinate (one unit past the top-right point of the region).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new `GridBounds` instance from four explicit coordinate components.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size (width and height) of the bounds.
    ///
    /// For a half-open range, the size is simply `max - min`, which correctly
    /// yields the number of unique integer coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within the bounds.
    ///
    /// Follows the half-open range convention: `[min.x, max.x)` and `[min.y, max.y)`.
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Returns a default, zero-sized bounds at the origin (0, 0) to (0, 0).
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}
<<< FILE END: rust\ssxl_shared\src\chunk\grid_bounds.rs >>>

>>> FILE START: rust\ssxl_shared\src\chunk\mod.rs (3 LOC) <<<
// ssxl_shared/src/chunk/mod.rs

pub mod chunk_data;
pub mod grid_bounds;
<<< FILE END: rust\ssxl_shared\src\chunk\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\config\config.rs (22 LOC) <<<
// ssxl_shared/src/config.rs

//! # Global Configuration Constants (`ssxl_shared::config`)
//!
//! This module defines fundamental, immutable constants that govern the structure
//! and scale of the SSXL procedural world. These values must be consistent
//! across all SSXL-ext crates (math, generate, cache, godot) to ensure data
//! integrity and system entropy is controlled.

// --- World Geometry Constants ---

/// The canonical side length of a procedural chunk in tiles.
///
/// **Value:** 32 (meaning chunks are 32x32 tiles).
///
/// This constant defines the resolution and granularity of the generated world
/// and is critical for both memory allocation and generation performance.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles contained within a single `ChunkData` structure.
///
/// **Calculation:** CHUNK_SIZE * CHUNK_SIZE (32 * 32 = 1024).
///
/// This value is used to define the fixed-size array in `ChunkData` and for
/// ensuring generators return the correct payload size.
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
<<< FILE END: rust\ssxl_shared\src\config\config.rs >>>

>>> FILE START: rust\ssxl_shared\src\config\mod.rs (2 LOC) <<<
// ssxl_shared/src/config/mod.rs

pub mod config;
<<< FILE END: rust\ssxl_shared\src\config\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\error\errors.rs (60 LOC) <<<
// ssxl_shared/src/errors.rs

//! # SSXL Error Definitions (`ssxl_shared::errors`)
//!
//! This module defines the global, canonical error type for the entire SSXL-ext
//! procedural generation engine. Centralizing error handling ensures that failures
//! across different crates (math, generate, cache, godot) can be consistently
//! reported, managed, and debugged, particularly across FFI boundaries.

use thiserror::Error;

/// A specialized `Result` type for the SSXL-ext project.
///
/// All function calls that can fail within the SSXL ecosystem should return this
/// type, wrapping the concrete `SSXLError` enum.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// The comprehensive enumeration of all possible errors within the SSXL-ext engine.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Wrapper for standard I/O errors (e.g., file system access, network issues).
    /// This variant automatically handles conversion from `std::io::Error`.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors encountered during data serialization (e.g., using Bincode or Serde).
    /// Indicates problems with converting data to or from a byte stream.
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors related to unexpected or invalid data states, such as a generator
    /// returning a tile array of the wrong size or an invalid chunk key.
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the procedural generation pipeline (e.g., a generator
    /// failing to find a valid output after too many iterations).
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors occurring in the Godot GDExtension bridge or FFI layer.
    /// Crucial for debugging communication issues between Rust and the Godot runtime.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// A critical, unexpected error indicating a bug in the core logic that
    /// should never occur under normal execution (a **"BUG!"**).
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Generic wrapper for errors originating from third-party libraries or crates
    /// that are not covered by other specific variants.
    #[error("External Crate Error: {0}")]
    External(String),
}


// --- Error Conversion Implementations ---

/// Implements conversion from the `bincode::Error` type into the SSXL `Serialization` error.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Implements conversion from the generic `anyhow::Error` type into the SSXL `External` error.
/// This provides a convenient way to integrate external library errors into the SSXL system.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        // Use the debug message of the anyhow error to retain the source chain.
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}
<<< FILE END: rust\ssxl_shared\src\error\errors.rs >>>

>>> FILE START: rust\ssxl_shared\src\error\mod.rs (2 LOC) <<<
// ssxl_shared/src/error/mod.rs

pub mod errors;
<<< FILE END: rust\ssxl_shared\src\error\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\job\mod.rs (40 LOC) <<<
// File: ssxl_shared/src/job/mod.rs (Optimized Imports)

// FIX: Removed unused imports: `ChunkId` and `std::fmt::Display`.
use crate::ChunkData; // Import public re-exports from lib.rs

// --- The Instruction Packet ---
pub enum SSXLJob {
    /// Command to initialize map generation.
    BuildMap {
        width: u32,
        height: u32,
        seed: u64, // Use parsed seed
        // FIX: Replaced unknown GString with standard String
        generator_id: String
    },
    /// Command to change the active generator configuration.
    SetGenerator {
        // FIX: Replaced unknown GString with standard String
        generator_id: String
    },
    /// Command to stop all running and pending jobs.
    StopGeneration,
    // ...
}

// --- The Result Packet (Sent back to the Engine::tick) ---
// FIX: Renamed to JobResult to avoid collision with SSXLResult alias
pub enum JobResult {
    /// A chunk has been successfully generated and is ready for world state update.
    ChunkGenerated {
        // NOTE: x/y coordinates are often implicitly contained in ChunkData's bounds,
        // but keeping them here for explicit communication.
        x: i32,
        y: i32,
        // FIX: ChunkData is now imported and recognized
        data: ChunkData
    },
    /// The BuildMap job is finished.
    MapBuildComplete,
    /// An error occurred during processing.
    // FIX: Replaced unknown GString with standard String
    Error(String),
}
<<< FILE END: rust\ssxl_shared\src\job\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\math\math_primitives.rs (41 LOC) <<<
// ssxl_shared/src/math_primitives.rs

//! # Math Primitives & Serde Helpers (`ssxl_shared::math_primitives`)
//!
//! This module contains custom logic, primarily Serde serialization/deserialization
//! functions, for mathematical or standard library types that require specific,
//! deterministic formatting (e.g., `SystemTime`) for cross-platform compatibility
//! and persistent caching.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};


/// Serde serialization/deserialization helper for `std::time::SystemTime`.
///
/// This custom serializer converts `SystemTime` to and from a `u64` representing
/// the time in milliseconds since the Unix epoch (1970-01-01). This guarantees
/// a **deterministic, platform-independent** representation for caching and networking.
pub mod system_time_serde {
    use super::*;

    /// Serializes a `SystemTime` into a `u64` representing milliseconds since epoch.
    /// This is used by Serde when writing data (e.g., saving a `ChunkData` to cache).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Calculate the duration from the UNIX_EPOCH to the current time.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert the duration to milliseconds (u64) to ensure a stable format.
        let ms = duration.as_millis() as u64;
        // Serialize the u64 millisecond count.
        serializer.serialize_u64(ms)
    }

    /// Deserializes a `u64` (milliseconds since epoch) back into a `SystemTime`.
    /// This is used by Serde when reading data (e.g., loading a `ChunkData` from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize the u64 millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert the millisecond count into a Duration, then add it to UNIX_EPOCH.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}
<<< FILE END: rust\ssxl_shared\src\math\math_primitives.rs >>>

>>> FILE START: rust\ssxl_shared\src\math\mod.rs (2 LOC) <<<
// ssxl_shared/src/math/mod.rs

pub mod math_primitives;
<<< FILE END: rust\ssxl_shared\src\math\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\message\generation_message.rs (46 LOC) <<<
// ssxl_shared/src/message/generation_message.rs (Fixed Imports & Variants)

//! # Generation Messaging (`ssxl_shared::message::generation_message`)
//!
//! This module defines the structures and enumerations used for communication
//! between the main **Conductor** thread and the asynchronous **Worker Threads**
//! (managed by the `RuntimeManager` in the `ssxl_generate` crate).
//!
//! These structures manage the flow of work requests (`GenerationTask`) and
//! completed results (`GenerationMessage`).

// FIX: Update the path from crate::chunk_data to the new subdirectory path.
use crate::chunk::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use std::sync::Arc;


// --- Work Request Structure ---

/// Defines a single unit of work (a task) to be processed by a worker thread.
///
/// This structure is put into the engine's `TaskQueue` by the `Conductor`.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    /// The chunk-space coordinates of the chunk that needs to be generated.
    pub chunk_coords: Vec2i,
    /// The unique identifier of the generator to be used for this task (e.g., "cellular_automata").
    pub generator_id: String,
}


// --- Communication Message Enumeration ---

/// An enumeration of messages sent from the worker threads back to the
/// main thread or the Conductor to signal task completion or pipeline status.
#[derive(Debug)]
pub enum GenerationMessage {
    // FIX 1: Renamed from `ChunkGenerated` to `Generated` to match the name 
    // expected by `ssxl_godot/src/engine/tick.rs`.
    // FIX 3: Re-introducing the `Vec2i` coordinate to match the 
    // previous pattern expectation in `ssxl_generate/src/conductor/conductor.rs`.
    /// Signals that a chunk has been successfully generated.
    ///
    /// The payload includes the chunk coordinates (for tracking) and the
    /// atomic reference-counted data.
    Generated(Vec2i, Arc<ChunkData>),

    // FIX 2: Added the missing `StatusUpdate` variant, which the Godot code requires.
    /// Signals a change in the internal generation status or progress update.
    StatusUpdate(String),

    /// Signals that all current tasks related to a specific generation batch
    /// or request have been finalized. Used by the `Conductor` to update
    /// the generation state.
    GenerationComplete,
}
<<< FILE END: rust\ssxl_shared\src\message\generation_message.rs >>>

>>> FILE START: rust\ssxl_shared\src\message\messages.rs (86 LOC) <<<
// ssxl_shared/src/message/messages.rs (Final Optimized Imports)

//! # Core Communication Contracts (`ssxl_shared::message::messages`)
//!
//! This module defines the essential messaging structures used for asynchronous
//! communication between the Godot FFI layer, the Conductor, and the Rayon worker pool.
//! These public types centralize the data contract to break the cyclic dependency
//! between `ssxl_animate` and `ssxl_sync`.

// FIX: Removed the last unused import: `super::generation_message::GenerationMessage`
// The public alias `ChunkMessage` still functions as it uses a fully qualified path
// to resolve `GenerationMessage` at compile time, thus the `use` statement is not required
// and was correctly flagged as unused.
use tokio::sync::mpsc::UnboundedSender;
use crate::{ChunkId, TileCoord};


// --- Core Animation Communication (Cycle-Breaking Types) ---

/// Defines the various types of animation behaviors that workers can execute.
#[derive(Debug, Clone)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

/// Defines the change to a tile (e.g., new frame ID, new tween value).
#[derive(Debug, Clone)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

/// A structure representing a single update to be applied by the Godot main thread.
#[derive(Debug, Clone)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

/// The command sent from the Godot FFI layer (via ssxl_sync) to the async workers.
#[derive(Debug, Clone)]
pub enum AnimationCommand {
    /// Command 1: Delegate heavy animation work to the Rayon thread pool.
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    
    /// Command 2: System command to kick off a dedicated test or demo animation.
    StartTestAnimation,
    
    /// Command 3: State command to adjust the overall simulation speed.
    SetTimeScale(f32),

    /// State command to enable or disable the animation conductor thread.
    SetEnabled(bool),
    
    /// Command 4: System command to trigger a graceful shutdown of the Conductor.
    Shutdown,
}

/// The sender handle for the main update channel (Tokio/MPSC).
/// Used by Rayon workers to send results back to the main thread poller.
pub type UpdateSender = UnboundedSender<AnimationUpdate>;


// --- FFI / Conductor Control Types (Completing the Contract) ---

/// The handle returned to the FFI layer to send AnimationCommands to the Conductor.
/// This type lives here to break the package dependency cycle (ssxl_sync -> ssxl_animate).
pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

/// A simple Result type for command processing success/failure.
pub type CommandResult = Result<(), String>;

/// The current runtime state of the Animation Conductor (e.g., Running, Paused).
#[derive(Debug, Clone, Copy, Default)]
pub struct AnimationState {
    pub time_scale: f32, // The state field required by the SetTimeScale command
    // FIX: Added to track the enabled/disabled state, resolving E0599.
    pub is_enabled: bool,
}

impl AnimationState {
    /// Implements the required method for the Conductor to update local state.
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    /// FIX: Implements the required setter for the `AnimationCommand::SetEnabled` command.
    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}


// --- Generic Data Messages (REMOVED DUPLICATION) ---

// NOTE: Since the Godot code was using ChunkMessage, we will ensure that 
// GenerationMessage is exported as a public alias for compatibility.
// This resolves the `unused import` warning by removing the direct import,
// while keeping the public re-export which uses the fully qualified path.
pub use super::generation_message::GenerationMessage as ChunkMessage;
<<< FILE END: rust\ssxl_shared\src\message\messages.rs >>>

>>> FILE START: rust\ssxl_shared\src\message\mod.rs (6 LOC) <<<
// ssxl_shared/src/message/mod.rs

pub mod generation_message;
pub mod messages;

// FIX 1: Publicly re-export AnimationUpdate from the messages module.
// This makes the type available as `ssxl_shared::message::AnimationUpdate`.
pub use messages::AnimationUpdate;
<<< FILE END: rust\ssxl_shared\src\message\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\tile\mod.rs (3 LOC) <<<
// ssxl_shared/src/tile/mod.rs

pub mod tile_data;
pub mod tile_type;
<<< FILE END: rust\ssxl_shared\src\tile\mod.rs >>>

>>> FILE START: rust\ssxl_shared\src\tile\tile_data.rs (123 LOC) <<<
// ssxl_shared/src/tile_data.rs

//! # Tile Data Structures (`ssxl_shared::tile_data`)
//!
//! This module defines the `TileData` structure, which holds the minimal necessary
//! information for a single tile in the procedural world. It also includes utility
//! structures and bitmask constants (`tile_flags`) for efficient property management.
//! The use of `Copy` and `u8` flags is key to maintaining the high-speed "Tempo"
//! of the multi-threaded engine.

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};

// Re-exports a core math primitive for use in related structures (e.g., AnimationUpdate).
use ssxl_math::Vec2i;


// --- Core Data Structure ---

/// Represents the data payload for a single tile in a chunk.
///
/// Marked `Copy` for high performance, as tiles are frequently cloned/copied
/// within generation and rendering loops.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The material or type of tile (e.g., grass, rock, empty).
    pub tile_type: TileType,
    
    /// The raw noise value (e.g., Perlin, Simplex) used to determine this tile's type.
    /// This is crucial for seamless neighbor checks and debugging the procedural generation.
    pub noise_value: f32,
    
    /// A compact bitfield storing up to 8 boolean properties about the tile.
    pub flags: u8,
}

impl Default for TileData {
    /// Returns the default state for a tile: `TileType::Void` with zero noise and no flags set.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}


// --- Godot FFI Message Structure ---

/// Data structure used specifically for communication between the Rust engine
/// and the Godot runtime regarding tile animations.
///
/// This message is typically used by a dedicated rendering or animation system.
#[derive(Debug, Clone, Serialize, Deserialize)] // FIX: Added Serialize and Deserialize
pub struct AnimationUpdate {
    /// The layer or dimension the tile belongs to.
    pub layer: i32,
    /// The source ID of the tile map or animation source.
    pub source_id: i32,
    /// The world coordinates of the tile to update.
    pub tile_coords: Vec2i,
    /// The new coordinates within the texture atlas for the tile's animation frame.
    pub new_atlas_coords: Vec2i,
}


// --- Bitwise Flag Constants ---

/// Bitmasks used to set, check, or clear properties in the `TileData::flags` field.
/// This maximizes data density by storing 8 booleans in a single byte (`u8`).
pub mod tile_flags {
    /// Bit 0: Is the tile physically passable by entities? (e.g., air, water surface)
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001;
    /// Bit 1: Is the tile currently visible/rendered by the client?
    pub const IS_RENDERED:    u8 = 0b0000_0010;
    /// Bit 2: Has this tile been manually changed post-generation by a player/editor?
    pub const IS_MODIFIED:    u8 = 0b0000_0100;
    /// Bit 3: Does this tile contain a gatherable resource or item?
    pub const HAS_RESOURCE:    u8 = 0b0000_1000;
    // Bits 4-7 are reserved for future properties.
}


impl TileData {
    /// Creates a new `TileData` instance with specified type and noise value.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0, // Flags are initialized to zero (all false)
        }
    }

    /// Checks if the tile is considered a "solid" block, typically used for collision.
    pub const fn is_solid(&self) -> bool {
        // Relies on a method in TileType to define "solidity."
        !self.tile_type.is_empty()
    }

    /// Sets a flag based on its **bit index** (0-7).
    pub fn set_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise OR assignment: sets the bit at the given index to 1.
            self.flags |= 1 << flag_index;
        }
    }

    /// Clears (sets to 0) a flag based on its **bit index** (0-7).
    pub fn clear_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise AND assignment with the inverted mask: sets the bit to 0.
            self.flags &= !(1 << flag_index);
        }
    }

    /// Checks the status of a flag based on its **bit index** (0-7).
    pub fn check_flag_by_index(&self, flag_index: u8) -> bool {
        if flag_index < 8 {
            // Bitwise AND with the mask: returns true if the bit is set.
            (self.flags & (1 << flag_index)) != 0
        } else {
            false
        }
    }
    
    /// Sets or clears a property using a predefined **flag mask** (e.g., `tile_flags::IS_TRAVERSABLE`).
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            // Set the bit(s) (|= is bitwise OR assignment).
            self.flags |= flag_mask;
        } else {
            // Clear the bit(s) (&! is bitwise AND with the inverted mask).
            self.flags &= !flag_mask;
        }
    }

    /// Checks the status of a property using a predefined **flag mask**.
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        // Returns true if any of the bits in the mask are set in self.flags.
        (self.flags & flag_mask) != 0
    }
}
<<< FILE END: rust\ssxl_shared\src\tile\tile_data.rs >>>

>>> FILE START: rust\ssxl_shared\src\tile\tile_type.rs (107 LOC) <<<
// ssxl_shared/src/tile_type.rs

//! # Tile Type Enumeration (`ssxl_shared::tile_type`)
//!
//! This module defines the canonical `TileType` enum, which identifies the material
//! or nature of a single tile. It is a fundamental data structure shared across
//! the entire SSXL-ext engine.
//!
//! **Critical Feature:** The use of `#[repr(u8)]` is a **memory optimization**
//! that guarantees the enum is stored as a single byte, drastically reducing the
//! memory footprint of the massive `ChunkData` tile arrays.

use serde::{Deserialize, Serialize};

/// Enumeration of all primary tile materials available in the procedural world.
///
/// Ensures strict memory layout as a single byte for efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    /// The default, empty state (e.g., air or background).
    Void = 0,
    /// A fluid, typically used for rivers, oceans, or lower areas.
    Water = 1,
    /// Base terrain, usually flat and traversable.
    Grass = 2,
    /// Elevated terrain, potentially difficult to traverse.
    Mountain = 3,
    /// An artificial boundary used to cap chunk edges or isolate generation regions.
    Boundary = 4,
    /// An engineered or placed structure (e.g., a ruin, road, or wall).
    Structure = 5,
    /// A solid, rocky, non-soil terrain type.
    Rock = 6,
    /// Reserved for generator-specific customization or future expansion.
    Custom1 = 7,
    /// Reserved for generator-specific customization or future expansion.
    Custom2 = 8,
}


impl Default for TileType {
    /// The default state of a tile is always `TileType::Void` (empty).
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Converts the `TileType` instance into its underlying `u8` representation.
    #[inline] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a raw `u8` value back into a `TileType`.
    ///
    /// Returns `None` if the input value does not correspond to a defined variant,
    /// ensuring safe deserialization.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TileType::Void),
            1 => Some(TileType::Water),
            2 => Some(TileType::Grass),
            3 => Some(TileType::Mountain),
            4 => Some(TileType::Boundary),
            5 => Some(TileType::Structure),
            6 => Some(TileType::Rock),
            7 => Some(TileType::Custom1),
            8 => Some(TileType::Custom2),
            _ => None,
        }
    }
    
    /// Provides a simple, default unique ID for this tile type (equal to its u8 value).
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Provides default atlas coordinates (X, Y) for initial rendering/visual representation.
    ///
    /// This is a common lookup function used by the rendering component (`ssxl_godot`).
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // All default tiles are expected to be on the first row (Y=0) of the atlas.
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            // Void and unspecified types default to the origin (0, 0).
            _ => (0, 0), 
        }
    }
}


impl TileType {
    /// Checks if the tile type is one that a character can typically traverse (walk on).
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type is considered a fluid (e.g., for flow/buoyancy simulation).
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is empty (the default/void state).
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}
<<< FILE END: rust\ssxl_shared\src\tile\tile_type.rs >>>

>>> FILE START: rust\ssxl_sync\Cargo.toml (24 LOC) <<<
[package]
name = "ssxl_sync"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
# Required for shared data types and the canonical error type
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_animate = { path = "../ssxl_animate" }

# --- EXTERNAL CONCURRENCY & DIAGNOSTICS ---
# Primary async runtime
tokio               = { workspace = true, features = ["full"] }
# High-performance channel types
crossbeam           = { workspace = true }
crossbeam-channel   = { workspace = true }
# High-performance sync primitives (like RwLock, often preferred over std::sync)
parking_lot         = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing             = { workspace = true }
godot               = { workspace = true, optional = true }

[features]
# Add a feature flag for Godot-specific dependencies
godot-bindings = ["godot"]
<<< FILE END: rust\ssxl_sync\Cargo.toml >>>

>>> FILE START: rust\ssxl_sync\src\animation_conductor.rs (89 LOC) <<<
// ssxl_sync/src/animation_conductor.rs (Type Resolution Fix)

use ssxl_shared::{
    AnimationConductorHandle,
    AnimationState,
    AnimationCommand, 
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tracing::info;

// FIX: Import the exact nested type required by the CoreAnimationWorker's signature 
// and alias it as `AnimationUpdate`. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: We rely on the core worker being defined as `conductor::AnimationConductor` within ssxl_animate.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct (for passing state between FFI stages)
// -----------------------------------------------------------------------------

/// Holds all the necessary internal channels and initial state required to spawn the
/// heavy, background Animation Conductor thread.
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,
    /// The receiver for Godot commands, which the worker thread will consume.
    pub command_receiver: UnboundedReceiver<AnimationCommand>,
    
    /// The sender for updates, which the worker thread will use.
    // This field now holds the correctly nested type due to the aliased import above.
    pub update_sender: UnboundedSender<AnimationUpdate>,
}

// -----------------------------------------------------------------------------
// 2. The Public Conductor Struct (The FFI-facing worker wrapper)
// -----------------------------------------------------------------------------

/// The SSXL Animation Conductor. This struct is responsible for executing the
/// animation logic in a background thread.
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup (Non-blocking)
    // -------------------------------------------------------------------------
    
    /// Creates all the necessary MPSC channels and the initial `AnimationState`.
    /// 
    /// # Returns
    /// A tuple containing:
    /// 1. `AnimationConductorInternalSetup`: The struct holding internal handles for spawning.
    /// 2. `AnimationConductorHandle`: The public command sender handle exposed to Godot's FFI layer.
    /// 3. `UnboundedReceiver<AnimationUpdate>`: The public update receiver handle exposed to Godot's Poller.
    pub fn setup_channels_and_state() -> (AnimationConductorInternalSetup, AnimationConductorHandle, UnboundedReceiver<AnimationUpdate>) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channels for commands from Godot to the worker.
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channels for updates from the worker to Godot (Poller).
        // This channel uses the correctly aliased type.
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        let initial_state = AnimationState::default();

        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        let public_command_handle = command_tx;

        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------

    /// Consumes the setup handles and spawns the core animation worker thread.
    /// 
    /// # Arguments
    /// * `setup`: The internal channels and initial state from the setup stage.
    /// 
    /// # Returns
    /// A new `AnimationConductor` instance representing the running worker.
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // This call is now correct because `setup.update_sender` holds the 
        // type the `CoreAnimationWorker::new` function requires.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the opaque public handle struct
        AnimationConductor {} 
    }
}
<<< FILE END: rust\ssxl_sync\src\animation_conductor.rs >>>

>>> FILE START: rust\ssxl_sync\src\lib.rs (65 LOC) <<<
// ssxl_sync/src/lib.rs

//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//!
//! This crate provides the core primitives and manager structs necessary for
//! thread synchronization, communication, and high-performance worker management
//! within the SSXL-ext engine. This includes:
//! 1. **Data Safety:** Atomic wrappers for thread-safe shared resources.
//! 2. **Worker Management:** Thread pools and specialized, dedicated worker threads (Conductors).
//! 3. **Communication:** Channel definitions for command and result passing.

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import tokio for the channel types used in the aliases below.
use tokio::sync::mpsc; 
// CRITICAL: Import all core contract types from ssxl_shared.
use ssxl_shared::{
    SSXLError, 
    AnimationUpdate,
    AnimationCommand, 
    // FIX: Removed unused import AnimationState
};
// FIX: Import and public re-export the core struct in one step to avoid E0252/E0365.
pub use ssxl_animate::AnimationConductor; 

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

/// Defines core thread-safe types, enums, and channel aliases used for concurrency and communication.
pub mod primitives;

/// Manages the generic, fixed-size thread pool used for synchronous, CPU-intensive tasks.
pub mod pool;

/// Manages the dedicated worker thread and state for calculating visual animation frames.
pub mod animation_conductor;


// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

// --- 1. Generic Primitives and Utility Functions (from primitives) ---

/// Re-exports of generic thread-safe resource wrappers, synchronous channels, and worker placeholders.
pub use primitives::{
    AtomicResource, 
    create_sync_channel, 
    start_sync_worker
};

// --- 2. Animation Conductor Types ---

// FIX: Removed the unused `pub use animation_conductor::{...};` block.
// The primary conductor struct is handled by the `pub use ssxl_animate::AnimationConductor` above.


// --- 3. Thread Pool Manager Types (from pool_manager) ---

/// Re-exports of all public types related to the generic CPU worker thread pool.
pub use pool::{
    WorkerPool, 
    GenerationTask, 
    ConductorResult, 
    Task, 
    TaskResult
};

// --------------------------------------------------------------------------------
// --- Final Type Aliases (CRATE ROOT API) ---
// --------------------------------------------------------------------------------

// The UnboundedSender type is used to send commands to the Conductor's thread.
pub type AnimationConductorHandle = mpsc::UnboundedSender<AnimationCommand>;

// The Receiver half of the command channel for the AnimationConductor.
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;

// The UnboundedSender type is used to send updates (e.g., animation frames) back to the main thread.
pub type UpdateSender = mpsc::UnboundedSender<AnimationUpdate>; 

// The standard result wrapper, using SSXLError.
pub type CommandResult = Result<(), SSXLError>;
<<< FILE END: rust\ssxl_sync\src\lib.rs >>>

>>> FILE START: rust\ssxl_sync\src\pool.rs (151 LOC) <<<
//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::Vec2i;
// FIX: Import ChunkData directly from the root of ssxl_shared to resolve both E0433 errors.
use ssxl_shared::ChunkData; 

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    // FIX 1 (Line 47): Use the directly imported ChunkData.
    CompletedChunk(Arc<ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // FIX 2 (Line 130): Use the directly imported ChunkData.
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
<<< FILE END: rust\ssxl_sync\src\pool.rs >>>

>>> FILE START: rust\ssxl_sync\src\primitives.rs (34 LOC) <<<
use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
use tracing::info;

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline]
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline]
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

pub fn create_sync_channel() -> (Sender<String>, Receiver<String>) {
    unbounded()
}

pub fn start_sync_worker() {
    info!("SSXL Synchronization Worker placeholder started.");
}
<<< FILE END: rust\ssxl_sync\src\primitives.rs >>>

>>> FILE START: rust\ssxl_tools\Cargo.toml (10 LOC) <<<
[package]
name = "ssxl_tools"
edition = "2021" 

[dependencies]
# Internal dependencies (Local Crates)
ssxl_shared = { path = "../ssxl_shared" }

# External dependency (Workspace-Inherited)
regex = { workspace = true }
once_cell = { workspace = true }
tracing = { workspace = true }
<<< FILE END: rust\ssxl_tools\Cargo.toml >>>

>>> FILE START: rust\ssxl_tools\src\lib.rs (127 LOC) <<<
// ssxl_tools/src/lib.rs

//! # SSXL Engine Tools (`ssxl_tools`)
//!
//! Provides utility functions for **configuration management**, **data validation**,
//! and other engine-wide tooling not specific to generation or synchronization.

use once_cell::sync::Lazy;
use regex::Regex;
use tracing::{info, warn};
use std::io::{self, Read};
use std::fs::File;

use ssxl_shared::SSXLData;

// --------------------------------------------------------------------------------
// --- Configuration Constants ---
// --------------------------------------------------------------------------------

/// The default file path to check for engine configuration.
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
/// The ID of the generator used when configuration loading fails or is not specified.
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
/// The default Cellular Automata ruleset ID to use.
const DEFAULT_CA_RULESET: u8 = 0;

// --------------------------------------------------------------------------------
// --- SSXL Configuration Management ---
// --------------------------------------------------------------------------------

/// Configuration structure holding key engine settings, primarily for generation defaults.
pub struct SSXLConfig {
    /// The ID of the world generator to use when no specific one is requested.
    default_generator_id: String,
    /// The default ruleset ID for the Cellular Automata generator.
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Creates a new `SSXLConfig` instance populated with hardcoded default values.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to read and simulate loading engine configuration from a file path.
    ///
    /// The actual configuration parsing logic is currently simulated:
    /// it reads the file and then unconditionally returns hardcoded override values.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                // Read the entire file content into a string.
                file.read_to_string(&mut contents)?;

                info!("SSXLConfig: File read successfully. Simulating config override.");
                // Placeholder: In a real implementation, 'contents' would be parsed (e.g., via TOML).
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), // Simulated override
                    ca_default_ruleset: 1,                               // Simulated override
                })
            },
            // If file opening fails, propagate the standard I/O error.
            Err(e) => Err(e),
        }
    }

    /// Returns the configured default generator ID string.
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Returns the configured default Cellular Automata ruleset ID.
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Attempts to load the configuration from the specified path.
///
/// If `path` is `None`, it defaults to `DEFAULT_CONFIG_PATH`.
/// If the file loading fails for any reason, it logs a warning and **returns
/// a new `SSXLConfig` instance populated with hardcoded defaults** (safe fallback).
pub fn get_config_from_path(path: Option<&str>) -> Result<SSXLConfig, io::Error> {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            Ok(config)
        },
        Err(e) => {
            // Log the failure but ensure the engine has a runnable configuration.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            // Return the defaults wrapped in an Ok() to ensure initialization succeeds.
            Ok(SSXLConfig::new_with_defaults())
        }
    }
}

// --------------------------------------------------------------------------------
// --- Static Configuration (DEPRECATED) ---
// --------------------------------------------------------------------------------

/// Lazy-initialized static instance of the default configuration.
///
/// Used by the deprecated `get_config()` function.
static CONFIG: Lazy<SSXLConfig> = Lazy::new(SSXLConfig::new_with_defaults);

/// Retrieves the global static configuration instance.
///
/// **WARNING:** This function is **DEPRECATED**. It does not allow for specifying
/// a configuration path and relies on a hardcoded static default.
/// Use [`get_config_from_path`] instead.
pub fn get_config() -> &'static SSXLConfig {
    warn!("DEPRECATED: Called `get_config()`. Use `get_config_from_path()` for correct FFI CWD handling and dynamic loading.");
    &CONFIG
}

// --------------------------------------------------------------------------------
// --- Utility Functions ---
// --------------------------------------------------------------------------------

/// Lazy-initialized regular expression for validating SSXL data IDs (must be composed only of digits).
static ID_REGEX: Lazy<Regex> = Lazy::new(|| {
    // Pattern matches one or more digits from start to end of the string.
    Regex::new(r"^\d+$").expect("Failed to compile ID validation regex")
});

/// Validates that an `SSXLData` ID is composed solely of digits.
pub fn validate_data_id(data: &SSXLData) -> bool {
    // Checks if the string representation of the data ID matches the digit-only regex.
    ID_REGEX.is_match(&data.id.to_string())
}

/// Initializes engine tool utilities.
///
/// This function triggers the lazy initialization of necessary static resources,
/// such as the ID validation regex, ensuring they are ready before first use.
pub fn initialize() {
    // Force initialization of the static regex.
    let _ = &*ID_REGEX;
    info!("SSXL Tools: Configuration and data validation utilities initialized.");
}
<<< FILE END: rust\ssxl_tools\src\lib.rs >>>

