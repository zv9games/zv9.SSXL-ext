>>> FILE START: rust\ssxl_math\Cargo.toml (16 LOC) <<<
[package]
name = "ssxl_math"
version = "0.9.1"
edition.workspace = true

[dependencies]
# Internal dependencies (Local Crates)

# External dependencies (Workspace-Inherited)
# FIX: Explicitly re-enable the 'serde' feature for glam.
# This ensures IVec3 implements Serialize/Deserialize, resolving the E0277 errors.
glam = { workspace = true, features = ["serde"] }
serde = { workspace = true }
thiserror = { workspace = true } # Added for defining local crate Result type
tracing = { workspace = true }
sha2 = { workspace = true }
rand = { workspace = true }
rand_pcg = { workspace = true }
<<< FILE END: rust\ssxl_math\Cargo.toml >>>

>>> FILE START: rust\ssxl_math\src\coordinate_system.rs (119 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// serde::{Serialize, Deserialize}
//   - Enables serialization and deserialization of structs (WorldPos, ChunkKey, TileOffset).
//   - Useful for saving/loading world state or transmitting coordinates across systems.
use serde::{Serialize, Deserialize};

// CHUNK_SIZE_I64
//   - Constant defining the cubic dimension of a chunk (e.g., 32).
//   - Used to calculate chunk boundaries and offsets.
use crate::primitives::CHUNK_SIZE_I64;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows extremely large coordinate ranges, far beyond i32 limits.
use glam::I64Vec3;

// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------
// These structs define the fundamental coordinate system for the engine.
// They wrap I64Vec3 to provide semantic meaning (WorldPos vs ChunkKey vs TileOffset).

// WorldPos
//   - Represents a specific point in the infinite 3D world.
//   - Stored as a 64-bit vector to handle huge coordinates safely.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

// ChunkKey
//   - Identifies a chunk in the world.
//   - Each chunk is a cubic volume of size CHUNK_SIZE_I64.
//   - Acts as the "index" of the chunk in world space.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

// TileOffset
//   - Represents the local position of a tile inside its parent chunk.
//   - Always non-negative, ranging from 0 to CHUNK_SIZE_I64 - 1.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);

// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------
// Provides conversion from global coordinates to chunk-local coordinates.
impl WorldPos {
    // to_chunk_coords
    //   - Splits a global WorldPos into (ChunkKey, TileOffset).
    //   - Uses Euclidean division to handle negative coordinates correctly.
    //   - Ensures TileOffset is always non-negative.
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        let chunk_size = CHUNK_SIZE_I64;

        // Compute tile offset using rem_euclid (always non-negative).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // Compute chunk index by subtracting offset and dividing by chunk size.
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------
// Provides conversion from chunk-local coordinates back to global coordinates.
impl ChunkKey {
    // to_world_pos
    //   - Reconstructs a WorldPos from a ChunkKey and TileOffset.
    //   - Formula: World = (Chunk Index * Chunk Size) + Tile Offset.
    //   - Ensures round-trip consistency with WorldPos::to_chunk_coords.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates correctness of conversions, especially for large and negative coordinates.
#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    #[test]
    fn test_world_to_chunk_positive() {
        // Large positive coordinate (well beyond i32::MAX).
        let huge_coord = 5_000_000_000i64;
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64;
        let expected_offset = huge_coord % CHUNK_SIZE_I64;

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // Verify chunk index and offset.
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        // Case 1: (-1, -1, -1) → ChunkKey = -1, Offset = 31.
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Case 2: (-33, -64, -100) → deeper negative coordinates.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        // Round-trip test: WorldPos → (ChunkKey, TileOffset) → WorldPos.
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();
        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}

<<< FILE END: rust\ssxl_math\src\coordinate_system.rs >>>

>>> FILE START: rust\ssxl_math\src\generation_utils.rs (65 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLData
//   - Trait defined in the primitives module.
//   - Provides two essential methods:
//       * get_id() -> u64: returns a unique identifier for the data.
//       * get_value_len() -> usize: returns the length of the associated value.
//   - Used here to process data objects generically.
use crate::primitives::SSXLData;

// rand::Rng
//   - Trait from the `rand` crate that provides random number generation utilities.
//   - Enables us to call gen_range() for chance rolls.
use rand::Rng;

// -----------------------------------------------------------------------------
// Function: generate_percent_roll
// -----------------------------------------------------------------------------
// Purpose:
//   - Performs a probabilistic roll against a given percentage chance.
//   - Used in procedural generation to decide whether an event occurs (e.g., spawning resources).
//
// Arguments:
//   - target_percent: u8 (0–100), representing the probability of success.
//
// Behavior:
//   - Generates a random integer between 0 and 99 inclusive.
//   - Compares it against target_percent.
//   - Returns 0 if success (random < target_percent).
//   - Returns 1 if failure (random >= target_percent).
//
// Example:
//   - generate_percent_roll(25) → 25% chance of returning 0 (success).
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the range [0, 99].
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Compare against target_percent.
    if rand_val < target_percent {
        0 // Success
    } else {
        1 // Failure
    }
}

// -----------------------------------------------------------------------------
// Function: process_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Processes an object implementing SSXLData to derive a simple aggregate identifier.
//   - Combines the object's unique ID with the length of its value payload.
//   - Useful for lightweight hashing, checksums, or quick uniqueness checks.
//
// Arguments:
//   - data: reference to any object implementing SSXLData.
//
// Behavior:
//   - Calls get_id() to retrieve the object’s unique identifier.
//   - Calls get_value_len() to retrieve the length of its payload.
//   - Adds them together to produce a u64 aggregate value.
//
// Returns:
//   - u64 representing the combined identifier + payload length.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine ID and payload length into a single value.
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}

<<< FILE END: rust\ssxl_math\src\generation_utils.rs >>>

>>> FILE START: rust\ssxl_math\src\hashing.rs (110 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLResult
//   - A custom result type defined in the primitives module.
//   - Used here to wrap hashing results, ensuring consistency with the rest of the engine.
use crate::primitives::SSXLResult;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows chunk coordinates to span extremely large worlds without overflow.
use glam::I64Vec3;

// sha2::{Digest, Sha256}
//   - Digest: trait providing hashing functionality.
//   - Sha256: implementation of the SHA-256 cryptographic hash algorithm.
//   - Used to generate deterministic, collision-resistant hashes.
use sha2::{Digest, Sha256};

// -----------------------------------------------------------------------------
// Function: hash_chunk_coords
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a given 3D chunk coordinate.
//   - Ensures that identical coordinates always produce the same hash string.
//   - Used as a unique identifier for chunks in caching and procedural generation.
//
// Arguments:
//   - coords: I64Vec3 representing the chunk’s world-space coordinates.
//
// Behavior:
//   - Serializes coordinates into a canonical string format ("x:y:z").
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string.
//
// Returns:
//   - SSXLResult<String> containing the hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // Serialize coordinates into a deterministic string.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // Convert hash bytes into lowercase hex string.
    Ok(format!("{:x}", result))
}

// -----------------------------------------------------------------------------
// Function: hash_content_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a generic u64 data key.
//   - Used for content caching (e.g., assets, seeds, configurations).
//   - Adds a "content_" prefix for easy identification in cache systems.
//
// Arguments:
//   - data_key: u64 identifier for the content.
//
// Behavior:
//   - Converts the key into a string.
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string prefixed with "content_".
//
// Returns:
//   - SSXLResult<String> containing the prefixed hash.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // Convert numeric key into string.
    let key_string = data_key.to_string();

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // Prefix with "content_" and return.
    Ok(format!("content_{:x}", result))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates determinism, uniqueness, and formatting of the hashing functions.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chunk_coords_determinism() {
        // Same coordinates should always produce identical hashes.
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        // Adjacent coordinates should produce different hashes.
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        // Verify hash length and uniqueness.
        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    fn test_content_data_determinism_and_format() {
        // Same content key should always produce identical hashes.
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        // Verify prefix and total length.
        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}

<<< FILE END: rust\ssxl_math\src\hashing.rs >>>

>>> FILE START: rust\ssxl_math\src\lib.rs (104 LOC) <<<
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// These modules define the mathematical foundation of the SSXL engine.
// Each module is declared here so they can be accessed throughout the crate.

// coordinate_system
//   - Defines core coordinate types (WorldPos, ChunkKey, TileOffset).
//   - Handles conversion between global world positions and chunk-local offsets.
pub mod coordinate_system;

// generation_utils
//   - Provides utility functions for procedural generation.
//   - Includes randomness utilities (percent rolls) and data processing helpers.
pub mod generation_utils;

// hashing
//   - Provides deterministic hashing functions.
//   - Used for chunk IDs, cache keys, and ensuring stable procedural generation.
pub mod hashing;

// primitives
//   - Defines core mathematical constants, types, and result/error handling.
//   - Acts as the foundation for other modules.
pub mod primitives;

// -----------------------------------------------------------------------------
// Fast Inverse Square Root (q_rsqrt)
// -----------------------------------------------------------------------------
// Purpose:
//   - Approximates 1/sqrt(number) extremely quickly using bit-level operations.
//   - Famous algorithm from Quake III Arena, adapted here for safe use.
//   - Used for vector normalization and other math-heavy operations.
//
// Arguments:
//   - number: f32, the value to invert square root.
//
// Behavior:
//   - Returns 0.0 if input is <= 0.0 (safety guard).
//   - Uses bit manipulation to approximate inverse square root.
//   - Refines result with one Newton-Raphson iteration.
//
// Returns:
//   - Approximate 1/sqrt(number).
#[inline(always)]
pub fn q_rsqrt(number: f32) -> f32 {
    // Safety guard: prevent NaN or undefined behavior.
    if number <= 0.0 { 
        return 0.0;
    }

    // Constant used in Newton-Raphson iteration.
    const THREEHALFS: f32 = 1.5;

    // Half of the input number.
    let x2 = number * 0.5;
    let y = number;
    
    // Bit-level hack: reinterpret float bits as integer.
    let i = y.to_bits();
    // Magic constant (0x5f3759df) minus half of exponent bits.
    let j_bits = 0x5f3759df_u32.wrapping_sub(i >> 1);

    // Reinterpret back into float.
    let mut y = f32::from_bits(j_bits);
    
    // One iteration of Newton-Raphson refinement.
    y = y * (THREEHALFS - (x2 * y * y));
    y
}

// -----------------------------------------------------------------------------
// Vector Normalization
// -----------------------------------------------------------------------------
// Purpose:
//   - Computes the unit vector (normalized vector) of a 3D vector.
//   - Uses q_rsqrt for fast inverse square root approximation.
//
// Arguments:
//   - x, y, z: f32 components of the vector.
//
// Behavior:
//   - Computes squared magnitude (x² + y² + z²).
//   - Uses q_rsqrt to approximate 1/sqrt(mag_sq).
//   - Multiplies each component by inverse magnitude.
//
// Returns:
//   - Tuple (f32, f32, f32) representing normalized vector.
pub fn normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32) {
    let mag_sq = x * x + y * y + z * z;
    let inv_mag = q_rsqrt(mag_sq); 
    
    (x * inv_mag, y * inv_mag, z * inv_mag)
}

// -----------------------------------------------------------------------------
// Prelude Module
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a convenience re-export of all essential types and functions.
//   - Allows other crates to import `ssxl_math::prelude::*` for quick access.
//
// Contents:
//   - Re-exports coordinate_system, generation_utils, hashing, primitives.
//   - Re-exports q_rsqrt and normalize_vector_3d.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
    
    pub use super::q_rsqrt;
    pub use super::normalize_vector_3d;
}

<<< FILE END: rust\ssxl_math\src\lib.rs >>>

>>> FILE START: rust\ssxl_math\src\primitives.rs (67 LOC) <<<
// -----------------------------------------------------------------------------
// Primitives: low-level types, aliases, traits, and constants
// -----------------------------------------------------------------------------
// serde::{Deserialize, Serialize}
//   - Derive macros to allow this crate’s basic types to be serialized/deserialized
//     for persistence, networking, and inter-crate messaging.
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Vec2i: a 2D integer vector
// -----------------------------------------------------------------------------
// Purpose:
//   - Canonical 2D coordinate used across the engine for tiles and chunk indexing.
// Design notes:
//   - Uses i64 to align with the engine’s 64-bit world coordinates (I64Vec3),
//     preventing silent overflow if values are promoted or combined with i64 math.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    // X component (horizontal axis)
    pub x: i64,
    // Y component (vertical axis)
    pub y: i64,
}

impl Vec2i {
    // Constructor for Vec2i, emphasizing explicitness and avoiding field-order mistakes.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// -----------------------------------------------------------------------------
// Type aliases: semantic clarity with zero runtime cost
// -----------------------------------------------------------------------------
// TileCoord
//   - Semantic alias for a tile’s coordinate in 2D space (world or local).
//   - Keeps API readable and intent-focused while reusing Vec2i’s layout.
pub type TileCoord = Vec2i; 

// ChunkId
//   - Semantic alias for a chunk’s 2D identifier in a world grid.
//   - Mirrors TileCoord’s layout for consistency across APIs and storage.
pub type ChunkId = Vec2i; 

// SSXLResult<T>
//   - Project-wide lightweight Result alias with String errors.
//   - Favoring human-readable messages across crate boundaries without custom error enums.
pub type SSXLResult<T> = Result<T, String>;

// -----------------------------------------------------------------------------
// Trait: SSXLData
// -----------------------------------------------------------------------------
// Purpose:
//   - Minimal contract for data managed by the engine (task queues, caches, workers).
// Concurrency:
//   - Send + Sync required to safely move/share implementors across thread boundaries.
pub trait SSXLData: Send + Sync {
    // Unique, stable identifier used for indexing, caching, and deduplication.
    fn get_id(&self) -> u64;

    // Size of the core payload (bytes or elements), useful for diagnostics and limits.
    fn get_value_len(&self) -> usize;
}

// -----------------------------------------------------------------------------
// Global constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE_I64
//   - Canonical cubic side length for procedural chunks.
//   - i64 type matches engine math and avoids cross-type casting pitfalls.
pub const CHUNK_SIZE_I64: i64 = 32;

// F32_EPSILON
//   - Small tolerance for floating-point comparisons in math-heavy routines
//     (e.g., noise interpolation, normalization).
pub const F32_EPSILON: f32 = 1.0e-6;

<<< FILE END: rust\ssxl_math\src\primitives.rs >>>

