SSXL-ext Codebase LOC Report
Generated (Epoch Seconds): 1761688853
Root Directory: ../rust/
Scan Time: 5.00ms
Total Files Scanned: 34
Total Lines of Code (LOC): 3932

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
  396 LOC | ssxl_generate\src\conductor.rs
  390 LOC | ssxl_godot\src\ssxl_engine.rs
  270 LOC | ssxl_cli\src\cli_util_actions.rs
  215 LOC | ssxl_cli\src\cli_util_loc_scan.rs
  199 LOC | ssxl_cli\src\cli_util_bench.rs
  179 LOC | ssxl_generate\src\cellular_automata_generator.rs
  162 LOC | ssxl_cli\src\cli_util_inspect.rs
  146 LOC | ssxl_shared\src\chunk_data.rs
  143 LOC | ssxl_sync\src\lib.rs
  130 LOC | ssxl_math\src\coordinate_system.rs
  128 LOC | ssxl_tools\src\lib.rs
  116 LOC | ssxl_cli\src\main.rs
  107 LOC | ssxl_shared\src\tile_data.rs
  105 LOC | ssxl_generate\src\perlin_generator.rs
  102 LOC | ssxl_math\src\hashing.rs
  101 LOC | ssxl_engine_ffi\src\lib.rs
  100 LOC | manifest.rs
   89 LOC | ssxl_shared\src\tile_type.rs
   84 LOC | ssxl_godot\src\ssxl_oracle.rs
   77 LOC | ssxl_cache\src\lib.rs
   74 LOC | ssxl_cli\src\cli_util_menu.rs
   70 LOC | ssxl_shared\src\lib.rs
   67 LOC | ssxl_generate\src\lib.rs
   64 LOC | ssxl_shared\src\errors.rs
   58 LOC | ssxl_shared\src\grid_bounds.rs
   58 LOC | ssxl_godot\src\ssxl_signals.rs
   53 LOC | ssxl_godot\src\build.rs
   45 LOC | ssxl_math\src\primitives.rs
   45 LOC | ssxl_math\src\generation_utils.rs
   43 LOC | ssxl_generate\src\benchmark_logic.rs
   41 LOC | ssxl_shared\src\math_primitives.rs
   34 LOC | ssxl_math\src\lib.rs
   23 LOC | ssxl_godot\src\lib.rs
   18 LOC | ssxl_generate\src\generator.rs




======================================================
SSXL-ext Codebase DETAILED CONTENT DUMP
======================================================



//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\conductor.rs (396 LOC)
//////////////////////////////////////////////////////

//! The core manager for the ssxl Engine, responsible for coordinating
//! generation, concurrency, and caching via the Tokio asynchronous runtime.

use tokio::runtime::{Runtime, Handle};
use tokio::sync::mpsc; 
use tracing::{info, error, warn};
use std::collections::HashMap;
use std::sync::{Arc, Mutex, atomic::{AtomicUsize, Ordering}};
use std::io;

// NEW: Chunk size constant (assumed 64x64 from control_panel.gd)
const CHUNK_SIZE: usize = 64; 

// NEW: Cache and Math imports for Phase 6
use ssxl_cache::ChunkCache;
use ssxl_math::Vec2i;
use ssxl_math::prelude::ChunkKey; 
use glam::IVec3; 

// --- INTERNAL CRATE DEPENDENCIES ---
use crate::Generator;
use crate::perlin_generator::PerlinGenerator;
use crate::cellular_automata_generator::{
    CellularAutomataGenerator, 
    RULE_BASIC_CAVE, 
    RULE_MAZE
};

// --- EXTERNAL CRATE DEPENDENCIES ---
use ssxl_shared::chunk_data::ChunkData;
use ssxl_tools::get_config_from_path;

// FIX: Define a type alias that includes Send + Sync bounds for thread-safe trait objects
type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- MPSC Channel Configuration ---
const PROGRESS_CHANNEL_BOUND: usize = 100;

// -----------------------------------------------------------------------------
// PHASE 8.4: GENERATION MESSAGES
// -----------------------------------------------------------------------------

/// Messages sent from the asynchronous generation task back to the main
/// thread (Godot's tick loop) for reporting progress and results.
#[derive(Debug)]
pub enum GenerationMessage {
    /// A general status update (e.g., "Initializing Noise", "Processing 5/100 Chunks").
    StatusUpdate(String),
    /// Reports the completion of a single chunk. Contains the chunk's coordinates.
    ChunkGenerated(Vec2i),
    /// Reports the final completion of the entire generation run.
    GenerationComplete,
    /// Reports a non-fatal error during generation.
    Error(String),
}


// -----------------------------------------------------------------------------
// PHASE 8.3: GENERATOR CONFIGURATION
// -----------------------------------------------------------------------------

/// Configuration data passed from the Godot API to the Conductor to start a
/// full map generation run.
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
}


// -----------------------------------------------------------------------------
// CONDUCTOR STATE AND STATUS (For Signal Inspector)
// -----------------------------------------------------------------------------

/// Represents the operational state of the Conductor.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,
    Running,
    Paused,
    ShuttingDown,
    Error,
}

/// Shared, thread-safe state exposed to the CLI for monitoring.
#[derive(Clone)]
pub struct ConductorState {
    status: Arc<Mutex<ConductorStatus>>,
    // Represents the number of pending tasks in the generation queue
    queue_depth: Arc<AtomicUsize>, 
    // The ID of the currently active generation algorithm
    active_generator_id: Arc<Mutex<String>>,
}

impl ConductorState {
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: Arc::new(Mutex::new(ConductorStatus::Initializing)),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: Arc::new(Mutex::new(initial_generator_id)),
        }
    }

    // Public methods for the CLI to inspect the state
    pub fn get_status(&self) -> ConductorStatus {
        // Handle Mutex poisoning gracefully
        match self.status.lock() {
            Ok(guard) => *guard,
            Err(e) => {
                error!("Mutex poisoned when reading status: {}", e);
                ConductorStatus::Error
            }
        }
    }

    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    pub fn get_active_generator_id(&self) -> String {
        // Handle Mutex poisoning by unwrapping (less critical than status)
        self.active_generator_id.lock().unwrap().clone()
    }
    
    // Internal methods for the Conductor to update the state
    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.lock().unwrap() = new_status;
    }
    
    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.lock().unwrap() = id.to_string();
    }
}

// -----------------------------------------------------------------------------
// CONDUCTOR MANAGER
// -----------------------------------------------------------------------------

/// The central manager for the procedural generation pipeline.
pub struct Conductor {
    runtime: Runtime,
    generators: HashMap<String, Arc<DynGenerator>>,
    internal_state: ConductorState,
    // PHASE 6: Thread-safe handle to the ChunkCache for persistence
    chunk_cache: Arc<Mutex<ChunkCache>>,
    // PHASE 8.4: The sender side of the progress channel. Cloned for each task.
    progress_sender: mpsc::Sender<GenerationMessage>,
}
            
impl Conductor {
    /// Initializes the Conductor, starts the runtime, creates the MPSC channel,
    /// and returns the MPSC Receiver for the FFI consumer (Godot) to poll.
    pub fn new(config_path: Option<&str>) -> Result<(Self, ConductorState, mpsc::Receiver<GenerationMessage>), io::Error> {
        // Load configuration first
        let config = get_config_from_path(config_path)?; 

        // --- Runtime Setup ---
        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(4) 
            .enable_all()
            .build()?;

        // --- Generator Registration ---
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // 1. Perlin Generator (MVG)
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));

        // 2. Cellular Automata Generator (Cave)
        let ca_cave: DynGenerator = Box::new(CellularAutomataGenerator::new(RULE_BASIC_CAVE));
        generators.insert(ca_cave.id().to_string(), Arc::new(ca_cave));
        
        // 3. Cellular Automata Generator (Maze)
        let ca_maze: DynGenerator = Box::new(CellularAutomataGenerator::new(RULE_MAZE));
        generators.insert(ca_maze.id().to_string(), Arc::new(ca_maze));
        
        // --- Cache Initialization (PHASE 6) ---
        let chunk_cache = match ChunkCache::new() {
            Ok(c) => {
                info!("ChunkCache initialized successfully.");
                Arc::new(Mutex::new(c))
            },
            Err(e) => {
                error!("Failed to initialize ChunkCache: {:?}", e);
                return Err(io::Error::new(io::ErrorKind::Other, "Cache initialization failed"));
            }
        };
        
        // --- MPSC Channel Setup (PHASE 8.4) ---
        let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);

        // --- Conductor State Initialization ---
        let mut initial_id = default_perlin_id.clone();
        
        // Use configured default, falling back to Perlin if not found
        let config_id = config.get_default_generator_id();
        if generators.contains_key(config_id) {
            initial_id = config_id.to_string();
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, default_perlin_id);
        }

        let state = ConductorState::new(initial_id.clone());
        state.set_status(ConductorStatus::Running);
        
        info!("Conductor initialized. Active generator: {}", initial_id);

        // Return the Conductor instance, the State, and the MPSC Receiver
        Ok((Conductor {
            runtime,
            generators,
            internal_state: state.clone(),
            chunk_cache,
            progress_sender,
        }, state, progress_receiver)) 
    }

    /// Public method to get a handle to the Runtime for task spawning.
    pub fn get_handle(&self) -> Handle {
        self.runtime.handle().clone()
    }

    /// Provides public read-access to the active generator ID.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }
    
    // -------------------------------------------------------------------------
    // PHASE 8.3: CORE GENERATION COMMAND ENTRY POINT
    // -------------------------------------------------------------------------

    /// Handles the main map generation command from an FFI wrapper (like Godot).
    pub fn start_generation(&mut self, config: GeneratorConfig) -> Result<(), Box<dyn std::error::Error>> {
        info!("Conductor received main generation command. Config: {:?}", config);

        // 1. Set the active generator based on the config name
        match self.set_active_generator(&config.generator_name) {
            Ok(_) => info!("Generator successfully set to '{}'", config.generator_name),
            Err(e) => {
                error!("Failed to set generator: {}", e);
                return Err(e.into()); 
            }
        }
        
        // 2. Prepare for Asynchronous Generation
        let internal_state_clone = self.internal_state.clone();
        let runtime_handle = self.get_handle();
        let progress_sender_clone = self.progress_sender.clone(); // PHASE 8.4: Clone Sender for the task.

        runtime_handle.spawn(async move {
            info!("Async generation task spawned with config: {:?}", config);
            
            // Send initial status update
            let _ = progress_sender_clone.send(GenerationMessage::StatusUpdate("Starting generation task...".into())).await;

            // Increment queue depth to signal a task has started
            internal_state_clone.queue_depth.fetch_add(1, Ordering::Relaxed);

            // --- IMPLEMENTATION: FULL CHUNK LOOP ---
            // Calculate the grid dimensions in chunks (using ceiling division)
            let width_in_chunks = (config.width + CHUNK_SIZE - 1) / CHUNK_SIZE;
            let height_in_chunks = (config.height + CHUNK_SIZE - 1) / CHUNK_SIZE;
            let total_chunks = width_in_chunks * height_in_chunks;
            
            if total_chunks == 0 {
                error!("Generation failed: Calculated chunk count is zero for size {}x{}. Sending error signal.", config.width, config.height);
                let _ = progress_sender_clone.send(GenerationMessage::Error("Map dimensions are too small to contain a single chunk.".into())).await;
            } else {
                info!("Generation starting: {} chunks ({}x{}) to process.", total_chunks, width_in_chunks, height_in_chunks);
                
                // Outer loop (Y-axis)
                for chunk_y in 0..height_in_chunks {
                    // Inner loop (X-axis)
                    for chunk_x in 0..width_in_chunks {
                        let chunk_coords = Vec2i::new(chunk_x as i32, chunk_y as i32);
                        
                        // Emit signal to Godot main thread to trigger synchronous generate_chunk() call
                        let send_result = progress_sender_clone.send(
                            GenerationMessage::ChunkGenerated(chunk_coords)
                        ).await;
                        
                        if send_result.is_err() {
                            // If the receiver (Godot) dropped the channel, gracefully stop the work.
                            warn!("Progress channel disconnected. Stopping generation task.");
                            
                            // Decrease queue depth before exiting the task.
                            internal_state_clone.queue_depth.fetch_sub(1, Ordering::Relaxed);
                            return; 
                        }
                    }
                }
            }
            
            // Send final completion message
            let _ = progress_sender_clone.send(GenerationMessage::GenerationComplete).await;

            // Decrement queue depth on completion
            internal_state_clone.queue_depth.fetch_sub(1, Ordering::Relaxed);

            info!("Async generation task finished processing command: {:?}", config);
        });

        Ok(())
    }

    // --- Shutdown Management (The Fix) ---

    /// Signals the Conductor's internal state to begin a graceful shutdown process.
    pub fn signal_shutdown_graceful(&self) {
        info!("Aetherion Conductor signaled for shutdown. Setting status to ShuttingDown.");
        self.internal_state.set_status(ConductorStatus::ShuttingDown);
    }
    
    /// Performs a full, graceful teardown of the Conductor, signaling shutdown and
    /// stopping the underlying Tokio runtime. This method consumes `self`.
    pub fn graceful_teardown(self) {
        self.signal_shutdown_graceful();
        
        // This stops the Tokio runtime pool, freeing its resources.
        self.runtime.shutdown_background(); 
        info!("SSXL Conductor full teardown complete.");
    }
    
    // --- Generator Management & Core Pipeline ---

    /// Changes the algorithm used for subsequent generation tasks.
    pub fn set_active_generator(&mut self, id: &str) -> Result<(), String> {
        if self.generators.contains_key(id) {
            info!("Active generator set to: {}", id);
            self.internal_state.set_active_generator_id(id);
            Ok(())
        } else {
            let err = format!("Generator ID '{}' not found. Available IDs: {:?}", id, self.generators.keys());
            error!("{}", err);
            Err(err)
        }
    }
    
    /// The primary synchronous function used to generate a chunk (blocking for now).
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let key_vec3 = IVec3::new(chunk_coords.x, chunk_coords.y, 0);
        let chunk_key = ChunkKey(key_vec3);

        // --- 1. Attempt to load from cache ---
        match self.chunk_cache.lock() {
            Ok(cache_lock) => {
                match cache_lock.load_chunk(&chunk_key) {
                    Ok(Some(data)) => {
                        info!("Conductor retrieved chunk {:?} (Key: {:?}) from cache.", chunk_coords, chunk_key);
                        return data;
                    },
                    Ok(None) => {
                        info!("Chunk {:?} not found in cache. Generating...", chunk_coords);
                    },
                    Err(e) => {
                        warn!("Cache load failed for {:?}: {:?}. Generating instead.", chunk_coords, e);
                    }
                }
            },
            Err(e) => {
                error!("Cache Mutex poisoned during load: {}", e);
            }
        }
        
        // --- 2. Generate the Chunk ---
        let active_id = self.internal_state.get_active_generator_id();
        let generator_arc = self.generators
            .get(&active_id)
            .expect("Active generator ID must be registered in Conductor.");
            
        info!("Conductor dispatching generation of chunk {:?} using '{}'", 
              chunk_coords, active_id);
            
        let chunk_data = generator_arc.generate_chunk(chunk_coords);
        
        // --- 3. Save to cache ---
        match self.chunk_cache.lock() {
            Ok(cache_lock) => {
                if let Err(e) = cache_lock.save_chunk(&chunk_key, &chunk_data) {
                    error!("Failed to save chunk {:?} (Key: {:?}) to cache: {:?}", chunk_coords, chunk_key, e);
                } else {
                    info!("Conductor saved chunk {:?} to cache.", chunk_coords);
                }
            },
            Err(e) => {
                error!("Cache Mutex poisoned during save: {}", e);
            }
        }
        
        chunk_data
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_engine.rs (390 LOC)
//////////////////////////////////////////////////////

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use godot::builtin::{GString, Dictionary, Array, Variant};
use godot::classes::TileMap;
use crate::ssxl_signals::SSXLSignals;

// PHASE 8.4: Required for the asynchronous receiver
use tokio::sync::mpsc; 

// Internal Crate Dependencies
use ssxl_generate::{Conductor, GeneratorConfig}; 
use ssxl_generate::conductor::GenerationMessage;
use ssxl_math::Vec2i;

// Standard library and utilities
use std::sync::{Arc, Mutex};
use tracing::info;
use godot::prelude::godot_error;
use godot::prelude::godot_print;


// -------------------------------------------------------------------------------------------------
// SSXL ENGINE GODOT WRAPPER
// -------------------------------------------------------------------------------------------------

/// The Godot-facing wrapper class for the SSXL Engine.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLEngine {
    /// The core Rust logic manager, safely wrapped in an Arc/Mutex for shared access.
    conductor: Option<Arc<Mutex<Conductor>>>,
    
    /// Reference to the AetherionSignals node for signal emission.
    signals_node: Option<Gd<Node>>, 
    
    /// Reference to the main expansive TileMap for drawing/manipulation.
    tilemap_node: Option<Gd<TileMap>>, 

    /// PHASE 8.4: The receiver side of the MPSC channel for progress updates.
    /// This is stored on the main thread and polled every tick.
    generation_receiver: Option<mpsc::Receiver<GenerationMessage>>,

    #[base]
    base: Base<Node>,
}

// ------------------------------------------------------------------------------------
// Constructor
// ------------------------------------------------------------------------------------
impl SSXLEngine {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            conductor: None,
            signals_node: None, 
            tilemap_node: None, 
            generation_receiver: None, 
            base,
        }
    }
}

// ------------------------------------------------------------------------------------
// API methods remain in the #[godot_api] block.
// ------------------------------------------------------------------------------------
#[godot_api]
impl SSXLEngine {
    #[func]
    pub fn get_status(&self) -> GString {
        if self.conductor.is_some() {
            GString::from("STATUS: Conductor Ready")
        } else {
            GString::from("STATUS: Waiting for Init")
        }
    }

    /// Helper to emit the status signal (optional, but good practice for internal changes)
    pub fn emit_status_updated(&mut self, status: GString) {
        self.base_mut().emit_signal("status_updated", &[status.to_variant()]);
    }
    
    
    
    #[signal] 
    fn status_updated(status_message: godot::prelude::GString);

    // --- PHASE 8.4: MPSC POLLING AND HANDLING ---

    /// Private helper to process a single `GenerationMessage` and emit the corresponding Godot signals.
    fn handle_generation_update(&mut self, message: GenerationMessage) {
        // Collect the status message first, so we can call self.emit_status_updated 
        // after the immutable borrow of self.signals_node ends. (FIXES E0502)
        let mut status_update: Option<GString> = None;
        
        if let Some(signals) = &self.signals_node {
            match message {
                GenerationMessage::StatusUpdate(msg) => {
                    info!("Generation Status: {}", msg);
                    status_update = Some(GString::from(format!("GENERATING: {}", msg).as_str()));
                }
                GenerationMessage::ChunkGenerated(coords) => {
                    // Convert Vec2i to i32 for Godot signal
                    info!("Chunk Generated: ({}, {})", coords.x, coords.y);
                    if let Ok(mut ssxl_signals_instance) = signals.clone().try_cast::<SSXLSignals>() {
                        ssxl_signals_instance.bind_mut().emit_chunk_generated(coords.x as i32, coords.y as i32);
                    }
                }
                GenerationMessage::GenerationComplete => {
                    info!("Generation Complete.");
                    status_update = Some(GString::from("IDLE: Ready for next command."));
                    if let Ok(mut ssxl_signals_instance) = signals.clone().try_cast::<SSXLSignals>() {
                        ssxl_signals_instance.bind_mut().emit_build_map_complete();
                    }
                }
                GenerationMessage::Error(e) => {
                    godot_error!("Generation Task Error: {}", e);
                    status_update = Some(GString::from(format!("ERROR: {}", e).as_str()));
                }
            }
        }

        // FIX E0502: Mutably borrow self here, after the immutable borrow of self.signals_node has ended.
        if let Some(status) = status_update {
            self.emit_status_updated(status);
        }
    }

    /// Main engine tick method, called by SSXLOracle.
    #[func]
    pub fn tick(&mut self, current_tick: u64) {
        godot_print!("SSXLEngine: Received tick #{}", current_tick);

        // FIX E0499: Take ownership of the receiver to avoid a mutable borrow of self 
        // that conflicts with the mutable borrow in self.handle_generation_update().
        if let Some(mut receiver) = self.generation_receiver.take() {
            let mut messages = Vec::new();
            let mut disconnected = false;

            // Use a non-blocking loop to drain the channel quickly
            loop {
                match receiver.try_recv() {
                    Ok(message) => {
                        // Store the message for processing later
                        messages.push(message); 
                    }
                    Err(mpsc::error::TryRecvError::Empty) => {
                        // Channel is empty, done for this tick.
                        break;
                    }
                    Err(mpsc::error::TryRecvError::Disconnected) => {
                        // All senders have dropped (task finished or crashed).
                        godot_error!("Generation channel disconnected.");
                        disconnected = true;
                        break;
                    }
                }
            }

            // Process messages here, now that the mutable borrow from the receiver is released.
            for message in messages {
                self.handle_generation_update(message);
            }
            
            // Put the receiver back ONLY if it wasn't disconnected.
            if !disconnected {
                self.generation_receiver = Some(receiver);
            }
        }
    }
    
    // Helper to initialize conductor lazily with logging
    fn ensure_conductor(&mut self) -> bool {
        if self.conductor.is_some() {
            return true;
        }

        // --- FIX APPLIED HERE ---
        // Changed godot_error! to godot_print! to stop this message from appearing as an error (E) in Godot.
        godot_print!("--- Initializing Conductor lazily ---");
        
        // PHASE 8.4: Update to handle the new return tuple: (Conductor, State, Receiver)
        match Conductor::new(None) {
            Ok((conductor_instance, _state, progress_receiver)) => {
                info!("SSXL Conductor initialized successfully.");
                self.conductor = Some(Arc::new(Mutex::new(conductor_instance)));
                self.generation_receiver = Some(progress_receiver); // Store the receiver
                true
            }
            Err(e) => {
                godot_error!("SSXL Conductor failed to initialize: REASON: {:?}", e);
                false
            }
        }
    }

    // --- NODE SETTERS (Required by control_panel.gd) ---

    /// Sets the reference to the SSXLSignals node for emitting core events.
    #[func]
    pub fn set_signals_node(&mut self, signals_node: Gd<Node>) {
        self.signals_node = Some(signals_node);
        info!("SSXLEngine: Signals Node reference set.");
    }
    
    /// Sets the reference to the main expansive TileMap for visual updates.
    #[func]
    pub fn set_tilemap(&mut self, tilemap_node: Gd<TileMap>) {
        self.tilemap_node = Some(tilemap_node);
        info!("SSXLEngine: TileMap Node reference set.");
    }
    
    // --- CORE GENERATION & PIPELINE (Phase 8.3 Implementation) ---

    /// Implements Phase 8.3: Triggers the core map generation pipeline in the Conductor.
    #[func]
    pub fn build_map(&mut self, width: i32, height: i32, seed: GString, generator_name: GString) {
        // --- 1. Validation and Initialization ---
        if !self.ensure_conductor() {
            return;
        }

        // Clone the Arc before locking to satisfy the borrow checker (E0502 fix from prior step).
        let conductor_arc = self.conductor.as_ref().unwrap().clone();

        // Prepare the configuration object
        let config = GeneratorConfig {
            width: width as usize,
            height: height as usize,
            seed: seed.to_string(),
            generator_name: generator_name.to_string(),
        };
        
        // --- 2. Conductor Command and Error Handling ---
        let result = match conductor_arc.lock() {
            Ok(mut conductor) => {
                // Call the conductor's start generation method.
                match conductor.start_generation(config) {
                    Ok(_) => {
                        info!("SSXLEngine: Conductor command accepted: START GENERATION.");
                        Ok(())
                    }
                    Err(e) => {
                        godot_error!("Conductor failed to start generation: REASON: {:?}", e);
                        Err("ERROR: Generation Command Failed")
                    }
                }
            }
            // Gracefully handle Mutex Poisoning
            Err(e) => {
                godot_error!("CRITICAL: Mutex lock failed during build_map command: {:?}", e);
                Err("ERROR: Engine Lock Failure")
            }
        };

        // --- 3. Status & Signals (Moved outside the lock block to avoid E0502) ---
        match result {
            Ok(_) => {
                self.emit_status_updated(GString::from("GENERATING"));

                if let Some(signals) = &self.signals_node {
                    if let Ok(mut ssxl_signals_instance) = signals.clone().try_cast::<SSXLSignals>() {
                        // Emit the build_map_start signal to trigger Godot-side UI/flow logic.
                        ssxl_signals_instance.bind_mut().emit_build_map_start();
                    } else {
                        godot_error!("Signal Emission Failed: Signals Node reference is not of type SSXLSignals.");
                    }
                } else {
                    godot_error!("Signal Emission Failed: SSXLSignals node reference not set.");
                }
            }
            Err(status_msg) => {
                self.emit_status_updated(GString::from(status_msg));
            }
        }
    }


    /// Returns the generated chunk data as a Godot Dictionary,
	/// satisfying the GDScript validation expectations.
	#[func]
    // FIX: Changed to `&mut self` to allow lazy initialization via `ensure_conductor`.
	pub fn generate_chunk(&mut self, x: i32, y: i32, key_z: i32) -> Dictionary {
		let chunk_coords = Vec2i::new(x, y);
		let mut result_dict = Dictionary::new();

		// 1. FIX: Ensure Conductor is initialized, solving the FFI test failure.
		if !self.ensure_conductor() { 
			godot_error!("Cannot generate chunk: Conductor not initialized.");
			return result_dict;
		}

		let conductor_arc = self.conductor.as_ref().unwrap();

		// 2. Lock the Mutex to access the Conductor's data
		match conductor_arc.lock() {
			Ok(conductor) => {
				// Log for debugging purposes
				godot_print!("Godot: Calling core generate_single_chunk for {:?}", chunk_coords);
        
				// NOTE: This is a synchronous call to retrieve data.
				let chunk_data = conductor.generate_single_chunk(chunk_coords);

				// --- DATA CONVERSION: Rust `ChunkData` to Godot `Dictionary` ---
				let mut tile_array = Array::new();

				for tile in chunk_data.tiles {
					let mut tile_dict = Dictionary::new();

					// Assumed fields for TileData struct
					tile_dict.set("id", Variant::from(tile.tile_type as i32));
					tile_dict.set("level", Variant::from(tile.noise_value));

					// Safely push complex data
					tile_array.push(&tile_dict.to_variant());
				}

				// Populate the result dictionary
				result_dict.set("key_x", Variant::from(x));
				result_dict.set("key_y", Variant::from(y));
				result_dict.set("key_z", Variant::from(key_z));
				result_dict.set("tile_count", Variant::from(tile_array.len() as i32));
				result_dict.set("tiles", tile_array.to_variant());
			},
			Err(e) => {
				godot_error!("Mutex lock failed during chunk generation: {:?}", e);
			}
		}

		result_dict	
	}
    
    /// Sets the active generator algorithm by its string ID (e.g., "perlin_basic_2d").
    #[func]
    pub fn set_generator(&mut self, id: GString) -> bool {
        let id_str = id.to_string();

        if !self.ensure_conductor() {
            godot_error!("Cannot set generator: Conductor not initialized.");
            return false;
        }

        let conductor_arc = self.conductor.as_ref().unwrap();

        match conductor_arc.lock() {
            Ok(mut conductor) => {
                conductor.set_active_generator(&id_str).is_ok()
            },
            Err(e) => {
                godot_error!("Mutex lock failed during set_generator: {:?}", e);
                false
            }
        }
    }

    /// Returns the ID of the currently active generator.
    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        if self.conductor.is_none() {
            godot_error!("Cannot get active generator: Conductor not initialized.");
            return GString::from("ERROR: CONDUCTOR NOT INITIALIZED");
        }

        let conductor_arc = self.conductor.as_ref().unwrap();

        match conductor_arc.lock() {
            Ok(conductor) => GString::from(conductor.get_active_generator_id().as_str()),
            Err(_) => GString::from("ERROR: MUTEX POISONED"),
        }
    }

    // --- Destructor Replacement ---
    /// Expose a function for Godot to call on cleanup.
    #[func]
    pub fn shutdown_engine(&mut self) {
        info!("SSXLEngine: Shutting down.");

        // Clear the receiver, forcing a disconnection if the task is still running
        self.generation_receiver = None; 

        if let Some(conductor_arc) = self.conductor.take() {
            if let Ok(c) = Arc::try_unwrap(conductor_arc) {
                if let Ok(conductor) = c.into_inner() {
                    conductor.graceful_teardown();
                }
            } else {
                godot_error!("SSXLEngine: Cannot fully shutdown Conductor; other references still exist. This is usually okay if other systems hold a shared reference, but it might indicate a leak if unintended.");
            }
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_actions.rs (270 LOC)
//////////////////////////////////////////////////////

//! Core action implementations for the SSXL Dev Console CLI menu.

use std::process::Command;
use tracing::{info, warn, error};

// NEW IMPORTS for Signal Inspector / Concurrency
use std::sync::{Arc, Mutex, atomic::{AtomicBool, Ordering}};
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use ctrlc;
use std::env;

// PHASE 2 TRANSITION: Import the Conductor types
use ssxl_generate::conductor::{Conductor, ConductorStatus};

// --- CONSTANTS ---
// FIX: Consolidate path constants for re-use in multiple launch functions
const GODOT_EXE_PATH: &str = "./godot.windows.editor.x86_64.exe";
const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../ssxl_engine_tester";
const GODOT_TEST_SCENE: &str = "res://test_scene/test_ffi_data.tscn";


// --- CORE CLI ACTIONS ---

/// 🚀 Runs the full Rust test suite via Cargo
pub fn run_cargo_tests() {
	println!("🚀 Running full cargo test suite...");

	let status = Command::new("cargo")
		.args(&["test", "--", "--nocapture"])
		.status()
		.expect("Failed to run cargo test");

	if status.success() {
		info!("✅ All tests passed.");
	} else {
		error!("❌ Some tests failed.");
	}
}

/// Helper to calculate the absolute path to the Godot project tester directory.
fn get_godot_project_abs_path() -> Result<String, String> {
    let mut current_dir = env::current_dir()
        .map_err(|e| format!("Failed to determine CWD: {}", e))?;

    current_dir.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    current_dir.canonicalize()
        .map(|p| p.to_string_lossy().to_string())
        .map_err(|e| format!("Cannot resolve project path fragment '{}': {}. Does the directory exist?", RELATIVE_PROJECT_PATH_FRAGMENT, e))
}

// -----------------------------------------------------------------------------
// PHASE 8: NON-HEADLESS CLIENT LAUNCH (UPDATED)
// -----------------------------------------------------------------------------

/// 🚀 Launches the full **Godot Editor** (non-headless) with the project loaded.
/// This is the Phase 8 validation goal for debugging the main scene structure.
pub fn launch_godot_client() {
    info!("🚀 LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs);

    // Launch the Godot process with the --editor flag
    match Command::new(GODOT_EXE_PATH)
        .arg("--editor") // <--- 🔥 CRITICAL FIX: Forces the launch of the Godot Editor UI
        .arg("--path")
        .arg(&project_path_abs)
        .spawn() // Use spawn() for non-blocking launch
    {
        Ok(_) => {
            info!("✅ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is in the current directory: {}", GODOT_EXE_PATH);
        }
    }
}


/// 🎮 Placeholder to launch headless Godot
pub fn launch_headless_godot() {
	warn!("🎮 Placeholder: Attempting to launch headless Godot (simple path check)...");
	
	// Simplified status check for the placeholder
	match Command::new(GODOT_EXE_PATH).arg("--version").status() {
		Ok(status) if status.success() => info!("🚀 Headless Godot launch command ready (path check OK)."),
		_ => error!("❌ Godot executable not found or command failed. Check path: {}", GODOT_EXE_PATH),
	}
}

// -----------------------------------------------------------------------------
// PHASE 7: FFI BRIDGE VALIDATION (E2E FINAL)
// -----------------------------------------------------------------------------

/// 🔥 Runs an end-to-end test of the FFI bridge by launching Godot headless
/// to load the dedicated GDExtension test scene and validate data transfer.
pub fn run_ffi_bridge_validation() {
    info!("🔥 STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    info!("Launching Godot (Headless) from: {}", GODOT_EXE_PATH);
    info!("Running test scene: {} in project (Absolute Path): {}", GODOT_TEST_SCENE, project_path_abs);

    // --- 3. Launch Godot Headless to Execute the GDExtension Test ---
    let godot_command = Command::new(GODOT_EXE_PATH)
        .arg("--headless") // Run without a GUI
        .arg("--path")
        .arg(&project_path_abs) // Pass the calculated absolute path
        .arg("--scene")
        .arg(GODOT_TEST_SCENE)
        .output();

    // --- 4. Process the Output ---
    match godot_command {
        Ok(output) => {
            // Print the standard output from the Godot process
            println!("\n--- GODOT TEST OUTPUT START ---");
            println!("{}", String::from_utf8_lossy(&output.stdout));
            println!("--- GODOT TEST OUTPUT END ---\n");

            if output.status.success() {
                info!("✅ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
            } else {
                error!("❌ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}", output.status.code());
                eprintln!("--- GODOT ERROR OUTPUT ---");
                eprintln!("{}", String::from_utf8_lossy(&output.stderr));
            }
        },
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is in the current directory: {}", GODOT_EXE_PATH);
        }
    }
}

// -----------------------------------------------------------------------------
// PHASE 1: FOUNDATION VALIDATION
// -----------------------------------------------------------------------------

/// Runs only the unit tests defined in the Phase 1 Foundation Layer packages.
pub fn run_priority_1_tests() {
	info!("Running Phase 1 Foundation Layer (P1) test suite...");

	// Target packages: aetherion_shared, aetherion_math, aetherion_sync
	let result = Command::new("cargo")
		.arg("test")
		.arg("--package")
		.arg("ssxl_shared")
		.arg("--package")
		.arg("ssxl_math")
		.arg("--package")
		.arg("ssxl_sync")
		.arg("--all-targets")
		.status();

	match result {
		Ok(status) if status.success() => {
			info!("✅ Phase 1 Validation Complete: All foundation tests passed successfully.");
		}
		_ => {
			error!("❌ Phase 1 Validation Failed. Check the errors above.");
		}
	}
}

// -----------------------------------------------------------------------------
// PHASE 4: SIGNAL INSPECTOR / LIVE FEED
// -----------------------------------------------------------------------------

/// 🔮 Starts the live **Signal Inspector** utility (CLI Menu [B]).
///
/// This function initializes the **Conductor** and begins a real-time inspection loop
/// using the shared `ConductorState`.
pub fn start_signal_inspector() {
    warn!("🔮 Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // 1. Initialize Conductor and retrieve the thread-safe state
    // FIX: Update destructuring to handle the new 3-element tuple returned by Conductor::new(None)
    let (conductor, state, _receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    // Wrap Conductor in Arc<Mutex<Option<>>> for safe, single consumption by the ctrlc handler.
    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    // 2. Setup atomic flag for graceful exit via Ctrl-C
    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    // Set a Ctrl-C handler to stop the loop and shut down the Conductor
    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        // Atomically take the Conductor out of the Mutex and shut it down once.
        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    // 3. Main Live Feed Loop
    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        // --- REAL-TIME DATA POLLING ---
        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        // Use carriage return (`\r`) to overwrite the current line.
        print!("\r");
        print!("🔮 LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        // Check for internal shutdown signals (e.g., error in Conductor)
        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        // Wait 50ms (20 FPS refresh)
        thread::sleep(Duration::from_millis(50));
    }

    // 4. Cleanup: Clear the line after exiting the loop
    let _ = writeln!(io::stdout(), "\r{: <200}", " "); // Overwrite and clear the line
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_loc_scan.rs (215 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/cli_util_loc_scan.rs

use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{info, warn, error};

// --- CONFIGURATION ---
// USER-SPECIFIED PATH: Retained as per your last request.
const ROOT_DIR: &str = "../rust/";
const OUTPUT_FILENAME_PREFIX: &str = "ssxl_loc_report_";
// FIXED: Output directory is now consistent with ROOT_DIR (one level up from CWD).
const OUTPUT_DIR: &str = "../loc_reports/";

/// 📐 Represents the LOC result for a single file.
struct FileLoc {
    path: PathBuf,
    loc: usize,
}

/// Helper function to generate a simple epoch seconds string for the filename.
fn get_timestamp_string() -> String {
    let now = SystemTime::now();
    let since_the_epoch = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    format!("{}", since_the_epoch.as_secs())
}


/// Recursively scans the target directory for all files matching the given extension
/// and calculates their Lines of Code (LOC).
fn recursive_loc_scan(path: &PathBuf, extension: &str, results: &mut Vec<FileLoc>) -> io::Result<()> {
    if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                // Fixed: Direct usage of path.file_name().map_or to avoid E0382 move error.
                
                // Skip the build output directory (target/)
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "target") {
                    warn!("LOC Scanner skipping build output directory: {}", path.display());
                    continue; // This stops recursion into the 'target' directory
                }
                
                // Skip the temporary/obsolete directory 'iteration5'
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "iteration5") {
                    warn!("LOC Scanner skipping obsolete directory: {}", path.display());
                    continue;
                }

                recursive_loc_scan(&path, extension, results)?;
            } else if path.extension().map_or(false, |ext| ext == extension) {
                // Only process files with the specified extension (e.g., "rs")
                match fs::read_to_string(&path) {
                    Ok(content) => {
                        let loc = content.lines().count();
                        results.push(FileLoc { path, loc });
                    }
                    Err(e) => {
                        error!("Failed to read file {}: {}", path.display(), e);
                    }
                }
            }
        }
    }
    Ok(())
}

/// Executes the full LOC scan, prints the summary, and writes the detailed report.
pub fn execute_loc_scan() {
    info!("LOC Scanner: Starting recursive scan for Rust files in {}", ROOT_DIR);
    
    let root_path = PathBuf::from(ROOT_DIR);
    if !root_path.exists() {
        error!("LOC Scanner failed: Root directory not found at {}", root_path.display());
        return;
    }

    let mut loc_results = Vec::new();
    let scan_start = SystemTime::now();

    match recursive_loc_scan(&root_path, "rs", &mut loc_results) {
        Ok(_) => {
            let scan_duration = scan_start.elapsed()
                                          .map_or("N/A".to_string(), |d| format!("{:.2}ms", d.as_millis() as f32));

            let total_loc: usize = loc_results.iter().map(|f| f.loc).sum();
            let file_count = loc_results.len();

            // --- Generate Output File ---
            let timestamp_str = get_timestamp_string();
            let output_filename = format!("{}{}.txt", OUTPUT_FILENAME_PREFIX, timestamp_str);
            let output_path = PathBuf::from(OUTPUT_DIR).join(&output_filename);

            // Ensure output directory exists
            if let Err(e) = fs::create_dir_all(PathBuf::from(OUTPUT_DIR)) {
                error!("Failed to create output directory {}: {}", OUTPUT_DIR, e);
                return;
            }

            match fs::File::create(&output_path) {
                Ok(mut file) => {
                    // Write File Details (sorted by LOC descending) - this is done before header 
                    // only to ensure the results are sorted for both the table and the dump.
                    loc_results.sort_unstable_by(|a, b| b.loc.cmp(&a.loc));
                    
                    // 1. Write Header
                    let header = format!(
                        "SSXL-ext Codebase LOC Report\n\
                        Generated (Epoch Seconds): {}\n\
                        Root Directory: {}\n\
                        Scan Time: {}\n\
                        Total Files Scanned: {}\n\
                        Total Lines of Code (LOC): {}\n\n\
                        ------------------------------------------------------\n\
                        {:>5} LOC | Relative File Path\n\
                        ------------------------------------------------------\n",
                        timestamp_str,
                        ROOT_DIR,
                        scan_duration,
                        file_count,
                        total_loc,
                        "FILE"
                    );
                    if file.write_all(header.as_bytes()).is_err() {
                        error!("Failed to write header to LOC report.");
                        return;
                    }

                    // 2. Write Summary Table
                    for result in &loc_results {
                        // Attempt to strip the root prefix for cleaner output path
                        let path_str = result.path.strip_prefix(&root_path)
                                                   .unwrap_or(&result.path)
                                                   .display()
                                                   .to_string();
                        let line = format!("{:>5} LOC | {}\n", result.loc, path_str);
                        if file.write_all(line.as_bytes()).is_err() {
                            error!("Failed to write line for {} to LOC report.", path_str);
                            // Continue to next file on failure
                        }
                    }

                    // 3. Write Detailed Content Dump (The requested feature)
                    let content_header = format!(
                        "\n\n\n\n======================================================\n\
                         SSXL-ext Codebase DETAILED CONTENT DUMP\n\
                         ======================================================\n"
                    );
                    if file.write_all(content_header.as_bytes()).is_err() {
                        error!("Failed to write content dump header.");
                        return;
                    }

                    for result in &loc_results {
                        let path_str = result.path.strip_prefix(&root_path)
                                                   .unwrap_or(&result.path)
                                                   .display()
                                                   .to_string();
                        
                        let file_separator = format!(
                            "\n\n\n//////////////////////////////////////////////////////\n\
                             // FILE: {} ({} LOC)\n\
                             //////////////////////////////////////////////////////\n\n",
                            path_str,
                            result.loc
                        );

                        // Write file separator header
                        if file.write_all(file_separator.as_bytes()).is_err() {
                            error!("Failed to write content separator for {}.", path_str);
                            continue;
                        }

                        // Read and write the entire file content
                        match fs::read_to_string(&result.path) {
                            Ok(content) => {
                                if file.write_all(content.as_bytes()).is_err() {
                                    error!("Failed to write content for {}.", path_str);
                                }
                            }
                            Err(e) => {
                                let error_message = format!("\n[ ERROR: FAILED TO READ FILE CONTENT: {} ]\n", e);
                                if file.write_all(error_message.as_bytes()).is_err() {
                                    error!("Failed to write error message for {}.", path_str);
                                }
                            }
                        }
                    }
                    
                    // Final Footer
                    if file.write_all(b"\n\n======================================================\nEND OF REPORT\n======================================================\n").is_err() {
                        error!("Failed to write report footer.");
                    }

                    info!("LOC Report: Successfully created report file: {}", output_path.display());

                    // Print summary to console
                    println!("\n[ LOC Scan Complete ]");
                    println!("Total Rust Files: {}", file_count);
                    println!("Total Lines of Code: {}", total_loc);
                    println!("Report saved to: {}", output_path.display());
                }
                Err(e) => {
                    error!("Failed to create LOC report file {}: {}", output_path.display(), e);
                }
            }
        }
        Err(e) => {
            error!("LOC Scanner: Recursive scan failed: {}", e);
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_bench.rs (199 LOC)
//////////////////////////////////////////////////////

//! Utilities for running generation benchmarks and conversion tests.

use tracing::{info, warn, error};
use std::time::Instant;
// NEW IMPORTS for Concurrency and Live Ticker
use std::thread;
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};
use std::io::{self, Write};
use std::time::Duration;

// --- EXTERNAL CRATE DEPENDENCIES ---
use ssxl_generate::benchmark_generation_workload; 
use ssxl_generate::conductor::Conductor; // Import Conductor
use ssxl_math::Vec2i; // Import Vec2i for chunk coordinates

// --- Test Utilities ---

/// 🧪 CLI-safe test: Initializes the Conductor, switches generators, and generates
/// a small set of chunks to validate the core pipeline.
pub fn test_generation_and_placement_cli() {
    warn!("🧪 Running CLI Test: Generation and Placement (Conductor Validation)...");

    // 1. Initialize Conductor and retrieve state
    // FIX: Update destructuring to handle the new 3-element tuple (Conductor, ConductorState, Receiver).
    let (mut conductor, _state, _receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    // --- 2. Test Perlin Generator ---
    let perlin_id = "perlin_mvg"; 
    if conductor.set_active_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            // FIX: Renamed 'chunk' to '_chunk' to suppress the unused variable warning.
            let _chunk = conductor.generate_single_chunk(coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            // In a real scenario, we would assert properties of '_chunk' here.
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    // --- 3. Test Cellular Automata Generator ---
    let ca_id = "cellular_automata_basic"; 
    if conductor.set_active_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        // FIX: Renamed 'chunk' to '_chunk' to suppress the unused variable warning.
        let _chunk = conductor.generate_single_chunk(coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    // --- 4. Report and Shutdown ---
    if chunks_generated > 0 {
        info!("✅ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).", 
            chunks_generated, 
            conductor.get_active_generator_id() // Reports the last active ID
        );
    } else {
        error!("❌ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    // FIX: Use the renamed, consuming shutdown method.
    conductor.graceful_teardown();
}

// --- Conversion Utilities ---

/// 🧪 Converts a PNG into a tile chunk using bitmask logic (Placeholder).
pub fn run_bitmask_conversion() {
    warn!("🧪 Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("✅ Conversion complete. Tiles placed: {}", tiles_placed);
}

// --- Benchmark Utilities ---

/// 🧪 Benchmarks tile placement throughput.
///
/// Executes a fixed workload concurrently with a live progress ticker.
pub fn run_max_grid_benchmark() {
    warn!("🧪 Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000; 

    // --- 1. SETUP SHARED ATOMIC STATE ---
    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    // --- 2. START THE WORKLOAD (GENERATION) THREAD ---
    // NOTE: Conductor::new() is called inside benchmark_generation_workload 
    // and is assumed to be fixed there (to pass None).
    let workload_handle = thread::spawn(move || {
        // NOTE: The function signature in aetherion_generate now includes the counter.
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone); 
    });

    // --- 3. START THE TICKER (CLI REPORTING) THREAD ---
    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            // Load the current progress atomically
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            // Calculate live throughput
            let throughput = if elapsed > 0.0 { 
                (current as f64 / elapsed).round() as u64 
            } else { 
                0 
            };

            // Use \r to reset the cursor to the start of the line for a live update
            print!("\r⏳ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s", 
                percentage, 
                current / 1_000_000, // Display in Millions
                WORKLOAD_TILES / 1_000_000, // Display Total in Millions
                throughput
            );
            // Ensure the output is immediately visible
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            // Poll progress every 50ms
            thread::sleep(Duration::from_millis(50));
        }
    });

    // --- 4. WAIT FOR WORKLOAD AND MEASURE TIME ---
    let start = Instant::now();
    
    // Block until the generation work is finished
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        // Clean the line and exit
        let _ = println!("\r❌ Benchmark failed: Generation thread panic. {: <100}", " "); 
        return; 
    }
    
    // Ensure the ticker thread prints 100% and finishes its loop
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64; 
    let actual_tiles_placed = WORKLOAD_TILES;
    
    // Clear the progress line before printing final results
    println!("\r✅ Benchmark complete. Workload: {} tiles. Duration: {:.2}s", 
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        // --- Outputting Max Possible Throughput ---
        println!("⚡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("⚡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        // --- Performance Analysis ---
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("🚀 CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("📈 Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("⚠️ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector [B] to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("❌ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\cellular_automata_generator.rs (179 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/cellular_automata_generator.rs

use crate::Generator; 
use ssxl_math::{
    Vec2i,
    generation_utils::fast_rand,
};
use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    grid_bounds::GridBounds,
    tile_data::TileData,
    tile_type::TileType,
};
use tracing::{info, warn};

// --- CONSTANTS ---
const CA_ITERATIONS: u8 = 4;
const INITIAL_FILL_PERCENT: u8 = 45; // 45% of tiles start as 'Rock'

// --- RULESET DEFINITIONS ---
pub const RULE_BASIC_CAVE: u8 = 0; // Current rules: Generates large, open cave systems.
pub const RULE_MAZE: u8 = 1;       // New rules: Generates thin, winding maze/pillar structures.


/// ⚙️ Implements a 2D Cellular Automata (CA) generator for pattern-based terrain.
#[allow(dead_code)]
pub struct CellularAutomataGenerator {
    /// The ID of the CA ruleset to use (e.g., 0 for Cave, 1 for Maze).
    ruleset: u8,
}

impl CellularAutomataGenerator {
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// --- CORE GENERATION LOGIC ---

/// Determines the next tile type based on the current type, live neighbors, and the active ruleset.
fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    // NOTE: We only handle Rock/Void transitions here.
    
    // Define Birth (B) and Survival (S) conditions based on the ruleset
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4), // B3/S1234: Cells need exactly 3 neighbors to be born, and survive if they have 1 to 4 neighbors.
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // B45/S1234567: High birth rate (4 or 5) and high survival (1-7) for open caves.
    };
    
    match current_type {
        TileType::Rock => {
            // Survival Rule
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        TileType::Void => {
            // Birth Rule
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        // Preserve any other tile types (e.g., Water, Grass) that might be introduced later.
        _ => current_type,
    }
}

/// Applies one step of the Cellular Automata rule to the chunk grid.
fn apply_ca_step(chunk_data: &mut ChunkData, ruleset: u8) {
    let mut new_tiles: Vec<TileData> = chunk_data.tiles.iter().cloned().collect();

    for x in 0..CHUNK_SIZE {
        for y in 0..CHUNK_SIZE {
            let index = (y * CHUNK_SIZE + x) as usize;
            let current_tile = &chunk_data.tiles[index];
            let live_neighbors = count_live_neighbors(chunk_data, x, y);

            let new_type = get_next_tile_type(
                current_tile.tile_type, 
                live_neighbors, 
                ruleset
            );
            
            // Retain existing noise value (no change during CA smoothing)
            new_tiles[index] = TileData::new(new_type, current_tile.noise_value);
        }
    }
    chunk_data.insert_tiles(new_tiles);
}

/// Counts the number of 'live' (TileType::Rock) neighbors for a given coordinate (Moore neighborhood).
fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;
    
    for dx in -1..=1 {
        for dy in -1..=1 {
            if dx == 0 && dy == 0 {
                continue;
            }

            let nx = cx as i32 + dx;
            let ny = cy as i32 + dy;

            // Check if neighbor is within chunk bounds
            if nx >= 0 && nx < CHUNK_SIZE as i32 && ny >= 0 && ny < CHUNK_SIZE as i32 {
                let index = (ny as u32 * CHUNK_SIZE + nx as u32) as usize;
                
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}

// --- TRAIT IMPLEMENTATION ---

impl Generator for CellularAutomataGenerator {
    fn id(&self) -> &str {
        match self.ruleset {
            RULE_MAZE => "cellular_automata_maze",
            RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // --- 1. CHUNK METADATA INITIALIZATION ---
        let chunk_tile_size = CHUNK_SIZE as i32;

        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x as i64,
            world_start_y as i64,
            (world_start_x + chunk_tile_size) as i64,
            (world_start_y + chunk_tile_size) as i64,
        );

        let dimension_name = self.id().to_string(); // Use the ID as the dimension name

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // --- 2. INITIAL RANDOM FILL (Seed) ---
        let mut tiles = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);
        
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            // fast_rand(N) returns 0 if a random number 0..=99 is < N
            let is_rock = fast_rand(INITIAL_FILL_PERCENT) == 0; 

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            tiles.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles);

        // --- 3. APPLY CA ITERATIONS ---
        for i in 0..CA_ITERATIONS {
            // Pass the active ruleset ID
            apply_ca_step(&mut chunk_data, self.ruleset); 
            info!("CA Generator: Iteration {} complete.", i + 1);
        }

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        chunk_data
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_inspect.rs (162 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/cli_util_inspect.rs (Final, Cleaned Code)

//! Inspection utilities for diagnostics and developer introspection.

use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration; 

// --- Module Tree Inspection ---

/// 📦 Prints a tree of Rust modules across all workspace crates.
/// NOTE: This assumes the CLI is executed from the 'rust/' directory.
pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| 🌲 RUST WORKSPACE MODULE TREE (Scanning...)                           |");
	println!("=========================================================================");
	
	// Assuming execution from the workspace root (e.g., 'rust/')
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n🔍 Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                // Core files are highlighted
                                "├── [CORE] "
                            } else {
                                "│   └── "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


// --- API Inspection ---

/// 🧪 Scans for GDScript-callable Rust methods exposed via #[func]
/// NOTE: This assumes the CLI is executed from the 'rust/' directory.
pub fn print_godot_api_surface() {
    // FIX: Define an array of all known Godot API files.
	let godot_api_files: [&str; 3] = [
        "ssxl_godot/src/ssxl_engine.rs",
        "ssxl_godot/src/ssxl_oracle.rs", // Assuming this is where oracle functions live
        "ssxl_godot/src/ssxl_signals.rs",
    ];

    println!("🧪 API scan triggered (targeting {} files in ssxl_godot/src/)...", godot_api_files.len());
    
    // Regex to find the function signature line that follows #[func].
    // Captures: 1=method_name, 2=arguments, 3=return_type
    let fn_signature_regex = Regex::new(
        r"^\s*pub\s+fn\s+(\w+)\s*(\([^\{]*)\s*(?:->\s*([^\{]*))?\s*\{"
    ).unwrap();

    // Regex to find the #[func] marker line.
    let func_marker_regex = Regex::new(r"^\s*#\[func\]\s*$").unwrap();

    // Store API methods with source file name
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();

    // Iterate over all target files
    for file_path_str in godot_api_files.iter() {
        // FIX: The following variables are correctly scoped to the loop iteration.
        let godot_lib_path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        let mut func_line_pending = false;

        match fs::read_to_string(godot_lib_path) {
            Ok(contents) => {
                info!("Successfully read {}", godot_lib_path.display());
                
                for line in contents.lines() {
                    // 1. Check for the #[func] marker
                    if func_marker_regex.is_match(line) {
                        func_line_pending = true;
                        continue;
                    }

                    // 2. If marker was found, check for the function signature
                    if func_line_pending {
                        if let Some(captures) = fn_signature_regex.captures(line) {
                            
                            let method_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                            
                            // Argument capture: remove surrounding parentheses and trim whitespace
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            // Return type capture: trim whitespace, default to "()"
                            let return_type = captures.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                            
                            // Store the method along with its source file name
                            api_methods.push((method_name, args, return_type, file_name.to_string()));
                            
                            func_line_pending = false;
                        } else if !line.trim().is_empty() {
                            func_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                // FIX: Use `file_path_str` here to report the error correctly.
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- 🎮 SSXL Engine Godot API Surface ---");
    if api_methods.is_empty() {
        warn!("No #[func] methods found in the targeted ssxl_godot API files. Is the Godot binding active?");
    } else {
        println!("Registered {} callable methods:", api_methods.len());
        for (name, args, return_type, source_file) in &api_methods {
            // Display as: MethodName(arguments) -> ReturnType [SourceFile]
            println!("  ✅ func {}({}) -> {} [{}]", name, args, return_type, source_file);
        }
    }
	println!("-------------------------------------------\n");

    info!("API scan complete: {} methods detected.", api_methods.len());
    thread::sleep(Duration::from_secs(2));
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\chunk_data.rs (146 LOC)
//////////////////////////////////////////////////////

// aetherion_shared/src/chunk_data.rs
//! Canonical data structure for a single, dimension-agnostic chunk of procedural data.

use serde::{Serialize, Deserialize};
use std::time::SystemTime;

// Import types from other modules in aetherion_shared
use crate::grid_bounds::GridBounds;
use crate::tile_data::TileData; 
use crate::math_primitives; // Used for the SystemTime serde helper

// Import Vec2i from the dedicated aetherion_math crate (External Dependency)
use ssxl_math::Vec2i; 

use serde_big_array::BigArray;

// --- CONSTANTS ---

/// The canonical size for all chunks in the Aetherion Engine (32x32 tiles).
pub const CHUNK_SIZE: u32 = 32;
/// The total number of tiles in a single chunk (32 * 32 = 1024).
const TILE_COUNT: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize; 

// --- STRUCT DEFINITION ---
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub struct ChunkData {
    pub id: u64,
    pub bounds: GridBounds,
    /// The fixed-size array containing all tile data. `BigArray` is used for efficient
    /// serialization of the large array.
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_COUNT],
    pub dimension_tag: String,
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}

// --- IMPLEMENTATION ---

impl ChunkData {
    pub const SIZE: u32 = CHUNK_SIZE;

    /// Creates a new, empty ChunkData instance initialized with default data.
    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        let tiles = [TileData::default(); TILE_COUNT];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    /// Creates a new ChunkData instance using only the chunk coordinates.
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = CHUNK_SIZE as i64;
        
        // Convert chunk coordinates to world-space grid coordinates (i64 for GridBounds)
        let min_x = chunk_coords.x as i64 * chunk_size_i64;
        let min_y = chunk_coords.y as i64 * chunk_size_i64;
        let max_x = min_x + chunk_size_i64 - 1;
        let max_y = min_y + chunk_size_i64 - 1;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        // NOTE: In a final system, the ID should be derived via robust hashing.
        let id = chunk_coords.x as u64 ^ chunk_coords.y as u64; 
        let tiles = [TileData::default(); TILE_COUNT];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    /// Converts local (x, y) coordinates to a flattened array index.
    #[inline(always)]
    fn coord_to_index(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    /// Returns the data for a tile at the given local (x, y) coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    /// **CRITICAL FIX for CA Generator:** Replaces the chunk's fixed-size tile array with a new set of tiles.
    /// Used by generators (like Cellular Automata) that produce a `Vec<TileData>`.
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        if tiles_vec.len() == TILE_COUNT {
            // Efficiently copy the vector's contents into the fixed-size array
            self.tiles.clone_from_slice(&tiles_vec);
        } else {
            panic!(
                "Tile vector size mismatch for chunk {:?}: Expected {} but got {}", 
                self.bounds, 
                TILE_COUNT, 
                tiles_vec.len()
            );
        }
    }
    
    /// Returns a mutable reference to the tile data at the given local (x, y) coordinates.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Tests the coordinate flattening function for standard and edge cases.
    #[test]
    fn test_coord_to_index() {
        // Chunk size is 32 (CHUNK_SIZE)
        
        // 1. Basic check (0, 0)
        assert_eq!(ChunkData::coord_to_index(0, 0), Some(0));

        // 2. Middle point check
        // (Y=16 * SIZE=32) + X=16 = 512 + 16 = 528
        assert_eq!(ChunkData::coord_to_index(16, 16), Some(528));

        // 3. Max boundary check (31, 31)
        // (Y=31 * SIZE=32) + X=31 = 992 + 31 = 1023 (TILE_COUNT - 1)
        assert_eq!(ChunkData::coord_to_index(31, 31), Some(1023));

        // 4. Out-of-bounds check (size is 32, so 32 is out)
        assert_eq!(ChunkData::coord_to_index(32, 0), None);
        assert_eq!(ChunkData::coord_to_index(0, 32), None);
        assert_eq!(ChunkData::coord_to_index(33, 33), None);
    } // <-- Missing brace restored
} // <-- Missing brace restored


//////////////////////////////////////////////////////
// FILE: ssxl_sync\src\lib.rs (143 LOC)
//////////////////////////////////////////////////////

// ssxl_sync/src/lib.rs
//!
//! Provides the core synchronization and communication channels for the engine,
//! allowing data exchange between the main thread, Godot, and worker threads.

use crossbeam_channel::{unbounded, Receiver, Sender};
use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
// We use the tracing framework (configured in Cargo.toml) for logging.
use tracing::info;

// NOTE: We are using String as a temporary placeholder for the complex
// AetherionData struct, which will be defined later in the project.

// --- 1. Thread-Safe Resource Wrapper ---

/// A thread-safe wrapper for resources that allows multiple readers
/// or a single writer at any time.
#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    /// Creates a new AtomicResource instance.
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    /// Acquires a read lock on the resource.
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    /// Acquires a write lock on the resource.
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

// --- 2. Channel Utilities ---

/// Creates an unbounded crossbeam channel pair.
pub fn create_sync_channel() -> (Sender<String>, Receiver<String>) {
    unbounded()
}

/// Starts the main synchronization worker task.
pub fn start_sync_worker() {
    info!("SSXL Synchronization Worker placeholder started.");
}

// ---------------------------
// IMPL: Unit Tests (Phase 1 Validation)
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    // --- Channel Tests ---

    #[test]
    fn test_channel_functionality() {
        let (sender, receiver) = create_sync_channel();
        let test_message = "Test data for Phase 1 sync check".to_string();

        sender.send(test_message.clone()).expect("Failed to send test message");
        let received_message = receiver.recv().expect("Failed to receive test message");

        assert_eq!(received_message, test_message, "Received message did not match sent message.");
    }

    #[test]
    fn test_sync_worker_placeholder_runs() {
        start_sync_worker();
    }
    
    // --- AtomicResource Tests ---

    /// Tests that the AtomicResource correctly handles concurrent reads and a single write.
    /// FIX: Explicitly join reader threads to eliminate the race condition.
    #[test]
    fn test_concurrent_read_write() {
        let resource = AtomicResource::new(0);

        // 1. Concurrent Reads (Must all read 0)
        let mut handles = vec![];
        for _ in 0..5 {
            let res_clone = resource.clone();
            handles.push(thread::spawn(move || {
                let value = *res_clone.read();
                assert_eq!(value, 0);
            }));
        }

        // CRITICAL FIX: Wait for all initial readers to complete before allowing the writer to run.
        for h in handles {
            h.join().unwrap();
        }

        // 2. Single Write (Set to 42)
        let mut writer_guard = resource.write();
        *writer_guard = 42;
        drop(writer_guard); // Lock released

        // 3. New Concurrent Reads (Must all read 42)
        let mut handles = vec![];
        for _ in 0..5 {
            let res_clone = resource.clone();
            handles.push(thread::spawn(move || {
                let value = *res_clone.read();
                assert_eq!(value, 42); // Verify the change
            }));
        }
        
        // Wait for all subsequent reader threads to complete.
        for h in handles {
            h.join().unwrap();
        }
    }

    /// Tests basic read/write access without concurrency.
    #[test]
    fn test_basic_read_write() {
        let resource = AtomicResource::new(10);
        
        {
            let value = *resource.read();
            assert_eq!(value, 10);
        }
        
        {
            let mut writer = resource.write();
            *writer = 20;
        }

        assert_eq!(*resource.read(), 20, "Basic write failed.");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\coordinate_system.rs (130 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/coordinate_system.rs
//!
//! Defines the coordinate system types used throughout the engine and provides
//! conversion utilities between them.
//!
//! The Aetherion engine uses a chunked, tile-based world system.
//! - WorldPos: Global coordinate, precise to the tile (i32).
//! - ChunkKey: Identifier for the chunk the tile belongs to (i32).
//! - TileOffset: Local position of the tile within its chunk (u8).

use serde::{Serialize, Deserialize};
// FIX: Imported CHUNK_SIZE_I32, as the constant was renamed in math_primitives.rs
use crate::primitives::CHUNK_SIZE_I32;
use glam::IVec3;


// --- 1. Coordinate Types ---

/// A global coordinate precise to the tile level.
/// Used for physics, networking, and high-level queries.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub IVec3);

/// The key/identifier for a specific chunk in the world grid.
/// Used for data fetching, loading/unloading, and persistent storage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub IVec3);

/// The local coordinate of a tile *within* its chunk.
/// Used for array indexing and rendering offsets.
// We use IVec3 (i32) here for consistency, though components will be small (0 to CHUNK_SIZE-1)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub IVec3);


// --- 2. Coordinate Conversion Functions ---

impl WorldPos {
    /// Converts a global WorldPos into its corresponding ChunkKey and local TileOffset.
    ///
    /// The conversion uses the relationship:
    /// WorldPos = (ChunkKey * CHUNK_SIZE) + TileOffset
    ///
    /// This requires using the Euclidean remainder (`rem_euclid`) for the offset,
    /// and then deriving the ChunkKey via floor division to correctly handle negative coordinates.
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        
        // 1. Tile Offset calculation (uses Euclidean remainder, which is correct)
        let tile_x = self.0.x.rem_euclid(CHUNK_SIZE_I32);
        let tile_y = self.0.y.rem_euclid(CHUNK_SIZE_I32);
        let tile_z = self.0.z.rem_euclid(CHUNK_SIZE_I32);

        // 2. Chunk Key calculation (FIXED: Use Euclidean quotient derivation)
        // We calculate the quotient by solving: ChunkKey = (WorldPos - TileOffset) / CHUNK_SIZE_I32
        let chunk_x = (self.0.x - tile_x) / CHUNK_SIZE_I32;
        let chunk_y = (self.0.y - tile_y) / CHUNK_SIZE_I32;
        let chunk_z = (self.0.z - tile_z) / CHUNK_SIZE_I32;

        let chunk_key = ChunkKey(IVec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(IVec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

impl ChunkKey {
    /// Converts a ChunkKey and a local TileOffset back into a global WorldPos.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let world_x = self.0.x * CHUNK_SIZE_I32 + offset.0.x;
        let world_y = self.0.y * CHUNK_SIZE_I32 + offset.0.y;
        let world_z = self.0.z * CHUNK_SIZE_I32 + offset.0.z;

        WorldPos(IVec3::new(world_x, world_y, world_z))
    }
}

// ---------------------------
// IMPL: Unit Tests (Unchanged)
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::IVec3;
    // NOTE: CHUNK_SIZE_I32 is imported, let's assume it's 32 for test context.

    #[test]
    fn test_world_to_chunk_positive() {
        // Position (33, 10, 64) -> 1 chunk over, 10 offset, 2 chunks over, 0 offset
        let pos = WorldPos(IVec3::new(33, 10, 64));
        let (key, offset) = pos.to_chunk_coords();
        
        assert_eq!(key.0, IVec3::new(1, 0, 2), "ChunkKey should be (1, 0, 2)");
        assert_eq!(offset.0, IVec3::new(1, 10, 0), "TileOffset should be (1, 10, 0)");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        // Test 1: Position (-1, -1, -1) - The critical check for Euclidean remainder.
        let pos = WorldPos(IVec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        // Must correctly resolve to chunk key (-1, -1, -1)
        assert_eq!(key.0, IVec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        // Must correctly resolve to max offset (31, 31, 31)
        assert_eq!(offset.0, IVec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test 2: Deep inside the negative space
        let pos_deep = WorldPos(IVec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();
        
        // Expected Key: -2, -2, -4. Expected Offset: 31, 0, 28.
        assert_eq!(key_deep.0, IVec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, IVec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        let original_pos = WorldPos(IVec3::new(-123, 456, -789));
        
        // 1. Convert
        let (key, offset) = original_pos.to_chunk_coords();
        
        // 2. Convert back
        let final_pos = key.to_world_pos(offset);

        // 3. Verify
        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_tools\src\lib.rs (128 LOC)
//////////////////////////////////////////////////////

// ssxl_tools/src/lib.rs (Final, Corrected Code)

//! Core utilities for configuration, asset management, and data validation.

// Restored missing necessary imports
use once_cell::sync::Lazy;
use regex::Regex;
use tracing::{info, warn}; 
use std::io::{self, Read}; 
use std::fs::File; 

// --- CRATE DEPENDENCIES ---
use ssxl_shared::SSXLData; 

// --- CONFIGURATION CONSTANTS ---
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml"; 
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
const DEFAULT_CA_RULESET: u8 = 0; 

// -----------------------------------------------------------------------------
// SSXL CONFIGURATION UTILITIES (RESTORED DEFINITION)
// -----------------------------------------------------------------------------

/// 🔧 Stores all global, static configuration settings for the SSXL Engine.
// E0412 & E0433 Fix: SSXLConfig struct definition is now present.
pub struct SSXLConfig {
    default_generator_id: String,
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Private constructor to initialize config with defaults.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to load configuration from the specified path.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                file.read_to_string(&mut contents)?;

                // --- SIMULATED PARSING ---
                info!("SSXLConfig: File read successfully. Simulating config override.");
                // Return a simulated config that is NOT the default
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), 
                    ca_default_ruleset: 1, 
                })
            },
            Err(e) => {
                // Return the I/O error
                Err(e)
            }
        }
    }

    /// Accessor for the default generator ID.
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Accessor for the Cellular Automata default ruleset ID.
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Public function to load config, allowing the caller (Conductor) to specify the path.
pub fn get_config_from_path(path: Option<&str>) -> Result<SSXLConfig, io::Error> {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            Ok(config)
        },
        Err(e) => {
            // Log error and return defaults (Crucial for FFI stability)
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            Ok(SSXLConfig::new_with_defaults())
        }
    }
}

/// Provides thread-safe, static access to a configuration instance *initialized only with defaults*.
static CONFIG: Lazy<SSXLConfig> = Lazy::new(SSXLConfig::new_with_defaults);

/// DEPRECATED: Public function to retrieve a reference to the global configuration.
pub fn get_config() -> &'static SSXLConfig {
    warn!("DEPRECATED: Called `get_config()`. Use `get_config_from_path()` for correct FFI CWD handling.");
    &CONFIG
}

// -----------------------------------------------------------------------------
// DATA VALIDATION UTILITIES (RESTORED DEFINITION)
// -----------------------------------------------------------------------------

/// Provides a thread-safe, lazily initialized Regex instance for data ID validation.
// E0425 Fix: ID_REGEX static definition is now present.
static ID_REGEX: Lazy<Regex> = Lazy::new(|| {
    // Requires IDs to be numeric strings.
    Regex::new(r"^\d+$").expect("Failed to compile ID validation regex")
});

/// Validates the ID field of an AetherionData primitive against a standard regex pattern.
pub fn validate_data_id(data: &SSXLData) -> bool {
    // Assumes AetherionData::id is accessible and implements ToString (e.g., u64).
    ID_REGEX.is_match(&data.id.to_string())
}


// -----------------------------------------------------------------------------
// CRATE ENTRY
// -----------------------------------------------------------------------------

/// Initializes the `aetherion_tools` crate.
pub fn initialize() {
    // Force initialization of the static regex.
    let _ = &*ID_REGEX; 
    info!("SSXL Tools: Configuration and data validation utilities initialized.");
}


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\main.rs (116 LOC)
//////////////////////////////////////////////////////

// ssxl_cli/src/main.rs

// --- MODULES ---
// These files must be created in the ssxl_cli/src directory.
mod cli_util_actions;	// Contains the menu action functions (e.g., run_tests)
mod cli_util_inspect;	// Contains inspection functions (API surface, module tree)
mod cli_util_menu;		// Contains MenuItem struct, build_menu, and print_menu
mod cli_util_bench;		// Contains benchmark/conversion functions
mod cli_util_loc_scan;	// ADDED: Recursive LOC scanning utility (Space fixed here)

// --- EXTERNAL IMPORTS ---
use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

// Tracing imports are correct.
use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

// --- INTERNAL IMPORTS ---
use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // To be called once on startup
use crate::cli_util_loc_scan::execute_loc_scan; // ADDED: Import the LOC function


/// 🖐️ Optional pause after action
fn wait_for_enter() {
	println!("\nPress Enter to return to menu...");
	let _ = io::stdin().read_line(&mut String::new());
}

fn init_logging_and_engine() {
// ... (content of this function remains unchanged)
	// This sets up a simple console logger for the CLI environment.
	tracing_subscriber::registry()
		// Whitespace cleaned here
		.with(
			tracing_subscriber::fmt::layer()
				.with_writer(io::stdout) // Direct output to stdout
				.with_filter(LevelFilter::INFO),
		)
		.init();

	info!("SSXLBinary: Interactive CLI initializing.");

	// Call the FFI initialization (placeholder for engine boot)
	if ssxl_initialize_engine() {
		info!("Engine FFI core initialized.");
	} else {
		error!("Failed to initialize Engine FFI core.");
	}
}

fn main() {
	// 🧠 Startup
	init_logging_and_engine();
	
	// Execute LOC scan on startup and generate file
	execute_loc_scan(); // ADDED: Run the LOC scan at bootup

	println!(
    r#"
           (__)
           (oo)
    /-------\/
   / |     ||
  * ||-----||
    ~~    ~~
SSXL-ext Engine Console Initialized
"#
);

	// 🧭 Menu setup
	let menu = build_menu();
// ... (rest of main function remains unchanged)
	let mut last_keys = HashSet::new();

	// 🔁 Main loop
	loop {
		print_menu(&menu);
		info!("Console: Awaiting menu selection...");
		print!("> ");
		io::stdout().flush().unwrap();

		// Wait for keypress
		loop {
			if event::poll(Duration::from_millis(500)).unwrap() {
				if let Event::Key(key_event) = event::read().unwrap() {
					if let KeyCode::Char(c) = key_event.code {
						if last_keys.insert(c) {
							if let Some(item) = menu.iter().find(|m| m.key == c) {
								info!("Menu: Selected: {}", item.label);
								println!("\n[{}] {}\n", c, item.label);
								(item.action)();

								if c == '9' {
									info!("Exit: Engine shutdown complete.");
									return;
								}

								wait_for_enter();
								break;	
							}
						}
					}
				}
			} else {
				last_keys.clear();	// Space fixed here
			}

			thread::sleep(Duration::from_millis(10));
		}
	}
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\tile_data.rs (107 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/tile_data.rs
//! Defines the TileData structure: a compact, serializable unit holding all
//! generated and runtime data for a single tile in the world grid.
//!
//! Total size is 6 bytes (1 + 4 + 1), which is highly memory-efficient for bulk storage.

use super::tile_type::TileType;
use serde::{Serialize, Deserialize};

/// A compact structure holding the state of a single tile in the world.
///
/// This type is designed to be small, cheap to copy, and highly serializable for
/// use in the aetherion_cache.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The fundamental type of terrain/feature, determined by the MVG.
    /// This uses the u8 discriminant of the TileType enum.
    pub tile_type: TileType,
    
    /// The raw noise value V ∈ [0.0, 1.0] used to determine the `tile_type`.
    /// This serves as the primary elevation/metric field, combining the roles of 
    /// the previous `height_value` and potentially `aux_value` for simplicity.
    pub noise_value: f32, // 4 bytes
    
    /// An 8-bit field for general-purpose runtime flags (e.g., IsModified, IsTraversable).
    pub flags: u8, // 1 byte
}

impl Default for TileData {
    /// Provides a default, uninitialized state.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(), // Defaults to Void
            noise_value: 0.0,
            flags: 0,
        }
    }
}

// ---------------------------
// IMPL: Constructor, Flags Utility and Logic
// ---------------------------

/// Bitmask constants for the `flags` field
pub mod tile_flags { 
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001; // Bit 0: Is the tile physically passable?
    pub const IS_RENDERED:    u8 = 0b0000_0010; // Bit 1: Is the tile currently visible/rendered?
    pub const IS_MODIFIED:    u8 = 0b0000_0100; // Bit 2: Has this tile been manually changed post-generation?
    pub const HAS_RESOURCE:   u8 = 0b0000_1000; // Bit 3: Does this tile contain a gatherable resource?
    // Bits 4-7 are available for future logic.
}

impl TileData {
    /// Creates a new TileData instance with the generated type and noise value.
    /// This is the primary constructor used by the aetherion_generate MVG.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        // Initialize other fields to their defaults when constructed by the generator
        TileData {
            tile_type,
            noise_value,
            flags: 0, 
        }
    }

    /// Checks if the tile is considered solid or non-traversable (Air/Void).
    /// This relies on the `TileType`'s inherent logic for better consistency.
    pub const fn is_solid(&self) -> bool {
        !self.tile_type.is_empty()
    }

    /// Sets a specific bit flag by index (0-7).
    pub fn set_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            self.flags |= 1 << flag_index;
        }
    }

    /// Clears a specific bit flag by index (0-7).
    pub fn clear_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            self.flags &= !(1 << flag_index);
        }
    }

    /// Checks if a specific bit flag is set by index (0-7).
    pub fn check_flag_by_index(&self, flag_index: u8) -> bool {
        if flag_index < 8 {
            (self.flags & (1 << flag_index)) != 0
        } else {
            false
        }
    }
    
    /// Sets or clears a flag using the public constant masks (e.g., tile_flags::IS_TRAVERSABLE).
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            self.flags |= flag_mask;
        } else {
            self.flags &= !flag_mask;
        }
    }

    /// Checks if a specific flag is set using the public constant masks.
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        (self.flags & flag_mask) != 0
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\perlin_generator.rs (105 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/perlin_generator.rs

use crate::Generator;
// FIX 1: Import ChunkData and CHUNK_SIZE directly from chunk_data.
use ssxl_shared::chunk_data::{ChunkData, CHUNK_SIZE};
// FIX 2: Import GridBounds directly from its sub-module (aetherion_shared/src/grid_bounds.rs).
use ssxl_shared::grid_bounds::GridBounds; 
use ssxl_math::Vec2i;
use ssxl_shared::tile_data::TileData;
use ssxl_shared::tile_type::TileType;

// --- External Dependency ---
// FIX 3 (Warning): Removed unused 'Seedable' import.
use noise::{NoiseFn, Perlin}; 
use tracing::info;

/// Implements the Minimal Viable Generator (MVG) using Perlin Noise.
pub struct PerlinGenerator {
    /// Noise function instance for generation.
    perlin: Perlin,
    /// The scale factor to control the 'zoom' of the noise.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator with a fixed seed and configurable scale.
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42; // A simple, fixed seed for consistency
        PerlinGenerator { 
            // FIX: Supply the required u32 seed argument to Perlin::new()
            perlin: Perlin::new(DEFAULT_SEED), // <--- CHANGE THIS LINE
            scale,
        }
    }
}

impl Generator for PerlinGenerator {
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates the content for a single chunk using 2D Perlin noise.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i32; 

        // 1. Calculate the World-Space Start Position of the chunk
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // ChunkData::new arguments: id, bounds, dimension_name
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
        
        // FIX 4: GridBounds::new requires min_x, min_y, max_x, max_y (all i64)
        let bounds = GridBounds::new(
            world_start_x as i64, 
            world_start_y as i64, 
            (world_start_x + chunk_tile_size) as i64, 
            (world_start_y + chunk_tile_size) as i64
        ); 
        
        let dimension_name = "2D_Noise".to_string(); 
        
        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
        
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // 2. Loop through every tile in the chunk
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // 3. Use the noise function to get a height value
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Map the noise range [-1.0, 1.0] to a positive range [0.0, 1.0]
                let normalized_value = (noise_value + 1.0) / 2.0;

                // 4. Map the height value to a TileType and populate the ChunkData
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };
                
                // TileData::new requires 2 arguments: tile_type, noise_value: f32
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }
        
        // set_tiles renamed to insert_tiles
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)", 
            chunk_coords, 
            (CHUNK_SIZE * CHUNK_SIZE) 
        );
        
        chunk_data // Return the generated and populated chunk data
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\hashing.rs (102 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/hashing.rs
//! Core hashing utilities for converting coordinate data into unique identifiers (hashes).
//! These hashes are primarily used as stable keys for the cache and storage layers.

use crate::primitives::SSXLResult;
use glam::IVec3;
use sha2::{Digest, Sha256};

/// Generates a unique SHA-256 hash string for a given 3D integer coordinate (chunk position).
///
/// This hash is deterministic and collision-resistant, making it ideal for use as a
/// primary key in the cache or database for persistent data lookup.
///
/// # Arguments
///
/// * `coords` - The 3D integer coordinates (e.g., chunk index).
///
/// # Returns
///
/// A `String` containing the hexadecimal representation of the SHA-256 hash.
pub fn hash_chunk_coords(coords: IVec3) -> SSXLResult<String> {
    // 1. Format the coordinate string: "x:y:z"
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Hash the string using SHA-256
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash result to a hexadecimal string
    Ok(format!("{:x}", result))
}

/// Generates a unique content hash for a piece of data (e.g., a ChunkData struct).
///
/// This is a placeholder function that will be fully implemented later once we have the
/// full `ChunkData` structure. For now, it returns a simple hash based on a u64 key.
///
/// # Arguments
///
/// * `data_key` - A unique identifier or version number for the data.
///
/// # Returns
///
/// A `String` containing a placeholder hash.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    let key_string = data_key.to_string();
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    Ok(format!("content_{:x}", result))
}

// ---------------------------
// IMPL: Unit Tests
// ---------------------------

#[cfg(test)]
mod tests {
    use super::*;

    /// Tests that the SHA-256 hashing of coordinates is strictly deterministic.
    #[test]
    fn test_chunk_coords_determinism() {
        let coords = IVec3::new(10, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();
        
        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    /// Tests that adjacent coordinates produce different hashes and verifies the format.
    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = IVec3::new(1, 1, 1);
        let coords2 = IVec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        // SHA-256 produces 64 characters in hex format
        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    /// Tests that the content hash is deterministic and prepends the 'content_' prefix.
    #[test]
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;
        
        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        // Determinism check
        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        // Format check
        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // The SHA-256 hex part is 64 chars long. "content_" is 8 chars. Total: 72 chars.
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_engine_ffi\src\lib.rs (101 LOC)
//////////////////////////////////////////////////////

// ssxl_engine_ffi/src/lib.rs (Functional Fix)

//! Low-level C FFI Bridge for Godot Communication.
//!
//! This module exposes functions to C/Godot that manage the SSXL runtime lifecycle
//! and facilitate the transfer of generated chunk data.

use std::ffi::CString;
use std::sync::OnceLock;

// --- EXTERNAL CRATE DEPENDENCIES ---
use ssxl_generate::{Conductor, start_runtime_placeholder};
// FIX: Removed unused import `ssxl_math::Vec2i`
use ssxl_shared::initialize_shared_data;
use tracing::{info, error};

// --- 1. Conductor Management (Singleton State) ---

/// A thread-safe, lazily initialized global instance of the Conductor.
static CONDUCTOR: OnceLock<Conductor> = OnceLock::new();

/// Initializes the Aetherion Runtime (Conductor) and stores it globally.
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    // ... [Function Body Remains Unchanged]
    initialize_shared_data(); 

    if CONDUCTOR.get().is_some() {
        info!("FFI Bridge: Runtime already running.");
        return true;
    }

    match Conductor::new(None) {
        Ok((conductor, _state, _receiver)) => {
            if CONDUCTOR.set(conductor).is_err() {
                error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                return false;
            }
            info!("FFI Bridge: Conductor Runtime started successfully.");
            true
        }
        Err(e) => {
            tracing::error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
            false
        }
    }
}

/// Gracefully shuts down the Conductor by signaling its internal state.
#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    if let Some(conductor) = CONDUCTOR.get() {
        conductor.signal_shutdown_graceful();
        info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
    }
}

/// Checks if the engine's asynchronous core has been successfully initialized.
#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    CONDUCTOR.get().is_some()
}

// --- 2. Generation Bridge (If applicable, call internal logic here) ---

// --- 3. Compatibility and Utility Functions (Kept for CLI) ---

/// Triggers the structural test of the Conductor (used by CLI menu).
#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    info!("FFI Bridge: Received command to trigger Conductor structural test.");
    start_runtime_placeholder();
    info!("FFI Bridge: Conductor test sequence complete.");
}

#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

#[no_mangle]
pub extern "C" fn ssxl_get_status(id: u32) -> *mut std::os::raw::c_char {
    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        CONDUCTOR.get().is_some()
    );
    match CString::new(status) {
        Ok(c_string) => c_string.into_raw(),
        Err(_) => CString::new("Error: Invalid Status String").unwrap().into_raw(),
    }
}

/// FFI function to free strings allocated by Rust.
#[no_mangle]
pub extern "C" fn ssxl_free_string(s: *mut std::os::raw::c_char) {
    unsafe {
        if s.is_null() { return }
        let _ = CString::from_raw(s);
    }
}


//////////////////////////////////////////////////////
// FILE: manifest.rs (100 LOC)
//////////////////////////////////////////////////////

scan every line, it's not ready. 
#intro

SSXL-ext is a mythic core — a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ →).

🪶 Manifest v9.0.seed


#files

────────────────────────────────────────────────────────────
📁 Directory/File Structure

Legend:
├── Directory
│   Subdirectory
└── File


────────────────────────────────────────────────────────────
📦 zv9.SSXL-ext/ — Unified Workspace Root

C:/ZV9/zv9.SSXL-ext/rust

rust/                                # Workspace Member Root
	├── ssxl_cache/             # 💾 Data Caching and Chunk Storage
		├── cargo.toml
		├── /src
			├──lib.rs
	
	├── ssxl_cli/               # 🧰 Interactive Console, Benchmarks, and Diagnostics
		├── cargo.toml
		├── src/
			├──cli_util_actions.rs
			├──cli_util_bench.rs
			├──cli_util_inspect.rs
			├──cli_util_menu.rs
			├──main.rs
	
	├── ssxl_engine_ffi/        # 🔗 Low-level C FFI Bridge for Godot Communication
		├──cargo.toml
		├── src/
			├──lib.rs
   
	├── ssxl_generate/          # ⚙️ Core Generation Algorithms (Noise, Pattern Mapping)
		├──cargo.toml
		├── src/
			├──cellular_automata_generator.rs
			├──conductor.rs
			├──generator.rs
			├──lib.rs
			├──perlin_generator.rs
			├──benchmark_logic.rs
   
	├── ssxl_godot/             # 🎮 High-level Godot Bindings (GDExtension API)
		├──cargo.toml
		├── src/
			├──lib.rs
   
	├── ssxl_math/              # 📐 Mathematical Primitives and Coordinate Systems
		├──cargo.toml
		├── src/
			├──lib.rs
			├──coordinate_system.rs
			├──generation_utils.rs
			├──hashing.rs
			├──primitives.rs
			
   
	├── ssxl_shared/            # 🧱 Global Data Primitives (Chunk, Tile, Grid Types)
		├──cargo.toml
		├── src/
			├──lib.rs
			├──chunk_data.rs
			├──errors.rs
			├──grid_bounds.rs
			├──math_primitives.rs
			├──tile_data.rs
			├──tile_type.rs
   
	├── ssxl_sync/              # 🚦 Concurrency Primitives and Thread Safety
		├──cargo.toml
		├── src/
			├──lib.rs
   
	├── ssxl_tools/             # 🔧 Utility Logic (Configuration, Logging, Profiling)
		├──cargo.toml
		├── src/
			├──lib.rs
   
   └── iteration5/                  # 🗑️ Obsolete/Temporary Directory (For cleanup)

C:/ZV9/zv9.gdext/ //<-- local clone of fork of godot-rust master linked in toml's

#manifest

CHANGEOVER STEPS:
print source code to .txt



//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\tile_type.rs (89 LOC)
//////////////////////////////////////////////////////

//! Defines the canonical set of fundamental types that a Tile can represent.
//!
//! This enum is used by the generation modules to assign meaning to raw noise values,
//! and by the rendering engine (Godot) to select the correct visual asset.

use serde::{Serialize, Deserialize};

/// The fundamental, physical classification of a tile, aligned with the MVG schema.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] // Ensures compact storage for cache serialization
pub enum TileType {
    /// 0: The default, empty, or uninitialized state (Void/Air).
    Void = 0,
    /// 1: Represents a water body (V < 0.3).
    Water = 1,
    /// 2: Represents standard ground/plains (0.3 <= V < 0.6).
    Grass = 2,
    /// 3: Represents high-elevation terrain (V >= 0.6).
    Mountain = 3,
    /// 4: Represents a boundary or special-condition tile that cannot be traversed or modified easily.
    Boundary = 4,
    /// 5: Reserved for future structured objects/built environment (Structure/Roads).
    Structure = 5,
    /// 6: **(CA GENERATOR)** Represents solid ground or a wall, used as the 'live' cell by the Cellular Automata Generator.
    Rock = 6,
    /// 7: Reserved for future expansion or custom user types.
    Custom1 = 7,
    /// 8: Reserved for future expansion or custom user types.
    Custom2 = 8,
}

// ---------------------------
// IMPL: Default and Conversion
// ---------------------------

impl Default for TileType {
    /// The default state of a tile is non-solid and empty.
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Helper function to convert the enum variant into its underlying u8 representation.
    #[inline] // Hint to the compiler for potential inlining for performance
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a u8 into a TileType. Returns None if the value is outside the defined range.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TileType::Void),
            1 => Some(TileType::Water),
            2 => Some(TileType::Grass),
            3 => Some(TileType::Mountain),
            4 => Some(TileType::Boundary),
            5 => Some(TileType::Structure),
            // FIX: Added Rock
            6 => Some(TileType::Rock), 
            // FIX: Updated Custom variants' values
            7 => Some(TileType::Custom1),
            8 => Some(TileType::Custom2),
            _ => None,
        }
    }
}

// ---------------------------
// IMPL: Gameplay Logic Helpers
// ---------------------------

impl TileType {
    /// Checks if the tile type indicates a ground-based, traversable surface.
    pub const fn is_walkable(self) -> bool {
        // FIX: Added Rock as a walkable surface
        matches!(self, TileType::Grass | TileType::Mountain | TileType::Structure | TileType::Rock)
    }

    /// Checks if the tile type indicates a liquid that typically requires fluid dynamics simulation.
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is a placeholder state that hasn't been generated yet.
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_oracle.rs (84 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/aetherion_oracle.rs (Cleaned and updated for v8.2)

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use godot::builtin::Variant;
use crate::ssxl_engine::SSXLEngine; 

/// 🔮 AetherionOracle — Godot-facing node for manually driving the AetherionEngine 
/// and providing complex query/lookup logic (future state).
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    /// Link to the SSXL instance. Stored as Gd<SSXLEngine> for safety.
    engine: Option<Gd<SSXLEngine>>, 
    tick_count: u64,
}

impl SSXLOracle {
    pub fn init(base: Base<Node>) -> Self { 
        Self { 
            base, 
            engine: None, 
            tick_count: 0 
        } 
    }
}

#[godot_api]
impl SSXLOracle {

    /// Called when the node enters the scene tree.
    #[func]
    fn _ready(&mut self) {
        godot_print!("🔮 SSXLOracle (v8.2) is online. I await the ignition.");
        self.base_mut().set_process(true);
    }

    /// Links the Oracle to a target engine node.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
        godot_print!("🔗 Oracle: Engine link established.");
    }

    /// Sends a tick to the linked engine (via an explicit call to the engine's tick function).
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // Assuming SSXLEngine will have a #[func] called 'tick'
                let args = [Variant::from(self.tick_count)];
                engine.call("tick", &args); 
                
                godot_print!("🔮 Oracle: Tick {} → Engine", self.tick_count);
                self.tick_count += 1;
            }
            None => {
                godot_warn!("⚠️ Oracle: No engine linked. Tick aborted.");
            }
        }
    }

    /// Responds to a ping from external systems.
    #[func]
    pub fn ping(&self) {
        godot_print!("🔮 Oracle: Ping received. I am awake.");
    }

    /// Resets the internal tick counter.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
        godot_print!("🔄 Oracle: Tick counter reset.");
    }

    /// Returns the current tick count.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_cache\src\lib.rs (77 LOC)
//////////////////////////////////////////////////////

// ssxl_cache/src/lib.rs
//! In-memory caching layer for storing and retrieving procedural generation data (Chunks).

use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
use ssxl_shared::chunk_data::ChunkData; // NEW: Use the final data structure
use std::collections::HashMap;
use std::io; // NEW: Required for Result type in new(), load_chunk, and save_chunk
use tracing::{info, warn};

// --- 1. Obsolete ChunkDataPlaceholder structure removed for Phase 6. ---

// --- 2. Cache Structure ---

// Type alias for the thread-safe core map
type CacheMap = HashMap<ChunkKey, ChunkData>; // FIX: Switched to ChunkData

/// The thread-safe, in-memory cache for generated Chunk data.
/// Uses AtomicResource to allow safe concurrent read/write access across worker threads.
#[derive(Debug, Clone)]
pub struct ChunkCache {
    storage: AtomicResource<CacheMap>,
}

impl ChunkCache {
    /// Creates a new, empty, thread-safe cache instance.
    // FIX: Changed return type to Result<Self, io::Error> to satisfy Conductor's initialization.
    pub fn new() -> Result<Self, io::Error> {
        info!("SSXL ChunkCache initialized: Ready for thread-safe storage.");
        Ok(ChunkCache {
            storage: AtomicResource::new(HashMap::new()),
        })
    }

    /// Attempts to retrieve a ChunkData by its ChunkKey (Cache Load implementation).
    // FIX: Implemented load_chunk as required by the Conductor (Fixes E0599).
    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<ChunkData>, io::Error> {
        let map = self.storage.read();
        // Returns a clone of the ChunkData, or None. Wrapped in Ok.
        Ok(map.get(key).cloned()) 
    }

    /// Inserts a ChunkData into the cache (Cache Save implementation).
    // FIX: Implemented save_chunk as required by the Conductor (Fixes E0599).
    pub fn save_chunk(&self, key: &ChunkKey, data: &ChunkData) -> Result<(), io::Error> {
        let mut map = self.storage.write();
        
        if map.insert(*key, data.clone()).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
        } else {
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }

    /// Reports the current number of chunks stored in the cache.
    pub fn len(&self) -> usize {
        self.storage.read().len()
    }

    /// Clears all entries from the cache.
    pub fn clear(&self) {
        self.storage.write().clear();
        info!("SSXL ChunkCache cleared.");
    }

    /// Checks if the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

// ---------------------------
// IMPL: Unit Tests (Removed obsolete tests)
// ---------------------------
// Note: Obsolete unit tests relying on ChunkDataPlaceholder and old methods (get/insert) 
// have been removed for project cleanup.


//////////////////////////////////////////////////////
// FILE: ssxl_cli\src\cli_util_menu.rs (74 LOC)
//////////////////////////////////////////////////////

// FIX: Replace the log import with the tracing import.
use tracing::warn;
// NEW IMPORT: Add the new function to be called from the menu
use crate::cli_util_actions::{
    run_cargo_tests, 
    // FIX: Renaming this to reflect the Phase 8 goal: launch the actual Godot client.
    launch_godot_client, // <--- NEW ACTION (Replaced start_aetherion_runtime)
    launch_headless_godot, 
    run_priority_1_tests, 
    start_signal_inspector,
    run_ffi_bridge_validation,
}; 
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};

/// 🧩 Menu item definition
pub struct MenuItem {
	pub key: char,
	pub label: &'static str,
	pub action: Box<dyn Fn()>,
}

/// 🧭 Builds the interactive dev console menu
pub fn build_menu() -> Vec<MenuItem> {
	vec![
		// ✅ Core Actions & Inspection
		MenuItem { key: '0', label: "✅ Run: Cargo Test Suite", action: Box::new(run_cargo_tests) },
		MenuItem { key: '1', label: "✅ Inspect: Godot-Callable API Surface", action: Box::new(print_godot_api_surface) },
		MenuItem { key: '2', label: "✅ Inspect: Rust Module Tree", action: Box::new(print_module_tree) },
		MenuItem { key: '3', label: "⚠️ Run: Trailkeeper Scan (TODO)", action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented.")) },
		
		// 🚀 Runtime & Benchmarks
		// FIX: Update to the Phase 8 goal: Launch the full Godot client.
		MenuItem { 
            key: '4', 
            label: "🚀 Launch: Godot Client (Non-Headless)", 
            action: Box::new(launch_godot_client) // <--- UPDATED ACTION
        },
		MenuItem { key: '5', label: "🧪 Test: Generation & Placement CLI", action: Box::new(test_generation_and_placement_cli) },
		MenuItem { key: '6', label: "✅ Perform: Bitmask PNG Conversion", action: Box::new(run_bitmask_conversion) },
		MenuItem { key: '7', label: "🧪 Benchmark: Max Grid Placement", action: Box::new(run_max_grid_benchmark) },
		
		// 🎮 Engine Integration (Phase 8 Focus)
		MenuItem { 
            key: '8', 
            label: "🎮 Launch: Headless Godot (External)", 
            action: Box::new(launch_headless_godot) 
        },
		// FIX: The FFI test is now confirmed successful (✅) and moved to a final validation status.
		MenuItem { 
            key: '9', 
            label: "✅ Validate: FFI Bridge Data Transfer (E2E Final)", 
            action: Box::new(run_ffi_bridge_validation) 
        },
		
		// 🚪 Exit
		MenuItem { key: 'E', label: "✅ Exit", action: Box::new(|| {}) },
		
		// 🔮 Future Expansion / TODOs / Final Checks
		MenuItem { key: 'A', label: "🔮 TODO: Export Chunk Hashes for Streaming", action: Box::new(|| warn!("TODO: Chunk hashing not yet implemented.")) },
		MenuItem { key: 'B', label: "🔮 Start: Signal Inspector / Live Feed", action: Box::new(start_signal_inspector) }, 
		MenuItem { key: 'C', label: "✅ Validate: Phase 1 Final Integration Check", action: Box::new(run_priority_1_tests) },
	]
}

/// 🖥 Prints the menu to the console
pub fn print_menu(menu: &[MenuItem]) {
	
	println!("\n🧭 SSXL-ext Engine Dev Console\n");
	for item in menu {
		println!("[{}] {}", item.key, item.label);
	}
	println!("\nSelect an option by pressing its number key or letter key...\n");
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\lib.rs (70 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/lib.rs

//! The Foundation Layer crate. Defines all core data structures, common utilities,
//! and the canonical error type for the entire Aetherion Engine workspace.

use serde::{Serialize, Deserialize};
use tracing; // Import tracing for logging initialization

// --- MODULE DEFINITIONS ---
// P1 Data Structures
pub mod chunk_data;
pub mod tile_data;
pub mod grid_bounds;
pub mod tile_type;
pub mod errors;

// P1 Math/Utility (To be implemented next)
pub mod math_primitives;

// --- CRITICAL TYPE EXPORTS ---
// Export the primary data structures
pub use chunk_data::ChunkData;
pub use tile_data::TileData;
pub use grid_bounds::GridBounds;
pub use tile_type::TileType;

// Export the canonical error type and the engine-wide Result alias
pub use errors::{SSXLError, SSXLResult};

// ------------------------------------------------------------------
// CORE ENGINE FUNCTIONALITY
// ------------------------------------------------------------------

/// Initializes global data primitives and configuration for the engine.
/// This function is typically called once on engine startup by the FFI bridge.
// FIX: Added the missing function (E0425) expected by aetherion_engine_ffi.
pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
    // Future work: Add validation of global constants (e.g., CHUNK_SIZE) here.
}

// ------------------------------------------------------------------
// COMPATIBILITY EXPORTS (Temporary/Legacy/Simple Structures)
// ------------------------------------------------------------------

// Re-export the anyhow crate for macro usage (e.g., anyhow!("...")).
pub use anyhow;

/// A simple, generic data structure used by placeholder logic (e.g., aetherion_cache).
/// This structure provides the fields expected by the current implementation of calculate_data_hash.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

// --- COMMON EXPORTS (PRELUDE) ---
/// A common prelude to be imported by other crates for quick access
/// to fundamental types and the core error handling alias.
pub mod prelude {
    // Shared Data
    pub use super::chunk_data::ChunkData;
    pub use super::tile_data::TileData;
    pub use super::grid_bounds::GridBounds;
    pub use super::tile_type::TileType;
    
    // Shared Error Handling
    pub use super::errors::{SSXLError, SSXLResult};
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\lib.rs (67 LOC)
//////////////////////////////////////////////////////

//! Core generation algorithms, runtime orchestration, and task management.

// -------------------------------------------------------------------------------------------------
// MODULE EXPOSURE
// -------------------------------------------------------------------------------------------------
// Expose the Conductor (the validated Runtime/Orchestration core).
pub mod conductor;
pub mod benchmark_logic;
pub mod perlin_generator;
pub mod cellular_automata_generator;

// Direct re-exports of concrete implementations
pub use cellular_automata_generator::CellularAutomataGenerator;
pub use perlin_generator::PerlinGenerator;

// -------------------------------------------------------------------------------------------------
// CORE TRAIT DEFINITION (Generator Interface)
// -------------------------------------------------------------------------------------------------
use ssxl_shared::chunk_data::ChunkData;
use ssxl_math::Vec2i;

/// Defines the core contract for all procedural generation algorithms.
/// Every generator (Perlin, CA, DiamondSquare, etc.) must implement this trait.
pub trait Generator {
    /// The unique identifier for this specific algorithm (e.g., "perlin_2d_v1").
    fn id(&self) -> &str;

    /// Generates the content for a single Chunk.
    /// It takes a Vec2i which is the world-space coordinate of the chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


// -------------------------------------------------------------------------------------------------
// PUBLIC EXPORTS
// -------------------------------------------------------------------------------------------------
// Re-export the main components for easy use by other crates (aetherion_godot, aetherion_cli).
pub use conductor::Conductor;
// PHASE 8.3 EXPORT: Expose GeneratorConfig for use by the FFI/Godot wrapper.
pub use conductor::GeneratorConfig;

// EXPOSED BENCHMARK FUNCTION: This resolves the E0432 error in aetherion_cli
pub use benchmark_logic::benchmark_generation_workload;

// -------------------------------------------------------------------------------------------------
// PUBLIC API FOR CLI/FFI (Validation Entry Points)
// -------------------------------------------------------------------------------------------------
use tracing::{info, error};

/// Starts the ssxl Runtime, creating and immediately shutting down the Conductor.
///
/// NOTE: This is the **structural validation test for CLI Menu [4]** (Start Runtime).
pub fn start_runtime_placeholder() {
    // Pass None as the config_path argument to satisfy the updated Conductor::new signature.
    match Conductor::new(None) {
        // FIX: Properly destructure the 3-element tuple (Conductor, ConductorState, Receiver).
        Ok((conductor, _state, _receiver)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Call the consuming teardown method.
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\errors.rs (64 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/errors.rs
//! Defines the canonical error type for the entire Aetherion Engine workspace.
//!
//! All crates should return an 'AetherionError' to ensure clean, consistent
//! error propagation throughout the engine layers (Core, Generation, Godot Interface).

use thiserror::Error;

/// The primary result type used throughout the Aetherion Engine.
/// Aliases the standard Result using the engine's canonical error type.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// Canonical error type for all Aetherion Engine components.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Errors related to file operations, configuration loading, or I/O failure.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors related to data serialization or deserialization (e.g., failed bincode/serde operation).
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors caused by data structures being in an invalid or impossible state (e.g., malformed GridBounds).
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the generation pipeline, often due to configuration or boundary failures.
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors related to external FFI or GDExtension communication.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// An error that should never happen, indicating a fundamental bug in logic or state management.
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Catch-all for other external errors, often used when converting from third-party crates.
    /// This variant is primarily used to wrap `anyhow::Error`.
    #[error("External Crate Error: {0}")]
    External(String),
}

// --- Helper Conversion Implementations (for common libraries) ---

/// Example conversion for the 'bincode' serialization library.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Allows conversion from a generic `anyhow::Error` into the canonical `AetherionError`.
/// This is CRITICAL for using the `anyhow!` macro in dependent crates.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        SSXLError::External(format!("General anyhow error: {}", err))
    }
}

// You can add more 'From' implementations here as you introduce new dependencies,
// like 'tokio::JoinError' or 'rand::Error'.



//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\grid_bounds.rs (58 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/grid_bounds.rs
//! Defines the spatial boundaries for a Chunk or any defined area within the procedural world.
//!
//! Uses i64 coordinates to support extremely large, super-massive, expansive arcs.

use serde::{Serialize, Deserialize};

/// Represents a simple 2D integer coordinate (X, Y).
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    pub x: i64,
    pub y: i64,
}

/// Defines the minimum (min) and maximum (max) corners of a rectangular area
/// in the Aetherion world space, typically used to bound a Chunk or Region.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum corner of the bounding box (bottom-left).
    pub min: Coord2D,
    /// The exclusive maximum corner of the bounding box (top-right + 1).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new GridBounds instance.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size of the bounded area along the X and Y axes.
    /// The size is calculated as max - min.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within these bounds (inclusive minimum, exclusive maximum).
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Provides a default (zero-sized) GridBounds instance.
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}



//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\ssxl_signals.rs (58 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/ssxl_signals.rs (Final, Clean Code)

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Base;
// FIX: Removed unused imports `GString`, `Dictionary`, and `Array`

// -------------------------------------------------------------------------------------------------
// SSXL SIGNALS GODOT WRAPPER
// -------------------------------------------------------------------------------------------------

/// A dedicated Godot Node class used purely for emitting signals from the Rust core back to GDScript.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

#[godot_api]
impl SSXLSignals {
    pub fn init(base: Base<Node>) -> Self {
        SSXLSignals {
            base,
        }
    }
    
    // --- Signal Declarations ---

    #[signal] 
    fn build_map_start();

    #[signal]
    fn chunk_generated(x: i32, y: i32);
    
    #[signal]
    fn build_map_complete();

    // --- Signal Emitter Functions ---

    /// Emits the signal that the map build process has started.
    #[func]
    pub fn emit_build_map_start(&mut self) {
        self.base_mut().emit_signal("build_map_start", &[]);
    }

    /// Emits the signal that a new chunk has been generated and is ready to be loaded.
    #[func]
    pub fn emit_chunk_generated(&mut self, x: i32, y: i32) {
        self.base_mut().emit_signal("chunk_generated", &[x.to_variant(), y.to_variant()]);
    }

    /// Emits the signal that the entire map build process is complete.
    #[func]
    pub fn emit_build_map_complete(&mut self) {
        self.base_mut().emit_signal("build_map_complete", &[]);
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\build.rs (53 LOC)
//////////////////////////////////////////////////////

// rust/SSXL_godot/build.rs

use std::env;
use std::path::PathBuf;
use std::process::Command; // 🛑 New import for executing shell commands

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // The directory where cargo.toml resides (e.g., .../rust/aetherion_godot)
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    
    // The name of the resulting GDExtension DLL (must match your .gdextension file)
    let dll_name = "ssxl_engine.dll"; 
    
    // Determine the profile (debug or release)
    let profile = env::var("PROFILE").unwrap();    

    // --- 1. Calculate Source Path ---
    let src_path = manifest_dir
        .parent().unwrap() // .. to rust/
        .join("target")
        .join(&profile)
        .join(dll_name);

    // --- 2. Calculate Destination Path ---
    let dst_path = manifest_dir
        .parent().unwrap()      // up to rust/
        .parent().unwrap()      // up to zv9.aetherion/
        .join("ssxl_engine_tester")
        .join(dll_name);

    // --- 3. Execute Native Windows Copy Command ---
    // Using `cmd /C copy /Y` is more robust on Windows than fs::copy.
    let status = Command::new("cmd")
        // /C runs the command and terminates; copy /Y overwrites without prompt
        .args(&["/C", "copy", "/Y"]) 
        .arg(&src_path)
        .arg(&dst_path)
        .status();

    match status {
        Ok(s) if s.success() => {
            println!("cargo:warning=✅ SUCCESS (CMD): Deployed {} to {}", dll_name, dst_path.display());
        }
        _ => {
            println!("cargo:warning=🚨 CRITICAL FAILURE (CMD): DLL deployment failed!");
            println!("cargo:warning=  Source Path: {}", src_path.display());
            println!("cargo:warning=  Dest Path: {}", dst_path.display());
            println!("cargo:warning=  Note: The shell command failed. Check file locks or path permissions.");
        }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\primitives.rs (45 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/primitives.rs
//! Core types and constants for the Aetherion math foundation layer.

use serde::{Serialize, Deserialize};

// -------------------------------------------------------------------------
// I. PRIMITIVE TYPES AND TRAITS (MUST BE PUB)
// -------------------------------------------------------------------------

/// The canonical signed 2D integer vector for coordinate system logic (Chunk Coords).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    pub x: i32,
    pub y: i32,
}

/// A simplified, common result type.
pub type SSXLResult<T> = Result<T, String>;

/// A simplified, common data structure trait implemented by data structs like ChunkData.
pub trait SSXLData: Send + Sync {
    // FIX: Removed 'pub' keyword from trait methods (E0449 resolved)
    fn get_id(&self) -> u64; 
    fn get_value_len(&self) -> usize;
}

// -------------------------------------------------------------------------
// II. CORE CONSTANTS (MUST BE PUB)
// -------------------------------------------------------------------------

/// The standard size (width, height, depth) of a chunk in tiles.
pub const CHUNK_SIZE_I32: i32 = 32;

/// Standard epsilon value for floating-point comparisons (f32).
pub const F32_EPSILON: f32 = 1.0e-6;

// -------------------------------------------------------------------------
// III. IMPLEMENTATION
// -------------------------------------------------------------------------

impl Vec2i {
    pub fn new(x: i32, y: i32) -> Self {
        Vec2i { x, y }
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\generation_utils.rs (45 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/generation_utils.rs
//! Utility module for core functions used by the generation pipeline.

// FIX: Corrected the module path from 'math_primitives' to 'primitives'
use crate::primitives::SSXLData; 
use std::time::SystemTime; // Required for seeding fast_rand

/// 🛠️ Implements a basic placeholder fast random utility for CA seeding.
///
/// Returns `0` if a generated random value (0-99) is less than `target_percent`.
/// This is used to randomly select tiles for the initial Cellular Automata seed.
pub fn fast_rand(target_percent: u8) -> u32 {
    // Uses time/memory address hash for a quick, non-cryptographic pseudo-random seed
    let seed = SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64;
        
    // Simple modulo 100 to get a value for percent chance check
    let rand_val = (seed % 100) as u8;

    if rand_val < target_percent {
        0
    } else {
        1
    }
}

/// Processes the input data, applying a placeholder mathematical transformation.
///
/// In a real engine, this would perform preliminary calculations (e.g., noise sampling,
/// terrain height adjustments) before final structure generation.
///
/// # Arguments
///
/// * `data` - A reference to the core `AetherionData` structure containing relevant state.
///
/// # Returns
///
/// A simple derived u64 value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Uses the trait methods defined on SSXLData in ssxl_math/src/primitives.rs
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\benchmark_logic.rs (43 LOC)
//////////////////////////////////////////////////////

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

/// 🧪 Executes a fixed tile generation workload for throughput benchmarking.
///
/// This function simulates the work of the Minimal Viable Generator (MVG) by
/// iterating a fixed number of times, representing the processing of each tile.
///
/// It accepts an atomic counter to update real-time progress for the CLI ticker.
pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    // We only update the progress counter every 10 million tiles to minimize atomic overhead.
    const UPDATE_INTERVAL: u64 = 10_000_000; 

    // Placeholder for actual generation work.
    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        // A minimal, but non-trivial, calculation that depends on the loop variable 'i'.
        // This simulates the core work (e.g., noise lookup, pattern mapping).
        result = result.wrapping_add(i % 17);
        
        // --- REAL-TIME PROGRESS UPDATE ---
        if (i + 1) % UPDATE_INTERVAL == 0 {
            // Atomically increment the counter by the interval.
            // Ordering::Relaxed is sufficient as we only care about the final value and ordering within the thread.
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    // Ensure the counter is set to the final value, covering any remaining tiles in the last batch.
    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    // Print a result outside the loop to ensure the calculation itself is not optimized away.
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}


//////////////////////////////////////////////////////
// FILE: ssxl_shared\src\math_primitives.rs (41 LOC)
//////////////////////////////////////////////////////

// ssxl_shared/src/math_primitives.rs
//! This module holds utility functions and constants needed by shared data structures,
//! primarily serialization helpers for standard library types.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};

// NOTE: CHUNK_SIZE_I32 and F32_EPSILON are removed from here.
// CHUNK_SIZE_I32 should be moved to aetherion_math/src/primitives.rs to break the cycle.
// F32_EPSILON is a generic math constant and should also live in aetherion_math.

// -----------------------------------------------------------------------------
// SERDE HELPERS (Remains in Shared, as it aids shared data structures)
// -----------------------------------------------------------------------------

/// Serde serialization and deserialization helpers for `std::time::SystemTime`.
///
/// This allows `SystemTime` to be used in structs with `#[derive(Serialize/Deserialize)]`
/// by converting it to and from a serializable `u64` (milliseconds since epoch).
pub mod system_time_serde {
    use super::*;

    /// Serializes `SystemTime` as milliseconds elapsed since the Unix epoch (u64).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        let ms = duration.as_millis() as u64;
        serializer.serialize_u64(ms)
    }

    /// Deserializes milliseconds (u64) back into a `SystemTime` struct.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        let ms = u64::deserialize(deserializer)?;
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_math\src\lib.rs (34 LOC)
//////////////////////////////////////////////////////

// ssxl_math/src/lib.rs

//! The Foundation Layer crate for all spatial types, vector math,
//! coordinate systems, and deterministic hashing algorithms.

// --- MODULE DEFINITIONS ---
pub mod coordinate_system;
pub mod generation_utils;
pub mod hashing;
// --- FIX: Renamed to primitives to match usage below ---
pub mod primitives; 

// -------------------------------------------------------------------------
// EXPORTS FOR DOWNSTREAM CRATES
// -------------------------------------------------------------------------
pub use coordinate_system::{ChunkKey, WorldPos, TileOffset};
pub use crate::generation_utils::process_data;
// Exports correctly point to the 'primitives' module
pub use crate::primitives::Vec2i; 
pub use crate::primitives::SSXLResult;
pub use crate::primitives::SSXLData;

/// Math-specific prelude for convenient imports in downstream crates.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    // Exports correctly point to the 'primitives' module
    pub use super::primitives::*; 
}

pub fn initialize_math_system() {
    tracing::info!("SSXL Math system initialized and ready.");
}


//////////////////////////////////////////////////////
// FILE: ssxl_godot\src\lib.rs (23 LOC)
//////////////////////////////////////////////////////

// ssxl_godot/src/lib.rs

// 🛑 Declare sub-modules (no change needed here)
pub mod ssxl_engine;
pub mod ssxl_signals;
pub mod ssxl_oracle;

use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel}; 

// --- GDEXTENSION ENTRY POINT ---

struct SSXLExtension;

// 🛑 FIX: Use the simple, stable, declarative ExtensionLibrary implementation.
// This is the correct signature for your version and relies on the #[derive(GodotClass)] 
// in the sub-modules to perform registration.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    fn on_level_init(_level: InitLevel) {
        // Leave the body empty. Registration happens automatically via macros.
    }
}


//////////////////////////////////////////////////////
// FILE: ssxl_generate\src\generator.rs (18 LOC)
//////////////////////////////////////////////////////

// ssxl_generate/src/generator.rs

use ssxl_shared::chunk_data::ChunkData;
// FIX: Imported Vec2i from aetherion_math, where it is now defined and exported.

use ssxl_math::Vec2i;

/// Defines the core contract for all procedural generation algorithms.
/// Every generator (Perlin, CA, DiamondSquare, etc.) must implement this trait.
#[allow(dead_code)]
pub trait Generator {
    /// The unique identifier for this specific algorithm (e.g., "perlin_2d_v1").
    fn id(&self) -> &str;

    /// Generates the content for a single Chunk.
    /// It takes a Vec2i which is the world-space coordinate of the chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

======================================================
END OF REPORT
======================================================
