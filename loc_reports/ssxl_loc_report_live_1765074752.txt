SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1765074752
Root Directories: rust, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       130 LOC | rust/ssxl_cache/src\lib.rs
// --- START: rust/ssxl_cache/src\lib.rs ---
// ============================================================================
// üóÑÔ∏è Chunk Cache System (`ssxl_cache`)
// ----------------------------------------------------------------------------
// This module implements a thread-safe, region-aware cache for chunk data in
// the SSXL engine. It combines an LRU (Least Recently Used) eviction policy
// with region indexing to balance performance, memory usage, and spatial
// organization.
//
// Key Concepts:
//   ‚Ä¢ ChunkCache:
//       - Stores chunks in an LRU cache, automatically evicting the least
//         recently used entries when capacity is exceeded.
//       - Provides methods to load, save, and remove chunks safely.
//       - Tracks cache metrics (hits, misses, evictions) for performance tuning.
//   ‚Ä¢ RegionIndex:
//       - Maps regions (groups of chunks) to sets of chunk keys.
//       - Regions are defined by dividing world coordinates by REGION_SIZE.
//       - Supports insertion and removal of chunk keys, automatically cleaning
//         up empty regions.
//   ‚Ä¢ CacheMetrics:
//       - Atomic counters for hits, misses, and evictions.
//       - Provides lightweight tracking of cache performance without locking.
//   ‚Ä¢ REGION_SIZE:
//       - Defines the granularity of regions (here, 64 units).
//       - Used to group chunks spatially for efficient lookup.
//
// Workflow:
//   1. Initialization (`ChunkCache::new`):
//      - Creates an LRU cache with a non-zero capacity.
//      - Initializes region index and metrics tracker.
//   2. Loading (`load_chunk`):
//      - Attempts to retrieve a chunk by key.
//      - Increments hit/miss counters accordingly.
//   3. Saving (`save_chunk`):
//      - Inserts a chunk into the cache and updates the region index.
//      - If capacity is exceeded, evicts the least recently used chunk.
//      - Tracks eviction metrics and cleans up region index.
//   4. Removal (`remove_chunk`):
//      - Manually removes a chunk and updates the region index.
//   5. Inspection (`len`, `capacity`):
//      - Provides current cache size and maximum capacity.
//
// Design Choices:
//   ‚Ä¢ `parking_lot::Mutex` and `RwLock` provide high-performance locking
//     primitives for concurrent access.
//   ‚Ä¢ `Arc` ensures safe shared ownership of chunks and metrics across threads.
//   ‚Ä¢ `AtomicResource` wraps the region index for ergonomic thread-safe access.
//   ‚Ä¢ `lru::LruCache` provides a proven eviction strategy for bounded memory.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a layered caching strategy:
//       - LRU eviction ensures memory bounds.
//       - Region indexing provides spatial organization.
//       - Metrics tracking enables runtime tuning.
//   ‚Ä¢ By combining these techniques, the engine achieves efficient chunk
//     management in large, procedurally generated worlds.
// ============================================================================


use ssxl_math::coordinate_system::ChunkKey;
use ssxl_shared::ChunkData;
use ssxl_sync::AtomicResource;

use std::collections::{HashMap, HashSet};
use std::sync::{
    Arc,
    atomic::{AtomicUsize, Ordering}
};
use std::io;
use std::num::NonZeroUsize;

use parking_lot::{Mutex, RwLock};
use tracing::info;
use glam::I64Vec3;
use lru::LruCache;

const REGION_SIZE: i64 = 64;
type RegionKey = ChunkKey;
type RegionList = RwLock<HashSet<ChunkKey>>;

#[derive(Debug, Default)]
pub struct CacheMetrics {
    pub hits: AtomicUsize,
    pub misses: AtomicUsize,
    pub evictions: AtomicUsize,
}

impl CacheMetrics {
    #[inline(always)]
    pub fn hit(&self) { self.hits.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn miss(&self) { self.misses.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn evict(&self) { self.evictions.fetch_add(1, Ordering::Relaxed); }
}

#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<HashMap<RegionKey, Arc<RegionList>>>,
}

impl RegionIndex {
    pub fn new() -> Self {
        Self {
            storage: AtomicResource::new(HashMap::new()),
        }
    }

    #[inline(always)]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let p = chunk_key.0;
        let rx = p.x / REGION_SIZE;
        let ry = p.y / REGION_SIZE;
        let rz = p.z / REGION_SIZE;
        ChunkKey(I64Vec3::new(rx, ry, rz))
    }

    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = {
            let mut map = self.storage.write();
            map.entry(region_key)
                .or_insert_with(|| Arc::new(RwLock::new(HashSet::new())))
                .clone()
        };
        let mut list = list_arc.write();
        list.insert(chunk_key);
    }

    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = self.storage.read().get(&region_key).cloned();

        if let Some(list_arc) = list_arc {
            let mut list = list_arc.write();
            if list.remove(&chunk_key) {
                if list.is_empty() {
                    drop(list);
                    self.storage.write().remove(&region_key);
                    info!("Removed empty region from index: {:?}", region_key);
                }
                return true;
            }
        }
        false
    }
}

#[derive(Debug)]
pub struct ChunkCache {
    storage: Mutex<LruCache<ChunkKey, Arc<ChunkData>>>,
    region_index: RegionIndex,
    capacity: NonZeroUsize,
    pub metrics: Arc<CacheMetrics>,
}

impl ChunkCache {
    pub fn new(max_chunks: usize) -> io::Result<Self> {
        let capacity = NonZeroUsize::new(max_chunks.max(1))
            .unwrap_or(NonZeroUsize::new(1024).unwrap());
        
        info!("ChunkCache initialized with LRU eviction (capacity: {})", capacity);

        Ok(Self {
            storage: Mutex::new(LruCache::new(capacity)),
            region_index: RegionIndex::new(),
            capacity,
            metrics: Arc::new(CacheMetrics::default()),
        })
    }

    pub fn load_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let mut guard = self.storage.lock();
        let result = guard.get(key).map(Arc::clone);
        
        if result.is_some() {
            self.metrics.hit();
        } else {
            self.metrics.miss();
        }

        result
    }

    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> io::Result<()> {
        let key = *key;
        let mut guard = self.storage.lock();

        self.region_index.insert_key(key);

        let _old_data = guard.put(key, data);
        
        if let Some((evicted_key, _)) = guard.pop_lru() {
            self.metrics.evict();
            self.region_index.remove_key(evicted_key);
            info!(
                "LRU evicted chunk: {:?} (cache size: {})",
                evicted_key,
                guard.len()
            );
        }

        Ok(())
    }

    pub fn remove_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let removed = self.storage.lock().pop(key);
        if removed.is_some() {
            self.region_index.remove_key(*key);
            info!("Manually removed chunk from cache: {:?}", key);
        }
        removed
    }

    pub fn len(&self) -> usize {
        self.storage.lock().len()
    }

    pub fn capacity(&self) -> usize {
        self.capacity.get()
    }
}

// --- END: rust/ssxl_cache/src\lib.rs ---
       139 LOC | rust/ssxl_engine_ffi/src\lib.rs
// --- START: rust/ssxl_engine_ffi/src\lib.rs ---
// ============================================================================
// üéÆ SSXL Engine Godot Extension (`ssxl_godot::engine`)
// ----------------------------------------------------------------------------
// This module defines the `SSXLEngine` Godot node, which acts as the bridge
// between the Rust-based SSXL engine and the Godot game engine via GDExtension.
//
// Purpose:
//   ‚Ä¢ Provide a Godot-facing node that orchestrates procedural generation tasks.
//   ‚Ä¢ Manage communication channels between Rust async tasks and Godot runtime.
//   ‚Ä¢ Render generated chunks into a Godot `TileMap`.
//   ‚Ä¢ Expose methods and signals for Godot scripts to interact with the engine.
//
// Key Components:
//   ‚Ä¢ Feature Flag
//       - `#![feature(int_roundings)]` enables nightly integer division helpers
//         like `div_ceil`, used for chunk calculations.
//
//   ‚Ä¢ Imports
//       - Godot prelude, Node, TileMap, INode trait for GDExtension integration.
//       - Tokio channels for async task communication.
//       - `tracing` for structured logging.
//       - SSXL subsystems: `Conductor`, `ConductorState`, `GenerationTask`,
//         `GenerationMessage`, math utilities, and shared constants.
//
//   ‚Ä¢ create_dummy_engine_state
//       - Provides a fallback engine state if the Conductor fails to start.
//       - Ensures the node remains valid even without generation capability.
//
//   ‚Ä¢ SSXLEngine Struct
//       - Annotated with `#[derive(GodotClass)]` to register as a Godot node.
//       - Fields:
//           ‚Ä¢ base: underlying Godot Node.
//           ‚Ä¢ conductor: orchestrates generation tasks.
//           ‚Ä¢ request_sender: channel for sending tasks.
//           ‚Ä¢ progress_rx: channel for receiving updates.
//           ‚Ä¢ tilemap: optional Godot TileMap reference.
//           ‚Ä¢ state: conductor state tracking activity.
//
//   ‚Ä¢ INode Implementation
//       - `init`: initializes shared data, starts conductor, or falls back.
//       - `process`: runs every frame, consumes progress messages, applies
//         generated chunks to the TileMap, and emits signals.
//       - `exit_tree`: gracefully shuts down conductor when node is removed.
//
//   ‚Ä¢ Public Methods
//       - `set_tilemap`: assigns a Godot TileMap for rendering.
//       - `build_map`: schedules generation tasks for a given width/height,
//         dividing into chunks using `div_ceil`.
//       - `is_active`: checks conductor activity state.
//       - `chunk_applied`: signal emitted when a chunk is rendered.
//
//   ‚Ä¢ Extension Entry Point
//       - `SSXLExtension` struct implements `ExtensionLibrary` to register
//         the engine node with Godot.
//
// Workflow:
//   1. Godot instantiates `SSXLEngine` as a node.
//   2. Rust initializes conductor and shared resources.
//   3. Godot requests map generation via `build_map`.
//   4. Rust sends tasks, processes updates, and applies chunks to TileMap.
//   5. Signals notify Godot scripts when chunks are applied.
//   6. Node shuts down gracefully when removed.
//
// Design Choices:
//   ‚Ä¢ Async channels decouple generation tasks from rendering loop.
//   ‚Ä¢ Arc ensures safe sharing of chunk data across threads.
//   ‚Ä¢ Signals provide a clean Godot-side API for reacting to generation events.
//   ‚Ä¢ Fallback dummy state prevents crashes if conductor initialization fails.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can extend Godot with high-performance
//     procedural generation, while maintaining safe concurrency and ergonomic
//     scripting interfaces.
//   ‚Ä¢ By combining async task orchestration with Godot signals, developers gain
//     a powerful workflow for integrating complex systems into game engines.
// ============================================================================


#![feature(int_roundings)]

use godot::{
    prelude::*,
    classes::{Node, TileMap, INode},
    obj::{Base, Gd},
};

use std::sync::Arc;
use tokio::sync::mpsc::{
    channel,
    Receiver,
    UnboundedSender,
    unbounded_channel,
    error::TryRecvError
};
use tracing::{info, error, Level, span};

use ssxl_generate::Conductor;
use ssxl_generate::conductor::ConductorState;
use ssxl_generate::task::task_queue::{GenerationMessage, GenerationTask};

use ssxl_math::prelude::Vec2i;
use ssxl_shared::{initialize_shared_data, CHUNK_SIZE};

fn create_dummy_engine_state(base: Base<Node>) -> SSXLEngine {
    let (dummy_tx, _) = unbounded_channel();
    let (_, dummy_rx) = channel(1);

    SSXLEngine {
        base,
        conductor: None,
        state: ConductorState::new(String::new()),
        request_sender: dummy_tx,
        progress_rx: dummy_rx,
        tilemap: None,
    }
}

#[derive(GodotClass)]
#[class(base = Node)]
pub struct SSXLEngine {
    base: Base<Node>,
    conductor: Option<Conductor>,
    request_sender: UnboundedSender<GenerationTask>,
    progress_rx: Receiver<GenerationMessage>,
    tilemap: Option<Gd<TileMap>>,
    state: ConductorState,
}

#[godot_api]
impl INode for SSXLEngine {
    fn init(base: Base<Node>) -> Self {
        let _span = span!(Level::INFO, "SSXLEngine::init").entered();

        initialize_shared_data();

        match Conductor::new(None) {
            Ok((conductor, state, request_sender, progress_rx)) => {
                info!("SSXLEngine ‚Üí Conductor ONLINE");
                Self {
                    base,
                    conductor: Some(conductor),
                    state,
                    request_sender,
                    progress_rx,
                    tilemap: None,
                }
            }
            Err(e) => {
                error!("Failed to start Conductor: {:?}", e);
                create_dummy_engine_state(base)
            }
        }
    }

    fn process(&mut self, _delta: f64) {
        loop {
            let message = match self.progress_rx.try_recv() {
                Ok(msg) => msg,
                Err(TryRecvError::Empty) => break,
                Err(e) => {
                    error!("Progress channel error: {:?}", e);
                    break;
                }
            };

            match message {
                GenerationMessage::Generated(key, chunk_data) => {
                    let Some(tilemap) = self.tilemap.as_mut() else { continue; };

                    let origin_x = (key.x as i32) * CHUNK_SIZE as i32;
                    let origin_y = (key.y as i32) * CHUNK_SIZE as i32;
                    let layer = 0;

                    let tiles = Arc::try_unwrap(chunk_data)
                        .unwrap_or_else(|arc| (*arc).clone())
                        .tiles;

                    for (idx, _tile) in tiles.iter().enumerate() {
                        let local_x = (idx as u32 % CHUNK_SIZE) as i32;
                        let local_y = (idx as u32 / CHUNK_SIZE) as i32;

                        let world_x = origin_x + local_x;
                        let world_y = origin_y + local_y;

                        tilemap.set_cell(
                            layer,
                            Vector2i::new(world_x, world_y),
                        );
                    }

                    self.base_mut().emit_signal(
                        "chunk_applied",
                        &[key.x.to_variant(), key.y.to_variant()],
                    );
                }

                GenerationMessage::GenerationComplete => {
                    info!("Generation Task Queue signaled completion.");
                }

                GenerationMessage::StatusUpdate(status) => {
                    info!("Generation status update: {}", status);
                }
            }
        }
    }

    fn exit_tree(&mut self) {
        if let Some(conductor) = self.conductor.take() {
            conductor.signal_shutdown_graceful();
        }
    }
}

#[godot_api]
impl SSXLEngine {
    #[func]
    pub fn set_tilemap(&mut self, tilemap: Gd<TileMap>) {
        self.tilemap = Some(tilemap);
    }

    #[func]
    pub fn build_map(&self, width: i32, height: i32, generator_id: GString) {
        if self.request_sender.is_closed() {
            error!("Conductor is shut down. Cannot request map.");
            return;
        }

        let chunks_x = width.div_ceil(CHUNK_SIZE as i32);
        let chunks_y = height.div_ceil(CHUNK_SIZE as i32);

        for x in 0..chunks_x {
            for y in 0..chunks_y {
                let task = GenerationTask {
                    chunk_coords: Vec2i::new(x as i64, y as i64),
                    generator_id: generator_id.to_string(),
                };
                let _ = self.request_sender.send(task);
            }
        }

        info!("Sent {} generation tasks.", chunks_x * chunks_y);
    }

    #[func]
    pub fn is_active(&self) -> bool {
        self.state.is_active()
    }

    #[signal]
    fn chunk_applied(key_x: i64, key_y: i64);
}

struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {}

// --- END: rust/ssxl_engine_ffi/src\lib.rs ---
       123 LOC | rust/ssxl_generate/src\ca\cellular_automata_generator.rs
// --- START: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
// ============================================================================
// üß© SSXL Cellular Automata Generator (`ssxl_generate::ca_generator`)
// ----------------------------------------------------------------------------
// This module implements a procedural generation algorithm based on Cellular
// Automata (CA). It is responsible for producing chunk data (tile grids) that
// simulate cave-like, maze-like, or static patterns depending on the ruleset.
//
// Purpose:
//   ‚Ä¢ Provide a flexible generator that can evolve tile states using CA rules.
//   ‚Ä¢ Support both iterative simulations and static pattern generation.
//   ‚Ä¢ Ensure deterministic results by seeding a PRNG with chunk coordinates.
//
// Key Components:
//   ‚Ä¢ Constants
//       - CA_ITERATIONS: number of iterations to stabilize the CA pattern.
//       - INITIAL_FILL_PERCENT: percentage of tiles initially seeded as Rock.
//
//   ‚Ä¢ CellularAutomataGenerator
//       - Struct holding a numeric ruleset ID.
//       - Provides `new` constructor for initialization.
//       - Implements the `Generator` trait for integration with the engine.
//
//   ‚Ä¢ generate_static_pattern
//       - Produces non-iterative static patterns (Solid fill, Checkerboard).
//       - Bypasses CA simulation for efficiency.
//       - Builds chunk data directly from ruleset logic.
//
//   ‚Ä¢ run_ca_simulation
//       - Executes iterative CA simulation using double-buffering.
//       - For each tile, counts live neighbors and applies ruleset logic.
//       - Swaps buffers after each iteration to evolve the state.
//       - Logs progress after each iteration.
//
//   ‚Ä¢ Generator Trait Implementation
//       - `id`: returns a string identifier for the generator based on ruleset.
//       - `generate_chunk`: orchestrates chunk generation workflow:
//           1. Logs start of generation.
//           2. Handles static rulesets directly.
//           3. Seeds PRNG deterministically from chunk coordinates.
//           4. Builds initial randomized tile state.
//           5. Runs CA simulation to evolve state.
//           6. Returns final chunk data.
//
// Workflow:
//   1. A chunk coordinate is passed to `generate_chunk`.
//   2. If ruleset is static, generate a direct pattern.
//   3. Otherwise, seed PRNG and build randomized initial state.
//   4. Run CA iterations to evolve tile states.
//   5. Return final `ChunkData` for rendering or further processing.
//
// Design Choices:
//   ‚Ä¢ Deterministic seeding ensures reproducible worlds across runs.
//   ‚Ä¢ Double-buffering avoids in-place mutation errors during CA iteration.
//   ‚Ä¢ Static patterns allow efficient bypass for simple rulesets.
//   ‚Ä¢ Logging (`tracing`) provides visibility into generation steps.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata are widely used in procedural generation for caves,
//     dungeons, and organic structures.
//   ‚Ä¢ This implementation demonstrates how Rust can combine deterministic PRNG,
//     efficient memory handling, and modular design to produce complex,
//     reproducible terrain patterns.
// ============================================================================


use crate::Generator;
use ssxl_math::prelude::Vec2i;
use fastrand;
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

const CA_ITERATIONS: u8 = 4;
const INITIAL_FILL_PERCENT: u8 = 45;

pub struct CellularAutomataGenerator {
    ruleset: u8,
}

impl CellularAutomataGenerator {
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;

    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;

    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );

    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };

    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    if (x + y) % 2 == 0 { TileType::Rock } else { TileType::Void }
                }
                _ => TileType::Void,
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    let mut target_tiles = chunk_data.tiles.clone();

    for i in 0..CA_ITERATIONS {
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;

                let current_tile = &chunk_data.tiles[index];

                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }

        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        info!("CA Generator: Iteration {} complete.", i + 1);
    }

    chunk_data
}

impl Generator for CellularAutomataGenerator {
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);

        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;
            let tile_type = if is_rock { TileType::Rock } else { TileType::Void };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles_vec);

        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}

// --- END: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
         3 LOC | rust/ssxl_generate/src\ca\mod.rs
// --- START: rust/ssxl_generate/src\ca\mod.rs ---
// ============================================================================
// üß© Cellular Automata Module (`crate::ca`)
// ----------------------------------------------------------------------------
// This module serves as the entry point for the Cellular Automata (CA) system
// within the SSXL engine. It organizes and exposes submodules that implement
// different aspects of CA-based procedural generation.
//
// Purpose:
//   ‚Ä¢ Provide a modular, extensible framework for CA-driven terrain and structure generation.
//   ‚Ä¢ Separate concerns into distinct submodules for clarity and maintainability.
//   ‚Ä¢ Expose a clean public API surface so other parts of the engine can access
//     CA functionality via `crate::ca::<submodule>`.
//
// Submodules:
//   ‚Ä¢ cellular_automata_generator
//       - Contains the `CellularAutomataGenerator` struct.
//       - Implements the `Generator` trait for CA-based chunk generation.
//       - Responsible for seeding chunks, running CA iterations, and producing
//         final `ChunkData`.
//
//   ‚Ä¢ rule_set
//       - Defines specific CA rulesets (e.g., Solid fill, Checkerboard, Basic Cave, Maze).
//       - Encapsulates logic for determining the next tile type based on current
//         state and neighbor counts.
//       - Enables experimentation and swapping of rule sets without changing
//         generator logic.
//
//   ‚Ä¢ neighbor_check
//       - Provides low-level functions for inspecting tile neighbors.
//       - Example: `count_live_neighbors` counts adjacent Rock tiles.
//       - Supplies local state information to the `rule_set` logic.
//       - Keeps neighborhood definitions modular (e.g., Moore vs. Von Neumann).
//
// Workflow:
//   1. The generator seeds a chunk with initial tile states.
//   2. Neighbor checks provide local context for each tile.
//   3. Rule sets apply CA logic to evolve tile states.
//   4. The generator produces final chunk data for rendering or simulation.
//
// Design Choices:
//   ‚Ä¢ Modular submodules improve readability and allow independent evolution.
//   ‚Ä¢ Clear separation of generator, rules, and neighbor logic supports reuse
//     and experimentation.
//   ‚Ä¢ Public module declarations (`pub mod`) ensure external access to CA
//     components while maintaining internal organization.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata are a powerful tool for procedural generation,
//     producing organic, cave-like, or maze-like structures.
//   ‚Ä¢ This module demonstrates how Rust‚Äôs module system can be leveraged to
//     build a clean, extensible architecture for complex algorithms.
// ============================================================================


pub mod cellular_automata_generator;
pub mod rule_set;
pub mod neighbor_check;

// --- END: rust/ssxl_generate/src\ca\mod.rs ---
        25 LOC | rust/ssxl_generate/src\ca\neighbor_check.rs
// --- START: rust/ssxl_generate/src\ca\neighbor_check.rs ---
// ============================================================================
// üß© Cellular Automata Utility: Neighbor Check (`count_live_neighbors`)
// ----------------------------------------------------------------------------
// This module provides a helper function for the Cellular Automata (CA)
// subsystem of the SSXL engine. It inspects the local neighborhood of a tile
// within a chunk and counts how many surrounding tiles are "live" (defined as
// `TileType::Rock`). This information is critical for applying CA rulesets
// that evolve terrain patterns.
//
// Purpose:
//   ‚Ä¢ Support CA simulation by providing local neighbor counts.
//   ‚Ä¢ Implement a 3x3 Moore neighborhood (8 surrounding cells).
//   ‚Ä¢ Handle boundary conditions safely to avoid out-of-bounds indexing.
//
// Function: count_live_neighbors
//   ‚Ä¢ Arguments:
//       - `chunk_data`: reference to the chunk‚Äôs tile data.
//       - `cx`: X coordinate of the center cell (0..CHUNK_SIZE-1).
//       - `cy`: Y coordinate of the center cell (0..CHUNK_SIZE-1).
//   ‚Ä¢ Returns:
//       - `u8` count of live neighbors (0‚Äì8).
//
// Workflow:
//   1. Convert center coordinates to signed integers for arithmetic.
//   2. Iterate over relative offsets (dx, dy) in the range -1..=1.
//   3. Skip the center cell itself.
//   4. Compute neighbor coordinates and check boundaries.
//   5. If inside bounds, compute linear index into the tile array.
//   6. Increment count if neighbor tile is `TileType::Rock`.
//   7. Return total count.
//
// Design Choices:
//   ‚Ä¢ Uses signed arithmetic (`i32`) for safe offset calculations.
//   ‚Ä¢ Boundary checks prevent invalid indexing at chunk edges.
//   ‚Ä¢ Linear indexing formula (`y * CHUNK_SIZE + x`) ensures efficient lookup.
//   ‚Ä¢ Returns `u8` since maximum neighbor count is 8.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how to implement neighborhood checks in
//     Cellular Automata systems.
//   ‚Ä¢ By separating neighbor counting from rule application, the design remains
//     modular and extensible (e.g., supporting different neighborhood types).
// ============================================================================


use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;

    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    for dx in -1..=1 {
        for dy in -1..=1 {
            if dx == 0 && dy == 0 {
                continue;
            }

            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;

                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }

    count
}

// --- END: rust/ssxl_generate/src\ca\neighbor_check.rs ---
        28 LOC | rust/ssxl_generate/src\ca\rule_set.rs
// --- START: rust/ssxl_generate/src\ca\rule_set.rs ---
// ============================================================================
// üß© Cellular Automata Rule Set (`crate::ca::rule_set`)
// ----------------------------------------------------------------------------
// This module defines the rulesets and transition logic for the Cellular
// Automata (CA) subsystem of the SSXL engine. It determines how tiles evolve
// from one generation to the next based on their current state and the number
// of live neighbors.
//
// Purpose:
//   ‚Ä¢ Provide reusable constants for identifying different CA rulesets.
//   ‚Ä¢ Implement the core transition function (`get_next_tile_type`) that applies
//     Birth/Survival rules to evolve tile states.
//   ‚Ä¢ Support multiple terrain generation styles (caves, mazes, static fills).
//
// Rule Set Identifiers:
//   ‚Ä¢ RULE_BASIC_CAVE (0)
//       - Birth: 4‚Äì5 neighbors
//       - Survival: 1‚Äì7 neighbors
//       - Produces large, open cave-like structures.
//   ‚Ä¢ RULE_MAZE (1)
//       - Birth: exactly 3 neighbors
//       - Survival: 1‚Äì4 neighbors
//       - Produces thin, winding maze-like corridors.
//   ‚Ä¢ RULE_SOLID (2)
//       - Static rule: fills all tiles with Rock.
//   ‚Ä¢ RULE_CHECKERBOARD (3)
//       - Static rule: alternates Rock/Void in a checkerboard pattern.
//
// Function: get_next_tile_type
//   ‚Ä¢ Arguments:
//       - current_type: current tile state (`TileType`).
//       - live_neighbors: number of Rock neighbors (0‚Äì8).
//       - ruleset: identifier for which ruleset to apply.
//   ‚Ä¢ Returns:
//       - Next tile state (`TileType`).
//
// Workflow:
//   1. Select Birth/Survival ranges based on ruleset.
//   2. If tile is Rock (alive):
//        - Survives if neighbor count is within survival range.
//        - Otherwise becomes Void.
//   3. If tile is Void (dead):
//        - Becomes Rock if neighbor count is within birth range.
//        - Otherwise remains Void.
//   4. Other tile types (e.g., Water, Ore) remain unchanged.
//
// Design Choices:
//   ‚Ä¢ Encapsulates ruleset logic in a single function for clarity.
//   ‚Ä¢ Uses pattern matching to separate Rock/Void cases.
//   ‚Ä¢ Birth/Survival ranges are defined per ruleset for flexibility.
//   ‚Ä¢ Supports extensibility: new rulesets can be added easily.
//
// Educational Note:
//   ‚Ä¢ Cellular Automata rulesets are often expressed in "B/S notation"
//     (e.g., B3/S1-4 for Maze, B4-5/S1-7 for Cave).
//   ‚Ä¢ This function demonstrates how to translate those rules into Rust logic,
//     enabling reproducible terrain generation across chunks.
// ============================================================================


use ssxl_shared::TileType;

pub const RULE_BASIC_CAVE: u8 = 0;
pub const RULE_MAZE: u8 = 1;
pub const RULE_SOLID: u8 = 2;
pub const RULE_CHECKERBOARD: u8 = 3;

pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7),
    };

    match current_type {
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                TileType::Void
            }
        }
        _ => current_type,
    }
}

// --- END: rust/ssxl_generate/src\ca\rule_set.rs ---
        76 LOC | rust/ssxl_generate/src\conductor\builder.rs
// --- START: rust/ssxl_generate/src\conductor\builder.rs ---
// ============================================================================
// üéº Conductor Setup and Spawn (`crate::conductor::setup`)
// ----------------------------------------------------------------------------
// This module provides the initialization and spawning logic for the SSXL
// Conductor, the central orchestrator of procedural generation tasks. It
// prepares channels, managers, and state, then launches the asynchronous
// request loop that drives chunk generation.
//
// Purpose:
//   ‚Ä¢ Bundle together configuration, managers, channels, and initial state.
//   ‚Ä¢ Provide a clean entry point for starting the Conductor runtime.
//   ‚Ä¢ Ensure safe, modular setup of async communication and caching systems.
//
// Key Components:
//   ‚Ä¢ PROGRESS_CHANNEL_BOUND
//       - Defines bounded capacity for the progress channel.
//       - Prevents unbounded queuing of progress messages, applying backpressure.
//
//   ‚Ä¢ setup_channels_and_state
//       - Loads configuration from a file path (or defaults).
//       - Initializes the GeneratorManager, which tracks available generators.
//       - Creates bounded progress channel for updates and unbounded request
//         channel for chunk generation tasks.
//       - Determines initial generator ID from config.
//       - Creates initial ConductorState with that ID.
//       - Returns a `ConductorInternalSetup` bundle containing all components.
//
//   ‚Ä¢ spawn
//       - Consumes `ConductorInternalSetup` and spawns the async request loop.
//       - Initializes a RuntimeManager (Tokio runtime wrapper).
//       - Clones generator map and creates a chunk cache (LRU, capacity 4096).
//       - Marks conductor state as running.
//       - Starts the async request loop with runtime handle, channels, generators,
//         cache, and state.
//       - Constructs a `Conductor` instance with runtime, managers, state, cache,
//         and channels.
//       - Returns tuple: (Conductor, ConductorState, request sender, progress receiver).
//
// Workflow:
//   1. `setup_channels_and_state` prepares configuration, managers, channels, and state.
//   2. `spawn` consumes setup bundle and starts async request loop.
//   3. Conductor instance is returned, ready to manage generation tasks.
//   4. Progress updates flow through bounded channel; requests flow through unbounded channel.
//   5. Chunk cache ensures efficient reuse of generated chunks.
//
// Design Choices:
//   ‚Ä¢ Separation of setup and spawn improves modularity and testability.
//   ‚Ä¢ Bounded progress channel prevents overload; unbounded request channel ensures flexibility.
//   ‚Ä¢ Arc-based sharing allows safe concurrent access to generators, cache, and state.
//   ‚Ä¢ Logging provides visibility into initialization and runtime events.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to structure async orchestration in Rust,
//     combining configuration, state management, channels, and runtime spawning.
//   ‚Ä¢ By encapsulating setup and spawn logic, the Conductor remains extensible
//     and maintainable, supporting complex procedural generation workflows.
// ============================================================================


use super::{conductor_state, Conductor};
use super::internal_setup::ConductorInternalSetup; 

use crate::manager::{GeneratorManager, RuntimeManager};
use crate::task::{start_request_loop, GenerationMessage, GenerationTask as ChunkRequest};
use ssxl_cache::ChunkCache;
use ssxl_shared::config::config::get_config_from_path;
use tokio::sync::mpsc::{self, Receiver, UnboundedSender};
use tracing::info;
use std::io;
use std::sync::Arc;

const PROGRESS_CHANNEL_BOUND: usize = 1024;

pub(crate) fn setup_channels_and_state(
    config_path: Option<&str>,
) -> Result<ConductorInternalSetup, io::Error> {
    let config = get_config_from_path(config_path);

    let generator_manager = GeneratorManager::new().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
    })?;

    let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
    let (request_sender_api, request_receiver) = mpsc::unbounded_channel();

    let initial_id = generator_manager.get_initial_id(&config.default_generator_id());
    let initial_state = conductor_state::ConductorState::new(initial_id.clone());

    info!("Conductor initialized. Active generator: {}", initial_id);

    Ok(ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    })
}

pub(crate) fn spawn(
    internal_setup: ConductorInternalSetup,
) -> Result<
    (
        Conductor,
        conductor_state::ConductorState,
        UnboundedSender<ChunkRequest>,
        Receiver<GenerationMessage>,
    ),
    io::Error,
> {
    let ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    } = internal_setup;

    let runtime_manager = RuntimeManager::new()?;
    let handle = runtime_manager.get_handle();

    let generators_for_loop = Arc::new(generator_manager.get_map_clone());
    let chunk_cache = Arc::new(ChunkCache::new(4096)?);
    let chunk_cache_for_loop = chunk_cache.clone();

    initial_state.set_status(conductor_state::ConductorStatus::Running);
    let state_for_loop = initial_state.clone();

    start_request_loop(
        handle,
        request_receiver,
        progress_sender.clone(),
        generators_for_loop,
        chunk_cache_for_loop,
        Arc::new(state_for_loop),
    );

    let conductor = Conductor {
        runtime_manager,
        generator_manager,
        internal_state: initial_state.clone(),
        chunk_cache,
        progress_sender,
        _request_sender: request_sender_api.clone(),
    };

    Ok((conductor, initial_state, request_sender_api, progress_receiver))
}

// --- END: rust/ssxl_generate/src\conductor\builder.rs ---
        79 LOC | rust/ssxl_generate/src\conductor\conductor.rs
// --- START: rust/ssxl_generate/src\conductor\conductor.rs ---
// ============================================================================
// üéº Conductor Module (`crate::conductor`)
// ----------------------------------------------------------------------------
// The Conductor is the central orchestrator of the SSXL engine‚Äôs procedural
// generation system. It manages runtime execution, generator selection,
// communication channels, and caching of generated chunks.
//
// Purpose:
//   ‚Ä¢ Provide a unified interface for starting, controlling, and shutting down
//     the generation system.
//   ‚Ä¢ Manage async communication between generation tasks and the engine.
//   ‚Ä¢ Track conductor state (active generator, lifecycle status).
//   ‚Ä¢ Expose constructors for both internal use and FFI integration.
//
// Key Components:
//   ‚Ä¢ Conductor Struct
//       - Holds references to:
//           ‚Ä¢ RuntimeManager: manages the async runtime.
//           ‚Ä¢ GeneratorManager: manages available generator instances.
//           ‚Ä¢ ConductorState: tracks active generator and lifecycle status.
//           ‚Ä¢ ChunkCache: shared cache for generated chunks.
//           ‚Ä¢ progress_sender: channel for sending progress updates.
//           ‚Ä¢ _request_sender: channel for sending chunk generation requests.
//
//   ‚Ä¢ Constructors
//       - `new`
//           ‚Ä¢ Initializes conductor with channels and state.
//           ‚Ä¢ Returns tuple: (Conductor, ConductorState, request sender, progress receiver).
//       - `new_for_ffi`
//           ‚Ä¢ Specialized for external bindings (FFI).
//           ‚Ä¢ Returns tuple: (Conductor, ConductorState, command sender, response receiver, progress receiver).
//
//   ‚Ä¢ Control Methods
//       - `get_active_generator_id`: returns ID of currently active generator.
//       - `set_generator`: switches active generator and logs the change.
//       - `stop_generation`: signals conductor to stop generation tasks.
//       - `graceful_teardown`: consumes conductor, shuts down runtime gracefully.
//       - `signal_shutdown_graceful`: signals shutdown without consuming conductor.
//       - `request_shutdown`: signals shutdown and stops runtime.
//
// Workflow:
//   1. Conductor is created via `new` or `new_for_ffi`.
//   2. Async request loop is spawned, handling chunk generation tasks.
//   3. Progress updates flow through bounded channels; requests flow through unbounded channels.
//   4. Conductor methods allow switching generators, stopping tasks, or shutting down gracefully.
//
// Design Choices:
//   ‚Ä¢ Separation of constructors for internal vs. FFI use improves flexibility.
//   ‚Ä¢ Arc-based cache ensures safe concurrent access to generated chunks.
//   ‚Ä¢ Logging provides visibility into generator changes and lifecycle events.
//   ‚Ä¢ Explicit shutdown methods prevent resource leaks and ensure graceful teardown.
//
// Educational Note:
//   ‚Ä¢ The Conductor demonstrates how to structure a central orchestrator in Rust,
//     combining async runtime management, modular generators, and safe concurrency.
//   ‚Ä¢ By exposing clear constructors and lifecycle controls, it provides a robust
//     foundation for procedural generation workflows in game engines or simulations.
// ============================================================================


use crate::conductor::builder::{setup_channels_and_state, spawn};

use ssxl_cache::ChunkCache;
use ssxl_shared::message::{GenerationCommand, GenerationResponse};

use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver};

use tracing::info;
use std::error::Error;
use std::io;
use std::sync::Arc;

use crate::manager::runtime_manager::RuntimeManager;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};

use crate::conductor::conductor_state::{self, ConductorState};

pub struct Conductor {
    pub(crate) runtime_manager: RuntimeManager,
    pub(crate) generator_manager: GeneratorManager,
    pub(crate) internal_state: conductor_state::ConductorState,
    pub(crate) chunk_cache: Arc<ChunkCache>,
    pub progress_sender: tokio::sync::mpsc::Sender<GenerationMessage>,
    #[allow(dead_code)]
    pub(crate) _request_sender: UnboundedSender<ChunkRequest>,
}

impl Conductor {
    pub fn new(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<ChunkRequest>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        spawn(setup)
    }

    pub fn new_for_ffi(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<GenerationCommand>,
            UnboundedReceiver<GenerationResponse>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        let (conductor, state, _req_tx, progress_rx) = spawn(setup)?;
        let (cmd_tx, _) = tokio::sync::mpsc::unbounded_channel();
        let (_, resp_rx) = tokio::sync::mpsc::unbounded_channel();
        Ok((conductor, state, cmd_tx, resp_rx, progress_rx))
    }

    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    pub fn set_generator(&mut self, id: &str) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_active_generator_id(id);
        info!("Active generator switched to: {}", id);
        Ok(())
    }

    pub fn stop_generation(&self) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Global stop requested.");
        Ok(())
    }

    pub fn graceful_teardown(self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
        self.runtime_manager.shutdown_graceful();
        info!("Conductor gracefully shut down.");
    }

    pub fn signal_shutdown_graceful(&self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor.rs ---
        58 LOC | rust/ssxl_generate/src\conductor\conductor_state.rs
// --- START: rust/ssxl_generate/src\conductor\conductor_state.rs ---
// ============================================================================
// üéº Conductor State Management (`crate::conductor::conductor_state`)
// ----------------------------------------------------------------------------
// This module defines the lifecycle state and shared state container for the
// Conductor, the central orchestrator of SSXL‚Äôs procedural generation system.
// It provides thread-safe, atomic access to conductor status, queue depth,
// active generator ID, and tile counters.
//
// Purpose:
//   ‚Ä¢ Represent the lifecycle phases of the Conductor (initializing, running,
//     generating, stopping, shutting down, error).
//   ‚Ä¢ Maintain shared state across async tasks and threads safely.
//   ‚Ä¢ Provide atomic counters and resources for concurrent mutation.
//   ‚Ä¢ Expose getters and mutators for monitoring and controlling conductor state.
//
// Key Components:
//   ‚Ä¢ ConductorStatus (enum)
//       - Represents lifecycle phases:
//           ‚Ä¢ Initializing: conductor is starting up.
//           ‚Ä¢ Running: actively processing tasks.
//           ‚Ä¢ Paused: temporarily halted.
//           ‚Ä¢ Generating: actively generating chunks.
//           ‚Ä¢ Stopping: graceful stop requested.
//           ‚Ä¢ ShuttingDown: final shutdown in progress.
//           ‚Ä¢ Error: fault state encountered.
//
//   ‚Ä¢ ConductorState (struct)
//       - Holds shared state with atomic safety:
//           ‚Ä¢ status: current lifecycle status.
//           ‚Ä¢ queue_depth: number of pending tasks.
//           ‚Ä¢ active_generator_id: ID of currently active generator.
//           ‚Ä¢ tile_counter: total number of tiles placed/generated.
//       - Designed for concurrent access across async tasks and threads.
//
//   ‚Ä¢ Implementation Methods
//       - new: constructs initial state with defaults.
//       - get_status: returns current lifecycle status.
//       - is_active: checks if conductor is in an active state (Running/Generating).
//       - get_queue_depth: returns number of tasks in queue.
//       - get_tiles_placed: returns total tiles placed/generated.
//       - get_active_generator_id: returns active generator ID.
//       - increment_queue_depth / decrement_queue_depth: adjust queue depth atomically.
//       - increment_tile_count: increase tile counter by specified amount.
//       - set_status: update lifecycle status.
//       - set_active_generator_id: update active generator ID.
//
// Workflow:
//   1. ConductorState is created with initial generator ID.
//   2. Async tasks increment/decrement queue depth as tasks are added/completed.
//   3. Tile counter tracks total tiles generated across tasks.
//   4. Status transitions reflect conductor lifecycle (e.g., Running ‚Üí Stopping).
//   5. Active generator ID can be switched dynamically.
//
// Design Choices:
//   ‚Ä¢ AtomicResource provides safe concurrent read/write for complex types.
//   ‚Ä¢ Arc + AtomicUsize/AtomicU64 ensure thread-safe counters.
//   ‚Ä¢ Relaxed ordering is used for performance where strict ordering isn‚Äôt required.
//   ‚Ä¢ Clear separation of getters and mutators improves readability and control.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to design thread-safe state containers in Rust,
//     combining atomic primitives with Arc for shared ownership.
//   ‚Ä¢ By encapsulating lifecycle and counters, it provides a robust foundation
//     for orchestrating async procedural generation workflows.
// ============================================================================


use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,
    Running,
    Paused,
    Generating,
    Stopping,
    ShuttingDown,
    Error,
}

#[derive(Clone)]
pub struct ConductorState {
    status: AtomicResource<ConductorStatus>,
    queue_depth: Arc<AtomicUsize>,
    active_generator_id: AtomicResource<String>,
    tile_counter: Arc<AtomicU64>,
}

impl ConductorState {
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: AtomicResource::new(ConductorStatus::Initializing),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: AtomicResource::new(initial_generator_id),
            tile_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
    }
    
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    pub fn get_active_generator_id(&self) -> String {
        self.active_generator_id.read().clone()
    }

    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    pub fn decrement_queue_depth(&self) {
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
    }

    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor_state.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\internal_setup.rs
// --- START: rust/ssxl_generate/src\conductor\internal_setup.rs ---
// ============================================================================
// üéº Conductor Internal Setup (`crate::conductor::internal_setup`)
// ----------------------------------------------------------------------------
// This module defines the `ConductorInternalSetup` struct, a bundle of all
// internal components required to initialize and run the Conductor. It acts
// as a "setup package" that can be passed between modules to ensure consistent
// initialization of channels, state, and managers.
//
// Purpose:
//   ‚Ä¢ Encapsulate all dependencies needed to start the Conductor runtime.
//   ‚Ä¢ Provide a clean, modular way to prepare async channels and state.
//   ‚Ä¢ Simplify spawning of the Conductor by bundling setup into one struct.
//
// Key Components:
//   ‚Ä¢ request_receiver
//       - UnboundedReceiver for incoming chunk generation requests.
//       - Consumed by the async request loop to process tasks.
//
//   ‚Ä¢ progress_sender
//       - Bounded Sender for progress updates.
//       - Ensures backpressure when too many updates are queued.
//
//   ‚Ä¢ request_sender_api
//       - UnboundedSender exposed to external modules.
//       - Allows API or other systems to submit chunk generation requests.
//
//   ‚Ä¢ progress_receiver
//       - Bounded Receiver for progress updates.
//       - Enables monitoring or reporting of generation progress.
//
//   ‚Ä¢ initial_state
//       - ConductorState tracking lifecycle status, queue depth,
//         active generator ID, and tile counters.
//       - Provides thread-safe, atomic access for concurrent tasks.
//
//   ‚Ä¢ generator_manager
//       - Manages available generator instances and their configurations.
//       - Provides access to generator logic during request loop execution.
//
// Workflow:
//   1. `setup_channels_and_state` constructs a `ConductorInternalSetup` bundle.
//   2. The bundle is passed into `spawn`, which consumes it to start the async
//      request loop and build a Conductor instance.
//   3. Channels handle communication between tasks and progress reporting.
//   4. State and managers ensure consistent orchestration of generation logic.
//
// Design Choices:
//   ‚Ä¢ Bundling setup into a single struct improves clarity and reduces boilerplate.
//   ‚Ä¢ Separation of bounded vs. unbounded channels balances flexibility with safety.
//   ‚Ä¢ Explicit inclusion of state and managers ensures all dependencies are tracked.
//
// Educational Note:
//   ‚Ä¢ This struct demonstrates how Rust can encapsulate complex initialization
//     logic into a single, reusable package.
//   ‚Ä¢ By centralizing setup, the Conductor remains modular, testable, and easy
//     to extend with new components or channels.
// ============================================================================


use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver, Sender};

pub(crate) struct ConductorInternalSetup {
    pub request_receiver: UnboundedReceiver<ChunkRequest>,
    pub progress_sender: Sender<GenerationMessage>,
    pub request_sender_api: UnboundedSender<ChunkRequest>,
    pub progress_receiver: Receiver<GenerationMessage>,
    pub initial_state: ConductorState,
    pub generator_manager: GeneratorManager,
}

// --- END: rust/ssxl_generate/src\conductor\internal_setup.rs ---
         9 LOC | rust/ssxl_generate/src\conductor\mod.rs
// --- START: rust/ssxl_generate/src\conductor\mod.rs ---
// ============================================================================
// üéº Conductor Module Declaration (`crate::conductor`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the
// Conductor system. It organizes submodules and re-exports key items so that
// other parts of the crate can easily access them without needing to know the
// internal layout.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for the Conductor system.
//   ‚Ä¢ Expose submodules that implement conductor logic, state management,
//     synchronization, setup, and internal utilities.
//   ‚Ä¢ Re-export commonly used items to simplify external imports.
//
// Submodules:
//   ‚Ä¢ conductor
//       - Core Conductor struct and its implementation.
//       - Provides constructors, lifecycle controls, and FFI integration.
//   ‚Ä¢ conductor_state
//       - Defines lifecycle states (Running, Stopping, etc.).
//       - Provides thread-safe state container for queue depth, generator ID,
//         and tile counters.
//   ‚Ä¢ sync
//       - Synchronization utilities for atomic resource sharing.
//       - Ensures safe concurrent access across async tasks.
//   ‚Ä¢ builder
//       - Setup and spawn logic for initializing conductor internals.
//       - Prepares channels, managers, and state before runtime starts.
//   ‚Ä¢ sync_get
//       - Helper functions for safely retrieving synchronized values.
//       - Improves ergonomics when working with atomic resources.
//   ‚Ä¢ internal_setup
//       - Defines `ConductorInternalSetup`, a bundle of channels, state, and
//         managers used during initialization.
//
// Re-exports:
//   ‚Ä¢ Conductor
//       - The main struct orchestrating chunk generation and lifecycle control.
//   ‚Ä¢ conductor_state::*
//       - Re-exports all items from `conductor_state` (status enum, state struct).
//   ‚Ä¢ sync::*
//       - Re-exports synchronization utilities for convenience.
//
// Workflow:
//   1. External code imports from `crate::conductor`.
//   2. Submodules provide specialized functionality (state, sync, setup).
//   3. Re-exports simplify usage by exposing key items directly.
//   4. Conductor orchestrates runtime, generators, and communication channels.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex subsystems into clear, modular components.
//   ‚Ä¢ By re-exporting key items, the public API remains clean and ergonomic,
//     while internal organization stays modular and maintainable.
// ============================================================================


pub mod conductor;
pub mod conductor_state;
pub mod sync;
pub mod builder;
pub mod sync_get;
pub mod internal_setup;

pub use conductor::Conductor;
pub use conductor_state::*;
pub use sync::*;

// --- END: rust/ssxl_generate/src\conductor\mod.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\sync.rs
// --- START: rust/ssxl_generate/src\conductor\sync.rs ---
// ============================================================================
// üéº Conductor Channel Types (`crate::conductor::sync_get`)
// ----------------------------------------------------------------------------
// This module defines domain-specific wrappers and aliases for the async
// communication channels used by the Conductor system. By introducing clear,
// descriptive names, it improves readability and makes the intent of each
// channel explicit.
//
// Purpose:
//   ‚Ä¢ Provide a type alias for request-sending channels to simplify usage.
//   ‚Ä¢ Wrap progress-receiving channels in a dedicated struct for clarity.
//   ‚Ä¢ Ensure that communication between tasks and the Conductor is both
//     ergonomic and domain-specific.
//
// Key Components:
//   ‚Ä¢ ConductorRequestSender (type alias)
//       - Alias for `UnboundedSender<GenerationTask>`.
//       - Represents the channel through which new chunk generation requests
//         are submitted into the Conductor system.
//       - Improves readability by avoiding repetitive generic type signatures.
//
//   ‚Ä¢ ConductorProgressReceiver (struct)
//       - Wraps a bounded `Receiver<GenerationMessage>`.
//       - Explicitly represents the channel for receiving progress updates
//         from generation tasks.
//       - Provides a constructor (`new`) for ergonomic initialization.
//
// Workflow:
//   1. External modules submit chunk generation requests via `ConductorRequestSender`.
//   2. The Conductor processes tasks asynchronously.
//   3. Progress updates are sent back through bounded channels.
//   4. `ConductorProgressReceiver` wraps the receiver, clarifying its purpose
//      as a conduit for progress messages.
//
// Design Choices:
//   ‚Ä¢ Separation of request and progress channels improves clarity.
//   ‚Ä¢ Use of type alias reduces boilerplate and emphasizes domain semantics.
//   ‚Ä¢ Wrapping the progress receiver in a struct makes its role explicit,
//     aiding maintainability and readability.
//   ‚Ä¢ Bounded vs. unbounded channels balance flexibility (requests) with
//     safety (progress updates).
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust‚Äôs type system can be leveraged to
//     create domain-specific abstractions over generic async channels.
//   ‚Ä¢ By naming and wrapping channels, developers can more easily understand
//     their purpose and avoid misuse in complex async systems.
// ============================================================================


use tokio::sync::mpsc::{Receiver, UnboundedSender};

use crate::task::task_queue::GenerationMessage;
use crate::task::task_queue::GenerationTask;

pub type ConductorRequestSender = UnboundedSender<GenerationTask>;

pub struct ConductorProgressReceiver {
    pub rx: Receiver<GenerationMessage>,
}

impl ConductorProgressReceiver {
    pub fn new(rx: Receiver<GenerationMessage>) -> Self {
        ConductorProgressReceiver { rx }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync.rs ---
        35 LOC | rust/ssxl_generate/src\conductor\sync_get.rs
// --- START: rust/ssxl_generate/src\conductor\sync_get.rs ---
// ============================================================================
// üéº Conductor Synchronous Chunk Retrieval (`Conductor::get_chunk_data`)
// ----------------------------------------------------------------------------
// This extension to the Conductor provides synchronous access to chunk data.
// While most of the Conductor system is designed around asynchronous task
// execution and streaming updates, there are scenarios where a caller needs
// immediate access to a chunk‚Äôs tile data. This method bridges that gap.
//
// Purpose:
//   ‚Ä¢ Allow synchronous retrieval of chunk data for given coordinates.
//   ‚Ä¢ Internally trigger chunk generation if data is not cached.
//   ‚Ä¢ Block until a `GenerationMessage::Generated` is received.
//   ‚Ä¢ Provide a fallback in case of channel errors.
//
// Key Components:
//   ‚Ä¢ active_generator_id
//       - Retrieved from conductor state.
//       - Determines which generator to use for chunk creation.
//
//   ‚Ä¢ temp_sender / temp_receiver
//       - Temporary bounded channel (capacity = 1).
//       - Used to send and receive the generated chunk synchronously.
//
//   ‚Ä¢ state_arc
//       - Arc-wrapped conductor state for safe sharing across tasks.
//
//   ‚Ä¢ handle_chunk_unit
//       - Core function that checks cache, generates chunk if missing,
//         and sends back a `GenerationMessage`.
//
// Workflow:
//   1. Retrieve active generator ID from conductor state.
//   2. Create a temporary bounded channel for synchronous communication.
//   3. Wrap conductor state in Arc for safe sharing.
//   4. Log the synchronous chunk request.
//   5. Call `handle_chunk_unit` to generate or fetch chunk data.
//   6. Enter blocking loop waiting for a `GenerationMessage`:
//        ‚Ä¢ If `Generated`: unwrap Arc<ChunkData> into owned ChunkData.
//        ‚Ä¢ If other message: ignore and continue waiting.
//        ‚Ä¢ If channel closed: log error and return fallback empty chunk.
//
// Design Choices:
//   ‚Ä¢ Blocking loop ensures synchronous semantics, even in async environment.
//   ‚Ä¢ Arc::try_unwrap optimizes ownership transfer; fallback clone ensures safety.
//   ‚Ä¢ Temporary channel isolates synchronous requests from async streams.
//   ‚Ä¢ Logging provides visibility into synchronous requests and errors.
//
// Educational Note:
//   ‚Ä¢ This method demonstrates how synchronous access can be layered on top of
//     an asynchronous system in Rust.
//   ‚Ä¢ By carefully using bounded channels and blocking receives, it provides
//     deterministic behavior without disrupting async workflows.
// ============================================================================


use super::Conductor;
use crate::task::{handle_chunk_unit, GenerationMessage};
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;
use std::sync::Arc;
use tokio::sync::mpsc;
use tracing::{info, error};

impl Conductor {
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();

        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        let state_arc = Arc::new(self.internal_state.clone());

        info!("Sync chunk request: {:?}", chunk_coords);

        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        loop {
            match temp_receiver.blocking_recv() {
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
                }
                Some(_) => continue,
                None => {
                    error!("Sync channel closed for {:?}", chunk_coords);
                    return ChunkData::new_at_coords(*chunk_coords);
                }
            }
        }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync_get.rs ---
        33 LOC | rust/ssxl_generate/src\lib.rs
// --- START: rust/ssxl_generate/src\lib.rs ---
// ============================================================================
// üéº SSXL Engine Crate Root (`lib.rs`)
// ----------------------------------------------------------------------------
// This file defines the core structure of the SSXL engine crate. It organizes
// all subsystems (generators, conductor, manager, tasks) and exposes a clean,
// unified public API for external use.
//
// Purpose:
//   ‚Ä¢ Serve as the entry point for the SSXL engine library.
//   ‚Ä¢ Define the `Generator` trait, the contract for all procedural generators.
//   ‚Ä¢ Organize submodules for different generation strategies and orchestration.
//   ‚Ä¢ Re-export key components to simplify external imports.
//   ‚Ä¢ Provide a placeholder runtime entry point for testing initialization.
//
// Submodules:
//   ‚Ä¢ ca
//       - Implements cellular automata generators.
//       - Provides rule-based cave/maze generation algorithms.
//   ‚Ä¢ conductor
//       - Orchestrates generator execution, task queue, and runtime lifecycle.
//       - Tracks conductor state and manages async task flow.
//   ‚Ä¢ manager
//       - Validates generator configuration (map dimensions, chunk limits).
//       - Maintains registry of available generators.
//   ‚Ä¢ perlin
//       - Implements Perlin noise generator for smooth terrain generation.
//   ‚Ä¢ task
//       - Provides task queue, batch processor, and benchmarking utilities.
//
// Trait:
//   ‚Ä¢ Generator
//       - Contract for all procedural generation algorithms.
//       - Methods:
//           ‚Ä¢ id(): returns unique identifier string.
//           ‚Ä¢ generate_chunk(): generates a chunk of terrain at given coordinates.
//
// Re-exports:
//   ‚Ä¢ CellularAutomataGenerator, PerlinGenerator
//       - Concrete generator implementations exposed at crate root.
//   ‚Ä¢ Conductor
//       - Orchestrator for runtime and task execution.
//   ‚Ä¢ GeneratorConfig
//       - Configuration validator for generator settings.
//   ‚Ä¢ ConductorProgressReceiver, ConductorRequestSender
//       - Sync interfaces for conductor communication.
//   ‚Ä¢ GenerationTask
//       - Represents a single chunk generation request.
//   ‚Ä¢ benchmark_generation_workload
//       - Utility for simulating heavy workloads.
//
// Function:
//   ‚Ä¢ start_runtime_placeholder
//       - Demonstrates runtime initialization and immediate teardown.
//       - Workflow:
//           1. Attempt to create a new Conductor with no configuration.
//           2. If successful:
//                ‚Ä¢ Log runtime creation.
//                ‚Ä¢ Forget progress_receiver to avoid drop side effects.
//                ‚Ä¢ Call graceful_teardown() on Conductor.
//           3. If failed:
//                ‚Ä¢ Log error with failure details.
//
// Design Choices:
//   ‚Ä¢ Modular organization ensures separation of concerns.
//   ‚Ä¢ Re-exports flatten hierarchy for ergonomic external use.
//   ‚Ä¢ Placeholder runtime provides a safe test harness for initialization logic.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust crates can be structured to balance
//     modularity and usability. By centralizing traits, modules, and re-exports,
//     SSXL provides a clean API surface while maintaining internal organization.
// ============================================================================


use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;
use tracing::{info, error};
use std::mem;

pub mod ca;
pub mod conductor;
pub mod manager;
pub mod perlin;
pub mod task;

pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

pub use conductor::conductor::Conductor;
pub use manager::config_validator::GeneratorConfig;

pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;

pub use task::task_queue::GenerationTask;
pub use task::benchmark_logic::benchmark_generation_workload;

pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _request_sender, progress_receiver)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            mem::forget(progress_receiver);
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}

// --- END: rust/ssxl_generate/src\lib.rs ---
        58 LOC | rust/ssxl_generate/src\manager\config_validator.rs
// --- START: rust/ssxl_generate/src\manager\config_validator.rs ---
// ============================================================================
// üéº Generator Configuration and Validation (`crate::manager::generator_config`)
// ----------------------------------------------------------------------------
// This module defines the configuration parameters for a generator run and
// provides validation logic to ensure map dimensions are safe and reasonable.
// It is a critical part of the SSXL engine‚Äôs setup pipeline, ensuring that
// generation requests do not exceed system limits.
//
// Purpose:
//   ‚Ä¢ Encapsulate generator metadata (map size, seed, generator type, overrides).
//   ‚Ä¢ Provide human-readable logging for configuration state.
//   ‚Ä¢ Validate map dimensions in terms of chunk counts before generation begins.
//
// Key Components:
//   ‚Ä¢ GeneratorConfig (struct)
//       - Holds configuration parameters for a generator run:
//           ‚Ä¢ width: map width in tiles.
//           ‚Ä¢ height: map height in tiles.
//           ‚Ä¢ seed: string used for deterministic random generation.
//           ‚Ä¢ generator_name: identifier for which generator to use.
//           ‚Ä¢ tile_overrides: optional overrides for specific tiles.
//       - Implements `Display` for human-readable logging.
//
//   ‚Ä¢ ConfigValidator (struct)
//       - Provides validation logic for `GeneratorConfig`.
//       - Ensures map dimensions are within safe bounds.
//       - Prevents runaway generation requests that could exhaust resources.
//
// Constants:
//   ‚Ä¢ MAX_ACTIVE_CHUNKS
//       - Defines the maximum number of active chunks allowed in memory.
//       - Protects against excessive generation requests.
//
// Workflow:
//   1. A `GeneratorConfig` is created with map dimensions, seed, generator name,
//      and optional tile overrides.
//   2. `ConfigValidator::validate_map_dimensions` is called before generation.
//   3. Validation steps:
//        ‚Ä¢ Convert dimensions and chunk size to i64 for safe arithmetic.
//        ‚Ä¢ Compute width and height in chunks using ceiling division.
//        ‚Ä¢ Calculate total number of chunks.
//        ‚Ä¢ Ensure total chunks > 0.
//        ‚Ä¢ Ensure total chunks ‚â§ MAX_ACTIVE_CHUNKS.
//   4. Log success or failure with structured messages.
//   5. Return `Ok(())` if valid, or `Err(String)` with error message if invalid.
//
// Design Choices:
//   ‚Ä¢ Ceiling division ensures partial chunks are counted as full.
//   ‚Ä¢ Logging provides traceability for both success and failure cases.
//   ‚Ä¢ Separation of configuration and validation improves modularity.
//   ‚Ä¢ Using `Display` for `GeneratorConfig` makes logs concise and readable.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can enforce safety at the configuration
//     level, preventing invalid or excessive workloads before they reach runtime.
//   ‚Ä¢ By combining strong typing, validation, and logging, it ensures reliability
//     and transparency in procedural generation workflows.
// ============================================================================


use tracing::{error, info};
use std::fmt;
use std::collections::HashMap;
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width,
            self.height,
            self.seed,
            self.generator_name,
            self.tile_overrides.len()
        )
    }
}

pub struct ConfigValidator;

impl ConfigValidator {
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}

// --- END: rust/ssxl_generate/src\manager\config_validator.rs ---
         6 LOC | rust/ssxl_generate/src\manager\generator.rs
// --- START: rust/ssxl_generate/src\manager\generator.rs ---
// ============================================================================
// üéº Generator Trait (`crate::generator::generator`)
// ----------------------------------------------------------------------------
// This module defines the `Generator` trait, the core contract for all
// procedural generation algorithms in the SSXL engine. By enforcing a common
// interface, the engine can treat all generators uniformly, swap them
// dynamically, and maintain modularity and extensibility.
//
// Purpose:
//   ‚Ä¢ Provide a unified interface for chunk generation algorithms.
//   ‚Ä¢ Ensure deterministic, self-contained generation logic.
//   ‚Ä¢ Enable the Conductor to manage multiple generator types seamlessly.
//
// Key Components:
//   ‚Ä¢ id (method)
//       - Returns a unique, static string identifier for the generator.
//       - Used by the Conductor to distinguish between generator types.
//       - Useful for logging, debugging, and configuration.
//       - Examples: "cellular_automata_basic", "perlin_noise".
//
//   ‚Ä¢ generate_chunk (method)
//       - Executes the generator‚Äôs algorithm to produce a single chunk of world data.
//       - Arguments:
//           ‚Ä¢ chunk_coords: Vec2i representing the global coordinates of the chunk.
//       - Returns:
//           ‚Ä¢ ChunkData: the fully generated chunk, ready for caching and use.
//       - Requirements:
//           ‚Ä¢ Must be deterministic: same coordinates and seed ‚Üí identical output.
//           ‚Ä¢ Must be self-contained: should not rely on external mutable state.
//       - Examples:
//           ‚Ä¢ Cave generator: runs a cellular automata simulation.
//           ‚Ä¢ Noise generator: samples Perlin/Simplex noise fields.
//
// Workflow:
//   1. Conductor requests chunk generation by calling `generate_chunk`.
//   2. Generator implementation produces deterministic tile data for the chunk.
//   3. Resulting `ChunkData` is cached and returned for use in the world grid.
//   4. Generator ID is logged and tracked for debugging and configuration.
//
// Design Choices:
//   ‚Ä¢ Trait-based design enforces consistency across all generator implementations.
//   ‚Ä¢ Separation of ID and generation logic improves clarity and modularity.
//   ‚Ä¢ Deterministic output ensures reproducibility across runs and seeds.
//
// Educational Note:
//   ‚Ä¢ This trait demonstrates how Rust traits can define contracts for modular,
//     pluggable systems.
//   ‚Ä¢ By requiring both identification and generation methods, it ensures that
//     all generators are discoverable, traceable, and interchangeable.
// ============================================================================


use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;

#[allow(dead_code)]
pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

// --- END: rust/ssxl_generate/src\manager\generator.rs ---
        54 LOC | rust/ssxl_generate/src\manager\generator_manager.rs
// --- START: rust/ssxl_generate/src\manager\generator_manager.rs ---
// ============================================================================
// üéº Generator Manager (`crate::manager::generator_manager`)
// ----------------------------------------------------------------------------
// This module defines the `GeneratorManager`, the central registry and access
// point for all procedural generation algorithms in the SSXL engine. It ensures
// that multiple generator types (e.g., Perlin noise, cellular automata) can be
// initialized, stored, and retrieved in a uniform way.
//
// Purpose:
//   ‚Ä¢ Maintain a registry of all available generator implementations.
//   ‚Ä¢ Provide safe, shared access to generators across async tasks.
//   ‚Ä¢ Allow dynamic lookup of generators by ID.
//   ‚Ä¢ Execute chunk generation requests using the active generator.
//
// Key Components:
//   ‚Ä¢ DynGenerator (type alias)
//       - Represents a dynamically dispatched generator trait object.
//       - Box<dyn Generator + Send + Sync> ensures uniform storage and thread safety.
//       - Wrapped in Arc for shared ownership across tasks.
//
//   ‚Ä¢ GeneratorManager (struct)
//       - Holds:
//           ‚Ä¢ generators: HashMap mapping generator IDs ‚Üí Arc<DynGenerator>.
//           ‚Ä¢ default_perlin_id: fallback ID for Perlin generator.
//       - Acts as the registry and dispatcher for all generators.
//
// Implementation Methods:
//   ‚Ä¢ new
//       - Initializes registry with:
//           ‚Ä¢ Perlin generator (base noise layer).
//           ‚Ä¢ Multiple cellular automata generators (different rule sets).
//       - Logs how many generators were registered.
//       - Returns a fully constructed `GeneratorManager`.
//
//   ‚Ä¢ get_map_ref
//       - Returns a reference to the internal generator map.
//       - Useful for quick lookups without cloning.
//
//   ‚Ä¢ get_map_clone
//       - Returns a cloned copy of the generator map.
//       - Useful for background tasks requiring ownership.
//
//   ‚Ä¢ generate_single_chunk
//       - Executes chunk generation for given coordinates using specified generator ID.
//       - Panics if ID is invalid (should be validated earlier).
//       - Returns fully generated `ChunkData`.
//
//   ‚Ä¢ get_initial_id
//       - Determines initial active generator ID based on configuration.
//       - If config ID exists ‚Üí return it.
//       - If not ‚Üí log warning and return default Perlin ID.
//
// Workflow:
//   1. Registry is initialized with Perlin + CA generators.
//   2. Conductor queries `GeneratorManager` for active generator ID.
//   3. Chunk generation requests are dispatched to the correct generator.
//   4. Fallback logic ensures system stability if config ID is invalid.
//
// Design Choices:
//   ‚Ä¢ Arc + Box<dyn Generator> ensures safe concurrent access and polymorphism.
//   ‚Ä¢ HashMap provides O(1) lookup for generator IDs.
//   ‚Ä¢ Logging improves visibility into registration and fallback events.
//   ‚Ä¢ Default Perlin fallback ensures system always has a valid generator.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can combine trait objects, smart pointers,
//     and collections to build a flexible plugin-like architecture.
//   ‚Ä¢ By centralizing generator management, the engine remains modular, extensible,
//     and resilient to configuration errors.
// ============================================================================


use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;
use crate::Generator;
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;
use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

pub type DynGenerator = Box<dyn Generator + Send + Sync>;

pub struct GeneratorManager {
    generators: HashMap<String, Arc<DynGenerator>>,
    default_perlin_id: String,
}

impl GeneratorManager {
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        generator_arc.generate_chunk(chunk_coords)
    }

    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!(
                "Config default generator ID '{}' not found. Falling back to Perlin: {}",
                config_id, self.default_perlin_id
            );
            self.default_perlin_id.clone()
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\generator_manager.rs ---
         8 LOC | rust/ssxl_generate/src\manager\mod.rs
// --- START: rust/ssxl_generate/src\manager\mod.rs ---
// ============================================================================
// üéº Manager Module Declaration (`crate::manager`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the
// Manager system. It organizes submodules related to configuration validation,
// generator logic, generator registry, and runtime management. By re-exporting
// key items, it simplifies usage for external code.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for all management-related functionality.
//   ‚Ä¢ Expose submodules that implement configuration checks, generator contracts,
//     generator registry, and runtime orchestration.
//   ‚Ä¢ Re-export commonly used items to provide a clean, ergonomic public API.
//
// Submodules:
//   ‚Ä¢ config_validator
//       - Provides validation logic for generator configurations.
//       - Ensures map dimensions and chunk limits are safe before generation.
//   ‚Ä¢ generator
//       - Defines the `Generator` trait, the contract for all generation algorithms.
//       - Enforces modularity and extensibility across procedural generators.
//   ‚Ä¢ generator_manager
//       - Acts as a registry for all available generators (Perlin, Cellular Automata, etc.).
//       - Provides lookup, fallback, and chunk generation execution.
//   ‚Ä¢ runtime_manager
//       - Manages the async runtime environment for executing generation tasks.
//       - Handles graceful shutdown and lifecycle control.
//
// Re-exports:
//   ‚Ä¢ config_validator::*
//       - Exposes `ConfigValidator` and related validation utilities.
//   ‚Ä¢ generator::*
//       - Exposes the `Generator` trait and related items.
//   ‚Ä¢ generator_manager::*
//       - Exposes `GeneratorManager` and type aliases for dynamic generators.
//   ‚Ä¢ runtime_manager::*
//       - Exposes `RuntimeManager` and runtime utilities.
//
// Workflow:
//   1. External code imports from `crate::manager`.
//   2. Submodules provide specialized functionality (validation, generator logic, registry, runtime).
//   3. Re-exports simplify usage by exposing key items directly.
//   4. Manager orchestrates configuration, generator selection, and runtime execution.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex subsystems into clear, modular components.
//   ‚Ä¢ By re-exporting key items, the public API remains clean and ergonomic,
//     while internal organization stays modular and maintainable.
// ============================================================================


pub mod config_validator;
pub mod generator;
pub mod generator_manager;
pub mod runtime_manager;

pub use config_validator::*;
pub use generator::*;
pub use generator_manager::*;
pub use runtime_manager::*;

// --- END: rust/ssxl_generate/src\manager\mod.rs ---
        34 LOC | rust/ssxl_generate/src\manager\runtime_manager.rs
// --- START: rust/ssxl_generate/src\manager\runtime_manager.rs ---
// ============================================================================
// üéº Runtime Manager (`crate::manager::runtime_manager`)
// ----------------------------------------------------------------------------
// This module defines the `RuntimeManager`, a wrapper around the Tokio runtime
// that manages its lifecycle. It ensures that asynchronous tasks in the SSXL
// engine are executed efficiently and that the runtime is properly initialized
// and shut down.
//
// Purpose:
//   ‚Ä¢ Provide a centralized manager for the Tokio runtime.
//   ‚Ä¢ Configure runtime with optimal worker threads based on available CPU cores.
//   ‚Ä¢ Expose a safe handle for spawning tasks without owning the runtime directly.
//   ‚Ä¢ Ensure graceful shutdown when the manager is dropped.
//
// Key Components:
//   ‚Ä¢ RuntimeManager (struct)
//       - Wraps an `Option<Runtime>` to allow safe ownership transfer during Drop.
//       - Encapsulates initialization, access, and shutdown logic.
//
// Implementation Methods:
//   ‚Ä¢ new
//       - Creates a new multi-threaded Tokio runtime.
//       - Configures worker threads equal to the number of CPU cores.
//       - Enables all Tokio features (I/O, time, etc.).
//       - Logs initialization details.
//       - Returns `Ok(RuntimeManager)` or `Err(io::Error)` if runtime fails to build.
//
//   ‚Ä¢ get_handle
//       - Provides a clone of the runtime handle.
//       - Allows spawning tasks without owning the runtime itself.
//       - Panics if runtime is unexpectedly None.
//
//   ‚Ä¢ shutdown_graceful
//       - Logs a graceful shutdown request.
//       - Actual shutdown is deferred to the Drop implementation.
//
// Drop Implementation:
//   ‚Ä¢ Ensures runtime is properly shut down when `RuntimeManager` goes out of scope.
//   ‚Ä¢ Steps:
//       1. Take ownership of runtime from Option (leaving None behind).
//       2. Log shutdown message.
//       3. Call `shutdown_background()` to stop runtime without blocking current thread.
//
// Workflow:
//   1. RuntimeManager is created via `new`, initializing a multi-threaded runtime.
//   2. Tasks are spawned using `get_handle`.
//   3. When shutdown is requested, `shutdown_graceful` logs the intent.
//   4. On drop, runtime is safely shut down in the background.
//
// Design Choices:
//   ‚Ä¢ Wrapping runtime in `Option` allows safe transfer of ownership during Drop.
//   ‚Ä¢ Using `num_cpus` ensures runtime scales with hardware capabilities.
//   ‚Ä¢ Logging provides visibility into initialization and shutdown events.
//   ‚Ä¢ Background shutdown prevents blocking the main thread during cleanup.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can manage async runtimes safely,
//     ensuring deterministic lifecycle control.
//   ‚Ä¢ By combining smart pointers, logging, and Drop semantics, it provides
//     a robust foundation for concurrent task execution in the SSXL engine.
// ============================================================================


use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

impl RuntimeManager {
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?;

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped ‚Äî shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\runtime_manager.rs ---
         2 LOC | rust/ssxl_generate/src\perlin\mod.rs
// --- START: rust/ssxl_generate/src\perlin\mod.rs ---
// ============================================================================
// üéº Perlin Module Declaration (`crate::perlin`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the Perlin
// noise subsystem in the SSXL engine. It organizes submodules related to Perlin
// noise generation and re-exports their contents for easier access.
//
// Purpose:
//   ‚Ä¢ Serve as the "entry point" for all Perlin-related functionality.
//   ‚Ä¢ Expose the `perlin_generator` submodule, which implements the Perlin noise algorithm.
//   ‚Ä¢ Re-export items so external code can import directly from `crate::perlin`
//     without drilling down into internal paths.
//
// Submodules:
//   ‚Ä¢ perlin_generator
//       - Contains the actual implementation of the Perlin noise generator.
//       - Conforms to the `Generator` trait, ensuring compatibility with the
//         Conductor and GeneratorManager systems.
//       - Provides deterministic chunk generation based on Perlin noise fields.
//
// Re-exports:
//   ‚Ä¢ pub use perlin_generator::*
//       - Exposes all items from the `perlin_generator` submodule.
//       - Simplifies external imports by flattening the module hierarchy.
//       - Example:
//           ‚Ä¢ Without re-export ‚Üí `use crate::perlin::perlin_generator::PerlinGenerator;`
//           ‚Ä¢ With re-export    ‚Üí `use crate::perlin::PerlinGenerator;`
//
// Workflow:
//   1. External code imports from `crate::perlin`.
//   2. The `perlin_generator` submodule provides Perlin noise generation logic.
//   3. Re-export ensures ergonomic access to `PerlinGenerator` and related items.
//   4. GeneratorManager registers Perlin as one of the available algorithms.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     specialized subsystems (like Perlin noise) while keeping the public API clean.
//   ‚Ä¢ By re-exporting, developers gain ergonomic access without sacrificing
//     modularity or maintainability.
// ============================================================================


pub mod perlin_generator;

pub use perlin_generator::*;

// --- END: rust/ssxl_generate/src\perlin\mod.rs ---
        68 LOC | rust/ssxl_generate/src\perlin\perlin_generator.rs
// --- START: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
// ============================================================================
// üéº Perlin Noise Generator (`crate::perlin::perlin_generator`)
// ----------------------------------------------------------------------------
// This module implements a procedural terrain generator based on Perlin noise.
// It conforms to the `Generator` trait, making it interchangeable with other
// generation algorithms in the SSXL engine.
//
// Purpose:
//   ‚Ä¢ Provide deterministic terrain generation using Perlin noise fields.
//   ‚Ä¢ Translate continuous noise values into discrete tile types (Water, Grass, Mountain).
//   ‚Ä¢ Ensure reproducibility by seeding the noise function.
//   ‚Ä¢ Integrate seamlessly with the Conductor and GeneratorManager systems.
//
// Key Components:
//   ‚Ä¢ PerlinGenerator (struct)
//       - Fields:
//           ‚Ä¢ perlin: Perlin noise object seeded for deterministic output.
//           ‚Ä¢ scale: scaling factor applied to coordinates before sampling noise.
//       - Larger scale ‚Üí smoother, larger terrain features.
//       - Smaller scale ‚Üí finer detail and variation.
//
//   ‚Ä¢ new (constructor)
//       - Creates a new PerlinGenerator with a given scale.
//       - Uses a hardcoded DEFAULT_SEED for reproducibility.
//       - Ensures consistent terrain generation across runs.
//
//   ‚Ä¢ id (trait method)
//       - Returns a unique identifier string ("perlin_basic_2d").
//       - Used by Conductor and GeneratorManager to select this generator.
//
//   ‚Ä¢ generate_chunk (trait method)
//       - Generates a single chunk of terrain using Perlin noise.
//       - Steps:
//           1. Compute chunk size in tiles.
//           2. Calculate world coordinates for chunk origin.
//           3. Create unique chunk ID by packing coordinates into u64.
//           4. Define spatial bounds for the chunk.
//           5. Initialize ChunkData container.
//           6. Pre-allocate vector for TileData entries.
//           7. Iterate over each tile in the chunk:
//                a. Compute world coordinates.
//                b. Sample Perlin noise at scaled coordinates.
//                c. Normalize noise value from [-1, 1] ‚Üí [0, 1].
//                d. Threshold into TileType (Water, Grass, Mountain).
//                e. Create TileData with type + raw noise metadata.
//                f. Push into tile vector.
//           8. Insert generated tiles into ChunkData.
//           9. Log completion message with chunk coordinates and tile count.
//          10. Return fully populated ChunkData.
//
// Workflow:
//   1. Conductor requests chunk generation via GeneratorManager.
//   2. PerlinGenerator samples noise field at scaled coordinates.
//   3. Noise values are normalized and mapped to discrete tile types.
//   4. ChunkData is populated with TileData entries.
//   5. Completed chunk is cached and returned for use in the world grid.
//
// Design Choices:
//   ‚Ä¢ Deterministic seed ensures reproducibility across runs.
//   ‚Ä¢ Scaling factor allows tuning of terrain smoothness vs. detail.
//   ‚Ä¢ Thresholds map continuous noise into meaningful terrain categories.
//   ‚Ä¢ Logging provides visibility into generation process.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how continuous mathematical noise functions
//     can be transformed into discrete, game-ready terrain data.
//   ‚Ä¢ By combining Perlin noise with clear thresholds, it produces varied yet
//     deterministic landscapes suitable for procedural world generation.
// ============================================================================


use crate::Generator;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use noise::{NoiseFn, Perlin};
use tracing::info;

pub struct PerlinGenerator {
    perlin: Perlin,
    scale: f64,
}

impl PerlinGenerator {
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

impl Generator for PerlinGenerator {
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                let normalized_value = (noise_value + 1.0) / 2.0;

                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                let tile = TileData::new(tile_type, normalized_value as f32);

                tiles.push(tile);
            }
        }

        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}

// --- END: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
        53 LOC | rust/ssxl_generate/src\task\batch_processor.rs
// --- START: rust/ssxl_generate/src\task\batch_processor.rs ---
// ============================================================================
// üéº Batch Generation Task Spawner (`crate::task::batch_generation`)
// ----------------------------------------------------------------------------
// This module defines the `spawn_batch_generation_task` function, which is
// responsible for orchestrating sequential batch generation of chunks in the
// SSXL engine. It leverages the Tokio runtime to spawn a blocking task that
// processes all chunks in a map configuration.
//
// Purpose:
//   ‚Ä¢ Execute full map generation in a controlled, sequential manner.
//   ‚Ä¢ Ensure stability when working with non-thread-safe generators and caches.
//   ‚Ä¢ Provide progress and completion signals back to the Conductor.
//   ‚Ä¢ Track queue depth to monitor active generation tasks.
//
// Key Components:
//   ‚Ä¢ runtime_handle
//       - A handle to the Tokio runtime.
//       - Used to spawn the blocking batch generation task.
//
//   ‚Ä¢ generators_clone
//       - Cloned registry of available generators.
//       - Provides access to generator implementations by ID.
//
//   ‚Ä¢ chunk_cache_clone
//       - Shared cache for storing/retrieving generated chunks.
//       - Prevents redundant computation.
//
//   ‚Ä¢ active_generator_id
//       - ID of the generator to use for this batch.
//       - Ensures deterministic selection of algorithm.
//
//   ‚Ä¢ progress_sender_clone
//       - Channel sender for progress/completion messages.
//       - Allows Conductor to track task lifecycle.
//
//   ‚Ä¢ internal_state_clone
//       - Tracks conductor lifecycle state and queue depth.
//       - Ensures proper accounting of active tasks.
//
//   ‚Ä¢ config_clone
//       - Generator configuration (map dimensions, seed, etc.).
//       - Defines the scope of the batch generation.
//
// Workflow:
//   1. Log the start of batch generation with configuration details.
//   2. Spawn a blocking task on the runtime to process chunks sequentially.
//   3. Increment queue depth to track active task.
//   4. Calculate map dimensions in terms of chunk counts using ceiling division.
//   5. Build a list of all chunk coordinates to be generated.
//   6. Iterate sequentially over each chunk coordinate:
//        ‚Ä¢ Call `handle_chunk_unit` to generate and cache chunk data.
//   7. Send a completion message via channel when finished.
//   8. Decrement queue depth to reflect task completion.
//   9. Log completion message with configuration details.
//
// Design Choices:
//   ‚Ä¢ Sequential processing ensures stability with non-thread-safe components.
//   ‚Ä¢ Ceiling division guarantees partial chunks are included in generation.
//   ‚Ä¢ Logging provides visibility into task lifecycle and edge cases.
//   ‚Ä¢ Queue depth tracking prevents runaway task spawning.
//   ‚Ä¢ Completion signaling integrates with Conductor‚Äôs orchestration layer.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how Rust + Tokio can coordinate blocking,
//     sequential workloads within an async runtime.
//   ‚Ä¢ By combining concurrency primitives (channels, Arc) with structured logging,
//     it ensures deterministic, traceable, and safe batch generation.
// ============================================================================


use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_cache::ChunkCache;
use crate::manager::config_validator::GeneratorConfig;
use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::DynGenerator;
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};
use ssxl_shared::CHUNK_SIZE;

pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<ChunkCache>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: Arc<ConductorState>,
    config_clone: GeneratorConfig,
) {
    info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

    runtime_handle.spawn_blocking(move || {
        internal_state_clone.increment_queue_depth();

        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        if all_chunk_coords.is_empty() {
            info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
        }

        let active_generator_id_ref = &active_generator_id;
        
        for &chunk_coords in all_chunk_coords.iter() {
            handle_chunk_unit(
                chunk_coords,
                active_generator_id_ref,
                &generators_clone,
                &chunk_cache_clone,
                &progress_sender_clone,
                &internal_state_clone,
            );
        }

        if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
            warn!("Batch completion signal dropped (Channel full).");
        }

        internal_state_clone.decrement_queue_depth();

        info!("Batch generation task finished processing command: {}", config_clone);
    });
}

// --- END: rust/ssxl_generate/src\task\batch_processor.rs ---
        21 LOC | rust/ssxl_generate/src\task\benchmark_logic.rs
// --- START: rust/ssxl_generate/src\task\benchmark_logic.rs ---
// ============================================================================
// üéº Benchmark Generation Workload (`crate::benchmark::generation_workload`)
// ----------------------------------------------------------------------------
// This module defines the `benchmark_generation_workload` function, which
// simulates a heavy tile-processing workload. It is primarily used for stress
// testing, benchmarking, and validating progress-tracking mechanisms in the
// SSXL engine.
//
// Purpose:
//   ‚Ä¢ Mimic the computational cost of large-scale chunk/tile generation.
//   ‚Ä¢ Provide a controlled workload for performance benchmarking.
//   ‚Ä¢ Update a shared atomic counter to report progress periodically.
//   ‚Ä¢ Log start and completion events for visibility.
//
// Key Components:
//   ‚Ä¢ workload_tiles
//       - Total number of tiles to simulate processing.
//       - Defines the scale of the benchmark workload.
//
//   ‚Ä¢ processed_tiles_counter
//       - Shared atomic counter (Arc<AtomicU64>).
//       - Updated periodically to reflect progress.
//       - Allows external systems (e.g., Conductor) to monitor task advancement.
//
// Workflow:
//   1. Log the start of workload execution with tile count.
//   2. Define update interval (every 10 million tiles).
//   3. Initialize result accumulator for dummy computation.
//   4. Iterate over all tiles:
//        ‚Ä¢ Perform dummy computation (checksum-like addition).
//        ‚Ä¢ Update atomic counter at each interval.
//   5. Handle final remainder update if workload size is not a multiple of interval.
//   6. Log completion message with final checksum value.
//
// Design Choices:
//   ‚Ä¢ Wrapping addition prevents overflow panics during dummy computation.
//   ‚Ä¢ Relaxed memory ordering provides fast atomic updates without synchronization overhead.
//   ‚Ä¢ Large update interval reduces contention on atomic counter.
//   ‚Ä¢ Logging ensures visibility into workload lifecycle.
//
// Educational Note:
//   ‚Ä¢ This function demonstrates how to simulate heavy workloads in Rust
//     while safely tracking progress across threads.
//   ‚Ä¢ By combining atomic counters, logging, and dummy computation, it provides
//     a reproducible benchmark for testing runtime performance and monitoring.
// ============================================================================


use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64>
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}

// --- END: rust/ssxl_generate/src\task\benchmark_logic.rs ---
         6 LOC | rust/ssxl_generate/src\task\mod.rs
// --- START: rust/ssxl_generate/src\task\mod.rs ---
// ============================================================================
// üéº Task Module Declaration (`crate::task`)
// ----------------------------------------------------------------------------
// This `mod.rs` file defines the structure and public API surface of the Task
// system in the SSXL engine. It organizes all task-related functionality,
// including batch generation, benchmarking, and task queue management.
//
// Purpose:
//   ‚Ä¢ Serve as the "table of contents" for task-related subsystems.
//   ‚Ä¢ Expose submodules that implement chunk batch processing, benchmarking,
//     and queue orchestration.
//   ‚Ä¢ Re-export commonly used items to simplify external imports.
//
// Submodules:
//   ‚Ä¢ batch_processor
//       - Handles sequential batch generation of chunks.
//       - Ensures stability with non-thread-safe generators and caches.
//   ‚Ä¢ benchmark_logic
//       - Provides benchmarking utilities for workload simulation.
//       - Useful for stress testing and performance validation.
//   ‚Ä¢ task_queue
//       - Manages the queue of chunk generation tasks.
//       - Supports both async and sync execution flows.
//
// Re-exports:
//   ‚Ä¢ pub use batch_processor::*
//       - Exposes batch generation functions directly from `crate::task`.
//   ‚Ä¢ pub use benchmark_logic::*
//       - Exposes benchmarking utilities directly from `crate::task`.
//   ‚Ä¢ pub use task_queue::*
//       - Exposes task queue management functions directly from `crate::task`.
//
// Workflow:
//   1. External code imports from `crate::task`.
//   2. Submodules provide specialized functionality (batch, benchmark, queue).
//   3. Re-exports flatten the hierarchy for ergonomic access.
//   4. Conductor orchestrates tasks using these utilities.
//
// Design Choices:
//   ‚Ä¢ Modular organization keeps batch, benchmark, and queue logic isolated.
//   ‚Ä¢ Re-exports simplify the public API, reducing boilerplate in external code.
//   ‚Ä¢ Clear separation of concerns ensures maintainability and scalability.
//
// Educational Note:
//   ‚Ä¢ This file demonstrates how Rust‚Äôs module system can be used to organize
//     complex task orchestration into clean, modular components.
//   ‚Ä¢ By re-exporting, developers gain ergonomic access while preserving
//     internal modularity and clarity.
// ============================================================================


pub mod batch_processor;
pub mod benchmark_logic;
pub mod task_queue;

pub use batch_processor::*;
pub use benchmark_logic::*;
pub use task_queue::*;

// --- END: rust/ssxl_generate/src\task\mod.rs ---
        97 LOC | rust/ssxl_generate/src\task\task_queue.rs
// --- START: rust/ssxl_generate/src\task\task_queue.rs ---
// ============================================================================
// üéº Task Queue System (`crate::task::task_queue`)
// ----------------------------------------------------------------------------
// This module defines the core task queue logic for the SSXL engine. It manages
// chunk generation requests, integrates with caching, and ensures that tasks
// are processed safely and efficiently within the Tokio runtime.
//
// Purpose:
//   ‚Ä¢ Provide an asynchronous task queue for chunk generation.
//   ‚Ä¢ Handle cache lookups and generation logic in a unified flow.
//   ‚Ä¢ Track conductor state (tile counts, lifecycle, active status).
//   ‚Ä¢ Ensure clean startup and shutdown of generation tasks.
//
// Key Components:
//   ‚Ä¢ DynGenerator (type alias)
//       - Dynamically dispatched `Generator` trait object.
//       - Send + Sync for concurrency safety.
//   ‚Ä¢ CHUNK_SIZE (constant)
//       - Local i64 constant derived from shared crate.
//       - Defines chunk dimensions for generation and caching.
//
// Functions:
//   ‚Ä¢ handle_chunk_unit
//       - Handles a single chunk request end-to-end.
//       - Workflow:
//           1. Build a unique `ChunkKey` from coordinates.
//           2. Check cache for existing chunk.
//           3. If cache hit ‚Üí send cached chunk via channel.
//           4. If cache miss ‚Üí generate new chunk using selected generator.
//           5. Update conductor state with tile count.
//           6. Save generated chunk to cache.
//           7. Send generated chunk via progress channel.
//       - Provides structured logging for cache hits/misses, errors, and results.
//
//   ‚Ä¢ start_request_loop
//       - Main async loop for processing incoming generation tasks.
//       - Workflow:
//           1. Spawn async loop on runtime.
//           2. Log start of task queue.
//           3. Maintain list of active blocking tasks.
//           4. For each incoming task:
//                a. Check conductor active state.
//                b. Clone necessary resources.
//                c. Spawn blocking task to handle chunk via `handle_chunk_unit`.
//                d. Track task handle.
//           5. When channel closes, drain all active tasks.
//           6. Send `GenerationComplete` message.
//           7. Log clean shutdown.
//       - Ensures graceful lifecycle management of generation tasks.
//
// Design Choices:
//   ‚Ä¢ Separation of concerns: `handle_chunk_unit` focuses on single chunk logic,
//     while `start_request_loop` orchestrates task queue lifecycle.
//   ‚Ä¢ Arc + HashMap ensures safe concurrent access to generators and cache.
//   ‚Ä¢ Structured logging (info, warn, debug, error) provides visibility into
//     task execution, cache behavior, and error handling.
//   ‚Ä¢ Blocking tasks are spawned for generation to isolate heavy workloads
//     while preserving async responsiveness.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust + Tokio can integrate async orchestration
//     with blocking workloads, ensuring both performance and safety.
//   ‚Ä¢ By combining caching, atomic state tracking, and structured logging,
//     it provides a robust foundation for procedural generation pipelines.
// ============================================================================


use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{info, error, warn, debug};
use std::collections::HashMap;
use std::sync::Arc;
use ssxl_math::prelude::Vec2i;
use ssxl_math::coordinate_system::ChunkKey;
use glam::I64Vec3;
use ssxl_cache::ChunkCache;
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE;
use crate::Generator;
use crate::conductor::conductor_state;
pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask};

type DynGenerator = Box<dyn Generator + Send + Sync>;
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;

pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
    conductor_state: &Arc<conductor_state::ConductorState>,
) {
    let chunk_key = ChunkKey(I64Vec3 {
        x: chunk_coords.x,
        y: chunk_coords.y,
        z: 0,
    });

    if let Some(chunk_data_arc) = chunk_cache.load_chunk(&chunk_key) {
        debug!(?chunk_coords, "Cache HIT");

        let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
        if progress_sender.try_send(msg).is_err() {
            warn!(?chunk_coords, "Failed to send cached chunk (channel full/closed)");
        }
        return;
    }

    debug!(?chunk_coords, generator = %generator_name, "Cache MISS ‚Üí generating");

    let generator = generators
        .get(generator_name)
        .expect("Generator must exist in map");

    let chunk_data = generator.generate_chunk(chunk_coords);

    let tile_count = chunk_data.tiles.len() as u64;
    conductor_state.increment_tile_count(tile_count);

    let chunk_data_arc = Arc::new(chunk_data);

    if chunk_cache.save_chunk(&chunk_key, chunk_data_arc.clone()).is_err() {
        error!(?chunk_coords, "Failed to save generated chunk to cache");
    }

    let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
    if progress_sender.try_send(msg).is_err() {
        warn!(?chunk_coords, "Failed to send generated chunk (channel full/closed)");
    } else {
        debug!(?chunk_coords, "Sent newly generated chunk");
    }
}

pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<conductor_state::ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue started");

        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();

        while let Some(task) = request_rx.recv().await {
            if !conductor_state.as_ref().is_active() {
                warn!(?task.chunk_coords, "Dropping task ‚Äî Conductor not active");
                continue;
            }

            let progress_tx = progress_tx.clone();
            let generators = generators.clone();
            let cache = chunk_cache.clone();
            let state = conductor_state.clone();

            let handle = tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators,
                    &cache,
                    &progress_tx,
                    &state,
                );
            });

            active_tasks.push(handle);
        }

        info!("Request channel closed. Draining {} active tasks...", active_tasks.len());

        for handle in active_tasks {
            if let Err(e) = handle.await {
                error!("Generation task panicked: {:?}", e);
            }
        }

        let _ = progress_tx.send(GenerationMessage::GenerationComplete).await;

        info!("Generation Task Queue shut down cleanly");
    });
}

// --- END: rust/ssxl_generate/src\task\task_queue.rs ---
        19 LOC | rust/ssxl_godot/src\anim\animation_api.rs
// --- START: rust/ssxl_godot/src\anim\animation_api.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Arc + Mutex: Used for thread-safe, shared ownership of the Conductor instance.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures safe, exclusive access to the Conductor when multiple threads interact.
//
// tracing macros:
//   - info!: for general lifecycle logs.
//   - error!: for critical failures.
//   - warn!: for warnings or unusual states.
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: a specialized handle for managing animation conductor state,
// typically used for coordinating animation-related tasks across threads.
use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

// -----------------------------------------------------------------------------
// Struct: AnimationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides an abstraction layer for animation-related orchestration.
//   - Holds references to conductor handles so the Rust FFI layer can manage
//     lifecycle and internal communication.
//
// Attributes:
//   - animation_conductor: optional reference to an AnimationConductorHandle.
//       * This is used to drive animation-specific orchestration.
//       * Stored as Option<&> to allow absence (None) when not needed.
//   - _conductor: optional reference to the core Conductor wrapped in Arc<Mutex>.
//       * Arc ensures shared ownership across threads.
//       * Mutex ensures safe concurrent access.
//       * Leading underscore (_) indicates this field may be unused directly,
//         but is retained for lifecycle management or future internal use.
#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// -----------------------------------------------------------------------------
// Implementation: AnimationAPI
// -----------------------------------------------------------------------------
// Provides constructor and potential extension points for animation orchestration.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Creates a new AnimationAPI instance with optional references to
    //     animation conductor and core conductor.
    //
    // Arguments:
    //   - animation_conductor: optional reference to AnimationConductorHandle.
    //   - conductor: optional reference to Arc<Mutex<Conductor>>.
    //
    // Returns:
    //   - AnimationAPI instance with provided references stored.
    //
    // Notes:
    //   - Both arguments are optional, allowing flexible initialization depending
    //     on whether animation or conductor orchestration is required.
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}

// --- END: rust/ssxl_godot/src\anim\animation_api.rs ---
        30 LOC | rust/ssxl_godot/src\engine\api.rs
// --- START: rust/ssxl_godot/src\engine\api.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary: Godot's built-in key-value container type, used here for returning
//             structured data back to the Godot engine in a format it understands.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Arc + Mutex: concurrency primitives for safe, shared ownership of the Conductor.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures exclusive access to Conductor when multiple threads interact.
use std::sync::{Arc, Mutex};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: specialized handle for animation conductor state,
// used to send animation-related commands across threads.
use ssxl_generate::Conductor;
use ssxl_shared::AnimationConductorHandle;

// GenesisHandles: struct returned by initialization routines, containing
// references to conductor, channels, and other setup artifacts.
// execute_channel_and_state_setup: function that sets up communication channels
// and conductor state during initialization.
use crate::engine::api_initializers::{execute_channel_and_state_setup, GenesisHandles};

// -----------------------------------------------------------------------------
// Struct: EngineInitializer
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a clean API for initializing the SSXL engine inside Godot.
//   - Encapsulates setup routines for channels, conductor state, and spawning
//     the conductor runtime.
//
// Notes:
//   - #[derive(Default)] allows creating an empty EngineInitializer with default values.
//   - This struct acts as a "bootstrapper" for the engine.
#[derive(Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Returns a new EngineInitializer instance.
    // Uses Default trait to simplify instantiation.
    pub fn new() -> Self { Self::default() }

    // -------------------------------------------------------------------------
    // Method: execute_channel_and_state_setup
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes communication channels and conductor state.
    //   - Delegates to the api_initializers module for actual setup logic.
    //
    // Arguments:
    //   - config_path: optional path to configuration file.
    //
    // Returns:
    //   - GenesisHandles: contains conductor, channels, and setup artifacts.
    //   - Box<dyn Error>: wraps any error that occurs during setup.
    pub fn execute_channel_and_state_setup(
        &self,
        config_path: Option<&str>,
    ) -> Result<GenesisHandles, Box<dyn Error>> {
        execute_channel_and_state_setup(config_path)
    }

    // -------------------------------------------------------------------------
    // Method: execute_conductor_setup_and_spawn
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Wraps the Conductor instance in Arc<Mutex> for safe sharing across threads.
    //   - Extracts and clones the AnimationConductorHandle for animation orchestration.
    //
    // Arguments:
    //   - handles: GenesisHandles containing conductor and channels.
    //
    // Returns:
    //   - Tuple:
    //       * Option<Arc<Mutex<Conductor>>>: shared, thread-safe conductor instance.
    //       * AnimationConductorHandle: handle for animation commands.
    pub fn execute_conductor_setup_and_spawn(
        &self,
        handles: GenesisHandles,
    ) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        let conductor_arc = Arc::new(Mutex::new(handles._gen_conductor));
        let anim_handle: AnimationConductorHandle = handles.anim_command_tx.clone();
        (Some(conductor_arc), anim_handle)
    }
}

// -----------------------------------------------------------------------------
// Struct: GenerationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing API for chunk data retrieval.
//   - Intended to be called from Godot scripts to fetch chunk data.
//   - Currently a stub implementation returning an empty Dictionary.
//
// Notes:
//   - #[derive(Default)] allows creating an empty GenerationAPI easily.
//   - MUST BE PUBLIC: ensures Godot can access this struct via FFI.
#[derive(Default)]
pub struct GenerationAPI {}

impl GenerationAPI {
    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Fetches chunk data for given coordinates (x, y).
    //   - Currently returns an empty Dictionary as a placeholder.
    //
    // Arguments:
    //   - _x, _y: chunk coordinates (unused in stub).
    //
    // Returns:
    //   - Dictionary: Godot-compatible container for chunk data.
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }
}

// --- END: rust/ssxl_godot/src\engine\api.rs ---
        64 LOC | rust/ssxl_godot/src\engine\api_initializers\mod.rs
// --- START: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Used for asynchronous communication between engine components.
//   - Provides unbounded channels for commands, responses, and updates.
use tokio::sync::mpsc;

// get_config_from_path
//   - Loads engine configuration from a file path.
//   - Provides runtime parameters for conductor initialization.
use ssxl_shared::config::config::get_config_from_path;

// Conductor + ConductorProgressReceiver + ConductorState
//   - Conductor: orchestrates generation tasks (terrain, chunks).
//   - ConductorProgressReceiver: receives progress updates from the conductor.
//   - ConductorState: snapshot of conductor‚Äôs current status.
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    conductor::ConductorState,
};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Message types
//   - AnimationCommand: commands for animation conductor.
//   - AnimationState: snapshot of animation conductor‚Äôs state.
//   - GenerationCommand: commands for generation conductor.
//   - GenerationResponse: responses from generation conductor.
//   - AnimationUpdate: updates from animation conductor.
use ssxl_shared::message::{
    AnimationCommand,
    AnimationState,
    GenerationCommand,
    GenerationResponse,
    AnimationUpdate,
};

// Error trait
//   - Used for returning boxed errors in Result types.
use std::error::Error;

// info!
//   - Logging macro for informational messages.
use tracing::info;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// These aliases simplify channel type signatures for readability.
pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;
pub type GenerationCommandTx = mpsc::UnboundedSender<GenerationCommand>;
pub type GenerationResponseRx = mpsc::UnboundedReceiver<GenerationResponse>;

// -----------------------------------------------------------------------------
// Struct: GenesisHandles
// -----------------------------------------------------------------------------
// Purpose:
//   - Bundles all handles, channels, and state objects created during initialization.
//   - Acts as the "genesis kit" for wiring the engine together.
//
// Fields:
//   - gen_state: snapshot of conductor state.
//   - anim_state: snapshot of animation state.
//   - gen_progress_rx: receiver for generation progress updates.
//   - anim_update_rx: receiver for animation updates.
//   - anim_command_tx: sender for animation commands.
//   - gen_command_tx: sender for generation commands.
//   - gen_response_rx: receiver for generation responses.
//   - _gen_conductor: internal conductor instance (not exposed).
//   - _anim_rx: internal receiver for animation commands.
//   - _anim_update_tx: internal sender for animation updates.
//   - _gen_resp_tx: internal sender for generation responses.
pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    pub gen_command_tx: GenerationCommandTx,
    pub gen_response_rx: GenerationResponseRx,
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>,
    pub(crate) _gen_resp_tx: mpsc::UnboundedSender<GenerationResponse>,
}

// -----------------------------------------------------------------------------
// Function: execute_channel_and_state_setup
// -----------------------------------------------------------------------------
// Purpose:
//   - Initializes all channels and state objects required for the engine.
//   - Returns a GenesisHandles struct bundling everything together.
//
// Arguments:
//   - config_path: optional path to configuration file.
//
// Steps:
//   1. Load configuration from path.
//   2. Create generation command + response channels.
//   3. Initialize conductor via Conductor::new_for_ffi.
//   4. Create animation command + update channels.
//   5. Initialize animation state.
//   6. Log successful initialization.
//   7. Return GenesisHandles with all handles and channels wired.
pub fn execute_channel_and_state_setup(
    config_path: Option<&str>,
) -> Result<GenesisHandles, Box<dyn Error>> {
    // Step 1: Load configuration.
    let _config = get_config_from_path(config_path);

    // Step 2: Create generation channels.
    let (gen_command_tx, _gen_cmd_rx) = mpsc::unbounded_channel::<GenerationCommand>();
    let (_gen_resp_tx, gen_response_rx) = mpsc::unbounded_channel::<GenerationResponse>();

    // Step 3: Initialize conductor.
    let (
        gen_conductor,
        gen_state,
        _internal_gen_cmd_tx,
        _internal_gen_resp_rx,
        gen_progress_rx_inner,
    ) = Conductor::new_for_ffi(config_path)?;

    // Step 4: Create animation channels.
    let (anim_command_tx_inner, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
    let (anim_update_tx, anim_update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();

    // Step 5: Initialize animation state.
    let anim_state = AnimationState::default();

    // Step 6: Log success.
    info!("Genesis engine initialized: Conductor + Animation systems ready.");

    // Step 7: Return GenesisHandles.
    Ok(GenesisHandles {
        gen_state,
        anim_state,
        gen_progress_rx: ConductorProgressReceiver::new(gen_progress_rx_inner),
        anim_update_rx,
        anim_command_tx: anim_command_tx_inner,

        gen_command_tx,
        gen_response_rx,
        _gen_conductor: gen_conductor,
        _anim_rx: anim_rx,
        _anim_update_tx: anim_update_tx,
        _gen_resp_tx,
    })
}

// --- END: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
        21 LOC | rust/ssxl_godot/src\engine\cleanup.rs
// --- START: rust/ssxl_godot/src\engine\cleanup.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), which is used as the return type.
//
// Arc
//   - Thread-safe reference-counted pointer for shared ownership.
//   - Used here to manage the Conductor instance across multiple threads.
use godot::prelude::*;
use std::sync::Arc;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module;
use state_module::{SSXLEngine, state};

// -----------------------------------------------------------------------------
// Function: shutdown_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing function for Godot to explicitly shut down the
//     SSXL engine, releasing all resources and background threads.
//   - Ensures the Conductor and related subsystems are gracefully torn down.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine, the core engine state.
//
// Returns:
//   - GString: a Godot-compatible string message confirming shutdown.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, attempt to unwrap and shut it down gracefully.
//   3. Clear other subsystems (conductor_state, animation_conductor, animation_state).
//   4. Clear Godot node references (signals_node, tilemap_node).
//   5. Return a confirmation message.
pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    // Step 1: Access internal state of SSXLEngine.
    let state = state!(engine);
    
    // Step 2: Gracefully shut down the Conductor if present.
    if let Some(conductor_arc) = state.conductor.take() {
        // Arc::try_unwrap attempts to consume the Arc if it is uniquely owned.
        //   - .ok(): discards error if Arc is not unique.
        //   - .and_then(|m| m.into_inner().ok()): consumes Mutex, discards poisoning errors.
        // Result: Option<Conductor> if successful.
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok()
            .and_then(|m| m.into_inner().ok())
        {
            // Call graceful_teardown on the owned Conductor instance.
            conductor.graceful_teardown();
        }
        // If Arc is not unique or Mutex is poisoned, shutdown is skipped.
    }
    
    // Step 3: Clear other subsystems.
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    // Step 4: Clear Godot node references.
    state.signals_node.take();
    state.tilemap_node.take();

    // Step 5: Return confirmation message as GString.
    "SSXLEngine resources shut down and released.".into()
}

// --- END: rust/ssxl_godot/src\engine\cleanup.rs ---
        26 LOC | rust/ssxl_godot/src\engine\commands.rs
// --- START: rust/ssxl_godot/src\engine\commands.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), used for passing strings between Rust and Godot.
use godot::prelude::*;

// AnimationCommand
//   - Enum representing commands sent to the animation conductor.
//   - Examples: enabling/disabling animations, updating flow fields, particle systems, etc.
use ssxl_shared::AnimationCommand;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: stop_generation_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Gracefully stops the current generation process.
//   - Intended to be called from Godot when the user requests a halt in terrain generation.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call stop_generation() on the Conductor.
//   4. Ignore errors silently (e.g., if lock acquisition fails).
pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

// -----------------------------------------------------------------------------
// Function: set_animation_enabled_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Toggles the low-latency animation conductor (flow fields, particle systems, etc.).
//   - Allows enabling or disabling animations dynamically during gameplay.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If an animation conductor channel exists, send a SetEnabled command.
//   3. The command is sent asynchronously to the animation conductor.
//   4. Ignore errors silently (e.g., if channel is full or closed).
pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

// -----------------------------------------------------------------------------
// Function: set_generator_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Changes the active generator mid-session.
//   - Useful for dynamic biome switching or runtime experimentation with different terrain algorithms.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call set_generator() on the Conductor, passing the new generator name.
//   4. Convert Godot's GString into a Rust String before passing.
//   5. Ignore errors silently (e.g., if lock acquisition fails).
pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            let _ = c.set_generator(&name.to_string());
        }
    }
}

// --- END: rust/ssxl_godot/src\engine\commands.rs ---
        83 LOC | rust/ssxl_godot/src\engine\init.rs
// --- START: rust/ssxl_godot/src\engine\init.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<Node>, GString, Dictionary, etc., which are used to bridge
//     between Rust and Godot‚Äôs scripting layer.
use godot::prelude::*;

// UnboundedSender: asynchronous channel sender from Tokio used for communication
// between threads without backpressure (unbounded queue).
use tokio::sync::mpsc::UnboundedSender;

// Node: Godot scene graph node type, used here for signals integration.
use godot::classes::Node;

// Dictionary: Godot‚Äôs built-in key-value container, used for returning structured
// data back to Godot scripts.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Logging macros for structured runtime output.
// - info!: lifecycle events.
// - error!: critical failures.
use tracing::{info, error};

// Internal Godot FFI glue for SSXLEngine functions.
use crate::engine::__godot_SSXLEngine_Funcs;

// SSXLEngine: the core engine state struct exposed to Godot.
use super::state::SSXLEngine;

// Tick processor: updates engine state each frame.
use crate::engine::tick::process_engine_tick;

// Commands: side-effect functions for stopping generation, toggling animation,
// and switching generators.
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};

// Query functions: read-only accessors for engine state (tile count, status, active generator).
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};

// Cleanup logic: graceful shutdown of engine resources.
use crate::engine::cleanup::shutdown_logic;

// AnimationConductorHandle: handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// AnimationCommand: enum representing animation-related commands (enable/disable, etc.).
use ssxl_shared::message::AnimationCommand;

// -----------------------------------------------------------------------------
// Godot API Implementation: SSXLEngine
// -----------------------------------------------------------------------------
// This block exposes SSXLEngine methods to Godot via #[godot_api] and #[func] attributes.
// Each method can be called directly from Godot scripts.
#[godot_api]
impl SSXLEngine {

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes the entire SSXL runtime, including conductor, worker threads,
    //     and communication channels.
    //   - Logs success or failure and returns a boolean to Godot.
    #[func]
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                self.shutdown();
                false
            }
        }
    }

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell_logic (private)
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Core initialization logic separated from public API.
    //   - Sets up channels, conductor threads, and wires handles into internal state.
    //
    // Steps:
    //   1. Initialize channels and core state objects.
    //   2. Clone animation command sender and store it.
    //   3. Spawn conductor threads via initializer.
    //   4. Wire conductor, signals node, and animation handles into internal state.
    //   5. Log successful wiring.
    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        let internal_state = unsafe { &mut *self._internal_state.get() };

        // Step 1: Initialize channels and core state.
        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // Step 2: Clone animation command sender.
        let inner_sender_clone: UnboundedSender<AnimationCommand> = handles.anim_command_tx.clone();
        let anim_command_tx_for_internal_state: AnimationConductorHandle = inner_sender_clone;

        // Step 3: Spawn conductor threads.
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        // Step 4: Wire handles into internal state.
        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);

        // Step 5: Log success.
        info!("SSXL Channels successfully wired to AsyncPoller.");

        Ok(())
    }

    // -------------------------------------------------------------------------
    // Method: shutdown
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Triggers graceful shutdown of SSXL runtime.
    //   - Delegates to cleanup::shutdown_logic.
    #[func]
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: build_map
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Starts a new generation run using provided configuration.
    //   - Currently stubbed to always return true.
    #[func]
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        true
    }

    // -------------------------------------------------------------------------
    // Method: stop_generation
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Stops any current generation/animation process gracefully.
    //   - Delegates to commands::stop_generation_logic.
    #[func]
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_enabled
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Enables or disables tile animation updates.
    //   - Delegates to commands::set_animation_enabled_logic.
    #[func]
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    // -------------------------------------------------------------------------
    // Method: set_generator
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Changes active generator mid-session (dynamic biome switching).
    //   - Delegates to commands::set_generator_logic.
    #[func]
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns total number of tiles generated so far.
    //   - Delegates to query::get_current_tile_count_logic.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_status
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns human-readable engine status string.
    //   - Delegates to query::get_status_logic.
    #[func]
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_active_generator_id
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns the name of the currently active generator.
    //   - Delegates to query::get_active_generator_id_logic.
    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Provides Godot with read-only access to specific chunk data.
    //   - Currently stubbed to return an empty Dictionary.
    #[func]
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }

    // -------------------------------------------------------------------------
    // Method: process_engine_tick
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Must be called every frame to update engine state and process async messages.
    //   - Increments tick counter and delegates to tick::process_engine_tick.
    #[func]
    pub fn process_engine_tick(&mut self) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}

// --- END: rust/ssxl_godot/src\engine\init.rs ---
        18 LOC | rust/ssxl_godot/src\engine\mod.rs
// --- START: rust/ssxl_godot/src\engine\mod.rs ---
// -----------------------------------------------------------------------------
// Module: engine (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `engine` module in the SSXL Godot integration.
// It acts as the central hub, organizing all submodules and re-exporting key items
// so that external code can access them easily.
//
// Think of this file as the "table of contents" for the engine layer.

// -----------------------------------------------------------------------------
// Macro Import
// -----------------------------------------------------------------------------
// #[macro_use] ensures that macros defined in the `state` module (such as `state!`)
// are available throughout the entire `engine` module without needing explicit imports.
// This is critical because the `state!` macro is used in multiple files (commands.rs, init.rs, etc.).
#[macro_use] 
pub mod state;

// -----------------------------------------------------------------------------
// Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the engine system.
// These submodules are implemented in their own files and encapsulate specific concerns:
//
// - init.rs: Runtime initialization logic (channels, conductor setup, etc.).
// - api.rs: Public-facing API for Godot to interact with the engine.
// - tick.rs: Game loop integration, processes engine state each frame.
// - commands.rs: Lightweight runtime commands (stop generation, toggle animation, switch generator).
// - query.rs: Read-only queries for engine state (tile count, status, active generator).
// - cleanup.rs: Graceful shutdown and resource release logic.
// - render_batch.rs: Rendering-related batch operations (integration with Godot visuals).
// - query_data.rs: Data access layer for chunk/tile queries.
// - api_initializers.rs: Helper functions for setting up channels and conductor state.
pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
pub mod api_initializers; 

// -----------------------------------------------------------------------------
// Re-exports: Submodules
// -----------------------------------------------------------------------------
// These `pub use` statements re-export all items from the submodules.
// This flattens the API so external code can import directly from `engine`
// without drilling down into submodules.
//
// Example:
//   Without re-export ‚Üí `use crate::engine::commands::stop_generation_logic;`
//   With re-export    ‚Üí `use crate::engine::stop_generation_logic;`
pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

// -----------------------------------------------------------------------------
// Re-export: SSXLEngine
// -----------------------------------------------------------------------------
// SSXLEngine is the Godot-exposed class representing the engine state.
// By re-exporting it here, external crates (like lib.rs) only need a single line
// to access the Godot class, rather than importing from deep inside the module.
//
// This makes the engine‚Äôs public API clean and ergonomic.
pub use state::SSXLEngine;

// --- END: rust/ssxl_godot/src\engine\mod.rs ---
        60 LOC | rust/ssxl_godot/src\engine\poller.rs
// --- START: rust/ssxl_godot/src\engine\poller.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// TokioReceiver: alias for tokio::sync::mpsc::Receiver, used to receive messages
// from asynchronous channels. This is the non-blocking receiver side of a channel.
use tokio::sync::mpsc::Receiver as TokioReceiver;

// GenerationMessage: enum representing messages from the generation system.
// These include progress updates, completed chunks, or completion signals.
use ssxl_generate::task_queue::GenerationMessage; 

// AnimationUpdate: struct representing lightweight, high-frequency animation updates.
// These are sent from the animation conductor to update flow fields, particles, etc.
use ssxl_shared::message::messages::AnimationUpdate; 

// VecDeque: double-ended queue, efficient for pushing/popping at both ends.
// Used here to collect batches of messages during polling.
use std::collections::VecDeque;

// warn!: logging macro for warnings, used when channels disconnect unexpectedly.
use tracing::warn; 

// TryRecvError: error type returned by try_recv() when a channel is empty or disconnected.
use tokio::sync::mpsc::error::TryRecvError;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Central struct responsible for non-blocking draining of asynchronous results.
//   - Holds two distinct channel receivers:
//       * gen_rx: for heavy generation results (chunks, progress).
//       * anim_rx: for lightweight animation updates.
//
// Notes:
//   - Both receivers are optional (Option<T>), allowing flexible initialization.
//   - If a channel disconnects, the Option is set to None to mark it permanently unavailable.
pub struct AsyncPoller {
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default AsyncPoller with no channels set.
// Useful for initializing before wiring channels in init.rs.
impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides setup methods (for wiring channels) and polling methods (for draining messages).
impl AsyncPoller {
    // -------------------------------------------------------------------------
    // Method: set_generation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for generation messages.
    //   - Called during initialization when channels are created.
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for animation updates.
    //   - Called during initialization when channels are created.
    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: poll_generation_messages
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available generation messages from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If gen_rx exists, loop until channel is empty or disconnected.
    //   3. Push messages into VecDeque.
    //   4. If disconnected, log warning and set gen_rx to None.
    //   5. Return collected messages.
    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        if let Some(rx) = &mut self.gen_rx {
            loop {
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None;
                        break;
                    }
                }
            }
        }
        messages
    }

    // -------------------------------------------------------------------------
    // Method: poll_animations
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available animation updates from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If anim_rx exists, loop until channel is empty or disconnected.
    //   3. Push updates into VecDeque.
    //   4. If disconnected, log warning and set anim_rx to None.
    //   5. Return collected updates.
    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None;
                        break;
                    }
                }
            }
        }
        updates
    }
}

// --- END: rust/ssxl_godot/src\engine\poller.rs ---
        24 LOC | rust/ssxl_godot/src\engine\query.rs
// --- START: rust/ssxl_godot/src\engine\query.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot‚Äôs string type), used for returning strings
//     back to Godot scripts in a compatible format.
use godot::prelude::*;

// StatusReporter
//   - Utility module responsible for producing human-readable status reports
//     and tile count summaries.
//   - Encapsulates logic for interpreting conductor and animation state.
use crate::tilemap::status_reporter::StatusReporter;

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: get_current_tile_count_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the total number of tiles generated so far across all chunks.
//   - Provides a read-only query with no side effects.
//
// Steps:
//   1. Use the `state!` macro to access the engine‚Äôs internal state.
//   2. Call StatusReporter::get_current_tile_count_value, passing a reference
//      to the conductor_state.
//   3. Return the tile count as u64.
pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

// -----------------------------------------------------------------------------
// Function: get_status_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns a human-readable engine status string.
//   - Example: "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
//
// Steps:
//   1. Use the `state!` macro to access the engine‚Äôs internal state.
//   2. Call StatusReporter::get_status_report, passing references to
//      conductor_state and animation_state.
//   3. Return the resulting GString.
pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

// -----------------------------------------------------------------------------
// Function: get_active_generator_id_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the name of the currently active generator.
//   - Examples: "perlin", "cellular", "simplex", "custom_my_gen"
//
// Steps:
//   1. Use the `state!` macro to access the engine‚Äôs internal state.
//   2. Check if a conductor exists (Option<Arc<Mutex<Conductor>>>).
//   3. If None ‚Üí return "Not Initialized".
//   4. If Some ‚Üí attempt to acquire lock on conductor.
//   5. On success ‚Üí call get_active_generator_id() and convert to GString.
//   6. On failure (mutex poisoned) ‚Üí return "Mutex Poisoned".
pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}

// --- END: rust/ssxl_godot/src\engine\query.rs ---
         6 LOC | rust/ssxl_godot/src\engine\query_data.rs
// --- START: rust/ssxl_godot/src\engine\query_data.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary
//   - Godot‚Äôs built-in key-value container type.
//   - Used here to return structured chunk data back to Godot in a format
//     that Godot scripts can easily consume.
use godot::builtin::Dictionary; 

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access to its fields.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: fetch_chunk_data_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides the external Godot layer with read-only access to specific chunk data.
//   - Acts as a query function: no mutation, no side effects, just data retrieval.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine (needed because the macro dereferences
//     internal state, even though this function itself does not mutate).
//   - x, y: integer coordinates of the chunk being requested.
//
// Returns:
//   - Dictionary: a Godot-compatible container holding the chunk‚Äôs data.
//     The actual contents depend on the implementation of generation_api.
//
// Steps:
//   1. Use the `state!` macro to access the engine‚Äôs internal state.
//   2. Call generation_api.fetch_chunk_data(x, y).
//   3. Return the resulting Dictionary to Godot.
pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    state!(engine).generation_api.fetch_chunk_data(x, y)
}

// --- END: rust/ssxl_godot/src\engine\query_data.rs ---
        42 LOC | rust/ssxl_godot/src\engine\render_batch.rs
// --- START: rust/ssxl_godot/src\engine\render_batch.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::builtin::*
//   - Provides Godot‚Äôs built-in types like Dictionary, PackedInt32Array, etc.
//   - These are essential for constructing data structures that Godot understands.
use godot::builtin::*;

// ChunkData, TileType
//   - ChunkData: represents a block of terrain tiles generated by the engine.
//   - TileType: enum/class describing the type of tile (e.g., grass, water, empty).
//     Provides helper methods like is_empty() and atlas coordinate lookup.
use ssxl_shared::{ChunkData, TileType};

// ToGodot trait
//   - Provides the to_variant() method, which converts Rust types into Godot Variant.
//   - Required for setting arrays into Dictionary fields in a Godot-compatible way.
use godot::prelude::ToGodot; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE: fixed dimension of a chunk (32x32 tiles).
// DEFAULT_SOURCE_ID: default identifier for the tile source in Godot‚Äôs TileMap.
pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

// -----------------------------------------------------------------------------
// Function: create_render_batch_dictionary
// -----------------------------------------------------------------------------
// Purpose:
//   - Converts a generated ChunkData into a Godot-ready Dictionary.
//   - This dictionary is structured specifically for Godot‚Äôs TileMap API.
//   - Acts as the translation layer between Rust‚Äôs generation system and Godot‚Äôs rendering.
//
// Arguments:
//   - chunk_data: reference to ChunkData containing tile information.
//   - chunk_x, chunk_y: coordinates of the chunk in world space.
//
// Returns:
//   - Dictionary: contains arrays of positions, source IDs, atlas coordinates, and alt tiles.
//
// Dictionary Format:
// {
//    "layer": 0,
//    "positions": PackedInt32Array [x1, y1, x2, y2, ...],
//    "source_ids": PackedInt32Array [id, id, ...],
//    "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
//    "alt_tiles": PackedInt32Array [0, 0, ...]
// }
pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    // Create the output dictionary.
    let mut dict = Dictionary::new();

    // Arrays to hold tile rendering data.
    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    // Set the rendering layer (always 0 for now).
    dict.set("layer", 0i64);

    // Counter for how many tiles are actually rendered.
    let mut tile_count = 0usize;

    // Iterate over every tile in the chunk grid (32x32).
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            // Compute linear index into chunk_data.tiles.
            let idx = (y * CHUNK_SIZE + x) as usize;

            // Fetch tile at this index.
            if let Some(tile) = chunk_data.tiles.get(idx) {
                // Skip empty tiles (no rendering needed).
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                // Compute world-space coordinates of the tile.
                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                // Push position into array (x, y).
                positions.push(world_x);
                positions.push(world_y);

                // Push default source ID (links to Godot TileSet).
                source_ids.push(DEFAULT_SOURCE_ID);

                // Lookup atlas coordinates for this tile type.
                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                // Push alt tile index (0 = default).
                alt_tiles.push(0);

                // Increment rendered tile count.
                tile_count += 1;
            }
        }
    }

    // Store arrays into dictionary (converted to Godot Variants).
    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    // Debug log if any tiles were prepared.
    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    // Return the fully constructed dictionary.
    dict
}

// --- END: rust/ssxl_godot/src\engine\render_batch.rs ---
        49 LOC | rust/ssxl_godot/src\engine\state.rs
// --- START: rust/ssxl_godot/src\engine\state.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, GString, etc., which are required to expose Rust
//     structs and methods to Godot‚Äôs scripting layer.
use godot::prelude::*;

// TileMap, Node
//   - Godot scene graph classes.
//   - TileMap: used for rendering tile-based maps.
//   - Node: base class for all Godot scene objects.
use godot::classes::{TileMap, Node};

// UnsafeCell
//   - Provides interior mutability for otherwise immutable structs.
//   - Required because Godot owns the object lifetime, not Rust.
//   - Allows us to store mutable state inside SSXLEngine safely.
use std::cell::UnsafeCell;

// Arc + Mutex
//   - Arc: atomic reference-counted pointer for shared ownership across threads.
//   - Mutex: ensures exclusive access to shared data.
//   - Together, they allow safe concurrent access to the Conductor.
use std::sync::{Arc, Mutex};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Conductor + ConductorState
//   - Conductor: central orchestrator of generation tasks.
//   - ConductorState: snapshot of conductor‚Äôs current status.
use ssxl_generate::{Conductor, conductor::ConductorState}; 

// AnimationState
//   - Snapshot of animation conductor‚Äôs current status.
use ssxl_shared::AnimationState;

// AsyncPoller
//   - Responsible for non-blocking draining of async channels (generation + animation).
use crate::tilemap::async_poll::AsyncPoller; 

// GenesisHandles
//   - Struct returned by initialization routines, containing conductor and channel handles.
//   - Aliased here as FfiGenesisHandles for clarity.
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 

// EngineInitializer + GenerationAPI
//   - EngineInitializer: bootstraps conductor threads and channels.
//   - GenerationAPI: provides public-facing API for chunk data queries.
use crate::engine::api::{GenerationAPI, EngineInitializer};

// -----------------------------------------------------------------------------
// Macro: state!
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides safe access to the _internal_state UnsafeCell inside SSXLEngine.
//   - Two forms:
//       * Expression form: state!(self) ‚Üí returns mutable reference to InternalState.
//       * Statement form: state!(self, name) ‚Üí binds InternalState to local variable.
//
// Notes:
//   - #[macro_export] makes the macro visible outside this module.
//   - This is the only safe way to touch _internal_state, since Godot owns object lifetime.
#[macro_export]
macro_rules! state {
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

// Re-export macro so other engine files can use it directly.
pub use state; 

// -----------------------------------------------------------------------------
// Struct: InternalState
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds all non-FFI-safe state for SSXLEngine.
//   - Encapsulates conductor, animation, nodes, and helper APIs.
//   - This struct is hidden from Godot and only accessed via the state! macro.
//
// Fields:
//   - conductor: shared Conductor instance (Arc<Mutex<Conductor>>).
//   - conductor_state: snapshot of conductor status.
//   - animation_conductor: handle for animation commands.
//   - animation_state: snapshot of animation status.
//   - signals_node: Godot Node for emitting signals.
//   - tilemap_node: Godot TileMap for rendering.
//   - initializer: EngineInitializer for bootstrapping.
//   - poller: AsyncPoller for draining async channels.
//   - genesis_handles: optional GenesisHandles from initialization.
//   - generation_api: API for chunk data queries.
//   - tick_count: frame counter for engine ticks.
pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    pub tick_count: u64,
}

// -----------------------------------------------------------------------------
// Default Implementation: InternalState
// -----------------------------------------------------------------------------
// Provides a default empty InternalState.
// All Option fields are initialized to None.
// initializer and poller are constructed with their own defaults.
// tick_count starts at 0.
impl Default for InternalState {
    fn default() -> Self {
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            tick_count: 0,
        }
    }
}

// -----------------------------------------------------------------------------
// Struct: SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - The Godot-facing class exposed to GDScript.
//   - Wraps InternalState inside UnsafeCell for interior mutability.
//   - Provides the bridge between Godot scripts and Rust engine logic.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLEngine as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot‚Äôs Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: Godot Node base.
//   - _internal_state: UnsafeCell<InternalState>, hidden from Godot.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}

// --- END: rust/ssxl_godot/src\engine\state.rs ---
        65 LOC | rust/ssxl_godot/src\engine\tick.rs
// --- START: rust/ssxl_godot/src\engine\tick.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, Variant conversions, etc.
use godot::prelude::*;

// SSXLEngine
//   - The Godot-facing engine struct, wrapping InternalState.
//   - Provides access to conductor, poller, signals, etc.
use super::state::SSXLEngine;

// create_render_batch_dictionary
//   - Utility function that converts ChunkData into a Godot Dictionary
//     formatted for TileMap rendering.
use super::render_batch::create_render_batch_dictionary;

// Signals FFI
//   - Provides SSXLSignals type, which defines the signals emitted to Godot.
//   - Signals are the bridge between Rust engine events and Godot script callbacks.
use crate::ffi::signals::*; 

// GString
//   - Godot‚Äôs string type, used for sending status updates back to Godot.
use godot::builtin::GString; 

// debug!
//   - Logging macro for debug-level output.
use tracing::debug;

// GenerationMessage
//   - Enum representing messages from the generation system.
//   - Variants include Generated(chunk), StatusUpdate(string), GenerationComplete.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Function: process_engine_tick
// -----------------------------------------------------------------------------
// Purpose:
//   - Called once per frame by Godot.
//   - Processes generation + animation messages from async channels.
//   - Emits signals back to Godot for rendering and status updates.
//   - Marks tick completion.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine.
//   - tick: current tick counter (frame number).
//
// Flow:
//   1. Access internal state via UnsafeCell.
//   2. Ensure conductor and signals_node exist.
//   3. Cast signals_node to SSXLSignals for emitting signals.
//   4. Poll generation messages and emit appropriate signals.
//   5. Poll animation messages and emit tile flip signals.
//   6. Emit tick_complete signal at the end.
pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    // Access the hidden InternalState inside SSXLEngine.
    let state = unsafe { &mut *engine._internal_state.get() };
    
    // Ensure conductor exists; if not, return early.
    let Some(_conductor) = &state.conductor else { return };
    
    // Ensure signals_node exists; if not, return early.
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    // Cast signals_node to SSXLSignals to allow emitting signals.
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    // -------------------------------------------------------------------------
    // Generation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available generation messages from AsyncPoller.
    let messages = state.poller.poll_generation();
    for msg in messages {
        match msg {
            // Case: A chunk has been generated.
            GenerationMessage::Generated(_, chunk) => {
                // Extract chunk coordinates.
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                // Convert chunk into Godot render batch dictionary.
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                // Emit signal if batch is non-empty.
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            // Case: Status update message.
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            // Case: Generation process complete.
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
        }
    }

    // -------------------------------------------------------------------------
    // Animation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available animation updates from AsyncPoller.
    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            // Handle frame update payloads.
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(),
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    // -------------------------------------------------------------------------
    // Tick Completion Signal
    // -------------------------------------------------------------------------
    // Emit tick_complete signal with current tick number.
    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}

// --- END: rust/ssxl_godot/src\engine\tick.rs ---
        17 LOC | rust/ssxl_godot/src\ffi\gde_api_defs.rs
// --- START: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and types for Rust integration.
//   - Includes InitHandle, ExtensionLibrary, Base<T>, and macros like #[gdextension].
use godot::prelude::*;

// Node
//   - Godot‚Äôs fundamental scene graph class.
//   - Used here as the base class for SSXLEngine.
use godot::classes::Node;

// Local engine import
//   - SSXLEngine: the Rust struct that represents the engine state and logic.
//   - This struct is exposed to Godot as a custom class.
use crate::ssxl_engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Function: ssxl_godot_init
// -----------------------------------------------------------------------------
// Purpose:
//   - Mandatory entry point for Godot‚Äôs GDExtension system.
//   - Called automatically when the dynamic library is loaded by Godot.
//   - Registers SSXLEngine as a Godot class so it can be instantiated in GDScript.
//
// Notes:
//   - #[gdextension] marks this function as the extension entry point.
//   - Declared unsafe because it interacts with Godot‚Äôs C/C++ runtime directly.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // Register SSXLEngine with Godot.
    // After this, SSXLEngine can be used in Godot scripts as a Node.
    builder.add_class::<SSXLEngine>();
}

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary for SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - Binds SSXLEngine to Godot‚Äôs Node lifecycle.
//   - Maps Godot‚Äôs virtual methods (_init, _process, _ready) to Rust implementations.
//
// Lifecycle Methods:
//   - _init: Constructor, runs when SSXLEngine is instantiated in Godot.
//   - _process: Called every frame, passes delta time to engine tick.
//   - _ready: Called once when the node enters the scene tree, used for setup.
impl ExtensionLibrary for SSXLEngine {
    // Godot‚Äôs constructor (_init).
    // base: the underlying Godot Node that SSXLEngine wraps.
    // Delegates initialization to SSXLEngine::init.
    fn _init(base: Base<Node>) -> Self {
        SSXLEngine::init(base)
    }

    // Godot‚Äôs frame update (_process).
    // delta: time elapsed since last frame (in seconds).
    // Delegates to SSXLEngine::tick, casting delta to u64 for internal use.
    fn _process(&mut self, delta: f64) {
        self.tick(delta as u64);
    }

    // Godot‚Äôs ready hook (_ready).
    // Runs once when the node enters the scene tree.
    // Delegates to SSXLEngine::on_ready for engine startup logic.
    fn _ready(&mut self) {
        self.on_ready();
    }
}

// --- END: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
         4 LOC | rust/ssxl_godot/src\ffi\mod.rs
// --- START: rust/ssxl_godot/src\ffi\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// Declares submodules within the `ffi` namespace.
// These correspond to files in `src/ffi/`.
//
// oracle.rs   ‚Üí Contains the SSXLOracle struct and related logic.
// signals.rs  ‚Üí Contains the SSXLSignals struct and signal definitions.
pub mod oracle;
pub mod signals;

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// Purpose:
//   - Makes selected types available directly from the `ffi` module,
//     so external code can import them without referencing submodules.
//
// Example:
//   Instead of writing:
//       use crate::ffi::oracle::SSXLOracle;
//   You can simply write:
//       use crate::ffi::SSXLOracle;
//
// This improves ergonomics and keeps external imports clean.
pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;

// --- END: rust/ssxl_godot/src\ffi\mod.rs ---
        64 LOC | rust/ssxl_godot/src\ffi\oracle.rs
// --- START: rust/ssxl_godot/src\ffi\oracle.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and macros for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// Node
//   - Godot‚Äôs fundamental scene graph class.
//   - SSXLOracle inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node;

// Base, Gd
//   - Base<Node>: wrapper around the Godot Node base class.
//   - Gd<T>: Godot reference-counted smart pointer for Rust objects exposed to Godot.
use godot::obj::{Base, Gd};

// SSXLEngine
//   - The core engine struct, containing generation and animation logic.
//   - SSXLOracle holds a reference to SSXLEngine to delegate work.
use crate::engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Struct: SSXLOracle
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as a Godot-facing "oracle" node that queries and delegates to SSXLEngine.
//   - Provides a lightweight interface for ticking the engine and retrieving status.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLOracle as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot‚Äôs Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node.
//   - engine: optional reference to SSXLEngine (bound later).
//   - tick_count: counter for how many ticks have been processed.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLOracle
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLOracle.
impl SSXLOracle {
    // init
    //   - Called when SSXLOracle is constructed.
    //   - Initializes with no engine bound and tick_count = 0.
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func] attributes.
// These methods can be called from GDScript or C#.
#[godot_api]
impl SSXLOracle {
    // _ready
    //   - Godot lifecycle method.
    //   - Called once when the node enters the scene tree.
    //   - Enables processing so _process() can run each frame.
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    // set_engine
    //   - Binds an SSXLEngine instance to this oracle.
    //   - Allows delegation of tick and query methods.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    // tick
    //   - Advances the engine by one tick.
    //   - Delegates to SSXLEngine::process_engine_tick.
    //   - Increments tick_count.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {
                // No engine bound; silently skip.
            }
        }
    }

    // get_current_tile_count
    //   - Queries SSXLEngine for the total number of tiles generated.
    //   - Returns 0 if engine is not bound.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_current_tile_count()
            }
            None => {
                0
            }
        }
    }

    // get_status
    //   - Queries SSXLEngine for a human-readable status string.
    //   - Returns "Engine not bound." if no engine is attached.
    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_status()
            }
            None => {
                GString::from("Engine not bound.")
            }
        }
    }
    
    // ping
    //   - Simple test function; currently does nothing.
    //   - Can be used to verify connectivity from Godot.
    #[func]
    pub fn ping(&self) {
    }

    // reset
    //   - Resets tick_count to 0.
    //   - Useful for restarting counters during testing or reinitialization.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    // get_tick
    //   - Returns the current tick_count.
    //   - Useful for monitoring how many ticks have been processed.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}

// --- END: rust/ssxl_godot/src\ffi\oracle.rs ---
        24 LOC | rust/ssxl_godot/src\ffi\signals.rs
// --- START: rust/ssxl_godot/src\ffi\signals.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Base<T>, GString, Dictionary, Vector2i, and the #[godot_api] attribute.
use godot::prelude::*;

// Node
//   - Godot‚Äôs fundamental scene graph class.
//   - SSXLSignals inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node; 

// -----------------------------------------------------------------------------
// Struct: SSXLSignals
// -----------------------------------------------------------------------------
// Purpose:
//   - Defines a Godot-facing class that emits signals from the Rust engine.
//   - Signals are the communication bridge between Rust logic and Godot scripts.
//   - This struct itself does not contain engine state; it only acts as a broadcaster.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLSignals as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot‚Äôs Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node that SSXLSignals wraps.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLSignals
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLSignals.
impl SSXLSignals {
    // init
    //   - Called when SSXLSignals is constructed.
    //   - Wraps the provided Node base inside the struct.
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Defines all signals exposed to Godot via #[signal] attributes.
// These signals can be connected to GDScript or C# methods in the Godot editor.
//
// Categories:
//   - Generation lifecycle signals
//   - Animation & utility signals
#[godot_api]
impl SSXLSignals {
    // -------------------------------------------------------------------------
    // Generation Lifecycle Signals
    // -------------------------------------------------------------------------

    // Emitted when map generation begins.
    #[signal]
    fn build_map_start();

    // Emitted when chunk data is updated (coordinates provided).
    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    // Emitted when a chunk is fully generated and converted into a render batch.
    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    // Emitted when map generation completes successfully.
    #[signal]
    fn build_map_complete();

    // Emitted when map generation is stopped prematurely.
    #[signal]
    fn build_map_stopped();

    // Emitted when a generation error occurs (error message provided).
    #[signal]
    fn generation_error(error_message: GString);

    // Emitted when chunk data is ready for use (coordinates provided).
    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    // Emitted at the end of each tick (frame), with current tick count.
    #[signal]
    fn tick_complete(current_tick: u64);

    // -------------------------------------------------------------------------
    // Animation & Utility Signals
    // -------------------------------------------------------------------------

    // Emitted when a tile‚Äôs flip frame is updated (tile ID + frame index).
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    // Emitted during animation updates (percent done + new atlas coordinates).
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    // Emitted when animation state changes (enabled/disabled).
    #[signal]
    fn animation_state_changed(enabled: bool);

    // Emitted when engine status changes (status message provided).
    #[signal]
    fn engine_status_updated(status_message: GString);
}

// --- END: rust/ssxl_godot/src\ffi\signals.rs ---
        10 LOC | rust/ssxl_godot/src\lib.rs
// --- START: rust/ssxl_godot/src\lib.rs ---
// -----------------------------------------------------------------------------
// Root Manifest: ssxl_godot
// -----------------------------------------------------------------------------
// This file is the entry point for the `ssxl_godot` crate.
// It defines the top-level module structure and the GDExtension boilerplate
// required for Godot to load this Rust library.

// -----------------------------------------------------------------------------
// Public Modules
// -----------------------------------------------------------------------------
// These modules are exposed to Godot and contain the core functionality.
// Each corresponds to a directory or file in `src/`.
//
// engine   ‚Üí Core engine logic (SSXLEngine, conductor, tick loop, API).
// ffi      ‚Üí Godot-facing FFI adapter nodes (SSXLOracle, SSXLSignals).
// tilemap  ‚Üí TileMap integration (SSXLTilemap, async_poll, status_reporter).
pub mod engine;
pub mod ffi;
pub mod tilemap; 

// -----------------------------------------------------------------------------
// Godot GDExtension Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides macros and traits for integrating Rust with Godot.
//   - Includes #[gdextension], Gd<T>, GodotClass, etc.
//
// ExtensionLibrary, InitLevel
//   - Traits and enums required to define the dynamic library‚Äôs lifecycle.
//   - InitLevel indicates which stage of Godot initialization is occurring.
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

// -----------------------------------------------------------------------------
// Struct: SSXLExtension
// -----------------------------------------------------------------------------
// Purpose:
//   - Placeholder struct required by godot-rust to implement ExtensionLibrary.
//   - Represents the extension library itself.
//   - Contains no fields because all logic is delegated to modules.
struct SSXLExtension;

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary
// -----------------------------------------------------------------------------
// #[gdextension]
//   - Marks this implementation as the entrypoint for Godot‚Äôs GDExtension system.
//   - Godot will call into this when loading the dynamic library.
//
// unsafe impl ExtensionLibrary
//   - Required by godot-rust to hook into Godot‚Äôs lifecycle.
//   - Declares how the extension behaves during initialization.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    // on_level_init
    //   - Called by Godot when a new initialization level is reached.
    //   - InitLevel indicates the stage (Core, Scene, Editor, etc.).
    //   - Currently does nothing, but can be extended to register classes,
    //     initialize resources, or set up global state.
    fn on_level_init(_level: InitLevel) {
        // No actions required at this stage.
    }
}

// --- END: rust/ssxl_godot/src\lib.rs ---
        72 LOC | rust/ssxl_godot/src\tilemap\async_poll.rs
// --- START: rust/ssxl_godot/src\tilemap\async_poll.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Receiver: bounded channel receiver (used for generation messages).
//   - UnboundedReceiver: unbounded channel receiver (used for animation updates).
//   - TryRecvError: error type returned when attempting non-blocking receive.
use tokio::sync::mpsc::{
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};

// AnimationUpdate
//   - Struct representing updates from the animation conductor.
//   - Typically contains tile coordinates and frame update payloads.
use ssxl_shared::AnimationUpdate; 

// GenerationMessage
//   - Enum representing messages from the generation conductor.
//   - Variants include Generated(chunk), StatusUpdate, GenerationComplete, etc.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// MAX_GEN_MSGS
//   - Maximum number of generation messages to process per poll.
//   - Prevents runaway loops if channel is flooded.
const MAX_GEN_MSGS: usize = 64;

// MAX_ANIM_MSGS
//   - Maximum number of animation messages to process per poll.
//   - Higher because animation updates can be more frequent.
const MAX_ANIM_MSGS: usize = 2048;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// AnimationReceiver
//   - Unbounded channel receiver for AnimationUpdate messages.
//   - Animation updates are frequent, so unbounded channel is used.
pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;

// GenerationReceiver
//   - Bounded channel receiver for GenerationMessage.
//   - Generation messages are controlled by the Conductor, so bounded channel is used.
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as the "bridge" between Tokio async channels and Godot‚Äôs main thread.
//   - Provides non-blocking polling methods to drain channels safely each frame.
//   - Stores optional receivers for generation and animation messages.
//
// Fields:
//   - generation_rx: optional bounded receiver for generation messages.
//   - animation_rx: optional unbounded receiver for animation updates.
#[derive(Default)]
pub struct AsyncPoller {
    generation_rx: Option<GenerationReceiver>,
    animation_rx: Option<AnimationReceiver>,
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides methods to set receivers, clear them, and poll messages.
impl AsyncPoller {
    // new
    //   - Creates a new AsyncPoller with default (None) receivers.
    pub fn new() -> Self {
        Self::default()
    }

    // set_animation_rx
    //   - Assigns an animation receiver to the poller.
    //   - Accepts Option<AnimationReceiver> to allow None when uninitialized.
    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        self.animation_rx = rx;
    }

    // set_generation_rx
    //   - Assigns a generation receiver to the poller.
    //   - Accepts Option<GenerationReceiver> to allow None when uninitialized.
    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        self.generation_rx = rx;
    }

    // clear_receivers
    //   - Clears both generation and animation receivers.
    //   - Useful for resetting state or shutting down channels.
    pub fn clear_receivers(&mut self) {
        self.generation_rx = None;
        self.animation_rx = None;
    }

    // poll_generation
    //   - Non-blocking poll of generation messages.
    //   - Drains up to MAX_GEN_MSGS messages from the channel.
    //   - Handles Empty (no messages) and Disconnected (channel closed).
    //   - Returns a vector of GenerationMessage.
    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.generation_rx = Some(rx);
        updates
    }

    // poll_animations
    //   - Non-blocking poll of animation updates.
    //   - Drains up to MAX_ANIM_MSGS messages from the channel.
    //   - Uses a smaller initial capacity (min(256)) for efficiency.
    //   - Returns a vector of AnimationUpdate.
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.animation_rx = Some(rx);
        updates
    }
}

// --- END: rust/ssxl_godot/src\tilemap\async_poll.rs ---
         3 LOC | rust/ssxl_godot/src\tilemap\mod.rs
// --- START: rust/ssxl_godot/src\tilemap\mod.rs ---
// -----------------------------------------------------------------------------
// Module: tilemap
// -----------------------------------------------------------------------------
// This file acts as the *parent module* for all tilemap-related components.
// It declares submodules and re-exports them so they can be accessed cleanly
// from other parts of the engine.
//
// Structure:
//   src/tilemap/
//     ‚îú‚îÄ‚îÄ mod.rs              ‚Üê this file
//     ‚îú‚îÄ‚îÄ ssxl_tilemap.rs     ‚Üê core tilemap logic
//     ‚îú‚îÄ‚îÄ async_poll.rs       ‚Üê async channel polling bridge
//     ‚îî‚îÄ‚îÄ status_reporter.rs  ‚Üê utility for reporting tilemap status

// -----------------------------------------------------------------------------
// Submodule: ssxl_tilemap
// -----------------------------------------------------------------------------
// Contains the main SSXLTilemap implementation.
//   - Responsible for managing tile placement, rendering, and integration
//     with Godot‚Äôs TileMap node.
//   - Provides the core API for interacting with chunks and tiles.
pub mod ssxl_tilemap;

// -----------------------------------------------------------------------------
// Submodule: async_poll
// -----------------------------------------------------------------------------
// Contains AsyncPoller, the bridge between Tokio async channels and Godot.
//   - Polls generation and animation channels safely on the main thread.
//   - Ensures non-blocking, panic-free message handling.
//   - Used by the engine tick loop to drain background updates.
pub mod async_poll;

// -----------------------------------------------------------------------------
// Submodule: status_reporter
// -----------------------------------------------------------------------------
// Contains utilities for reporting tilemap status back to Godot.
//   - Provides human-readable summaries of engine/tilemap state.
//   - Emits status updates via signals for debugging and monitoring.
//   - Helps external scripts understand the tilemap‚Äôs lifecycle.
pub mod status_reporter;

// --- END: rust/ssxl_godot/src\tilemap\mod.rs ---
       108 LOC | rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs
// --- START: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// TileMap, ITileMap
//   - TileMap: Godot‚Äôs built-in node for grid-based tile rendering.
//   - ITileMap: Trait that allows us to implement custom behavior for TileMap in Rust.
use godot::classes::{TileMap, ITileMap};

// Base
//   - Wrapper around the Godot base class for TileMap.
//   - Provides access to the underlying Godot object.
use godot::obj::Base;

// Vector2i, PackedVector2Array, PackedInt32Array
//   - Vector2i: integer 2D vector, used for tile coordinates.
//   - PackedVector2Array: efficient array of Vector2 values, used for batch positions.
//   - PackedInt32Array: efficient array of integers, used for alternative tile IDs.
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};

// OnceCell
//   - Thread-safe, one-time initialization cell.
//   - Used here to store the global TileMap instance ID for FFI callbacks.
use once_cell::sync::OnceCell;

// -----------------------------------------------------------------------------
// Global State
// -----------------------------------------------------------------------------
// TILEMAP_INSTANCE_ID
//   - Stores the Godot instance ID of the SSXLTilemap node.
//   - Allows external C-style FFI functions to access the TileMap safely.
pub static TILEMAP_INSTANCE_ID: OnceCell<InstanceId> = OnceCell::new(); 

// DEFAULT_LAYER
//   - Default layer index used when placing tiles via FFI callbacks.
const DEFAULT_LAYER: i32 = 0;

// -----------------------------------------------------------------------------
// Struct: SSXLTilemap
// -----------------------------------------------------------------------------
// Purpose:
//   - Custom Godot TileMap class that receives render batches from Rust signals
//     or FFI callbacks.
//   - Provides both batch rendering (signal-driven) and buffered updates (FFI-driven).
//
// Fields:
//   - base: underlying Godot TileMap node.
//   - tile_source_id: ID of the tile source used when setting cells.
//   - pending_updates: buffer of cell updates queued via FFI calls.
#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    pub tile_source_id: i32,
    pub pending_updates: Vec<(i32, i32, i32)>, // (world_x, world_y, tile_id)
}

// -----------------------------------------------------------------------------
// Implementation: ITileMap for SSXLTilemap
// -----------------------------------------------------------------------------
// Provides initialization logic when the TileMap node is created in Godot.
#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        // Store the instance ID globally for FFI access.
        let id = base.to_init_gd().instance_id();
        let _ = TILEMAP_INSTANCE_ID.set(id);

        Self {
            base,
            tile_source_id: 1,
            pending_updates: Vec::new(),
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: SSXLTilemap
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func].
#[godot_api]
impl SSXLTilemap {
    // -------------------------------------------------------------------------
    // Batch Render (Signal/GDScript)
    // -------------------------------------------------------------------------
    // batch_set_tiles
    //   - Primary entrypoint for rendering tiles in bulk.
    //   - Expects a Dictionary with keys: "layer", "positions", "atlas_coords", "alt_tiles".
    //   - Called from Rust signals or GDScript.
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        // Extract layer index.
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        // Extract positions array.
        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        // Extract atlas coordinates array.
        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        // Extract alternative tiles array (optional).
        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        // Ensure layer is enabled before placing tiles.
        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        // Iterate through all positions and place tiles.
        for i in 0..len {
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }

    // -------------------------------------------------------------------------
    // FFI Render (Callback)
    // -------------------------------------------------------------------------

    // get_instance
    //   - Retrieves the current SSXLTilemap instance using its global ID.
    //   - Allows external C functions to access the TileMap safely.
    fn get_instance() -> Option<Gd<Self>> {
        let id = TILEMAP_INSTANCE_ID.get()?;
        godot::prelude::Gd::try_from_instance_id(*id).ok()
    }

    // flush_updates
    //   - Flushes all pending updates queued via FFI calls.
    //   - Applies them to the TileMap in bulk.
    pub fn flush_updates(&mut self) {
        // Take ownership of the buffer before mutably borrowing self.base.
        let updates = std::mem::take(&mut self.pending_updates);
        let len = updates.len();

        if len == 0 {
            return;
        }

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();
        
        tilemap.set_layer_enabled(DEFAULT_LAYER, true);

        // Apply each update to the default layer.
        for (world_x, world_y, tile_id) in updates {
            let cell = Vector2i::new(world_x, world_y);
            let atlas = Vector2i::new(0, tile_id); 
            
            tilemap
                .set_cell_ex(DEFAULT_LAYER, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(0)
                .done();
        }

        godot_print!("FFI Host: Batch rendered {len} tiles via FFI callback.");
    }
}

// -----------------------------------------------------------------------------
// FFI Host Implementation
// -----------------------------------------------------------------------------
// These extern "C" functions are exposed for the ssxl_engine_ffi library.
// They allow C-style calls to queue and flush tile updates.

// ssxl_set_cell
//   - Queues a single cell update into pending_updates.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_set_cell(x: i32, y: i32, tile_id: i32) {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().pending_updates.push((x, y, tile_id));
    } else {
        godot_warn!("ssxl_set_cell: Tilemap instance not available. Update lost.");
    }
}

// ssxl_notify_tilemap_update
//   - Flushes all queued updates to the TileMap.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_notify_tilemap_update() {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().flush_updates();
    }
}

// --- END: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
        36 LOC | rust/ssxl_godot/src\tilemap\status_reporter.rs
// --- START: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// GString
//   - Godot‚Äôs string type, used for returning status messages to the scripting layer.
//   - Ensures compatibility with GDScript and C# in Godot.
use godot::prelude::GString;

// ConductorState
//   - Represents the state of the generation conductor (map/chunk generation).
//   - Provides methods like `get_status()` and `get_tiles_placed()` for querying progress.
use ssxl_generate::conductor::ConductorState;

// AnimationState
//   - Represents the state of the animation conductor.
//   - Provides fields like `time_scale` to indicate animation speed or whether it‚Äôs running.
use ssxl_shared::AnimationState;

// -----------------------------------------------------------------------------
// Struct: StatusReporter
// -----------------------------------------------------------------------------
// Purpose:
//   - Stateless utility struct for compiling human-readable status reports.
//   - Separates reporting logic from SSXLEngine, keeping engine code clean.
//   - Provides helper methods for status strings and tile counts.
pub struct StatusReporter;

// -----------------------------------------------------------------------------
// Implementation: StatusReporter
// -----------------------------------------------------------------------------
// Provides methods for generating status reports and querying tile counts.
impl StatusReporter {
    // -------------------------------------------------------------------------
    // Method: get_status_report
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Constructs a formatted status string combining generation and animation states.
    //   - Returns a Godot GString for direct use in the scripting layer.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState (generation system).
    //   - anim_state: optional reference to AnimationState (animation system).
    //
    // Behavior:
    //   - If gen_state is present, calls `get_status()` and formats it.
    //   - If anim_state is present, derives status from `time_scale`:
    //       * > 0.0 ‚Üí Running
    //       * == 0.0 ‚Üí Stopped
    //       * < 0.0 ‚Üí Error/Invalid
    //   - If either state is missing, defaults to "Uninitialized".
    //
    // Returns:
    //   - A GString containing: "STATUS: Generation: <gen_status> | Animation: <anim_status>"
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        // Handle generation state.
        let gen_status = gen_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Handle animation state.
        let anim_status = anim_state
            .map(|state| {
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Combine both statuses into one formatted string.
        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        // Return as Godot GString.
        GString::from(status.as_str())
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count_value
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Retrieves the total number of tiles placed by the generation conductor.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState.
    //
    // Behavior:
    //   - If gen_state is present, calls `get_tiles_placed()`.
    //   - If absent, defaults to 0.
    //
    // Returns:
    //   - u64 representing the tile count.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            .unwrap_or(0)
    }
}

// --- END: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
        58 LOC | rust/ssxl_math/src\coordinate_system.rs
// --- START: rust/ssxl_math/src\coordinate_system.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// serde::{Serialize, Deserialize}
//   - Enables serialization and deserialization of structs (WorldPos, ChunkKey, TileOffset).
//   - Useful for saving/loading world state or transmitting coordinates across systems.
use serde::{Serialize, Deserialize};

// CHUNK_SIZE_I64
//   - Constant defining the cubic dimension of a chunk (e.g., 32).
//   - Used to calculate chunk boundaries and offsets.
use crate::primitives::CHUNK_SIZE_I64;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows extremely large coordinate ranges, far beyond i32 limits.
use glam::I64Vec3;

// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------
// These structs define the fundamental coordinate system for the engine.
// They wrap I64Vec3 to provide semantic meaning (WorldPos vs ChunkKey vs TileOffset).

// WorldPos
//   - Represents a specific point in the infinite 3D world.
//   - Stored as a 64-bit vector to handle huge coordinates safely.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

// ChunkKey
//   - Identifies a chunk in the world.
//   - Each chunk is a cubic volume of size CHUNK_SIZE_I64.
//   - Acts as the "index" of the chunk in world space.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

// TileOffset
//   - Represents the local position of a tile inside its parent chunk.
//   - Always non-negative, ranging from 0 to CHUNK_SIZE_I64 - 1.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);

// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------
// Provides conversion from global coordinates to chunk-local coordinates.
impl WorldPos {
    // to_chunk_coords
    //   - Splits a global WorldPos into (ChunkKey, TileOffset).
    //   - Uses Euclidean division to handle negative coordinates correctly.
    //   - Ensures TileOffset is always non-negative.
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        let chunk_size = CHUNK_SIZE_I64;

        // Compute tile offset using rem_euclid (always non-negative).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // Compute chunk index by subtracting offset and dividing by chunk size.
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------
// Provides conversion from chunk-local coordinates back to global coordinates.
impl ChunkKey {
    // to_world_pos
    //   - Reconstructs a WorldPos from a ChunkKey and TileOffset.
    //   - Formula: World = (Chunk Index * Chunk Size) + Tile Offset.
    //   - Ensures round-trip consistency with WorldPos::to_chunk_coords.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates correctness of conversions, especially for large and negative coordinates.
#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    #[test]
    fn test_world_to_chunk_positive() {
        // Large positive coordinate (well beyond i32::MAX).
        let huge_coord = 5_000_000_000i64;
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64;
        let expected_offset = huge_coord % CHUNK_SIZE_I64;

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // Verify chunk index and offset.
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        // Case 1: (-1, -1, -1) ‚Üí ChunkKey = -1, Offset = 31.
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Case 2: (-33, -64, -100) ‚Üí deeper negative coordinates.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        // Round-trip test: WorldPos ‚Üí (ChunkKey, TileOffset) ‚Üí WorldPos.
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();
        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}

// --- END: rust/ssxl_math/src\coordinate_system.rs ---
        14 LOC | rust/ssxl_math/src\generation_utils.rs
// --- START: rust/ssxl_math/src\generation_utils.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLData
//   - Trait defined in the primitives module.
//   - Provides two essential methods:
//       * get_id() -> u64: returns a unique identifier for the data.
//       * get_value_len() -> usize: returns the length of the associated value.
//   - Used here to process data objects generically.
use crate::primitives::SSXLData;

// rand::Rng
//   - Trait from the `rand` crate that provides random number generation utilities.
//   - Enables us to call gen_range() for chance rolls.
use rand::Rng;

// -----------------------------------------------------------------------------
// Function: generate_percent_roll
// -----------------------------------------------------------------------------
// Purpose:
//   - Performs a probabilistic roll against a given percentage chance.
//   - Used in procedural generation to decide whether an event occurs (e.g., spawning resources).
//
// Arguments:
//   - target_percent: u8 (0‚Äì100), representing the probability of success.
//
// Behavior:
//   - Generates a random integer between 0 and 99 inclusive.
//   - Compares it against target_percent.
//   - Returns 0 if success (random < target_percent).
//   - Returns 1 if failure (random >= target_percent).
//
// Example:
//   - generate_percent_roll(25) ‚Üí 25% chance of returning 0 (success).
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the range [0, 99].
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Compare against target_percent.
    if rand_val < target_percent {
        0 // Success
    } else {
        1 // Failure
    }
}

// -----------------------------------------------------------------------------
// Function: process_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Processes an object implementing SSXLData to derive a simple aggregate identifier.
//   - Combines the object's unique ID with the length of its value payload.
//   - Useful for lightweight hashing, checksums, or quick uniqueness checks.
//
// Arguments:
//   - data: reference to any object implementing SSXLData.
//
// Behavior:
//   - Calls get_id() to retrieve the object‚Äôs unique identifier.
//   - Calls get_value_len() to retrieve the length of its payload.
//   - Adds them together to produce a u64 aggregate value.
//
// Returns:
//   - u64 representing the combined identifier + payload length.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine ID and payload length into a single value.
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}

// --- END: rust/ssxl_math/src\generation_utils.rs ---
        42 LOC | rust/ssxl_math/src\hashing.rs
// --- START: rust/ssxl_math/src\hashing.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLResult
//   - A custom result type defined in the primitives module.
//   - Used here to wrap hashing results, ensuring consistency with the rest of the engine.
use crate::primitives::SSXLResult;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows chunk coordinates to span extremely large worlds without overflow.
use glam::I64Vec3;

// sha2::{Digest, Sha256}
//   - Digest: trait providing hashing functionality.
//   - Sha256: implementation of the SHA-256 cryptographic hash algorithm.
//   - Used to generate deterministic, collision-resistant hashes.
use sha2::{Digest, Sha256};

// -----------------------------------------------------------------------------
// Function: hash_chunk_coords
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a given 3D chunk coordinate.
//   - Ensures that identical coordinates always produce the same hash string.
//   - Used as a unique identifier for chunks in caching and procedural generation.
//
// Arguments:
//   - coords: I64Vec3 representing the chunk‚Äôs world-space coordinates.
//
// Behavior:
//   - Serializes coordinates into a canonical string format ("x:y:z").
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string.
//
// Returns:
//   - SSXLResult<String> containing the hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // Serialize coordinates into a deterministic string.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // Convert hash bytes into lowercase hex string.
    Ok(format!("{:x}", result))
}

// -----------------------------------------------------------------------------
// Function: hash_content_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a generic u64 data key.
//   - Used for content caching (e.g., assets, seeds, configurations).
//   - Adds a "content_" prefix for easy identification in cache systems.
//
// Arguments:
//   - data_key: u64 identifier for the content.
//
// Behavior:
//   - Converts the key into a string.
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string prefixed with "content_".
//
// Returns:
//   - SSXLResult<String> containing the prefixed hash.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // Convert numeric key into string.
    let key_string = data_key.to_string();

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // Prefix with "content_" and return.
    Ok(format!("content_{:x}", result))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates determinism, uniqueness, and formatting of the hashing functions.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chunk_coords_determinism() {
        // Same coordinates should always produce identical hashes.
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        // Adjacent coordinates should produce different hashes.
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        // Verify hash length and uniqueness.
        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    fn test_content_data_determinism_and_format() {
        // Same content key should always produce identical hashes.
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        // Verify prefix and total length.
        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}

// --- END: rust/ssxl_math/src\hashing.rs ---
        30 LOC | rust/ssxl_math/src\lib.rs
// --- START: rust/ssxl_math/src\lib.rs ---
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// These modules define the mathematical foundation of the SSXL engine.
// Each module is declared here so they can be accessed throughout the crate.

// coordinate_system
//   - Defines core coordinate types (WorldPos, ChunkKey, TileOffset).
//   - Handles conversion between global world positions and chunk-local offsets.
pub mod coordinate_system;

// generation_utils
//   - Provides utility functions for procedural generation.
//   - Includes randomness utilities (percent rolls) and data processing helpers.
pub mod generation_utils;

// hashing
//   - Provides deterministic hashing functions.
//   - Used for chunk IDs, cache keys, and ensuring stable procedural generation.
pub mod hashing;

// primitives
//   - Defines core mathematical constants, types, and result/error handling.
//   - Acts as the foundation for other modules.
pub mod primitives;

// -----------------------------------------------------------------------------
// Fast Inverse Square Root (q_rsqrt)
// -----------------------------------------------------------------------------
// Purpose:
//   - Approximates 1/sqrt(number) extremely quickly using bit-level operations.
//   - Famous algorithm from Quake III Arena, adapted here for safe use.
//   - Used for vector normalization and other math-heavy operations.
//
// Arguments:
//   - number: f32, the value to invert square root.
//
// Behavior:
//   - Returns 0.0 if input is <= 0.0 (safety guard).
//   - Uses bit manipulation to approximate inverse square root.
//   - Refines result with one Newton-Raphson iteration.
//
// Returns:
//   - Approximate 1/sqrt(number).
#[inline(always)]
pub fn q_rsqrt(number: f32) -> f32 {
    // Safety guard: prevent NaN or undefined behavior.
    if number <= 0.0 { 
        return 0.0;
    }

    // Constant used in Newton-Raphson iteration.
    const THREEHALFS: f32 = 1.5;

    // Half of the input number.
    let x2 = number * 0.5;
    let y = number;
    
    // Bit-level hack: reinterpret float bits as integer.
    let i = y.to_bits();
    // Magic constant (0x5f3759df) minus half of exponent bits.
    let j_bits = 0x5f3759df_u32.wrapping_sub(i >> 1);

    // Reinterpret back into float.
    let mut y = f32::from_bits(j_bits);
    
    // One iteration of Newton-Raphson refinement.
    y = y * (THREEHALFS - (x2 * y * y));
    y
}

// -----------------------------------------------------------------------------
// Vector Normalization
// -----------------------------------------------------------------------------
// Purpose:
//   - Computes the unit vector (normalized vector) of a 3D vector.
//   - Uses q_rsqrt for fast inverse square root approximation.
//
// Arguments:
//   - x, y, z: f32 components of the vector.
//
// Behavior:
//   - Computes squared magnitude (x¬≤ + y¬≤ + z¬≤).
//   - Uses q_rsqrt to approximate 1/sqrt(mag_sq).
//   - Multiplies each component by inverse magnitude.
//
// Returns:
//   - Tuple (f32, f32, f32) representing normalized vector.
pub fn normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32) {
    let mag_sq = x * x + y * y + z * z;
    let inv_mag = q_rsqrt(mag_sq); 
    
    (x * inv_mag, y * inv_mag, z * inv_mag)
}

// -----------------------------------------------------------------------------
// Prelude Module
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a convenience re-export of all essential types and functions.
//   - Allows other crates to import `ssxl_math::prelude::*` for quick access.
//
// Contents:
//   - Re-exports coordinate_system, generation_utils, hashing, primitives.
//   - Re-exports q_rsqrt and normalize_vector_3d.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
    
    pub use super::q_rsqrt;
    pub use super::normalize_vector_3d;
}

// --- END: rust/ssxl_math/src\lib.rs ---
        19 LOC | rust/ssxl_math/src\primitives.rs
// --- START: rust/ssxl_math/src\primitives.rs ---
// -----------------------------------------------------------------------------
// Primitives: low-level types, aliases, traits, and constants
// -----------------------------------------------------------------------------
// serde::{Deserialize, Serialize}
//   - Derive macros to allow this crate‚Äôs basic types to be serialized/deserialized
//     for persistence, networking, and inter-crate messaging.
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Vec2i: a 2D integer vector
// -----------------------------------------------------------------------------
// Purpose:
//   - Canonical 2D coordinate used across the engine for tiles and chunk indexing.
// Design notes:
//   - Uses i64 to align with the engine‚Äôs 64-bit world coordinates (I64Vec3),
//     preventing silent overflow if values are promoted or combined with i64 math.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    // X component (horizontal axis)
    pub x: i64,
    // Y component (vertical axis)
    pub y: i64,
}

impl Vec2i {
    // Constructor for Vec2i, emphasizing explicitness and avoiding field-order mistakes.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// -----------------------------------------------------------------------------
// Type aliases: semantic clarity with zero runtime cost
// -----------------------------------------------------------------------------
// TileCoord
//   - Semantic alias for a tile‚Äôs coordinate in 2D space (world or local).
//   - Keeps API readable and intent-focused while reusing Vec2i‚Äôs layout.
pub type TileCoord = Vec2i; 

// ChunkId
//   - Semantic alias for a chunk‚Äôs 2D identifier in a world grid.
//   - Mirrors TileCoord‚Äôs layout for consistency across APIs and storage.
pub type ChunkId = Vec2i; 

// SSXLResult<T>
//   - Project-wide lightweight Result alias with String errors.
//   - Favoring human-readable messages across crate boundaries without custom error enums.
pub type SSXLResult<T> = Result<T, String>;

// -----------------------------------------------------------------------------
// Trait: SSXLData
// -----------------------------------------------------------------------------
// Purpose:
//   - Minimal contract for data managed by the engine (task queues, caches, workers).
// Concurrency:
//   - Send + Sync required to safely move/share implementors across thread boundaries.
pub trait SSXLData: Send + Sync {
    // Unique, stable identifier used for indexing, caching, and deduplication.
    fn get_id(&self) -> u64;

    // Size of the core payload (bytes or elements), useful for diagnostics and limits.
    fn get_value_len(&self) -> usize;
}

// -----------------------------------------------------------------------------
// Global constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE_I64
//   - Canonical cubic side length for procedural chunks.
//   - i64 type matches engine math and avoids cross-type casting pitfalls.
pub const CHUNK_SIZE_I64: i64 = 32;

// F32_EPSILON
//   - Small tolerance for floating-point comparisons in math-heavy routines
//     (e.g., noise interpolation, normalization).
pub const F32_EPSILON: f32 = 1.0e-6;

// --- END: rust/ssxl_math/src\primitives.rs ---
       133 LOC | rust/ssxl_shared/src\chunk\chunk_data.rs
// --- START: rust/ssxl_shared/src\chunk\chunk_data.rs ---
// ============================================================================
// üß± Chunk Data Module (`ssxl_shared::chunk::chunk_data`)
// ----------------------------------------------------------------------------
// This module defines the core structures and utilities for handling chunks,
// which are fixed-size grids of tiles (32x32 by default) in the SSXL engine.
// Chunks are the atomic unit of world generation, caching, and rendering.
//
// Key Concepts:
//   ‚Ä¢ ChunkCoords: Identifies a chunk‚Äôs position in chunk-space (grid coordinates).
//   ‚Ä¢ ChunkData: Holds all data for a chunk, including:
//       - Unique ID (hashed from coordinates)
//       - Bounds in world-space
//       - Tile array (1024 TileData entries)
//       - Dimension tag (e.g., "Overworld", "Default")
//       - Generation timestamp (serialized deterministically)
//
// Design Choices:
//   ‚Ä¢ Fixed size (CHUNK_SIZE = 32) ensures predictable memory layout.
//   ‚Ä¢ Tiles stored in a flat array for cache-friendly access.
//   ‚Ä¢ `serde_big_array` used to serialize large fixed arrays.
//   ‚Ä¢ `system_time_serde` ensures timestamps are cross-platform and deterministic.
//   ‚Ä¢ Zigzag encoding + bit-packing used to generate unique chunk IDs.
//
// Core Methods:
//   ‚Ä¢ new / new_at_coords: Constructors for creating chunks either by explicit
//     parameters or by grid coordinates.
//   ‚Ä¢ zigzag_encode / hash_coords_2d: Utilities for encoding signed coordinates
//     into compact, unique u64 identifiers.
//   ‚Ä¢ coord_to_index_checked / coord_to_index_unchecked: Convert (x,y) tile
//     coordinates into array indices, with or without bounds checking.
//   ‚Ä¢ get_tile / get_tile_mut: Safe accessors for tiles.
//   ‚Ä¢ get_tile_unchecked / get_tile_mut_unchecked: Unsafe, faster accessors
//     when bounds are guaranteed externally.
//   ‚Ä¢ insert_tiles: Bulk replacement of the tile array, with validation.
//
// Testing:
//   ‚Ä¢ Unit tests validate index conversion, zigzag encoding, and hashing logic.
//   ‚Ä¢ Ensures correctness for edge cases (negative coords, large values).
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how game engines balance safety and performance:
//     - Safe methods for general use.
//     - Unsafe methods for hot paths where performance is critical.
//   ‚Ä¢ Hashing and encoding strategies ensure chunks can be uniquely identified
//     across infinite coordinate ranges.
// ============================================================================


use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto;
use std::ptr; 

use super::grid_bounds::GridBounds;
use crate::tile::tile_data::TileData; 
use crate::math::math_primitives;
use ssxl_math::prelude::Vec2i;
use serde_big_array::BigArray;

pub const CHUNK_SIZE: u32 = 32;
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    pub id: u64,
    pub bounds: GridBounds,
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    pub dimension_tag: String,
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}

impl ChunkData {
    pub const SIZE: u32 = CHUNK_SIZE;

    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    #[inline(always)]
    pub const fn zigzag_encode(n: i64) -> u64 {
        ((n << 1) ^ (n >> 63)) as u64
    }

    #[inline(always)]
    pub const fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);
        ux | (uy << 32)
    }
    
    #[inline(always)]
    fn coord_to_index_checked(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    #[inline(always)]
    pub const fn coord_to_index_unchecked(x: u32, y: u32) -> usize {
        (y * Self::SIZE + x) as usize
    }

    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    #[inline(always)]
    pub unsafe fn get_tile_unchecked(&self, x: u32, y: u32) -> &TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &self.tiles[index]
    }
    
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        match tiles_vec.try_into() {
            Ok(arr) => {
                unsafe { ptr::write(&mut self.tiles, arr) };
            }
            Err(vec) => {
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }

    #[inline(always)]
    pub unsafe fn get_tile_mut_unchecked(&mut self, x: u32, y: u32) -> &mut TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &mut self.tiles[index]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_coord_to_index() {
        assert_eq!(ChunkData::coord_to_index_checked(0, 0), Some(0));
        assert_eq!(ChunkData::coord_to_index_checked(16, 16), Some(528));
        assert_eq!(ChunkData::coord_to_index_checked(31, 31), Some(1023));
        assert_eq!(ChunkData::coord_to_index_checked(32, 0), None);
        assert_eq!(ChunkData::coord_to_index_checked(0, 32), None);
        assert_eq!(ChunkData::coord_to_index_checked(33, 33), None);
        
        assert_eq!(ChunkData::coord_to_index_unchecked(0, 0), 0);
        assert_eq!(ChunkData::coord_to_index_unchecked(31, 31), 1023);
    }
    
    #[test]
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    fn test_hash_coords_2d() {
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        let big_x = i64::MAX / 2;
        let big_y = i64::MIN / 2;
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0);
    }
}

// --- END: rust/ssxl_shared/src\chunk\chunk_data.rs ---
        36 LOC | rust/ssxl_shared/src\chunk\grid_bounds.rs
// --- START: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
use crate::Serialize;
use crate::Deserialize;
// -----------------------------------------------------------------------------
// Grid Bounds Module Overview
// -----------------------------------------------------------------------------
// This module defines the fundamental 2D coordinate and bounding box structures
// used throughout the SSXL engine. These are essential for representing world-space
// positions and rectangular regions (chunks, tiles, or arbitrary areas).
//
// Key Components:
// - Coord2D: A single point in 2D world space.
// - GridBounds: A rectangular bounding box defined by min and max coordinates.
// -----------------------------------------------------------------------------
//
// Coord2D
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a single 2D coordinate in world space.
//   - Uses i64 to support extremely large coordinate ranges (beyond i32 limits).
// Derives:
//   - Debug, Clone, Copy: for easy inspection and duplication.
//   - PartialEq, Eq, PartialOrd, Ord, Hash: for comparisons and use in collections.
//   - Serialize, Deserialize: for persistence and networking.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    pub x: i64, // X component of the coordinate
    pub y: i64, // Y component of the coordinate
}

// -----------------------------------------------------------------------------
// GridBounds
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a rectangular region in 2D world space.
//   - Defined by inclusive minimum (min) and exclusive maximum (max) coordinates.
// Convention:
//   - Half-open range: [min, max)
//     * min is inclusive
//     * max is exclusive
//   - This ensures correct size calculation and avoids off-by-one errors.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    pub min: Coord2D, // Inclusive minimum coordinate (bottom-left corner)
    pub max: Coord2D, // Exclusive maximum coordinate (one past top-right corner)
}

impl GridBounds {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new GridBounds from explicit min and max coordinates.
    // Arguments:
    //   - min_x, min_y: inclusive minimum coordinates
    //   - max_x, max_y: exclusive maximum coordinates
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    // -------------------------------------------------------------------------
    // Method: size
    // -------------------------------------------------------------------------
    // Calculates the width and height of the bounds.
    // Formula:
    //   size.x = max.x - min.x
    //   size.y = max.y - min.y
    // Works correctly with half-open ranges, yielding the number of integer
    // coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    // -------------------------------------------------------------------------
    // Method: contains
    // -------------------------------------------------------------------------
    // Checks if a given coordinate lies within the bounds.
    // Follows half-open range convention:
    //   - min.x <= coord.x < max.x
    //   - min.y <= coord.y < max.y
    // Returns:
    //   - true if inside bounds
    //   - false otherwise
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default GridBounds instance.
//   - min = (0,0)
//   - max = (0,0)
// Represents a zero-sized bounds at the origin.
impl Default for GridBounds {
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}

// --- END: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
         2 LOC | rust/ssxl_shared/src\chunk\mod.rs
// --- START: rust/ssxl_shared/src\chunk\mod.rs ---
// -----------------------------------------------------------------------------
// Chunk Module Overview
// -----------------------------------------------------------------------------
// This file serves as the **module root** for all chunk-related functionality
// in the `ssxl_shared` crate. It organizes and exposes submodules that define
// the data structures and utilities for handling chunks in the SSXL engine.
//
// Why this matters:
//   - Rust modules are hierarchical. Declaring `pub mod ...` here tells the compiler
//     to look for corresponding files (or directories) and include them as part of
//     the `chunk` namespace.
//   - By centralizing these declarations, we ensure that all chunk-related logic
//     is grouped together and can be accessed via `ssxl_shared::chunk::...`.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Submodule: chunk_data
// -----------------------------------------------------------------------------
// Contains the **ChunkData** struct, which represents a single chunk of the world.
// Responsibilities:
//   - Stores chunk ID, bounds, tiles, dimension tag, and timestamp.
//   - Provides methods for tile access, insertion, and coordinate hashing.
//   - Acts as the atomic unit of procedural generation and caching.
// Usage:
//   - Accessed via `ssxl_shared::chunk::chunk_data::ChunkData`.
pub mod chunk_data;

// -----------------------------------------------------------------------------
// Submodule: grid_bounds
// -----------------------------------------------------------------------------
// Contains the **GridBounds** struct and supporting types (Coord2D).
// Responsibilities:
//   - Defines rectangular bounding boxes in world space.
//   - Provides utilities for size calculation and containment checks.
//   - Used by ChunkData to represent the spatial extent of a chunk.
// Usage:
//   - Accessed via `ssxl_shared::chunk::grid_bounds::GridBounds`.
pub mod grid_bounds;

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------
// Together, `chunk_data` and `grid_bounds` form the foundation of chunk management:
//   - `chunk_data` handles the contents and metadata of a chunk.
//   - `grid_bounds` defines the spatial boundaries of a chunk.
// This modular design keeps responsibilities clear and makes the engine easier
// to maintain, extend, and test.
// -----------------------------------------------------------------------------

// --- END: rust/ssxl_shared/src\chunk\mod.rs ---
        41 LOC | rust/ssxl_shared/src\config\config.rs
// --- START: rust/ssxl_shared/src\config\config.rs ---
// -----------------------------------------------------------------------------
// Global Configuration Module Overview
// -----------------------------------------------------------------------------
// This module defines the configuration structure and constants that govern
// the SSXL engine‚Äôs behavior. It ensures consistent values across crates
// (math, generate, cache, godot) and provides safe defaults when loading fails.
//
// Key Components:
// - SSXLConfig: Struct holding runtime configuration settings.
// - CHUNK_SIZE / TILE_ARRAY_SIZE: Constants defining chunk geometry.
// - DEFAULT_CONFIG_PATH: Default path for configuration file.
// - new_with_defaults: Provides safe fallback values.
// - load_from_path: Attempts to load configuration (placeholder implementation).
// - default_generator_id: Accessor for generator ID.
// - get_config_from_path: Public function to load configuration safely.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// tracing::{info, warn}
//   - Logging macros for runtime diagnostics (info-level success, warn-level failure).
// std::error::Error
//   - Trait object used for error handling in load_from_path.
// serde::{Deserialize, Serialize}
//   - Enables serialization/deserialization of SSXLConfig for persistence and loading.
use tracing::{info, warn};
use std::error::Error;
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Struct: SSXLConfig
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds runtime configuration settings for the SSXL engine.
// Fields:
//   - ca_default_ruleset: Default ruleset ID for cellular automata generation.
//   - default_generator_id: Identifier for the default generator used in world creation.
// Derives:
//   - Debug, Clone: For inspection and duplication.
//   - Serialize, Deserialize: For persistence and loading from config files.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSXLConfig {
    pub ca_default_ruleset: u8,
    pub default_generator_id: String,
}

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE
//   - Canonical side length of a chunk in tiles (32).
// TILE_ARRAY_SIZE
//   - Total number of tiles in a chunk (32 * 32 = 1024).
// DEFAULT_CONFIG_PATH
//   - Default file path for configuration JSON.
pub const CHUNK_SIZE: u32 = 32;
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
const DEFAULT_CONFIG_PATH: &str = "res://ssxl_config.json";

// -----------------------------------------------------------------------------
// Implementation: SSXLConfig
// -----------------------------------------------------------------------------
impl SSXLConfig {
    // -------------------------------------------------------------------------
    // Method: new_with_defaults
    // -------------------------------------------------------------------------
    // Provides a safe, hardcoded default configuration.
    // Ensures engine can initialize even if config file is missing or invalid.
    pub fn new_with_defaults() -> Self {
        SSXLConfig {
            ca_default_ruleset: 1,
            default_generator_id: "default_noise_gen".to_string(),
        }
    }

    // -------------------------------------------------------------------------
    // Method: load_from_path
    // -------------------------------------------------------------------------
    // Attempts to load configuration from a file path.
    // Currently a placeholder: always returns defaults.
    // Returns:
    //   - Ok(Self) on success
    //   - Err(Box<dyn Error>) on failure
    pub fn load_from_path(_path: &str) -> Result<Self, Box<dyn Error>> {
        Ok(SSXLConfig::new_with_defaults())
    }
    
    // -------------------------------------------------------------------------
    // Method: default_generator_id
    // -------------------------------------------------------------------------
    // Accessor for the default generator ID.
    // Returns a clone of the string to avoid ownership issues.
    pub fn default_generator_id(&self) -> String {
        self.default_generator_id.clone()
    }
}

// -----------------------------------------------------------------------------
// Function: get_config_from_path
// -----------------------------------------------------------------------------
// Purpose:
//   - Public entry point for loading configuration.
//   - Attempts to load from provided path or falls back to DEFAULT_CONFIG_PATH.
// Behavior:
//   - On success: logs info and returns loaded config.
//   - On failure: logs warning and returns safe defaults.
// Ensures engine always initializes with valid configuration.
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            warn!(
                "Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.",
                path_to_load,
                e
            );
            SSXLConfig::new_with_defaults()
        }
    }
}

// --- END: rust/ssxl_shared/src\config\config.rs ---
         1 LOC | rust/ssxl_shared/src\config\mod.rs
// --- START: rust/ssxl_shared/src\config\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/config/mod.rs
// -----------------------------------------------------------------------------
// Purpose:
//   - This file acts as the *module root* for configuration logic in the
//     `ssxl_shared` crate.
//   - By declaring `pub mod config;`, it exposes the `config.rs` file as a
//     public submodule, making its types and functions available under
//     `ssxl_shared::config::...`.
//
// Why it matters:
//   - Keeps the crate organized: all configuration constants and structs live
//     in one place.
//   - Provides a clean namespace boundary, so other crates can import
//     `SSXLConfig` or constants without digging into file paths.
// -----------------------------------------------------------------------------
pub mod config;

// --- END: rust/ssxl_shared/src\config\mod.rs ---
        21 LOC | rust/ssxl_shared/src\error\errors.rs
// --- START: rust/ssxl_shared/src\error\errors.rs ---
use thiserror::Error;

// -----------------------------------------------------------------------------
// SSXLResult
// -----------------------------------------------------------------------------
// A project-wide Result type that standardizes error handling.
// All fallible functions in the SSXL engine should return this type.
pub type SSXLResult<T> = Result<T, SSXLError>;

// -----------------------------------------------------------------------------
// SSXLError
// -----------------------------------------------------------------------------
// Central error enumeration for the SSXL engine.
// Each variant represents a distinct failure category, ensuring consistent
// reporting across subsystems and FFI boundaries.
#[derive(Error, Debug)]
pub enum SSXLError {
    // I/O failures such as file system or network errors.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    // Serialization or deserialization problems (e.g., Bincode, Serde).
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    // Invalid or inconsistent data states (e.g., wrong tile array size).
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    // Failures in the procedural generation pipeline.
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    // Errors in the Godot bridge or FFI layer.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    // Critical, unexpected bug in core logic.
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    // Wrapper for errors from external crates not covered elsewhere.
    #[error("External Crate Error: {0}")]
    External(String),
}

// -----------------------------------------------------------------------------
// Error Conversions
// -----------------------------------------------------------------------------
// Provides convenient conversions from common external error types into SSXLError.
// Ensures external libraries integrate smoothly with the SSXL error system.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}

// --- END: rust/ssxl_shared/src\error\errors.rs ---
         1 LOC | rust/ssxl_shared/src\error\mod.rs
// --- START: rust/ssxl_shared/src\error\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/error/mod.rs
// -----------------------------------------------------------------------------
// This file is the entry point for the `error` namespace in the `ssxl_shared` crate.
// By declaring `pub mod errors;`, it exposes the `errors.rs` submodule, which
// contains the canonical `SSXLError` enum and `SSXLResult` type alias.
// Purpose:
//   - Centralizes error handling for the engine.
//   - Provides a clean namespace so other crates can import errors via
//     `ssxl_shared::error::SSXLError` or `ssxl_shared::error::SSXLResult`.
// -----------------------------------------------------------------------------
pub mod errors;

// --- END: rust/ssxl_shared/src\error\mod.rs ---
        22 LOC | rust/ssxl_shared/src\job\mod.rs
// --- START: rust/ssxl_shared/src\job\mod.rs ---
// ============================================================================
// ‚ö° SSXL Job Module ‚ö°
// File: ssxl_shared/src/job/mod.rs
// ----------------------------------------------------------------------------
// This module is the **command center** of the SSXL engine.
// It defines the packets of intent (jobs) and the packets of outcome (results)
// that flow between the engine core and its generation pipeline.
// Think of it as the **messenger guild**: jobs go in, results come out.
// ============================================================================

use crate::ChunkData; // üéØ Core chunk payload imported from lib.rs

// -----------------------------------------------------------------------------
// üöÄ Instruction Packet: SSXLJob
// -----------------------------------------------------------------------------
// Represents the set of commands the engine can receive.
// Each variant is a ritual order, telling the generator what to do next.
pub enum SSXLJob {
    // üó∫Ô∏è BuildMap: Spin up a new world grid with given dimensions and seed.
    BuildMap {
        width: u32,
        height: u32,
        seed: u64,
        generator_id: String, // üîë Which generator to invoke
    },

    // üîß SetGenerator: Swap out the active generator configuration mid-flight.
    SetGenerator {
        generator_id: String,
    },

    // üõë StopGeneration: Halt all jobs, both running and queued.
    StopGeneration,

    // ... Future expansion: more job types can be added here.
}

// -----------------------------------------------------------------------------
// üéØ Result Packet: JobResult
// -----------------------------------------------------------------------------
// Represents the outcomes returned back to the engine tick loop.
// Each variant is a signal of success, completion, or failure.
pub enum JobResult {
    // üåü ChunkGenerated: A new chunk is ready for integration into world state.
    ChunkGenerated {
        x: i32,          // Explicit coordinates for clarity
        y: i32,
        data: ChunkData, // üì¶ The freshly minted chunk payload
    },

    // ‚úÖ MapBuildComplete: The BuildMap job has finished successfully.
    MapBuildComplete,

    // üí• Error: Something went wrong during job execution.
    Error(String),
}

// --- END: rust/ssxl_shared/src\job\mod.rs ---
        53 LOC | rust/ssxl_shared/src\lib.rs
// --- START: rust/ssxl_shared/src\lib.rs ---
// ============================================================================
// üì¶ SSXL Shared Crate Root
// File: ssxl_shared/src/lib.rs (or equivalent entry point)
// ----------------------------------------------------------------------------
// This file defines the top-level structure of the `ssxl_shared` crate.
// It organizes submodules, re-exports key types, and provides FFI entry points
// for external runtimes (CLI, Godot, etc.).
//
// Educational notes:
//   - In Rust, the crate root (`lib.rs` or `main.rs`) is the starting point
//     for module resolution. Declaring `pub mod ...` here makes submodules
//     available to the rest of the crate.
//   - Re-exports (`pub use ...`) provide a curated public API, so downstream
//     code doesn‚Äôt need to know the internal file layout.
//   - FFI functions (`#[no_mangle] extern "C" fn ...`) allow this crate to be
//     called from non-Rust environments (e.g., C, Godot).
// ============================================================================

use serde::{Deserialize, Serialize}; // Serialization traits for data persistence and networking
use tracing;                         // Structured logging for runtime diagnostics

// -----------------------------------------------------------------------------
// üìÇ Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` corresponds to a directory or file under `src/`.
// Declaring them here makes their contents available throughout the crate.
// -----------------------------------------------------------------------------
pub mod chunk;    // Chunk-related data structures (ChunkData, GridBounds, etc.)
pub mod tile;     // Tile-related data structures (TileData, TileType, etc.)
pub mod error;    // Error handling utilities (SSXLError, SSXLResult)
pub mod config;   // Configuration loading and parsing (SSXLConfig)
pub mod message;  // Messaging system for animation/generation commands
pub mod math;     // Math primitives and helpers (serialization, vectors, etc.)
pub mod job;      // Job definitions for generation tasks

// -----------------------------------------------------------------------------
// üîó Public Re-exports
// -----------------------------------------------------------------------------
// These re-exports expose commonly used types at the crate root.
// This simplifies imports for downstream crates (e.g., `ssxl_godot`).
// -----------------------------------------------------------------------------
pub use config::config::{get_config_from_path, SSXLConfig}; // Config loader + struct
pub use ssxl_math::primitives::{ChunkId, TileCoord};        // Core math identifiers

pub use chunk::chunk_data::{ChunkData, CHUNK_SIZE};         // Chunk struct + size constant
pub use tile::tile_data::TileData;                          // Tile struct
pub use chunk::grid_bounds::GridBounds;                     // Chunk boundary struct
pub use tile::tile_type::TileType;                          // Tile type enum

pub use message::messages::{
    AnimationCommand,           // Commands sent to animation subsystem
    AnimationType,              // Types of animations (flip, tween, etc.)
    AnimationPayload,           // Payload data for animation updates
    UpdateSender,               // Channel type for sending updates
    AnimationConductorHandle,   // Channel type for sending commands
    AnimationState,             // Global animation state struct
    CommandResult,              // Standardized command result type
    AnimationUpdate,            // Struct for animation update messages
};

pub use error::errors::{SSXLError, SSXLResult}; // Error type + result alias
pub use anyhow;                                // General-purpose error handling crate

// -----------------------------------------------------------------------------
// üåê FFI Export Function
// -----------------------------------------------------------------------------
// Provides an entry point for external runtimes (e.g., CLI).
// `#[no_mangle]` ensures the function name is preserved for linking.
// `extern "C"` makes it callable from C or other languages.
// -----------------------------------------------------------------------------
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    initialize_shared_data();
    tracing::info!("FFI Function `ssxl_start_runtime` called and shared initialization completed.");
    true 
}

// -----------------------------------------------------------------------------
// üìä Shared Data Structures
// -----------------------------------------------------------------------------
// Defines simple data primitives used across the engine.
// These can be serialized for persistence or transmitted across FFI boundaries.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,        // Unique identifier
    pub timestamp: u64, // Timestamp for creation/update
    pub value: String,  // Arbitrary string payload
}

pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

// -----------------------------------------------------------------------------
// üì¶ Prelude Module
// -----------------------------------------------------------------------------
// The `prelude` re-exports commonly used types so that downstream code can
// import them with a single `use ssxl_shared::prelude::*;`.
// This is a Rust convention for convenience and readability.
// -----------------------------------------------------------------------------
pub mod prelude {
    pub use super::chunk::chunk_data::{ChunkData, CHUNK_SIZE};
    pub use super::tile::tile_data::TileData;
    pub use super::chunk::grid_bounds::GridBounds;
    pub use super::tile::tile_type::TileType;
    
    pub use super::{ChunkId, TileCoord};
    
    pub use super::error::errors::{SSXLError, SSXLResult};
    
    // Animation-related types
    pub use super::message::messages::{AnimationCommand, AnimationType, AnimationState};
    pub use super::message::messages::AnimationUpdate;

    // Config access
    pub use super::config::config::SSXLConfig;
}

// -----------------------------------------------------------------------------
// üìà Global Atomic Counter
// -----------------------------------------------------------------------------
// Tracks the number of chunks completed during generation.
// `AtomicUsize` allows safe concurrent updates across threads.
// -----------------------------------------------------------------------------
use std::sync::atomic::AtomicUsize;

pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);

// --- END: rust/ssxl_shared/src\lib.rs ---
        20 LOC | rust/ssxl_shared/src\math\math_primitives.rs
// --- START: rust/ssxl_shared/src\math\math_primitives.rs ---
// ============================================================================
// üßÆ Math Primitives & Serde Helpers
// File: ssxl_shared/src/math_primitives.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Provides custom serialization/deserialization logic for mathematical and
//     standard library types that require deterministic formatting.
//   - Ensures cross-platform compatibility and stable persistence when caching
//     or transmitting data across the SSXL engine ecosystem.
//
// Why it matters:
//   - Default Serde behavior for certain types (like SystemTime) can vary
//     depending on platform or implementation.
//   - By enforcing a canonical format (milliseconds since UNIX epoch), we
//     guarantee consistency across all crates (math, generate, cache, godot).
// ============================================================================

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};

// -----------------------------------------------------------------------------
// ‚è±Ô∏è Module: system_time_serde
// -----------------------------------------------------------------------------
// Custom Serde helpers for `std::time::SystemTime`.
// Converts SystemTime <-> u64 (milliseconds since epoch).
// This ensures:
//   - Deterministic representation (always the same format).
//   - Platform independence (no OS-specific quirks).
//   - Stable caching and networking (safe to persist and reload).
// -----------------------------------------------------------------------------
pub mod system_time_serde {
    use super::*;

    // -------------------------------------------------------------------------
    // Function: serialize
    // -------------------------------------------------------------------------
    // Converts a SystemTime into a u64 millisecond count since UNIX_EPOCH.
    // Steps:
    //   1. Compute duration since epoch.
    //   2. Convert duration to milliseconds.
    //   3. Serialize as u64.
    // Usage:
    //   - Called automatically by Serde when writing data structures containing
    //     SystemTime (e.g., saving ChunkData to disk or sending over network).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Duration since epoch; errors if time < UNIX_EPOCH.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert to milliseconds (u64).
        let ms = duration.as_millis() as u64;
        // Serialize the millisecond count.
        serializer.serialize_u64(ms)
    }

    // -------------------------------------------------------------------------
    // Function: deserialize
    // -------------------------------------------------------------------------
    // Converts a u64 millisecond count back into a SystemTime.
    // Steps:
    //   1. Deserialize u64 from input.
    //   2. Create Duration from milliseconds.
    //   3. Add Duration to UNIX_EPOCH to reconstruct SystemTime.
    // Usage:
    //   - Called automatically by Serde when reading data structures containing
    //     SystemTime (e.g., loading ChunkData from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Read the millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert back into SystemTime.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}

// --- END: rust/ssxl_shared/src\math\math_primitives.rs ---
         1 LOC | rust/ssxl_shared/src\math\mod.rs
// --- START: rust/ssxl_shared/src\math\mod.rs ---
// ============================================================================
// üßÆ Math Module Index
// File: src/math/mod.rs
// ----------------------------------------------------------------------------
// In Rust, a `mod.rs` file serves as the "table of contents" for a directory.
// This file declares which submodules belong to the `math/` namespace.
//
// Purpose of the `math` module:
//   ‚Ä¢ Organize math-related helpers and primitives in one place.
//   ‚Ä¢ Provide deterministic serialization utilities for types like `SystemTime`.
//   ‚Ä¢ Keep the crate structure clean by grouping math logic separately from
//     chunks, tiles, and messaging.
//
// Why this matters:
//   ‚Ä¢ Other parts of the engine (e.g., chunk generation, caching) rely on
//     math primitives for consistent behavior.
//   ‚Ä¢ Declaring `pub mod math_primitives;` here makes the file
//     `src/math/math_primitives.rs` available as `crate::math::math_primitives`.
//   ‚Ä¢ This ensures imports like `use crate::math::math_primitives;` compile
//     correctly without unresolved path errors.
// ============================================================================

// Declare the `math_primitives` submodule.
// This corresponds to the file: src/math/math_primitives.rs
pub mod math_primitives;

// --- END: rust/ssxl_shared/src\math\mod.rs ---
        13 LOC | rust/ssxl_shared/src\message\generation_message.rs
// --- START: rust/ssxl_shared/src\message\generation_message.rs ---
// ============================================================================
// üì° Generation Messaging
// File: ssxl_shared/src/message/generation_message.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Defines the communication protocol between the Conductor (main thread)
//     and worker threads in the SSXL engine.
//   - Provides structures for sending generation tasks into the pipeline and
//     receiving results or status updates back.
//   - Ensures messages are serializable for persistence, networking, or debugging.
// ============================================================================

use crate::chunk::chunk_data::ChunkData;   // Core chunk payload type
use ssxl_math::prelude::Vec2i;             // 2D integer vector for chunk coordinates
use std::sync::Arc;                        // Atomic reference-counted pointer for safe sharing
use serde::{Serialize, Deserialize};       // Serialization traits for message passing

// -----------------------------------------------------------------------------
// üõ†Ô∏è Work Request Structure: GenerationTask
// -----------------------------------------------------------------------------
// Represents a single unit of work to be performed by a worker thread.
// Inserted into the engine‚Äôs TaskQueue by the Conductor.
// Fields:
//   - chunk_coords: identifies which chunk in chunk-space should be generated.
//   - generator_id: specifies which generator algorithm to use (e.g. "cellular_automata").
// Derives:
//   - Debug, Clone: for inspection and duplication.
//   - Serialize, Deserialize: for persistence and cross-thread communication.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationTask {
    pub chunk_coords: Vec2i,     // Target chunk coordinates in grid space
    pub generator_id: String,    // Generator identifier string
}

// -----------------------------------------------------------------------------
// üì¨ Communication Message Enumeration: GenerationMessage
// -----------------------------------------------------------------------------
// Represents messages sent back from worker threads to the Conductor.
// Each variant signals a different type of pipeline outcome.
// Variants:
//   - Generated: A chunk has been successfully produced.
//   - StatusUpdate: Informational message about progress or internal state.
//   - GenerationComplete: Signals that all tasks in a batch are finished.
// -----------------------------------------------------------------------------
#[derive(Debug, Serialize, Deserialize)]
pub enum GenerationMessage {
    // üåü Generated: A new chunk is ready.
    // Payload:
    //   - Vec2i: coordinates of the chunk.
    //   - Arc<ChunkData>: reference-counted chunk data for safe sharing.
    Generated(Vec2i, Arc<ChunkData>),

    // üìä StatusUpdate: Provides progress or state information.
    // Example: "50% complete" or "Switching generator mode".
    StatusUpdate(String),

    // ‚úÖ GenerationComplete: Marks the end of a batch of tasks.
    // Used by the Conductor to update global generation state.
    GenerationComplete,
}

// --- END: rust/ssxl_shared/src\message\generation_message.rs ---
        52 LOC | rust/ssxl_shared/src\message\messages.rs
// --- START: rust/ssxl_shared/src\message\messages.rs ---
// ============================================================================
// üì° Messaging System
// File: ssxl_shared/src/message/messages.rs
// ----------------------------------------------------------------------------
// This module defines the communication layer for the SSXL engine.
// It provides the data structures used to send instructions (commands)
// and receive feedback (updates/responses) between subsystems such as
// the Conductor, worker threads, and animation pipeline.
//
// Key goals:
//   - Standardize how tasks and updates are represented.
//   - Ensure all messages can be serialized (for persistence, networking, or debugging).
//   - Separate animation-related communication from generation-related communication.
// ============================================================================

use tokio::sync::mpsc::UnboundedSender; // Asynchronous channel for message passing
use crate::{ChunkId, TileCoord};        // Identifiers for chunks and tiles
use serde::{Deserialize, Serialize};    // Traits for serialization and deserialization

// -----------------------------------------------------------------------------
// üé® AnimationType
// -----------------------------------------------------------------------------
// Describes the *kind* of animation to apply.
// Each variant represents a different animation strategy:
//   - TileFlip: toggles a tile‚Äôs visual state.
//   - TweenMove: smoothly interpolates movement.
//   - PulseFade(f32): fades in/out with a given intensity.
//   - CustomScripted(String): allows user-defined scripted animations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

// -----------------------------------------------------------------------------
// üé® AnimationPayload
// -----------------------------------------------------------------------------
// Encapsulates the *data* needed for an animation update.
//   - FrameUpdate: specifies which frame to display.
//   - TweenValue: provides a key/value pair for a tweened property
//     (e.g., "opacity" -> 0.5).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

// -----------------------------------------------------------------------------
// üé® AnimationUpdate
// -----------------------------------------------------------------------------
// Represents a single animation update message.
// Fields:
//   - coord: the tile coordinate being animated.
//   - payload: the animation data to apply at that coordinate.
// This is what worker threads send back to the Conductor to indicate
// progress or changes in animation state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

// -----------------------------------------------------------------------------
// üé® AnimationCommand
// -----------------------------------------------------------------------------
// Commands sent *to* the animation subsystem.
// These instruct the system to start, modify, or stop animations.
// Variants:
//   - AnimateChunkSet: apply a chosen animation type to multiple chunks.
//   - StartTestAnimation: run a test/demo animation.
//   - SetTimeScale(f32): adjust global animation speed.
//   - SetEnabled(bool): enable/disable animations globally.
//   - Shutdown: terminate the animation subsystem.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationCommand {
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    StartTestAnimation,
    SetTimeScale(f32),
    SetEnabled(bool),
    Shutdown,
}

// Type alias for sending animation updates through an async channel.
// This makes it easier to reference the sender type consistently.
pub type UpdateSender = UnboundedSender<AnimationUpdate>;

// -----------------------------------------------------------------------------
// ‚öôÔ∏è GenerationCommand
// -----------------------------------------------------------------------------
// Commands sent to the *generation subsystem*.
// Variants:
//   - GenerateChunk: request generation of a specific chunk at given coordinates.
//   - SetGenerator: change which generator algorithm is active.
//   - Shutdown: stop the generation subsystem entirely.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GenerationCommand {
    GenerateChunk { coords: TileCoord },
    SetGenerator { id: String },
    Shutdown,
}

// -----------------------------------------------------------------------------
// ‚öôÔ∏è GenerationResponse
// -----------------------------------------------------------------------------
// Feedback returned after executing a generation command.
// Fields:
//   - success: true if the command succeeded, false otherwise.
//   - message: human-readable explanation of the outcome.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationResponse {
    pub success: bool,
    pub message: String,
}

// Type alias for sending animation commands to the conductor.
// Simplifies references to the channel type.
pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

// Type alias for generic command results.
// Standardizes return values across subsystems.
pub type CommandResult = Result<(), String>;

// -----------------------------------------------------------------------------
// üéõÔ∏è AnimationState
// -----------------------------------------------------------------------------
// Holds the *current global state* of the animation subsystem.
// Fields:
//   - time_scale: multiplier for animation speed (e.g., 2.0 = double speed).
//   - is_enabled: whether animations are globally active.
// Includes helper methods to update these values.
#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
pub struct AnimationState {
    pub time_scale: f32,
    pub is_enabled: bool,
}

impl AnimationState {
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}

// -----------------------------------------------------------------------------
// üîó Re-export
// -----------------------------------------------------------------------------
// Re-exports GenerationMessage from generation_message.rs as ChunkMessage.
// This allows other modules to import generation-related messages
// directly from `messages.rs`, keeping the API surface consistent.
pub use super::generation_message::GenerationMessage as ChunkMessage;

// --- END: rust/ssxl_shared/src\message\messages.rs ---
         9 LOC | rust/ssxl_shared/src\message\mod.rs
// --- START: rust/ssxl_shared/src\message\mod.rs ---
// ============================================================================
// üì° Message Module Index
// File: ssxl_shared/src/message/mod.rs
// ----------------------------------------------------------------------------
// This file serves as the *entry point* for all messaging-related code in the
// `ssxl_shared` crate. It organizes submodules and re-exports key types so that
// other parts of the engine (and external crates like `ssxl_godot`) can access
// messaging functionality through a clean, consistent API surface.
//
// Why this matters:
//   - Keeps the crate structure organized: `generation_message.rs` handles
//     worker-to-conductor communication, while `messages.rs` defines animation
//     and generation command types.
//   - Provides a single place to re-export commonly used types, avoiding deep
//     import paths in downstream code.
//   - Ensures that external modules can compile without unresolved import errors
//     (e.g., E0432 in `ssxl_godot/api_initializers.rs`).
// ============================================================================

pub mod generation_message; // Defines messages returned from generation workers
pub mod messages;           // Defines animation and generation command structures

// -----------------------------------------------------------------------------
// üîó Public Re-exports
// -----------------------------------------------------------------------------
// The following types are re-exported from `messages.rs` so that other crates
// can import them directly from `ssxl_shared::message`.
//
// Benefits:
//   - Simplifies usage: external code can write `use ssxl_shared::message::AnimationCommand;`
//     instead of navigating into `messages::AnimationCommand`.
//   - Provides a stable, curated API surface for messaging-related types.
// -----------------------------------------------------------------------------
pub use messages::{
    // Newly added re-exports to resolve current import errors
    AnimationCommand,
    AnimationState,
    
    // Existing re-exports for generation and animation updates
    AnimationUpdate,
    GenerationCommand, 
    GenerationResponse,
};

// --- END: rust/ssxl_shared/src\message\mod.rs ---
         2 LOC | rust/ssxl_shared/src\tile\mod.rs
// --- START: rust/ssxl_shared/src\tile\mod.rs ---
// ============================================================================
// üß© Tile Module Index
// File: ssxl_shared/src/tile/mod.rs
// ----------------------------------------------------------------------------
// This file acts as the *entry point* for all tile-related code in the
// `ssxl_shared` crate. In Rust, a `mod.rs` file inside a directory serves as
// the "table of contents" for that directory, declaring which submodules
// belong to it.
//
// Why this matters:
//   - Keeps the crate organized: all tile logic is grouped under `tile/`.
//   - Provides a clean namespace boundary: external code can import
//     `ssxl_shared::tile::TileData` or `ssxl_shared::tile::TileType` without
//     needing to know the internal file layout.
//   - Makes it easier to extend: new tile-related modules can be added here
//     and automatically become part of the `tile` namespace.
// ============================================================================

// -----------------------------------------------------------------------------
// üì¶ Submodule: tile_data
// -----------------------------------------------------------------------------
// Contains the definition of `TileData`, the core struct representing the
// state of a single tile in a chunk. This typically includes information
// such as:
//   - Tile type (floor, wall, water, etc.)
//   - Metadata (flags, properties, animation state)
//   - Serialization logic for saving/loading tile state.
//
// Usage example:
//   use ssxl_shared::tile::tile_data::TileData;
// -----------------------------------------------------------------------------
pub mod tile_data;

// -----------------------------------------------------------------------------
// üì¶ Submodule: tile_type
// -----------------------------------------------------------------------------
// Defines the `TileType` enumeration, which categorizes tiles by their role
// in the world (e.g., Grass, Stone, Water, Empty). This provides a strongly
// typed way to reason about tiles instead of relying on raw integers or
// strings.
//
// Usage example:
//   use ssxl_shared::tile::tile_type::TileType;
// -----------------------------------------------------------------------------
pub mod tile_type;

// --- END: rust/ssxl_shared/src\tile\mod.rs ---
        51 LOC | rust/ssxl_shared/src\tile\tile_data.rs
// --- START: rust/ssxl_shared/src\tile\tile_data.rs ---
//! ============================================================================
//! üß© Tile Data Structures (`ssxl_shared::tile::tile_data`)
//! ----------------------------------------------------------------------------
//! This module defines the core representation of a single tile in the SSXL
//! procedural world. Tiles are the smallest unit of world data, and their
//! design emphasizes efficiency, clarity, and compatibility with both Rust
//! and external systems (like Godot).
//!
//! Key responsibilities:
//!   - Provide a lightweight `TileData` struct for representing tile state.
//!   - Support serialization/deserialization for persistence and networking.
//!   - Use bitflags (`u8`) to store multiple boolean properties compactly.
//!   - Define FFI-friendly structures (`AnimationUpdate`) for communication
//!     with external runtimes such as Godot.
//!
//! Design choices:
//!   - `Copy` trait: allows tiles to be duplicated cheaply in tight loops.
//!   - `u8` flags: packs up to 8 booleans into one byte for memory efficiency.
//!   - Noise values: store raw procedural noise for debugging and neighbor checks.
//! ============================================================================

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};
use ssxl_math::prelude::Vec2i; // Used for coordinate-based updates in animations

// -----------------------------------------------------------------------------
// üì¶ Core Data Structure: TileData
// -----------------------------------------------------------------------------
// Represents the minimal payload for a single tile in a chunk.
// Fields:
//   - tile_type: categorizes the tile (e.g., grass, rock, void).
//   - noise_value: raw procedural noise used to determine type.
//   - flags: compact bitfield for boolean properties (see tile_flags).
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    pub tile_type: TileType,
    pub noise_value: f32,
    pub flags: u8,
}

impl Default for TileData {
    /// Provides a default tile: "empty" type, zero noise, no flags.
    /// This ensures predictable initialization when creating new chunks.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}

// -----------------------------------------------------------------------------
// üîó Godot FFI Message Structure: AnimationUpdate
// -----------------------------------------------------------------------------
// Used for communication between the Rust engine and the Godot runtime.
// Encapsulates tile animation updates in a format that can be serialized
// and passed across the FFI boundary.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub struct AnimationUpdate {
    pub layer: i32,             // Layer or dimension the tile belongs to
    pub source_id: i32,         // Source ID of the tilemap/animation system
    pub tile_coords: Vec2i,     // World coordinates of the tile to update
    pub new_atlas_coords: Vec2i // New texture atlas coordinates for animation frame
}

// -----------------------------------------------------------------------------
// ‚öôÔ∏è Bitwise Flag Constants
// -----------------------------------------------------------------------------
// Flags provide a compact way to store multiple boolean properties in one byte.
// Each constant represents a bitmask that can be set, cleared, or checked.
// -----------------------------------------------------------------------------
pub mod tile_flags {
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001; // Entities can move through this tile
    pub const IS_RENDERED:    u8 = 0b0000_0010; // Tile is visible to the client
    pub const IS_MODIFIED:    u8 = 0b0000_0100; // Tile was changed after generation
    pub const HAS_RESOURCE:   u8 = 0b0000_1000; // Tile contains a resource/item
    // Bits 4‚Äì7 reserved for future expansion
}

// -----------------------------------------------------------------------------
// üîß TileData Methods
// -----------------------------------------------------------------------------
// Utility functions for creating, inspecting, and modifying tile state.
// -----------------------------------------------------------------------------
impl TileData {
    /// Creates a new tile with a given type and noise value.
    /// Flags are initialized to zero (no properties set).
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0,
        }
    }

    /// Determines if the tile is "solid" (non-empty), typically used for collision.
    #[inline(always)]
    pub const fn is_solid(&self) -> bool {
        !self.tile_type.is_empty()
    }
    
    /// Sets or clears a flag property using a bitmask (e.g., `tile_flags::IS_TRAVERSABLE`).
    #[inline(always)]
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            self.flags |= flag_mask;   // Set bit(s)
        } else {
            self.flags &= !flag_mask;  // Clear bit(s)
        }
    }

    /// Checks whether a flag property is set.
    #[inline(always)]
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        (self.flags & flag_mask) != 0
    }
}

// --- END: rust/ssxl_shared/src\tile\tile_data.rs ---
        55 LOC | rust/ssxl_shared/src\tile\tile_type.rs
// --- START: rust/ssxl_shared/src\tile\tile_type.rs ---
//! ============================================================================
//! üß© Tile Type Enumeration (`ssxl_shared::tile::tile_type`)
//! ----------------------------------------------------------------------------
//! This module defines the `TileType` enum, which categorizes the material or
//! nature of a single tile in the SSXL engine. It is one of the most fundamental
//! data structures, used everywhere from chunk generation to rendering.
//!
//! Key design choices:
//!   - `#[repr(u8)]`: Forces the enum to be stored as a single byte. This is a
//!     critical memory optimization because each chunk contains thousands of tiles.
//!     Using one byte per tile type keeps memory usage predictable and efficient.
//!   - Serialization derives: Enables saving/loading tile data across FFI boundaries
//!     and persistent caches.
//!
//! Educational note:
//!   - Enums with `#[repr(u8)]` are often used in game engines to pack large grids
//!     of state into memory without wasting space.
//!   - Conversion helpers (`to_u8`, `from_u8`) make it easy to move between raw
//!     byte values and strongly typed variants.
//! ============================================================================

use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// üì¶ Core Enum: TileType
// -----------------------------------------------------------------------------
// Represents all canonical tile categories in the procedural world.
// Each variant corresponds to a material or terrain type.
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    Void = 0,       // Empty space (air/background)
    Water = 1,      // Fluid terrain (rivers, oceans)
    Grass = 2,      // Base terrain, flat and walkable
    Mountain = 3,   // Elevated terrain, harder to traverse
    Boundary = 4,   // Artificial boundary (chunk edges, isolation zones)
    Structure = 5,  // Engineered/placed structures (walls, ruins, roads)
    Rock = 6,       // Solid rocky terrain
    Custom1 = 7,    // Reserved for generator-specific customization
    Custom2 = 8,    // Reserved for generator-specific customization
}

// Maximum valid value for TileType when represented as a raw u8.
pub const MAX_TILE_TYPE_VALUE: u8 = 8;

// -----------------------------------------------------------------------------
// üîß Default Implementation
// -----------------------------------------------------------------------------
// Provides a predictable default: all tiles start as `Void` unless specified.
// -----------------------------------------------------------------------------
impl Default for TileType {
    fn default() -> Self {
        TileType::Void
    }
}

// -----------------------------------------------------------------------------
// üîß Conversion & Lookup Methods
// -----------------------------------------------------------------------------
// Utility functions for working with TileType in raw form or rendering contexts.
// -----------------------------------------------------------------------------
impl TileType {
    /// Converts the enum into its underlying `u8` representation.
    /// Useful for serialization or compact storage.
    #[inline(always)] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Converts a raw `u8` back into a `TileType`, if valid.
    /// Returns `None` if the value is outside the defined range.
    #[inline(always)]
    pub fn from_u8(value: u8) -> Option<Self> {
        if value <= MAX_TILE_TYPE_VALUE {
            // SAFETY: We checked that the value is within [0, 8].
            Some(unsafe { std::mem::transmute(value) })
        } else {
            None
        }
    }
    
    /// Provides a default unique ID for this tile type.
    /// By convention, this is just its `u8` value.
    #[inline(always)]
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Returns default atlas coordinates (X, Y) for rendering.
    /// These are used by the rendering system to look up textures.
    #[inline(always)]
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            _ => (0, 0), // Void and custom types default to origin
        }
    }
}

// -----------------------------------------------------------------------------
// üîß Semantic Helper Methods
// -----------------------------------------------------------------------------
// These methods provide higher-level meaning for tile types, used in gameplay
// logic such as collision, traversal, and fluid simulation.
// -----------------------------------------------------------------------------
impl TileType {
    /// Returns true if the tile can typically be walked on.
    #[inline(always)]
    pub const fn is_walkable(self) -> bool {
        matches!(self, TileType::Grass | TileType::Mountain | TileType::Structure | TileType::Rock)
    }

    /// Returns true if the tile is a fluid (e.g., water).
    #[inline(always)]
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Returns true if the tile is empty (Void).
    #[inline(always)]
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}

// --- END: rust/ssxl_shared/src\tile\tile_type.rs ---
        44 LOC | rust/ssxl_sync/src\animation_conductor.rs
// --- START: rust/ssxl_sync/src\animation_conductor.rs ---
// ============================================================================
// üé¨ Animation Conductor (FFI Worker Wrapper)
// File: ssxl_sync/src/animation_conductor.rs
// ----------------------------------------------------------------------------
// This module defines the SSXL Animation Conductor, which is responsible for
// coordinating animation logic in a background thread. It acts as the bridge
// between the Godot runtime (via FFI) and the Rust engine‚Äôs animation system.
//
// Key responsibilities:
//   ‚Ä¢ Set up non-blocking channels for communication between Godot and Rust.
//   ‚Ä¢ Maintain initial animation state for the worker thread.
//   ‚Ä¢ Spawn the heavy background worker (`CoreAnimationWorker`) defined in
//     the `ssxl_animate` crate.
//   ‚Ä¢ Resolve type mismatches by aliasing the exact nested types required.
//
// Educational notes:
//   ‚Ä¢ Rust‚Äôs `tokio::sync::mpsc` channels are used for async, multi-producer,
//     single-consumer communication. Here, they connect Godot commands to the
//     worker and worker updates back to Godot.
//   ‚Ä¢ Aliasing `AnimationUpdate` ensures type signatures match exactly across
//     crate boundaries, fixing compiler errors like E0308.
//   ‚Ä¢ Splitting into two stages (FAST setup vs HEAVY spawn) separates lightweight
//     channel creation from expensive thread spawning.
// ============================================================================

use ssxl_shared::{
    AnimationConductorHandle, // Public handle for sending commands to the conductor
    AnimationState,           // Global animation state struct
    AnimationCommand,         // Enum of animation commands (start, stop, etc.)
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender}; // Async channels
use tracing::info; // Structured logging

// FIX: Import the exact nested type required by CoreAnimationWorker.
// Aliased as `AnimationUpdate` to resolve type mismatch errors (E0308).
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: The core worker implementation lives in the `ssxl_animate` crate.
// We alias it here for clarity and to emphasize the separation of concerns.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct
// -----------------------------------------------------------------------------
// This struct holds the internal channels and initial state required to spawn
// the background worker. It is not exposed directly to FFI consumers; instead,
// it is used internally during setup.
// -----------------------------------------------------------------------------
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,                  // Starting animation state
    pub command_receiver: UnboundedReceiver<AnimationCommand>, // Commands from Godot
    pub update_sender: UnboundedSender<AnimationUpdate>,       // Updates back to Godot
}

// -----------------------------------------------------------------------------
// 2. Public Conductor Struct
// -----------------------------------------------------------------------------
// This is the FFI-facing wrapper. It exposes safe methods for setting up
// channels and spawning the background worker thread.
// -----------------------------------------------------------------------------
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup
    // -------------------------------------------------------------------------
    // Creates the necessary channels and initializes the animation state.
    // This stage is lightweight and non-blocking.
    //
    // Returns:
    //   1. AnimationConductorInternalSetup: internal handles for spawning.
    //   2. AnimationConductorHandle: public command sender for Godot.
    //   3. UnboundedReceiver<AnimationUpdate>: public update receiver for Godot.
    // -------------------------------------------------------------------------
    pub fn setup_channels_and_state() -> (
        AnimationConductorInternalSetup,
        AnimationConductorHandle,
        UnboundedReceiver<AnimationUpdate>,
    ) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channel for commands: Godot ‚Üí worker
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channel for updates: worker ‚Üí Godot
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        // Initialize animation state to defaults
        let initial_state = AnimationState::default();

        // Bundle internal setup handles
        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        // Public handle for sending commands into the conductor
        let public_command_handle: AnimationConductorHandle = command_tx;

        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------
    // Consumes the setup handles and spawns the background worker thread.
    // This stage is heavier because it involves thread creation and worker
    // initialization.
    //
    // Arguments:
    //   ‚Ä¢ setup: internal channels and initial state from Stage 1.
    //
    // Returns:
    //   ‚Ä¢ AnimationConductor: opaque public handle representing the running worker.
    // -------------------------------------------------------------------------
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // Spawn the core worker with the correct channel types and initial state.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the public wrapper
        AnimationConductor {} 
    }
}

// --- END: rust/ssxl_sync/src\animation_conductor.rs ---
        21 LOC | rust/ssxl_sync/src\lib.rs
// --- START: rust/ssxl_sync/src\lib.rs ---
//! ============================================================================
//! ‚ö° SSXL Synchronization and Concurrency (`ssxl_sync`)
//! ----------------------------------------------------------------------------
//! This crate provides the concurrency backbone of the SSXL engine.
//! It defines thread-safe primitives, manages worker pools, and exposes
//! high-level FFI channel handles for communication across asynchronous
//! boundaries (e.g., between Rust workers and Godot).
//!
//! Educational notes:
//!   ‚Ä¢ Synchronization: ensures safe sharing of resources across threads.
//!   ‚Ä¢ Concurrency: organizes work into pools and tasks for efficient parallelism.
//!   ‚Ä¢ FFI channels: provide a standardized way to send/receive messages
//!     between Rust and external runtimes.
//!
//! By centralizing these utilities, `ssxl_sync` acts as the glue layer
//! that keeps the engine‚Äôs multi-threaded systems coordinated.
//! ============================================================================

use tokio::sync::mpsc; // Tokio channels for async communication

// -----------------------------------------------------------------------------
// üîó External Imports
// -----------------------------------------------------------------------------
// Import core contract types from `ssxl_shared`. These are the fundamental
// message and error types used across the engine.
// -----------------------------------------------------------------------------
use ssxl_shared::{
    SSXLError,        // Standardized error type for engine operations
    AnimationUpdate,  // Struct representing animation update messages
    AnimationCommand, // Enum representing animation commands
    // AnimationConductorHandle could be imported directly if needed
};

// FIX: Import and re-export the core struct in one step.
// This avoids duplicate definitions (E0252) or conflicting re-exports (E0365).
pub use ssxl_animate::AnimationConductor;

// -----------------------------------------------------------------------------
// üìÇ Internal Modules
// -----------------------------------------------------------------------------
// These modules implement the building blocks of synchronization:
//   ‚Ä¢ primitives: atomic resources and channel helpers
//   ‚Ä¢ pool: worker pool and task scheduling
//   ‚Ä¢ animation_conductor: FFI-facing wrapper for animation threads
// -----------------------------------------------------------------------------
pub mod primitives;
pub mod pool;
pub mod animation_conductor;

// -----------------------------------------------------------------------------
// üåê Public Re-exports (Crate Facade)
// -----------------------------------------------------------------------------
// Re-export commonly used types so downstream crates can access them directly
// from `ssxl_sync` without needing deep paths.
// -----------------------------------------------------------------------------
pub use primitives::{AtomicResource, create_unbounded_channel};

pub use pool::{
    WorkerPool,       // Thread pool manager
    GenerationTask,   // Task definition for chunk generation
    ConductorResult,  // Result type for conductor operations
    Task,             // Generic task abstraction
    TaskResult,       // Result type for tasks
};

// -----------------------------------------------------------------------------
// üõ†Ô∏è FFI Wrappers and Type Aliases (Crate Root API)
// -----------------------------------------------------------------------------
// These type aliases define the public API surface for FFI communication.
// They standardize the channel types used to send commands and updates
// across the Rust ‚Üî Godot boundary.
// -----------------------------------------------------------------------------
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>; // Receives animation commands
pub type UpdateSender   = mpsc::UnboundedSender<AnimationUpdate>;     // Sends animation updates
pub type CommandResult  = Result<(), SSXLError>;                     // Standardized command result

// ‚úÖ No struct wrapper here ‚Äî we rely on the alias from `ssxl_shared`
// to keep the API surface consistent and avoid duplication.

// --- END: rust/ssxl_sync/src\lib.rs ---
        96 LOC | rust/ssxl_sync/src\pool.rs
// --- START: rust/ssxl_sync/src\pool.rs ---
// ============================================================================
// ‚öôÔ∏è Thread Pool Manager (`ssxl_sync::pool_manager`)
// ----------------------------------------------------------------------------
// This module implements a fixed-size thread pool for executing synchronous,
// CPU-intensive generation tasks outside of the main thread and Tokio runtime.
// It is the backbone for high-throughput batch processing of `ChunkData`,
// ensuring that heavy work does not block async event loops.
//
// Key Concepts:
//   ‚Ä¢ Worker: Represents a single thread in the pool, with an ID and join handle.
//   ‚Ä¢ GenerationTask: Enum describing the unit of work (e.g., generate a chunk,
//     or shut down gracefully).
//   ‚Ä¢ ConductorResult: Enum describing the result of a task (completed chunk or error).
//   ‚Ä¢ WorkerPool: Manages the pool of workers, task queue, and graceful shutdown.
//
// Design Choices:
//   ‚Ä¢ Fixed pool size (POOL_SIZE = 4) for predictable resource usage.
//   ‚Ä¢ `crossbeam_channel` used for task/result communication because it provides
//     synchronous, blocking semantics ideal for CPU-bound work.
//   ‚Ä¢ `Arc<Receiver<Task>>` allows multiple worker threads to share the same
//     task queue safely.
//   ‚Ä¢ Results are sent back to the Conductor via a separate channel, enabling
//     centralized collection of completed work.
//
// Workflow:
//   1. Initialization (`WorkerPool::new`):
//      - Creates task and result channels.
//      - Spawns N worker threads, each running `run_worker_loop`.
//   2. Task submission (`submit_task`):
//      - Sends a `GenerationTask` into the pool‚Äôs task channel.
//   3. Worker loop (`run_worker_loop`):
//      - Blocks until a task arrives.
//      - Processes the task (e.g., generate a chunk).
//      - Sends back a `ConductorResult`.
//      - Shuts down gracefully if the channel is closed.
//   4. Shutdown (`Drop` impl):
//      - Sends a `Shutdown` task to unblock workers.
//      - Joins all worker threads to ensure clean termination.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a classic concurrency pattern: a fixed-size
//     worker pool consuming tasks from a shared queue.
//   ‚Ä¢ By separating task submission, worker execution, and result collection,
//     the system achieves both parallelism and safety.
//   ‚Ä¢ Graceful shutdown ensures no threads are leaked and all resources are
//     properly cleaned up.
// ============================================================================


use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData; 

const POOL_SIZE: usize = 4;

struct Worker {
    id: usize,
    handle: Option<JoinHandle<()>>,
}

#[derive(Debug)]
pub enum GenerationTask {
    GenerateChunk,
    Shutdown,
}

#[derive(Debug)]
pub enum ConductorResult {
    CompletedChunk(Arc<ChunkData>),
    Error(String),
}

pub type Task = GenerationTask;
pub type TaskResult = ConductorResult;

pub struct WorkerPool {
    task_sender: Sender<Task>,
    workers: Vec<Worker>,
}

impl WorkerPool {
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                workers,
            },
            result_rx,
        )
    }

    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            match task_rx.recv() {
                Ok(task) => {
                    info!("Worker {} processing task {:?}", id, task);
                    
                    let result: TaskResult = TaskResult::CompletedChunk(
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        break;
                    }
                }
                Err(_) => {
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

impl Drop for WorkerPool {
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        let _ = self.task_sender.send(Task::Shutdown);
        
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}



// --- END: rust/ssxl_sync/src\pool.rs ---
        27 LOC | rust/ssxl_sync/src\primitives.rs
// --- START: rust/ssxl_sync/src\primitives.rs ---
// ============================================================================
// üîí Synchronization Primitives (`ssxl_sync::primitives`)
// ----------------------------------------------------------------------------
// This module defines two foundational building blocks for safe, concurrent
// programming in the SSXL engine:
//
// 1. AtomicResource<T>
//    ‚Ä¢ A thread-safe wrapper around shared data.
//    ‚Ä¢ Internally uses `Arc<RwLock<T>>` from the `parking_lot` crate.
//    ‚Ä¢ Provides cheap cloning (`Arc`) and fine-grained read/write access
//      (`RwLock`), allowing multiple readers or a single writer at a time.
//    ‚Ä¢ Exposes ergonomic `read()` and `write()` methods that return guards,
//      ensuring Rust‚Äôs borrow checker enforces safe access.
//    ‚Ä¢ Implements `Default` so resources can be initialized predictably.
//
//    Educational note:
//    ‚Ä¢ `RwLock` (read‚Äìwrite lock) is ideal when reads are frequent and writes
//      are rare, as it allows concurrent readers but exclusive writers.
//    ‚Ä¢ Wrapping in `Arc` makes the resource clonable and shareable across
//      threads without copying the underlying data.
//    ‚Ä¢ This pattern is common in game engines and async runtimes where shared
//      state (e.g., configuration, animation state) must be accessed safely
//      by multiple worker threads.
//
// 2. create_unbounded_channel<M>
//    ‚Ä¢ A helper function that creates an unbounded multi-producer,
//      single-consumer channel using `crossbeam_channel`.
//    ‚Ä¢ Generic over message type `M`, so it can be used for any kind of
//      communication payload (commands, updates, events).
//    ‚Ä¢ Unbounded channels are useful for high-throughput pipelines where
//      backpressure is not desired (e.g., logging, fire-and-forget updates).
//
//    Educational note:
//    ‚Ä¢ Channels are a core concurrency primitive in Rust, enabling safe
//      message passing between threads without shared mutable state.
//    ‚Ä¢ `crossbeam_channel` provides blocking semantics, which are well-suited
//      for CPU-bound worker pools (as opposed to async channels in Tokio).
//
// Why this matters:
// ‚Ä¢ Together, `AtomicResource` and `create_unbounded_channel` provide the
//   foundation for building higher-level concurrency abstractions in SSXL.
// ‚Ä¢ They encapsulate common patterns (shared state + message passing) in a
//   reusable, ergonomic way.
// ‚Ä¢ By centralizing these primitives, the engine ensures consistency and
//   reduces boilerplate across subsystems (generation, animation, networking).
// ============================================================================



use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline(always)]
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline(always)]
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

pub fn create_unbounded_channel<M>() -> (Sender<M>, Receiver<M>) {
    unbounded()
}

// --- END: rust/ssxl_sync/src\primitives.rs ---
        50 LOC | rust/ssxl_tools/src\lib.rs
// --- START: rust/ssxl_tools/src\lib.rs ---
// ============================================================================
// ‚öôÔ∏è SSXL Engine Configuration (`ssxl_tools::config`)
// ----------------------------------------------------------------------------
// This module defines the configuration management system for the SSXL engine.
// It provides a lightweight way to load, validate, and fall back to defaults
// when configuration files are missing or invalid.
//
// Key Concepts:
//   ‚Ä¢ SSXLConfig struct:
//       - Holds core engine settings such as the default world generator ID
//         and the default Cellular Automata ruleset.
//       - Designed to be clonable and debuggable for easy inspection.
//   ‚Ä¢ Default constants:
//       - DEFAULT_CONFIG_PATH: canonical location of the engine‚Äôs config file.
//       - DEFAULT_GENERATOR: fallback generator ID if none is specified.
//       - DEFAULT_CA_RULESET: fallback ruleset ID for Cellular Automata.
//   ‚Ä¢ Fallback strategy:
//       - If configuration loading fails, the engine logs a warning and
//         initializes with hardcoded defaults to guarantee safe startup.
//       - This ensures the engine can always run, even in environments where
//         configuration files are missing or corrupted.
//
// Design Choices:
//   ‚Ä¢ File I/O is simulated (no TOML parsing yet) to minimize complexity.
//     - The system checks for file existence, then applies a simulated override.
//     - This allows developers to test configuration flow without full parsing.
//   ‚Ä¢ Logging via `tracing`:
//     - `info!` logs successful load attempts.
//     - `warn!` logs failures and fallback usage.
//   ‚Ä¢ Accessor methods (`get_default_generator_id`, `get_ca_default_ruleset`)
//     provide O(1) retrieval of settings, keeping runtime overhead negligible.
//
// Workflow:
//   1. Engine calls `get_config_from_path()` with an optional path.
//   2. If the file exists, a simulated override config is returned.
//   3. If the file does not exist, defaults are returned with a warning.
//   4. Downstream systems (generation, simulation) query the config via
//      accessor methods to determine which generator and ruleset to use.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates a common pattern in engine design:
//       - Centralized configuration management.
//       - Safe fallbacks to ensure robustness.
//       - Clear logging for observability.
//   ‚Ä¢ Even though parsing is simulated here, the structure is ready to be
//     extended with real TOML/JSON/YAML parsing in the future.
// ============================================================================


use tracing::{info, warn};
use std::io;
use std::fs::File;

const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
const DEFAULT_CA_RULESET: u8 = 0;

#[derive(Debug, Clone)]
pub struct SSXLConfig {
    default_generator_id: String,
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(_file) => {
                info!("SSXLConfig: Config file found. Simulating config override (No TOML parsing).");
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(),
                    ca_default_ruleset: 1,
                })
            },
            Err(e) => Err(e),
        }
    }

    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            SSXLConfig::new_with_defaults()
        }
    }
}

// --- END: rust/ssxl_tools/src\lib.rs ---
       147 LOC | rust/ssxl_cli/src\actions\actions.rs
// --- START: rust/ssxl_cli/src\actions\actions.rs ---
// ============================================================================
// üß™ SSXL Engine Concurrency & Communication Tests
// ----------------------------------------------------------------------------
// This module defines a suite of diagnostic tests for validating the integrity
// of communication channels, data streaming, and conductor tempo in the SSXL
// engine. Each test simulates real-world concurrency scenarios to ensure that
// threads, channels, and timing behave correctly under load.
//
// Key Tests:
//   ‚Ä¢ run_communication_channel_test
//       - Validates basic async communication between threads using std::mpsc.
//       - Worker thread simulates heavy work (500ms sleep) before sending a
//         completion signal back to the main thread.
//       - Ensures signals are received within a timeout window, confirming
//         thread jump integrity.
//
//   ‚Ä¢ run_map_generation_test
//       - Simulates procedural map generation across multiple chunks.
//       - Worker thread emits chunk IDs via a data channel while main thread
//         consumes them with tempo checks.
//       - Validates streaming behavior, completion signaling, and resilience
//         against dropped channels.
//       - Confirms that all expected chunks are received before completion.
//
//   ‚Ä¢ run_data_channel_test
//       - Validates chunk/tile data channel integrity.
//       - Relies on `run_map_generation_test` for implicit validation.
//       - Provides a placeholder for explicit FFI type validation logic.
//
//   ‚Ä¢ run_animation_conductor_test
//       - Stress-tests the animation conductor‚Äôs ability to emit high-frequency
//         signals (approx. 120 signals in 2 seconds).
//       - Worker thread emits signals at ~120Hz (8.3ms intervals).
//       - Main thread measures latency (min/max) and counts signals received.
//       - Validates conductor tempo, signal integrity, and latency bounds.
//
// Design Choices:
//   ‚Ä¢ std::mpsc channels provide simple, synchronous communication primitives
//     for testing thread-to-thread message passing.
//   ‚Ä¢ Thread sleeps simulate heavy workloads and tempo-controlled signal
//     emission, mimicking real engine tasks.
//   ‚Ä¢ Timeout-based receivers ensure robustness against hangs or dropped
//     channels.
//   ‚Ä¢ Structured logging via `tracing` provides visibility into success/failure
//     states, making debugging straightforward.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how to validate concurrency primitives in Rust:
//       - Channels for message passing.
//       - Threads for parallel execution.
//       - Timeouts and latency checks for performance guarantees.
//   ‚Ä¢ By running these diagnostics, developers can confirm that the SSXL engine
//     maintains communication integrity, streaming reliability, and conductor
//     tempo under realistic workloads.
// ============================================================================


use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

pub fn run_communication_channel_test() {
    info!("TEST [2]: Starting Async Communication Channel Validation (Thread Jump Tempo Check)...");

    let (tx, rx) = mpsc::channel::<(String, String)>();

    let engine_test_thread = thread::spawn(move || {
        info!("WORKER: Starting 500ms sleep simulation (Simulating heavy map chunk 1 work)...");
        thread::sleep(Duration::from_millis(500));

        let message = "Async signal emission successful. Latency: 500ms".to_string();

        if tx.send(("TEST_COMPLETE".to_string(), message)).is_err() {
            error!("WORKER: Failed to send test signal. Receiver dropped (Godot side crashed?).");
        } else {
            info!("WORKER: Successfully sent TEST_COMPLETE signal back to main thread.");
        }
    });

    match rx.recv_timeout(Duration::from_secs(2)) {
        Ok((status, message)) => {
            if status == "TEST_COMPLETE" {
                info!("‚úÖ SUCCESS: Communication Channel Validated. {}", message);
                info!("   Thread jump integrity confirmed.");
            } else {
                error!("‚ùå FAIL: Received incorrect status: {}", status);
            }
        },
        Err(mpsc::RecvTimeoutError::Timeout) => {
            error!("‚ùå FAIL: Timeout (2s). Communication channel failed to establish required tempo.");
        },
        Err(mpsc::RecvTimeoutError::Disconnected) => {
            error!("‚ùå FAIL: Worker thread disconnected unexpectedly (Systemic Entropy).");
        }
    }

    engine_test_thread.join().unwrap();
}

pub fn run_map_generation_test() {
    info!("TEST [4]: Starting Map Generation Flow Validation (Procedural Purity & Streaming)...");

    let (data_tx, data_rx) = mpsc::channel::<usize>();
    let (done_tx, done_rx) = mpsc::channel::<()>();

    let total_chunks = 5;
    let engine_gen_thread = thread::spawn(move || {
        info!("WORKER: Starting map generation for {} chunks.", total_chunks);

        for i in 1..=total_chunks {
            thread::sleep(Duration::from_millis(50));

            if data_tx.send(i).is_err() {
                warn!("WORKER: Data channel dropped after chunk {}. Stopping.", i);
                return;
            }
            info!("WORKER: Emitted Chunk #{} (Data Payload Crypto Coded).", i);
        }

        if done_tx.send(()).is_err() {
            error!("WORKER: Failed to send generation_complete signal.");
        }
        info!("WORKER: Generation finished.");
    });

    let mut chunks_received = 0;

    loop {
        match data_rx.recv_timeout(Duration::from_millis(10)) {
            Ok(chunk_id) => {
                chunks_received += 1;
                info!("MAIN: Processed Chunk #{} (Data Channel) - Tempo maintained.", chunk_id);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                if done_rx.try_recv().is_ok() {
                    info!("MAIN: Detected Completion Signal (Generation Complete).");
                    break;
                }
                thread::sleep(Duration::from_millis(1));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                error!("‚ùå FAIL: Data channel disconnected prematurely (Systemic Entropy).");
                break;
            }
        }

        if done_rx.try_recv().is_ok() {
            info!("MAIN: Detected Completion Signal (Generation Complete).");
            break;
        }
    }

    engine_gen_thread.join().unwrap();

    if chunks_received == total_chunks {
        info!("‚úÖ SUCCESS: Map Generation Flow Validated. Received {}/{} chunks.", chunks_received, total_chunks);
        info!("   All data channels validated and quantum alignment achieved.");
    } else {
        error!("‚ùå FAIL: Map Generation Failed. Expected {} chunks, received {}.", total_chunks, chunks_received);
    }
}

pub fn run_data_channel_test() {
    info!("TEST [3]: Starting Chunk/Tile Data Channel Integrity Check...");

    info!("TEST [3]: Data channel integrity is validated implicitly and explicitly.");
    info!("   Implicitly: By checking successful channel send/receive in Action 4.");
    info!("   Explicitly: The FFI data type validation logic should be integrated here.");

    run_map_generation_test();
}

pub fn run_animation_conductor_test() {
    info!("TEST [5]: Starting Animation Conductor Tempo Validation (High-Frequency Loop Check)...");

    let (tx, rx) = mpsc::channel::<u64>();
    let required_signals = 120;
    let target_duration = Duration::from_millis(2000);

    let conductor_thread = thread::spawn(move || {
        info!("WORKER: Animation Conductor spun up. Targeting high tempo signal emission.");
        let start_time = Instant::now();
        let mut count = 0;

        while start_time.elapsed() < target_duration {
            thread::sleep(Duration::from_nanos(8333));

            if tx.send(start_time.elapsed().as_micros() as u64).is_err() {
                warn!("WORKER: Conductor signal dropped (Receiver disconnected).");
                return;
            }
            count += 1;
        }
        info!("WORKER: Conductor stopped. Emitted {} signals.", count);
    });

    let mut signals_received = 0;
    let mut min_latency_us = u64::MAX;
    let mut max_latency_us = 0;
    let main_start_time = Instant::now();

    while main_start_time.elapsed() < target_duration + Duration::from_millis(500) {
        match rx.recv_timeout(Duration::from_millis(1)) {
            Ok(timestamp_us) => {
                signals_received += 1;
                let elapsed_us = main_start_time.elapsed().as_micros() as u64;
                let latency_us = elapsed_us.saturating_sub(timestamp_us);

                min_latency_us = min_latency_us.min(latency_us);
                max_latency_us = max_latency_us.max(latency_us);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                thread::sleep(Duration::from_nanos(100));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                info!("MAIN: Conductor thread finished/disconnected.");
                break;
            }
        }
    }

    conductor_thread.join().unwrap();

    let success = signals_received >= required_signals;

    if success {
        info!("‚úÖ SUCCESS: Animation Conductor Tempo Validated.");
        info!("   Target Signals: {} | Received: {}", required_signals, signals_received);
        info!("   Latency (Main Thread Read Lag): Min {}¬µs, Max {}¬µs.", min_latency_us, max_latency_us);
    } else {
        error!("‚ùå FAIL: Animation Conductor FAILED to achieve required tempo.");
        error!("   Expected signals: {} | Received: {}. Check worker thread throttling.", required_signals, signals_received);
        error!("   Latency range suggests systemic entropy in signal marshalling.");
    }
}

// --- END: rust/ssxl_cli/src\actions\actions.rs ---
        66 LOC | rust/ssxl_cli/src\actions\benchmarking.rs
// --- START: rust/ssxl_cli/src\actions\benchmarking.rs ---
// ============================================================================
// üîÆ SSXL Signal Inspector & Benchmark Stub
// ----------------------------------------------------------------------------
// This module provides a command-line utility for monitoring the real-time
// status of the SSXL Conductor. It is designed as a diagnostic tool to give
// developers visibility into the conductor‚Äôs runtime behavior, queue depth,
// and generator activity.
//
// Key Components:
//   ‚Ä¢ start_signal_inspector
//       - Initializes the Conductor and begins a live feed loop.
//       - Displays frame count, conductor status, active generator ID, and
//         queue depth in real time.
//       - Uses Ctrl-C handling to gracefully shut down the conductor when
//         requested by the user.
//       - Monitors for critical states (ShuttingDown, Error) and triggers
//         teardown automatically.
//       - Provides a baseline metric (MVG_BASELINE) for tile throughput,
//         useful for performance comparisons.
//
//   ‚Ä¢ run_benchmark
//       - Placeholder function for future benchmarking logic.
//       - Currently logs a warning when invoked, signaling that benchmarking
//         is not yet implemented.
//
// Workflow:
//   1. Conductor initialization via `Conductor::new(None)`.
//   2. Wrap conductor in `Arc<Mutex>` for safe concurrent shutdown handling.
//   3. Register Ctrl-C handler:
//        - Sets running flag to false.
//        - Calls conductor‚Äôs graceful teardown.
//        - Prints shutdown message to stdout.
//   4. Enter live feed loop:
//        - Increment frame counter.
//        - Query conductor state for status, queue depth, and active generator.
//        - Print formatted status line to stdout.
//        - Flush output for real-time display.
//        - Sleep briefly to maintain tempo.
//   5. Exit loop when conductor signals shutdown or error.
//   6. Clear terminal line and log inspector termination.
//
// Design Choices:
//   ‚Ä¢ `Arc<Mutex>` ensures safe shared ownership of the conductor across
//     threads, particularly for shutdown handling.
//   ‚Ä¢ `AtomicBool` provides a lightweight flag for controlling the live feed
//     loop and responding to Ctrl-C signals.
//   ‚Ä¢ `ctrlc` crate integrates OS-level interrupt handling for graceful exits.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging
//     for visibility and debugging.
//   ‚Ä¢ Real-time printing with carriage return (`\r`) creates a dynamic,
//     single-line live feed in the terminal.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a responsive, real-time inspector
//     in Rust using concurrency primitives, structured logging, and signal
//     handling.
//   ‚Ä¢ It highlights the importance of graceful shutdown in long-running
//     systems, ensuring resources are cleaned up and runtime state is safely
//     terminated.
// ============================================================================


use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering}
};
use std::thread;
use std::time::Duration;
use ctrlc;

use ssxl_generate::conductor::{Conductor, ConductorStatus};

pub fn start_signal_inspector() {
    warn!("üîÆ Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    let (conductor, state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("‚ùå Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        print!("\r");
        print!("üîÆ LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        thread::sleep(Duration::from_millis(50));
    }

    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

#[allow(dead_code)]
pub fn run_benchmark() {
    warn!("‚è±Ô∏è Benchmark execution not yet implemented. Placeholder called.");
}

// --- END: rust/ssxl_cli/src\actions\benchmarking.rs ---
       102 LOC | rust/ssxl_cli/src\actions\godot_harness.rs
// --- START: rust/ssxl_cli/src\actions\godot_harness.rs ---
// ============================================================================
// üéÆ SSXL CLI: Godot Harness (`ssxl_cli::actions::godot_harness`)
// ----------------------------------------------------------------------------
// This module provides command-line utilities for integrating the SSXL engine
// with the Godot editor and runtime. It automates critical setup tasks such as
// copying the compiled Rust dynamic library into the Godot project and
// launching Godot in either editor or headless mode.
//
// Key Functions:
//   ‚Ä¢ copy_dll_to_tester_project_at_boot
//       - Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the
//         `target` build directory into the Godot project‚Äôs GDExtension folder.
//       - Ensures Godot loads the latest engine code when the project runs.
//       - Validates source path existence, logs warnings if missing, and
//         handles errors gracefully (e.g., file locked by running Godot).
//
//   ‚Ä¢ launch_godot_client
//       - Launches the Godot Editor in a non-blocking subprocess.
//       - Useful for debugging scenes and testing engine integration with GUI.
//       - Uses `--editor` flag to open the editor instead of running the game.
//       - Logs success/failure and provides guidance if the executable path is
//         misconfigured.
//
//   ‚Ä¢ launch_headless_godot
//       - Launches Godot in headless mode (no GUI).
//       - Ideal for automated testing, CI pipelines, or server-side execution.
//       - Uses `--headless` flag to run without a graphical interface.
//       - Logs success/failure and ensures correct path configuration.
//
// Workflow:
//   1. Build Rust engine (`cargo build`).
//   2. Run `copy_dll_to_tester_project_at_boot` to sync DLL into Godot project.
//   3. Launch Godot via either `launch_godot_client` (editor mode) or
//      `launch_headless_godot` (headless mode).
//   4. Godot loads the DLL from its GDExtension folder, enabling engine
//      integration.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` provides portable subprocess execution.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) ensure structured logging for
//     visibility and debugging.
//   ‚Ä¢ Path construction uses `env::current_dir` combined with project-specific
//     constants for portability across environments.
//   ‚Ä¢ Non-blocking subprocesses (`spawn`) allow the CLI to continue running
//     while Godot executes.
//
// Educational Note:
//   ‚Ä¢ This harness demonstrates how Rust can act as a build-time and runtime
//     companion to Godot, automating repetitive tasks and ensuring smooth
//     integration.
//   ‚Ä¢ By centralizing DLL copying and process launching here, developers avoid
//     manual setup errors and streamline the workflow between Rust and Godot.
// ============================================================================


use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};

pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    source.push(DLL_NAME);
    let source_path = source.as_path();

    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "‚úÖ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            Err(format!(
                "‚ùå FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}

pub fn launch_godot_client() {
    info!("üöÄ LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        .arg("--editor")
        .arg("--path")
        .arg(&project_path_abs)
        .spawn()
    {
        Ok(_) => {
            info!("‚úÖ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("‚ùå Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

pub fn launch_headless_godot() {
    info!("üöÄ LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        .arg("--headless")
        .arg("--path")
        .arg(&project_path_abs)
        .spawn()
    {
        Ok(_) => {
            info!("‚úÖ Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!("‚ùå Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}

// --- END: rust/ssxl_cli/src\actions\godot_harness.rs ---
        25 LOC | rust/ssxl_cli/src\actions\godot_tests.rs
// --- START: rust/ssxl_cli/src\actions\godot_tests.rs ---
// ============================================================================
// üß™ SSXL CLI: Godot Integration Tests (`godot_harness_tests`)
// ----------------------------------------------------------------------------
// This module defines a set of CLI-accessible integration tests that validate
// the connection between the Rust engine (via FFI/GDExtension) and the Godot
// runtime. Each test launches a specific Godot scene and checks for expected
// success signals, ensuring that critical subsystems are wired correctly.
//
// Key Functions:
//   ‚Ä¢ run_ffi_bridge_validation
//       - Validates the Foreign Function Interface (FFI) bridge between Rust
//         and Godot.
//       - Confirms that the compiled Rust dynamic library is correctly loaded
//         into Godot via GDExtension.
//       - Ensures bidirectional communication between Rust and Godot succeeds.
//
//   ‚Ä¢ run_headless_generation_integration_test
//       - Runs a headless Godot scene that exercises the full map generation
//         pipeline.
//       - Validates procedural generation, streaming, and integration without
//         requiring a graphical interface.
//       - Confirms that generated chunks are correctly processed and aligned.
//
//   ‚Ä¢ run_headless_animation_tempo_test
//       - Executes a headless Godot scene focused on animation conductor tempo.
//       - Validates high-frequency signal emission and latency handling.
//       - Ensures the conductor loop maintains expected performance under load.
//
// Workflow:
//   1. Each function calls `run_godot_test`, passing:
//        - A human-readable test description.
//        - The path to the Godot scene to execute.
//        - The expected success message for validation.
//   2. Godot runs the scene (editor or headless).
//   3. The CLI captures output and checks for the success string.
//   4. Results are logged, confirming subsystem integrity.
//
// Design Choices:
//   ‚Ä¢ Headless tests allow automated validation in CI/CD pipelines without GUI.
//   ‚Ä¢ Scene-based testing leverages Godot‚Äôs runtime to validate integration
//     rather than relying solely on unit tests.
//   ‚Ä¢ Success messages provide clear, human-readable confirmation of subsystem
//     health.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how to bridge Rust and Godot using FFI and
//     GDExtension, ensuring that engine subsystems (map generation, animation,
//     conductor tempo) are validated in real runtime conditions.
//   ‚Ä¢ By centralizing these checks in the CLI, developers can quickly confirm
//     integration health before deploying or debugging in the editor.
// ============================================================================


use super::{
    run_godot_test, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_ffi_bridge_validation() {
    run_godot_test(
        "FFI Bridge and GDExtension Integration Validation",
        GODOT_TEST_SCENE,
        "FFI/GDExtension Bridge VALIDATION SUCCEEDED!",
    );
}

pub fn run_headless_generation_integration_test() {
    run_godot_test(
        "Headless Map Generation Integration Test",
        HEADLESS_GEN_TEST_SCENE,
        "Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.",
    );
}

pub fn run_headless_animation_tempo_test() {
    run_godot_test(
        "Headless Animation Conductor Tempo Test",
        HEADLESS_ANIM_TEST_SCENE,
        "Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.",
    );
}

// --- END: rust/ssxl_cli/src\actions\godot_tests.rs ---
        46 LOC | rust/ssxl_cli/src\actions\mod.rs
// --- START: rust/ssxl_cli/src\actions\mod.rs ---
// ============================================================================
// ‚öôÔ∏è SSXL CLI Actions Module (`ssxl_cli::actions`)
// ----------------------------------------------------------------------------
// This module acts as the central fa√ßade for all command-line actions in the
// SSXL engine CLI. It aggregates constants, utilities, and exports from child
// modules, providing a unified interface for launching Godot, running tests,
// monitoring conductor status, and initiating benchmarks.
//
// Structure:
//   ‚Ä¢ Submodules:
//       - benchmarking: Tools for real-time monitoring of the Conductor and
//         placeholders for benchmark logic.
//       - godot_harness: Utilities for launching and managing the external
//         Godot tester project (editor and headless modes).
//       - testing: Menu and orchestration logic for executing test suites.
//       - test_suites: Self-contained architectural and data validation tests.
//       - test_core_suites: Tests requiring external processes like `cargo`
//         builds and Godot FFI validation.
//
//   ‚Ä¢ Configuration Constants:
//       - GODOT_EXE_PATH: Absolute path to the Godot executable.
//       - RELATIVE_PROJECT_PATH_FRAGMENT: Relative path to the Godot tester
//         project‚Äôs GDExtension folder.
//       - DLL_NAME: Expected name of the compiled Rust dynamic library.
//       - SOURCE_DLL_PATH_FRAGMENT: Path fragment where the compiled DLL is
//         found (e.g., `target/debug/`).
//       - GODOT_TEST_SCENE: Scene path for FFI bridge validation.
//       - HEADLESS_GEN_TEST_SCENE: Scene path for headless generation pipeline
//         validation.
//       - HEADLESS_ANIM_TEST_SCENE: Scene path for headless animation tempo
//         validation.
//
//   ‚Ä¢ Utility Functions:
//       - get_godot_project_abs_path: Calculates the absolute path to the Godot
//         tester project root, ensuring portability across environments.
//
//   ‚Ä¢ Public Exports (Fa√ßade):
//       - start_signal_inspector: Real-time conductor monitoring feed.
//       - copy_dll_to_tester_project_at_boot, launch_godot_client,
//         launch_headless_godot: Godot harness utilities.
//       - run_cargo_tests, run_ffi_bridge_validation,
//         run_headless_generation_integration_test,
//         run_headless_animation_tempo_test: Core test suite exports.
//       - run_communication_channel_test, run_data_channel_test,
//         run_map_generation_test, run_animation_conductor_test: General test
//         suite exports.
//       - execute_testing_menu: Entry point for orchestrating test execution.
//
// Design Choices:
//   ‚Ä¢ Modular organization ensures separation of concerns between harnessing,
//     benchmarking, and testing logic.
//   ‚Ä¢ Constants centralize configuration for portability and maintainability.
//   ‚Ä¢ Re-exports provide a clean fa√ßade, allowing external callers to interact
//     with CLI actions without needing to know internal module structure.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates the fa√ßade pattern in Rust: exposing a curated
//     set of functions and constants from multiple submodules to simplify
//     external usage.
//   ‚Ä¢ By consolidating CLI actions here, developers gain a single, predictable
//     entry point for managing Godot integration, conductor monitoring, and
//     validation pipelines.
// ============================================================================


use std::env;
use std::path::PathBuf;

mod benchmarking;
mod godot_harness;
mod testing;
mod test_suites;
mod test_core_suites;

pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXLtester2/";
pub const DLL_NAME: &str = "ssxl_engine.dll";
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; 
pub const HEADLESS_GEN_TEST_SCENE: &str = "res://tests/headless_gen_pipeline.tscn";
pub const HEADLESS_ANIM_TEST_SCENE: &str = "res://tests/headless_anim_tempo.tscn";

pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}

pub use benchmarking::start_signal_inspector;

pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
};

pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};

#[allow(unused_imports)]
pub use testing::execute_testing_menu;

// --- END: rust/ssxl_cli/src\actions\mod.rs ---
        36 LOC | rust/ssxl_cli/src\actions\testing.rs
// --- START: rust/ssxl_cli/src\actions\testing.rs ---
// ============================================================================
// üß™ SSXL CLI: Testing Menu (`ssxl_cli::actions::testing`)
// ----------------------------------------------------------------------------
// This module provides a command-line menu for executing various validation
// suites. It acts as the central dispatcher, delegating execution to both
// internal architectural tests and external integration tests.
//
// Purpose:
//   ‚Ä¢ Offer a unified interface for developers to run different categories of
//     tests directly from the CLI.
//   ‚Ä¢ Simplify orchestration by exposing a menu-driven workflow rather than
//     requiring manual invocation of individual test functions.
//   ‚Ä¢ Ensure that both Rust-only validation (unit/integration tests) and
//     Godot-linked integration tests can be triggered consistently.
//
// Key Components:
//   ‚Ä¢ TEST_ACTIONS (LazyLock<Vec<CliAction>>)
//       - Defines the available test actions as menu items.
//       - Each action has an identifier (`id`) and a description.
//       - LazyLock ensures thread-safe, runtime initialization of the menu.
//
//   ‚Ä¢ execute_testing_menu
//       - Central entry point for the testing menu.
//       - Creates a `CliMenu` with all available test actions.
//       - Enters a loop, prompting the user to select an action.
//       - Matches the selected action against its `id` and delegates execution
//         to the appropriate test function.
//       - Supports returning to the main menu via the "back" action.
//
// Supported Actions:
//   ‚Ä¢ "cargo"      ‚Üí Runs all standard Rust unit/integration tests via Cargo.
//   ‚Ä¢ "ffi"        ‚Üí Runs FFI bridge and GDExtension integration validation
//                    (headless Godot).
//   ‚Ä¢ "channel"    ‚Üí Runs communication channel tempo test (non-blocking mpsc).
//   ‚Ä¢ "generation" ‚Üí Runs Perlin-based map generation test.
//   ‚Ä¢ "animation"  ‚Üí Runs animation conductor data contract test.
//   ‚Ä¢ "back"       ‚Üí Exits the testing menu and returns to the main CLI menu.
//
// Design Choices:
//   ‚Ä¢ `CliAction` and `CliMenu` abstract away menu logic, keeping this module
//     focused on orchestration.
//   ‚Ä¢ LazyLock ensures initialization happens only once, avoiding global
//     mutable state issues.
//   ‚Ä¢ Pattern matching on `id` strings provides a simple, extensible way to
//     add new test actions in the future.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a fa√ßade for test orchestration,
//     combining multiple subsystems into a single, developer-friendly entry
//     point.
//   ‚Ä¢ By centralizing test execution here, developers can quickly validate
//     both internal architecture and external integration without switching
//     contexts or running multiple commands manually.
// ============================================================================


use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;
use crate::actions::test_core_suites;
use std::sync::LazyLock;

#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    CliAction::new("back", "‚Ü©Ô∏è Return to Main Menu"), 
]);

#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}

// --- END: rust/ssxl_cli/src\actions\testing.rs ---
       103 LOC | rust/ssxl_cli/src\actions\tests_core.rs
// --- START: rust/ssxl_cli/src\actions\tests_core.rs ---
// ============================================================================
// üß™ SSXL CLI: Core Test Runner (`ssxl_cli::actions::test_core_runner`)
// ----------------------------------------------------------------------------
// This module provides utilities for executing both Rust-based unit/integration
// tests and Godot-based headless integration tests. It acts as the backbone of
// the CLI testing framework, ensuring that internal Rust logic and external
// Godot integration are validated consistently.
//
// Key Functions:
//   ‚Ä¢ run_cargo_tests
//       - Executes the full Rust test suite via `cargo test`.
//       - Runs with `--nocapture` to stream output directly to the console.
//       - Reports success/failure based on Cargo‚Äôs exit status.
//
//   ‚Ä¢ read_all_output_from_stream
//       - Helper function for reading all output from a process stream.
//       - Runs in a separate thread to avoid blocking the main process.
//       - Collects stdout/stderr into strings for later logging.
//
//   ‚Ä¢ run_godot_test
//       - Generic runner for Godot-based integration tests.
//       - Accepts a test title, scene path, and success message.
//       - Spawns Godot in headless mode with the specified scene.
//       - Captures stdout and stderr concurrently for full visibility.
//       - Logs formatted output and reports success/failure based on Godot‚Äôs
//         exit status.
//
// Workflow:
//   1. Rust unit/integration tests are executed via `run_cargo_tests`.
//   2. Godot is launched in headless mode with a specific test scene.
//   3. Output streams (stdout/stderr) are captured in parallel threads.
//   4. Results are logged to the console, including success/failure messages.
//   5. Exit codes and captured output provide detailed diagnostics.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` is used to spawn external processes (Cargo, Godot).
//   ‚Ä¢ `Stdio::piped` allows capturing stdout/stderr for real-time logging.
//   ‚Ä¢ Threads are used to read output streams concurrently, preventing blocking.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Headless Godot execution ensures tests can run in CI/CD pipelines without
//     requiring a GUI.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can orchestrate external processes to
//     validate integration with another engine (Godot).
//   ‚Ä¢ By combining Cargo tests with Godot headless scenes, developers gain
//     confidence that both the Rust engine and its FFI bridge are functioning
//     correctly in real runtime conditions.
// ============================================================================


use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, 
    GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE, HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("üöÄ Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("‚úÖ All Rust unit and integration tests passed.");
    } else {
        error!("‚ùå Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub(crate) fn run_godot_test(
    test_title: &str,
    test_scene: &str,
    success_message: &str,
) -> bool {
    info!("üî• STARTING: {}...", test_title);

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå {} failed: {}", test_title, e);
            return false;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(test_scene)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process for {}: {}", test_title, e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return false;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait for {}: {}", test_title, e);
            return false;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());
    
    println!("\n--- GODOT {} TEST OUTPUT START ---", test_title.to_uppercase());
    println!("{}", stdout_output);
    println!("--- GODOT {} TEST OUTPUT END ---\n", test_title.to_uppercase());

    if status.success() {
        info!("‚úÖ {} SUCCEEDED! {}", test_title, success_message);
        true
    } else {
        error!(
            "‚ùå {} FAILED! Exit code: {:?}",
            test_title,
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
        false
    }
}

// --- END: rust/ssxl_cli/src\actions\tests_core.rs ---
       234 LOC | rust/ssxl_cli/src\actions\test_core_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_core_suites.rs ---
// ============================================================================
// üß™ SSXL CLI: Core Test Suites (`ssxl_cli::actions::test_core_suites`)
// ----------------------------------------------------------------------------
// This module defines the core integration tests that validate communication
// between the Rust engine and the Godot runtime. Unlike lightweight unit tests,
// these tests spawn external processes (Cargo and Godot) to ensure that the
// full pipeline‚Äîfrom compilation to FFI bridge to headless execution‚Äîworks
// correctly in real runtime conditions.
//
// Key Functions:
//   ‚Ä¢ run_cargo_tests
//       - Executes the full Rust test suite via `cargo test`.
//       - Runs with `--nocapture` to stream output directly to the console.
//       - Validates that all Rust unit and integration tests pass before
//         attempting Godot integration.
//
//   ‚Ä¢ run_ffi_bridge_validation
//       - Launches Godot in headless mode with the FFI bridge validation scene.
//       - Confirms that the Rust dynamic library is correctly loaded via
//         GDExtension and that communication between Rust and Godot succeeds.
//       - Captures stdout/stderr from the Godot process for detailed logging.
//       - Reports success/failure based on Godot‚Äôs exit status.
//
//   ‚Ä¢ run_headless_generation_integration_test
//       - Executes a headless Godot scene that validates the full map generation
//         pipeline.
//       - Ensures procedural generation, streaming, and integration logic work
//         without requiring a graphical interface.
//       - Captures and logs Godot output for debugging and validation.
//
//   ‚Ä¢ run_headless_animation_tempo_test
//       - Runs a headless Godot scene focused on animation conductor tempo.
//       - Validates high-frequency signal emission and latency handling in the
//         conductor loop.
//       - Confirms that the conductor maintains expected performance under load.
//
// Workflow:
//   1. Rust unit/integration tests are executed via `run_cargo_tests`.
//   2. Godot is launched in headless mode with specific test scenes.
//   3. Output streams (stdout/stderr) are captured in parallel threads.
//   4. Results are logged to the console, including success/failure messages.
//   5. Exit codes and captured output provide detailed diagnostics.
//
// Design Choices:
//   ‚Ä¢ `std::process::Command` is used to spawn external processes (Cargo, Godot).
//   ‚Ä¢ `Stdio::piped` allows capturing stdout/stderr for real-time logging.
//   ‚Ä¢ Threads are used to read output streams concurrently, preventing blocking.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Headless Godot execution ensures tests can run in CI/CD pipelines without
//     requiring a GUI.
//
// Educational Note:
//   ‚Ä¢ These tests demonstrate how Rust can orchestrate external processes to
//     validate integration with another engine (Godot).
//   ‚Ä¢ By combining Cargo tests with Godot headless scenes, developers gain
//     confidence that both the Rust engine and its FFI bridge are functioning
//     correctly in real runtime conditions.
// ============================================================================


use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("üöÄ Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("‚úÖ All Rust unit and integration tests passed.");
    } else {
        error!("‚ùå Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub fn run_ffi_bridge_validation() {
    info!("üî• STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(
            "‚ùå FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_generation_integration_test() {
    info!("üî• STARTING: Headless Map Generation Integration Test (Full Pipeline Validation)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_GEN_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS GENERATION TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS GENERATION TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.");
    } else {
        error!(
            "‚ùå Headless Generation Integration Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_animation_tempo_test() {
    info!("üî• STARTING: Headless Animation Conductor Tempo Test (Signal Latency Check)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("‚ùå Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_ANIM_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("‚ùå Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("‚ùå Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT START ---\n");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT END ---\n");

    if status.success() {
        info!("‚úÖ Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.");
    } else {
        error!(
            "‚ùå Headless Animation Tempo Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
// --- END: rust/ssxl_cli/src\actions\test_core_suites.rs ---
       107 LOC | rust/ssxl_cli/src\actions\test_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_suites.rs ---
// ============================================================================
// üß™ SSXL CLI: Internal Architectural & Data Validation Suites
// ----------------------------------------------------------------------------
// This module defines self-contained Rust tests that validate the integrity of
// internal data contracts, concurrency models, and core generation logic. Unlike
// integration tests that rely on external processes (e.g., Godot), these suites
// focus purely on architectural correctness within the Rust engine itself.
//
// Key Functions:
//   ‚Ä¢ run_communication_channel_test
//       - Validates non-blocking `mpsc` channels used between Godot‚Äôs main thread
//         and Rust worker threads (Generation and Animation Conductors).
//       - Simulates a conductor thread receiving commands while the CLI floods
//         the channel with messages.
//       - Confirms that messages are successfully transmitted and received within
//         a bounded test duration.
//
//   ‚Ä¢ run_data_channel_test
//       - Alias for `run_communication_channel_test`.
//       - Provides a semantic entry point for validating data channel integrity.
//
//   ‚Ä¢ run_map_generation_test
//       - Validates core map generation logic using the Perlin noise generator.
//       - Generates a chunk at specific coordinates and verifies tile count
//         against the expected `CHUNK_SIZE`¬≤.
//       - Reports generation time and throughput (tiles/sec) for performance
//         benchmarking.
//       - Ensures chunk data integrity and correctness of procedural generation.
//
//   ‚Ä¢ run_animation_conductor_test
//       - Validates the data contract for animation updates.
//       - Ensures the `AnimationUpdate` struct can be serialized and deserialized
//         using `bincode` without data loss.
//       - Confirms that tile coordinates and atlas coordinates remain consistent
//         after round-trip encoding/decoding.
//       - Provides confidence that animation updates can safely traverse FFI
//         boundaries and channels.
//
// Workflow:
//   1. Communication channels are stress-tested for throughput and reliability.
//   2. Map generation is validated for correctness and performance metrics.
//   3. Animation conductor data contracts are verified for serialization safety.
//   4. Results are logged via `tracing` for visibility and debugging.
//
// Design Choices:
//   ‚Ä¢ `mpsc` channels simulate real conductor communication without external
//     dependencies.
//   ‚Ä¢ `PerlinGenerator` provides deterministic procedural generation for chunk
//     validation.
//   ‚Ä¢ `bincode` ensures efficient serialization for FFI and channel transport.
//   ‚Ä¢ `tracing` macros (`info`, `error`) provide structured logging for clarity.
//
// Educational Note:
//   ‚Ä¢ These suites demonstrate how to validate concurrency, procedural generation,
//     and serialization contracts in isolation.
//   ‚Ä¢ By ensuring architectural correctness here, developers can trust that
//     higher-level integration tests (with Godot) are built on a solid foundation.
// ============================================================================


use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

use ssxl_generate::Generator;
use ssxl_generate::perlin::PerlinGenerator;
use ssxl_math::prelude::Vec2i;
use ssxl_shared::chunk::chunk_data::CHUNK_SIZE;
use ssxl_shared::tile::tile_data::AnimationUpdate;

pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1));
    }
    
    drop(cli_sender);

    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("‚ùå Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("‚úÖ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("‚ùå Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}

pub fn run_data_channel_test() {
    run_communication_channel_test();
}

pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords);
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("‚úÖ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("‚ùå Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("‚ùå Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("‚ùå Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("‚úÖ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("‚ùå Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}

// --- END: rust/ssxl_cli/src\actions\test_suites.rs ---
       129 LOC | rust/ssxl_cli/src\cli_util_bench.rs
// --- START: rust/ssxl_cli/src\cli_util_bench.rs ---
// ============================================================================
// ‚ö° SSXL CLI: Benchmarking Utilities (`ssxl_cli::cli_util_bench`)
// ----------------------------------------------------------------------------
// This module provides command-line utilities for validating and benchmarking
// the SSXL engine‚Äôs generation and conductor subsystems. It focuses on three
// core areas: synchronous chunk generation, placeholder conversion routines,
// and large-scale throughput benchmarking.
//
// Key Functions:
//   ‚Ä¢ test_generation_and_placement_cli
//       - Validates the Conductor by attempting chunk generation with multiple
//         generators (Perlin and Cellular Automata).
//       - Confirms that chunks can be generated synchronously via `get_chunk_data`.
//       - Reports success/failure based on the number of chunks generated.
//       - Ensures generator IDs are correctly registered and active.
//
//   ‚Ä¢ run_bitmask_conversion
//       - Placeholder function simulating conversion of a world image into tile
//         placement data.
//       - Logs a fixed number of tiles placed to demonstrate workflow.
//       - Serves as a stub for future image-to-world conversion logic.
//
//   ‚Ä¢ run_max_grid_benchmark
//       - Executes a large-scale workload benchmark to measure maximum tile
//         generation throughput.
//       - Spawns two threads:
//           1. Workload thread: runs `benchmark_generation_workload` to simulate
//              tile generation across a massive grid.
//           2. Ticker thread: monitors progress, calculates throughput, and
//              prints real-time updates to stdout.
//       - Reports final throughput in tiles/sec and diagnostics in tiles/ms.
//       - Compares results against baseline (MVG_BASELINE) and target thresholds
//         (ITERATION5_TARGET) to evaluate performance.
//       - Provides structured logging for success, warnings, or critical failures.
//
// Workflow:
//   1. Initialize Conductor or workload counters.
//   2. Spawn threads for generation and progress monitoring.
//   3. Capture progress in real time, printing formatted output to the console.
//   4. Join threads and calculate final throughput metrics.
//   5. Compare results against baseline/target thresholds and log outcomes.
//
// Design Choices:
//   ‚Ä¢ `Arc<AtomicU64>` provides thread-safe counters for progress tracking.
//   ‚Ä¢ `std::thread::spawn` enables concurrent workload execution and monitoring.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     visibility and debugging.
//   ‚Ä¢ Real-time progress printing with carriage return (`\r`) creates a dynamic,
//     single-line ticker in the terminal.
//   ‚Ä¢ Baseline and target thresholds allow performance regression detection.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build benchmarking tools in Rust using
//     concurrency primitives, atomic counters, and structured logging.
//   ‚Ä¢ By validating both correctness (chunk generation) and performance
//     (throughput benchmarks), developers gain confidence in the scalability
//     and reliability of the SSXL engine.
// ============================================================================


use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc,
    atomic::{AtomicU64, Ordering}
};
use std::io::{self, Write};
use std::time::Duration;

use ssxl_generate::benchmark_generation_workload;
use ssxl_generate::conductor::Conductor;
use ssxl_math::prelude::Vec2i;

pub fn test_generation_and_placement_cli() {
    warn!("üß™ Running CLI Test: Generation and Placement (Conductor Validation)...");

    let (mut conductor, _state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("‚ùå Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    let perlin_id = "perlin_basic_2d";
    if conductor.set_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            let _chunk = conductor.get_chunk_data(&coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    let ca_id = "cellular_automata_basic";
    if conductor.set_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.get_chunk_data(&coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    if chunks_generated > 0 {
        info!("‚úÖ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).",
            chunks_generated,
            conductor.get_active_generator_id()
        );
    } else {
        error!("‚ùå CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    conductor.graceful_teardown();
}

pub fn run_bitmask_conversion() {
    warn!("üß™ Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("‚úÖ Conversion complete. Tiles placed: {}", tiles_placed);
}

pub fn run_max_grid_benchmark() {
    warn!("üß™ Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000;

    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone);
    });

    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            let throughput = if elapsed > 0.0 {
                (current as f64 / elapsed).round() as u64
            } else {
                0
            };

            print!("\r‚è≥ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s",
                percentage,
                current / 1_000_000,
                WORKLOAD_TILES / 1_000_000,
                throughput
            );
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    let start = Instant::now();
    
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        let _ = println!("\r‚ùå Benchmark failed: Generation thread panic. {: <100}", " ");
        return;
    }
    
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    println!("\r‚úÖ Benchmark complete. Workload: {} tiles. Duration: {:.2}s",
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("‚ö° Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("‚ö° Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("üöÄ CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("üìà Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("‚ö†Ô∏è Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("‚ùå Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}

// --- END: rust/ssxl_cli/src\cli_util_bench.rs ---
       143 LOC | rust/ssxl_cli/src\cli_util_inspect.rs
// --- START: rust/ssxl_cli/src\cli_util_inspect.rs ---
// ============================================================================
// üå≤ SSXL CLI: Developer Utilities (`ssxl_cli::cli_util_dev_scan`)
// ----------------------------------------------------------------------------
// This module provides developer-facing utilities for scanning and visualizing
// the SSXL engine‚Äôs Rust workspace and Godot API surface. It is designed to
// help contributors quickly understand project structure and validate exposed
// FFI/GDExtension methods and signals.
//
// Key Functions:
//   ‚Ä¢ print_module_tree
//       - Recursively scans all crate source directories in the SSXL workspace.
//       - Prints a tree view of `.rs` files, highlighting core entry points
//         (`lib.rs`, `main.rs`) for each crate.
//       - Helps developers visualize module organization and identify where
//         architectural logic resides.
//       - Uses `walkdir` for recursive traversal and structured output.
//
//   ‚Ä¢ print_godot_api_surface
//       - Scans targeted Godot and FFI source files for callable methods and
//         registered signals.
//       - Uses regex to detect:
//           - `#[func]` annotated methods (GDExtension entry points).
//           - `#[no_mangle] pub extern "C"` functions (FFI core).
//           - `#[signal]` annotated broadcasts (Godot signal definitions).
//       - Collects method signatures (name, args, return type) and signal
//         signatures for reporting.
//       - Prints a consolidated ‚ÄúMASTER API Surface‚Äù showing all callable
//         methods and signals, grouped by source file.
//       - Differentiates between `[FFI CORE]` and `[GDExt]` methods for clarity.
//
// Workflow:
//   1. `print_module_tree` scans crate directories and prints a visual tree.
//   2. `print_godot_api_surface` reads targeted files, applies regex, and
//      extracts callable methods and signals.
//   3. Results are printed to stdout with structured formatting and markers.
//   4. Developers can use this output to validate API exposure and ensure
//      consistency across Rust and Godot integration layers.
//
// Design Choices:
//   ‚Ä¢ `walkdir` provides robust recursive directory traversal.
//   ‚Ä¢ `regex` enables flexible detection of annotated methods and signals.
//   ‚Ä¢ `tracing` macros (`info`, `warn`, `error`) provide structured logging for
//     success, warnings, and errors.
//   ‚Ä¢ Output formatting emphasizes clarity, highlighting core files and FFI
//     entry points.
//   ‚Ä¢ A short sleep (`thread::sleep`) ensures logs are flushed before returning.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust tooling can be extended to provide
//     developer ergonomics beyond compilation‚Äîoffering visibility into project
//     structure and API contracts.
//   ‚Ä¢ By centralizing scans here, contributors gain confidence that workspace
//     modules are organized correctly and that Godot-facing APIs are properly
//     exposed for integration.
// ============================================================================


use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;

pub fn print_module_tree() {
    println!("\n=========================================================================");
    println!("| üå≤ RUST WORKSPACE MODULE TREE (Scanning...)                            |");
    println!("=========================================================================");
    
    let crate_dirs = [
        "ssxl_cache/src",
        "ssxl_engine_ffi/src",
        "ssxl_generate/src",
        "ssxl_godot/src",
        "ssxl_math/src",
        "ssxl_shared/src",
        "ssxl_sync/src",
        "ssxl_tools/src",
        "ssxl_cli/src",
    ];

    for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
        println!("\nüîç Crate: {}", crate_dir);

        if crate_path.exists() && crate_path.is_dir() {
            for entry in WalkDir::new(&crate_path).min_depth(1) {
                match entry {
                    Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "‚îú‚îÄ‚îÄ [CORE] "
                            } else {
                                "‚îÇ   ‚îî‚îÄ‚îÄ "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
                    },
                    Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
                }
            }
        } else {
            warn!("Path does not exist or is not a directory: {}", crate_dir);
        }
    }
    println!("=========================================================================\n");
}

pub fn print_godot_api_surface() {
    let godot_api_files: [&str; 4] = [ 
        "ssxl_godot/src/engine/init.rs",
        "ssxl_godot/src/ffi/oracle.rs",      
        "ssxl_godot/src/ffi/signals.rs",
        "ssxl_engine_ffi/src/lib.rs", 
    ];

    println!("üß™ API scan triggered (targeting {} files in ssxl_godot/src/ and FFI core)...", godot_api_files.len());
    
    let method_regex = Regex::new(
        r#"(?s)(?:\s*#

\[func\]

.*?|#

\[no_mangle\]

.*?pub\s+extern\s+"C"\s*)\s*(?:pub\s+fn|fn)\s+(\w+)\s*(\([^\{;]*)\s*(?:->\s*([^\{]*))?"#
    ).unwrap();

    let signal_signature_regex = Regex::new(
        r"^\s*fn\s+(\w+)\s*(\([^;]*)\s*;\s*$"
    ).unwrap();
    let signal_marker_regex = Regex::new(r"^\s*#

\[signal\]

\s*$").unwrap();
    
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();
    let mut api_signals: Vec<(String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        
        let mut signal_line_pending = false;

        match fs::read_to_string(path) {
            Ok(contents) => {
                info!("Successfully read {}", path.display());
                
                for cap in method_regex.captures_iter(&contents) {
                    let method_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                    let args = cap.get(2)
                        .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                        .unwrap_or_default();
                    let return_type = cap.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                    
                    let clean_args = args.replace("self, ", "self,").trim().trim_start_matches("self").trim_start_matches(",").trim().to_string();

                    api_methods.push((method_name, clean_args, return_type, file_name.to_string()));
                }

                for line in contents.lines() {
                    let trimmed_line = line.trim();

                    if signal_marker_regex.is_match(trimmed_line) {
                        signal_line_pending = true;
                        continue;
                    }
                    
                    if signal_line_pending {
                        if let Some(captures) = signal_signature_regex.captures(trimmed_line) {
                            let signal_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_signal").to_string();
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            api_signals.push((signal_name, args, file_name.to_string()));
                            signal_line_pending = false; 
                        } else if !trimmed_line.is_empty() {
                            signal_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

    println!("\n--- üéÆ SSXL Engine Developer MASTER API Surface ---");
    
    println!("\n‚úÖ Callable Methods ({} total):", api_methods.len());
    if api_methods.is_empty() {
        warn!(" No callable methods found in targeted files (check FFI core!).");
    } else {
        for (name, args, return_type, source_file) in &api_methods {
            let marker = if source_file == "lib.rs" && api_methods.iter().any(|(n,_,_,s)| n == name && s == source_file) {
                "[FFI CORE]"
            } else {
                "[GDExt]"
            };
            println!(" > func {}({}) -> {} {} [{}]", name, args, return_type, marker, source_file);
        }
    }

    println!("\n‚≠ê Registered Signal Broadcasts ({} total):", api_signals.len());
    if api_signals.is_empty() {
        warn!(" No #[signal] broadcasts found in targeted files.");
    } else {
        for (name, args, source_file) in &api_signals {
            println!(" > signal {}({}) [{}]", name, args, source_file);
        }
    }
    println!("--------------------------------------------------");

    info!("API scan complete: {} methods and {} signals detected.", api_methods.len(), api_signals.len());
    thread::sleep(Duration::from_secs(2));
}

// --- END: rust/ssxl_cli/src\cli_util_inspect.rs ---
       106 LOC | rust/ssxl_cli/src\cli_util_loc.rs
// --- START: rust/ssxl_cli/src\cli_util_loc.rs ---
// ============================================================================
// üìä SSXL CLI: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
// ----------------------------------------------------------------------------
// This module provides developer utilities for scanning the SSXL-ext workspace,
// calculating Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`)
// files, and generating reports consumed by the Godot engine.
//
// Purpose:
//   ‚Ä¢ Track codebase growth and complexity across Rust and Godot components.
//   ‚Ä¢ Provide a single-number LOC file (`RUST_LOC_TOTAL.txt`) for fast parsing
//     by Godot at bootup.
//   ‚Ä¢ Generate detailed reports with per-file LOC counts and full file contents
//     for auditing and review.
//
// Key Components:
//   ‚Ä¢ OUTPUT_FINAL_LOC_FILE
//       - Fixed-name file (`RUST_LOC_TOTAL.txt`) written to the project root.
//       - Contains a single integer: the total Rust LOC count.
//       - Used by Godot for quick boot-time validation.
//
//   ‚Ä¢ LOC_REPORTS_DIR
//       - Directory (`../loc_reports`) where full LOC reports are stored.
//       - Each report is timestamped with epoch seconds for uniqueness.
//
//   ‚Ä¢ count_loc_from_content
//       - Helper function that counts non-empty, non-comment lines.
//       - Ignores lines starting with `//` (Rust) or `#` (GDScript).
//       - Provides a simplified but effective LOC metric.
//
//   ‚Ä¢ write_final_loc_total
//       - Writes the total Rust LOC count to the fixed-name file.
//       - Ensures Godot can quickly parse LOC without scanning the workspace.
//
//   ‚Ä¢ scan_and_report_loc
//       - Main entry point for LOC analysis.
//       - Scans all Rust crate directories under `ssxl-ext/rust/`.
//       - Scans GDScript files under `../ssxl_engine_tester`.
//       - Aggregates LOC counts, builds a detailed report, and writes both:
//           1. A full report with per-file LOC and file contents.
//           2. A single-number LOC file for Godot boot parsing.
//       - Uses `WalkDir` for recursive traversal and `fs::read_to_string`
//         for file content analysis.
//       - Sleeps briefly at the end to ensure logs and writes are flushed.
//
// Workflow:
//   1. Traverse Rust and GDScript source directories.
//   2. Count LOC for each file using `count_loc_from_content`.
//   3. Build a detailed report with LOC counts and file contents.
//   4. Write the report to `../loc_reports/ssxl_loc_report_live_<timestamp>.txt`.
//   5. Write the total Rust LOC to `../RUST_LOC_TOTAL.txt`.
//   6. Log results for developer visibility.
//
// Design Choices:
//   ‚Ä¢ Simplified LOC counting avoids parsing complexity while still providing
//     meaningful metrics.
//   ‚Ä¢ Reports include full file contents for transparency and auditing.
//   ‚Ä¢ Timestamped filenames prevent overwriting and allow historical tracking.
//   ‚Ä¢ Fixed-name LOC file ensures fast integration with Godot boot logic.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can be used to build developer tooling
//     that integrates with external engines (Godot).
//   ‚Ä¢ By automating LOC analysis, developers gain visibility into codebase
//     growth and maintainability, while Godot gains a quick boot-time metric.
// ============================================================================


use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";

fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

fn write_final_loc_total(loc_count: u64) {
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("üî• SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("‚ùå CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("‚ùå Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("‚úÖ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("‚ùå Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}

// --- END: rust/ssxl_cli/src\cli_util_loc.rs ---
       158 LOC | rust/ssxl_cli/src\cli_util_menu.rs
// --- START: rust/ssxl_cli/src\cli_util_menu.rs ---
// ============================================================================
// üß≠ SSXL CLI: Developer Console Menu (`ssxl_cli::cli_util_menu`)
// ----------------------------------------------------------------------------
// This module defines the interactive command-line menu system for the SSXL
// engine developer console. It provides a structured way to organize, present,
// and execute various developer actions, including validation tests, benchmarks,
// and inspection utilities.
//
// Purpose:
//   ‚Ä¢ Offer a unified interface for developers to run tests, benchmarks, and
//     debugging tools directly from the CLI.
//   ‚Ä¢ Simplify orchestration by exposing a menu-driven workflow rather than
//     requiring manual invocation of individual functions.
//   ‚Ä¢ Ensure that both Rust-only validation and Godot-linked integration tests
//     can be triggered consistently.
//
// Key Components:
//   ‚Ä¢ CliAction
//       - Represents a single executable action in the menu.
//       - Contains:
//           ‚Ä¢ key: the character used to trigger the action.
//           ‚Ä¢ label: human-readable description shown in the menu.
//           ‚Ä¢ id: internal identifier for the action.
//           ‚Ä¢ action: closure wrapping the function to execute.
//       - Provides a `new` constructor for placeholder actions.
//
//   ‚Ä¢ CliMenu
//       - Represents a group of actions under a common title.
//       - Provides `new` for initialization.
//       - Includes `prompt_action` (currently unimplemented) for interactive
//         selection logic.
//
//   ‚Ä¢ build_menu
//       - Constructs the full list of available actions for the developer console.
//       - Organizes actions into categories:
//           I. Core Rust Validation (cargo tests, FFI, channels, map generation, animation).
//           II. Headless Integration Tests (Godot-based generation and animation validation).
//           III. Engine Launch & Debugging Tools (launch Godot client/headless, signal inspector).
//           IV. Benchmarks & Utilities (generation tests, grid benchmarks, bitmask conversion).
//           V. System Control (exit).
//       - Each action is mapped to a key and closure for execution.
//
//   ‚Ä¢ print_menu
//       - Prints the structured menu to the console.
//       - Displays each action‚Äôs key and label for user selection.
//       - Provides a clear prompt for interaction.
//
// Workflow:
//   1. Developer runs the CLI console.
//   2. `build_menu` constructs the list of available actions.
//   3. `print_menu` displays the menu with keys and labels.
//   4. User selects an action by pressing the corresponding key.
//   5. The associated closure executes the requested function.
//
// Design Choices:
//   ‚Ä¢ Actions are closures wrapped in `Box<dyn Fn()>` for flexibility and dynamic dispatch.
//   ‚Ä¢ Keys are single characters for quick selection in interactive mode.
//   ‚Ä¢ Labels use emojis and descriptive text for clarity and developer ergonomics.
//   ‚Ä¢ Menu organization mirrors developer workflows: validation, integration, debugging,
//     benchmarking, and control.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how to build a modular CLI menu system in Rust,
//     combining structured data (CliAction, CliMenu) with dynamic execution.
//   ‚Ä¢ By centralizing developer actions here, contributors gain a predictable,
//     ergonomic interface for testing and debugging the SSXL engine.
// ============================================================================


use crate::actions::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use tracing::warn;

pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    pub fn new(id: &'static str, label: &'static str) -> Self {
        CliAction {
            key: '?',
            label,
            id,
            action: Box::new(|| {})
        }
    }
}

pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    pub fn prompt_action(&self) -> CliAction {
        unimplemented!()
    }
}

pub fn build_menu() -> Vec<CliAction> {
    vec![
        CliAction { 
            key: '0', 
            label: "‚úÖ Run: Full Cargo Test Suite", 
            id: "cargo_all", 
            action: Box::new(run_cargo_tests) 
        },
        CliAction {    
            key: '1',    
            label: "‚úÖ Validate: FFI Bridge Data Transfer (Data Integrity)",    
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction {    
            key: '2',    
            label: "‚úÖ Validate: Async Communication Channels (Godot <-> Rust)",    
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction {    
            key: '3',    
            label: "‚úÖ Validate: Chunk/Tile Data Channels (Crypto Coded)",    
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction {    
            key: '4',    
            label: "‚úÖ Validate: Map Generation Logic (Procedural Purity)",    
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction {    
            key: '5',    
            label: "‚úÖ Validate: Animation Conductor Tempo (Frame Consistency)",    
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },
        CliAction { 
            key: '6', 
            label: "‚úÖ Validate: Headless Generation Integration (Full Pipeline Simulation)", 
            id: "headless_gen_integration",
            action: Box::new(run_headless_generation_integration_test)
        },
        CliAction { 
            key: '7', 
            label: "‚úÖ Validate: Headless Animation Tempo Integration (Signal Latency Check)", 
            id: "headless_anim_tempo",
            action: Box::new(run_headless_animation_tempo_test)
        },
        CliAction {    
            key: 'L',    
            label: "üöÄ Launch: Godot Client (Non-Headless)",    
            id: "launch_client",
            action: Box::new(launch_godot_client)    
        },
        CliAction {    
            key: 'H',    
            label: "üéÆ Launch: Headless Godot (External)",    
            id: "launch_headless",
            action: Box::new(launch_headless_godot)    
        },
        CliAction {    
            key: 'S',    
            label: "üîÆ Start: Signal Inspector / Live Feed (TODO)",    
            id: "start_inspector",
            action: Box::new(start_signal_inspector)    
        },
        CliAction {    
            key: 'T',    
            label: "üß™ Test: Generation & Placement CLI",    
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli)    
        },
        CliAction {    
            key: 'B',    
            label: "üß™ Benchmark: Max Grid Placement",    
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)    
        },
        CliAction {    
            key: 'P',    
            label: "‚úÖ Perform: Bitmask PNG Conversion",    
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)    
        },
        CliAction {    
            key: 'A',    
            label: "‚úÖ Inspect: SSXL Developer API Surface (Callable + Signals)",    
            id: "api_surface",
            action: Box::new(print_godot_api_surface)    
        },
        CliAction {    
            key: 'I',    
            label: "‚úÖ Inspect: Rust Module Tree",    
            id: "module_tree",
            action: Box::new(print_module_tree)    
        },
        CliAction {    
            key: 'R',    
            label: "‚ö†Ô∏è Run: Trailkeeper Scan (TODO)",    
            id: "trailkeeper_scan",
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented."))    
        },
        CliAction { key: 'E', label: "‚úÖ Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}

pub fn print_menu(menu: &[CliAction]) {
    println!("\nüß≠ SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}

// --- END: rust/ssxl_cli/src\cli_util_menu.rs ---
        92 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
// ============================================================================
// üß≠ SSXL-ext CLI Developer Console (`ssxl_cli::main`)
// ----------------------------------------------------------------------------
// This module is the main entry point for the interactive developer console
// of the SSXL-ext engine. It orchestrates initialization, logging, FFI runtime
// setup, menu construction, and the interactive loop that allows developers
// to run validation tests, benchmarks, and inspection utilities.
//
// Purpose:
//   ‚Ä¢ Provide a unified, interactive interface for developers to control and
//     validate the SSXL engine from the command line.
//   ‚Ä¢ Simplify workflows by centralizing access to tests, benchmarks, and
//     external Godot integration tools.
//   ‚Ä¢ Ensure critical initialization steps (logging, FFI runtime, DLL copy)
//     are performed before any developer actions are executed.
//
// Key Components:
//   ‚Ä¢ Module Imports
//       - `actions`: Core functions for tests, benchmarks, and Godot interaction.
//       - `cli_util_inspect`: Utilities for scanning the Rust workspace and API surface.
//       - `cli_util_menu`: Menu structure and display logic (public for reuse).
//       - `cli_util_bench`: Benchmark and generation workload utilities.
//       - `cli_util_loc`: LOC (Lines of Code) analysis utilities.
//
//   ‚Ä¢ wait_for_enter
//       - Pauses execution until the user presses Enter.
//       - Used to provide acknowledgment before returning to the main menu.
//
//   ‚Ä¢ init_logging_and_engine
//       - Configures the tracing/logging system with INFO-level output.
//       - Initializes the SSXL engine core via FFI (`ssxl_start_runtime`).
//       - Ensures the latest compiled DLL is copied into the Godot tester project.
//
//   ‚Ä¢ main
//       - Performs initialization (logging, FFI, DLL copy).
//       - Declares symbolic references to FFI functions to ensure linker inclusion.
//       - Runs a LOC scan at startup for visibility into codebase size.
//       - Prints ASCII art banner to signal console readiness.
//       - Builds the menu structure via `build_menu`.
//       - Enters the main interactive loop:
//           1. Displays menu options.
//           2. Polls for key events using `crossterm`.
//           3. Debounces input to prevent repeated triggers.
//           4. Executes the selected action closure.
//           5. Waits for user acknowledgment before returning to menu.
//           6. Exits gracefully when the 'E' key is pressed.
//
// Workflow:
//   1. Initialize logging and engine runtime.
//   2. Copy DLL into Godot tester project.
//   3. Perform LOC scan and print startup banner.
//   4. Build and display the interactive menu.
//   5. Await user input and execute corresponding actions.
//   6. Continue until exit key is pressed.
//
// Design Choices:
//   ‚Ä¢ `tracing` and `tracing_subscriber` provide structured, leveled logging.
//   ‚Ä¢ `crossterm` enables cross-platform key event polling for interactive input.
//   ‚Ä¢ Input debouncing ensures smooth user experience without repeated triggers.
//   ‚Ä¢ Modular design separates concerns: actions, benchmarks, inspection, menu,
//     and LOC utilities are imported and orchestrated here.
//   ‚Ä¢ ASCII art banner provides a friendly, recognizable startup signal.
//
// Educational Note:
//   ‚Ä¢ This module demonstrates how Rust can be used to build an interactive,
//     developer-focused CLI with structured logging, FFI integration, and
//     modular action orchestration.
//   ‚Ä¢ By centralizing initialization and menu-driven workflows, developers gain
//     a predictable and ergonomic interface for testing and debugging the SSXL engine.
// ============================================================================


mod actions;
mod cli_util_inspect;
pub mod cli_util_menu;
mod cli_util_bench;
mod cli_util_loc;

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_shared::ssxl_start_runtime;
use crate::cli_util_loc::scan_and_report_loc;
use crate::actions::copy_dll_to_tester_project_at_boot;

fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

fn init_logging_and_engine() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    if ssxl_start_runtime() {
        info!("Engine FFI core initialized.");
    } else {
        error!("Failed to initialize Engine FFI core.");
    }
    
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    init_logging_and_engine();
    
    extern "C" {
        fn ssxl_set_cell(x: i32, y: i32, tile_id: i32);
        fn ssxl_notify_tilemap_update();
    }

    let _ = ssxl_set_cell as *const ();
    let _ = ssxl_notify_tilemap_update as *const ();
    
    scan_and_report_loc();
    
    println!(
        r#"
                (__)      
                (oo)
          /------\/
         / |    ||
        * ||----||
          ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    let menu = build_menu();
    let mut last_keys = HashSet::new();

    loop {
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                (item.action)();

                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return;
                                }

                                wait_for_enter();
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}

// --- END: rust/ssxl_cli/src\main.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("üåô Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("üßø Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("‚ö†Ô∏è No idle method found. Skipping ticker.")

func start_idle():
    print("ü™∂ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("‚ö° Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("üß∫ Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("üåÄ SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("‚ú® SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("‚ö†Ô∏è SSXL instance missing 'enter_idle' method.")
            else:
                push_error("‚ùå Failed to instantiate SSXL script.")
        else:
            push_error("‚ùå Invalid script resource at: %s" % script_path)
    else:
        push_error("‚ùå SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("üßπ SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("üß∫ SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("üåô SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("üßø Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("‚ö†Ô∏è No idle method found. Skipping ticker.")

func start_idle():
    print("ü™∂ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("‚ö° SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("üß∫ SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## üß≠ NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## ‚öôÔ∏è CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## üîó LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("‚ùå CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("‚úÖ Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## ‚å®Ô∏è INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## üñºÔ∏è CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## üì° PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("‚ö†Ô∏è Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("‚û°Ô∏è Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("‚û°Ô∏è Switched to Camera 2 (Map View).")
	else:
		push_warning("‚ö†Ô∏è Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED ‚Üí (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid ‚Äî cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature ‚Äî set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated ‚Üí", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error ‚Üí", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated ‚Üí (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete ‚Üí", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine ‚Üí Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine ‚Üí SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle ‚Üí Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected ‚Üí", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected ‚Üí", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("‚ùå FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "‚ùå CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("‚öôÔ∏è FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "üïí " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # ‚Üê THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # ‚Üê Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # ‚Üê Chunk data holder

# Old reference ‚Äî we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX ‚Äî only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready ‚Üí CONNECTED (first time)")
		else:
			print("chunk_data_ready ‚Üí already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\nüé∂ Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("‚ùå Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("‚ùå Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\nüìú Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd ‚Äî FINAL VERSION (2025 SSXL FFI Sync) ‚Äî RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle ‚Üí Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle ‚Üí Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine ‚Üí SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing ‚Äî no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED ‚Äî EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready ‚Üí tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready ‚Üí _on_chunk_data_ready CONNECTED ‚Äî RENDERING ENABLED")
		else:
			print("chunk_data_ready ‚Üí already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd ‚Äî Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("üì¢ SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("‚ùå FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("üì¢ SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("‚úÖ SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("‚úÖ GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("‚ùå GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("‚úÖ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("‚ùå FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
       4422 LOC | *.rs (Rust Total)
       961 LOC | *.gd (GDScript Total)
       5383 LOC | TOTALS
