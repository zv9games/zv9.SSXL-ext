>>> FILE START: rust\ssxl_generate\Cargo.toml (25 LOC) <<<
[package]
name = "ssxl_generate"
version = "0.9.1"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES (Foundation Layer) ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math   = { path = "../ssxl_math" }
ssxl_sync   = { path = "../ssxl_sync" }
ssxl_tools = { path = "../ssxl_tools" }
ssxl_cache  = { path = "../ssxl_cache" }

# --- EXTERNAL DEPENDENCIES (Core Computation) ---
# For parallel execution of generation algorithms
rayon            = { workspace = true }
# Core randomness library
rand             = { workspace = true }
# Used for saving/loading bitmap images (optional textures/noise visualizations)
image            = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing          = { workspace = true }
tokio            = { workspace = true }
noise            = { workspace = true }
glam             = { workspace = true }
fastrand = { workspace = true }
num_cpus = { workspace = true }


<<< FILE END: rust\ssxl_generate\Cargo.toml >>>

>>> FILE START: rust\ssxl_generate\src\lib.rs (99 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: the fundamental data structure representing a fully generated chunk.
// Vec2i: 2D integer vector type for chunk coordinates.
// info!, error!: logging macros for structured runtime output.
// mem: provides utilities for memory management (e.g., forgetting values).
use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;
use tracing::{info, error};
use std::mem;

// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// These modules organize the engine into distinct subsystems:
//   - ca: cellular automata generators.
//   - conductor: orchestrates generation tasks and runtime.
//   - manager: registry and configuration validation for generators.
//   - perlin: Perlin noise generator implementation.
//   - task: task queue, batch processor, benchmarking logic.
pub mod ca;
pub mod conductor;
pub mod manager;
pub mod perlin;
pub mod task;

// -----------------------------------------------------------------------------
// Trait: Generator
// -----------------------------------------------------------------------------
// Defines the contract for all procedural generation algorithms.
// Any generator (Perlin, Cellular Automata, etc.) must implement this trait.
//
// Methods:
//   - id(): returns a unique identifier string for the generator.
//   - generate_chunk(): generates a chunk of terrain at given coordinates.
pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

// -----------------------------------------------------------------------------
// Re-exports: Generators
// -----------------------------------------------------------------------------
// Re-export concrete generator implementations so they can be accessed directly
// from the crate root without drilling into submodules.
pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

// -----------------------------------------------------------------------------
// Re-exports: Conductor and Config
// -----------------------------------------------------------------------------
// Conductor: orchestrates generator execution, task queue, and runtime lifecycle.
// GeneratorConfig: validates map dimensions and generator settings.
pub use conductor::conductor::Conductor;
pub use manager::config_validator::GeneratorConfig;

// -----------------------------------------------------------------------------
// Re-exports: Conductor Sync Interfaces
// -----------------------------------------------------------------------------
// ConductorProgressReceiver: channel receiver for progress updates.
// ConductorRequestSender: channel sender for generation requests.
pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;

// -----------------------------------------------------------------------------
// Re-exports: Task Interfaces
// -----------------------------------------------------------------------------
// GenerationTask: represents a single chunk generation request.
// benchmark_generation_workload: benchmarking utility for simulating workloads.
pub use task::task_queue::GenerationTask;
pub use task::benchmark_logic::benchmark_generation_workload;

// -----------------------------------------------------------------------------
// Function: start_runtime_placeholder
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a placeholder entry point for testing runtime initialization.
//   - Demonstrates how to create a Conductor and immediately tear it down.
//
// Steps:
//   1. Attempt to create a new Conductor with no configuration (None).
//   2. If successful:
//        a. Log that runtime was created.
//        b. Forget the progress_receiver (to avoid drop/shutdown side effects).
//        c. Call graceful_teardown() on the Conductor.
//   3. If failed:
//        a. Log error with failure details.
pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _request_sender, progress_receiver)) => {
            // Step 2a: Log successful runtime creation.
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Step 2b: Forget progress_receiver to prevent automatic drop behavior.
            mem::forget(progress_receiver);
            
            // Step 2c: Gracefully shut down the conductor.
            conductor.graceful_teardown();
        }
        Err(e) => {
            // Step 3a: Log error if runtime initialization fails.
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}

<<< FILE END: rust\ssxl_generate\src\lib.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\cellular_automata_generator.rs (175 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

use crate::Generator;                         // Trait: defines the generator API contract.
use ssxl_math::prelude::Vec2i;                // Vec2i: integer 2D vector type for chunk coordinates.
use fastrand;                                 // Fast, lightweight PRNG for deterministic seeding.
use ssxl_shared::{
    ChunkData,                                // Struct: holds all tile data for a chunk.
    CHUNK_SIZE,                               // Constant: defines chunk dimensions (e.g., 16x16).
    GridBounds,                               // Struct: defines world-space boundaries of a chunk.
    TileData,                                 // Struct: represents a single tile’s data (type + noise).
    TileType,                                 // Enum: defines tile types (Rock, Void, etc.).
};
use tracing::{info, warn};                    // Logging macros for structured runtime output.

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
// RULE_SOLID, RULE_CHECKERBOARD: constants for static rulesets.
// get_next_tile_type: function that applies CA rules to determine next tile type.

use crate::ca::neighbor_check::count_live_neighbors;
// Function: counts how many neighboring tiles are "alive" (Rock) for CA rules.

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const CA_ITERATIONS: u8 = 4;                  // Number of CA iterations to stabilize the pattern.
const INITIAL_FILL_PERCENT: u8 = 45;          // Initial percentage of tiles seeded as Rock.

// -----------------------------------------------------------------------------
// Struct: CellularAutomataGenerator
// -----------------------------------------------------------------------------

pub struct CellularAutomataGenerator {
    ruleset: u8,                              // Numeric ID for which ruleset to apply.
}

impl CellularAutomataGenerator {
    // Constructor: create a new generator with a given ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// -----------------------------------------------------------------------------
// Helper Function: generate_static_pattern
// -----------------------------------------------------------------------------
// Generates non-iterative static patterns (Solid fill or Checkerboard).
// Bypasses CA simulation entirely for efficiency.
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;

    // Compute world-space boundaries for this chunk.
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;

    // Unique chunk ID: combine x and y into a 64-bit integer.
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

    // Define bounding box for the chunk.
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );

    // Dimension name based on ruleset.
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };

    // Initialize chunk data.
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

    // Temporary vector to hold tile states before inserting into fixed-size array.
    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    // Fill tiles according to ruleset.
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    if (x + y) % 2 == 0 { TileType::Rock } else { TileType::Void }
                }
                _ => TileType::Void,
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    // Insert tiles into chunk data.
    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

// -----------------------------------------------------------------------------
// Helper Function: run_ca_simulation
// -----------------------------------------------------------------------------
// Runs iterative Cellular Automata simulation using double-buffering.
// Reads from source buffer, writes to target buffer, then swaps.
fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    // Clone initial tile state into target buffer.
    let mut target_tiles = chunk_data.tiles.clone();

    // Perform CA iterations.
    for i in 0..CA_ITERATIONS {
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;

                // Current tile from source buffer.
                let current_tile = &chunk_data.tiles[index];

                // Count live neighbors.
                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                // Apply ruleset to determine next tile type.
                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                // Write new tile into target buffer.
                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }

        // Swap source and target buffers (O(1) pointer swap).
        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        info!("CA Generator: Iteration {} complete.", i + 1);
    }

    // Final state resides in chunk_data.tiles.
    chunk_data
}

// -----------------------------------------------------------------------------
// Trait Implementation: Generator
// -----------------------------------------------------------------------------
// Implements the Generator trait for CellularAutomataGenerator.
// Provides ID and chunk generation logic.
impl Generator for CellularAutomataGenerator {
    // Return string identifier for this generator.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    // Generate a chunk at given coordinates.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns directly.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // Seed PRNG deterministically based on chunk coordinates.
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);

        // Compute world-space boundaries and chunk ID.
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        // Initialize chunk data.
        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Build initial randomized tile state.
        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;
            let tile_type = if is_rock { TileType::Rock } else { TileType::Void };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles_vec);

        // Run CA simulation to evolve chunk state.
        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}

<<< FILE END: rust\ssxl_generate\src\ca\cellular_automata_generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\mod.rs (41 LOC) <<<
// -----------------------------------------------------------------------------
// Cellular Automata Module Declaration
// -----------------------------------------------------------------------------
// This file (`mod.rs`) acts as the entry point for the `ca` module in your
// project. It organizes and exposes submodules that implement different parts
// of the Cellular Automata (CA) generation system. By declaring them here,
// other parts of the crate can access them via `crate::ca::<submodule>`.

// -----------------------------------------------------------------------------
// Submodule: cellular_automata_generator
// -----------------------------------------------------------------------------
// Contains the main generator struct (`CellularAutomataGenerator`) and its
// implementation of the `Generator` trait. This is the high-level orchestrator
// that:
//   - Seeds chunks with initial random tile states.
//   - Runs CA iterations to evolve those states.
//   - Produces final `ChunkData` ready for use in the engine.
// Essentially, this is the "front door" for CA-based generation.
pub mod cellular_automata_generator;

// -----------------------------------------------------------------------------
// Submodule: rule_set
// -----------------------------------------------------------------------------
// Defines the specific Cellular Automata rulesets (e.g., Survival/Birth rules).
// Examples include:
//   - RULE_SOLID: fills all tiles with Rock.
//   - RULE_CHECKERBOARD: alternates Rock/Void tiles.
//   - RULE_BASIC_CAVE: cave-like generation rules.
//   - RULE_MAZE: maze/dungeon-like rules.
// This module abstracts the logic for determining the next tile type given
// the current state and neighbor counts, making it easy to swap or experiment
// with different rule sets.
pub mod rule_set;

// -----------------------------------------------------------------------------
// Submodule: neighbor_check
// -----------------------------------------------------------------------------
// Provides low-level functions for inspecting a tile’s neighbors in the grid.
// Example: `count_live_neighbors` counts how many adjacent tiles are Rock.
// This is the "microscope" of the CA system, feeding local state into the
// rule_set logic. By separating neighbor checks from rule application, you
// keep the design modular and easier to extend (e.g., different neighborhood
// definitions like Moore vs. Von Neumann).
pub mod neighbor_check;

<<< FILE END: rust\ssxl_generate\src\ca\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\neighbor_check.rs (60 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: holds all tile data for a chunk.
// CHUNK_SIZE: constant defining the width/height of a chunk (e.g., 16).
// TileType: enum representing tile states (Rock, Void, etc.).
use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

// -----------------------------------------------------------------------------
// Function: count_live_neighbors
// -----------------------------------------------------------------------------
// Purpose:
//   - Counts how many neighboring tiles around a given cell are "live"
//     (defined here as TileType::Rock).
//   - Uses a 3x3 Moore neighborhood (the 8 surrounding cells).
//   - Handles boundary conditions to avoid indexing outside the chunk.
//
// Arguments:
//   - chunk_data: reference to the chunk’s tile data.
//   - cx: X coordinate of the center cell (0..CHUNK_SIZE-1).
//   - cy: Y coordinate of the center cell (0..CHUNK_SIZE-1).
//
// Returns:
//   - u8 count of live neighbors (0–8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    // Initialize neighbor count.
    let mut count = 0;

    // Cache chunk size as i32 for safe signed arithmetic.
    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    // Convert center coordinates to i32 for arithmetic with dx/dy offsets.
    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    // Iterate over relative offsets in the 3x3 neighborhood.
    // dx, dy range from -1 to +1.
    for dx in -1..=1 {
        for dy in -1..=1 {
            // Skip the center cell itself.
            if dx == 0 && dy == 0 {
                continue;
            }

            // Compute neighbor coordinates.
            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            // Boundary check: ensure neighbor is inside chunk bounds.
            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                // Safe to cast back to u32 for indexing.
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;

                // Compute linear index into tiles array.
                // Formula: index = y * CHUNK_SIZE + x
                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                // Check if neighbor tile is "live" (Rock).
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }

    // Return total live neighbor count.
    count
}

<<< FILE END: rust\ssxl_generate\src\ca\neighbor_check.rs >>>

>>> FILE START: rust\ssxl_generate\src\ca\rule_set.rs (78 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// TileType: Enum representing the type of a tile (e.g., Rock, Void, Water, Ore).
// This is the fundamental state that Cellular Automata rules will evolve.
use ssxl_shared::TileType;

// -----------------------------------------------------------------------------
// Rule Set Identifiers
// -----------------------------------------------------------------------------
// These constants define which ruleset to apply when running the CA simulation.
// Each ruleset corresponds to a different "Birth/Survival" (B/S) configuration.
//
// RULE_BASIC_CAVE: Standard cave-like generation rules.
// RULE_MAZE: Maze/dungeon-like rules.
// RULE_SOLID: Static rule that fills everything with Rock.
// RULE_CHECKERBOARD: Static rule that alternates Rock/Void in a checkerboard pattern.
pub const RULE_BASIC_CAVE: u8 = 0;
pub const RULE_MAZE: u8 = 1;
pub const RULE_SOLID: u8 = 2;
pub const RULE_CHECKERBOARD: u8 = 3;

// -----------------------------------------------------------------------------
// Function: get_next_tile_type
// -----------------------------------------------------------------------------
// Purpose:
//   - Determines the next state of a tile (Rock or Void) based on:
//       1. Its current state.
//       2. The number of live neighbors (Rock tiles).
//       3. The chosen ruleset.
//
// Arguments:
//   - current_type: The tile’s current state (TileType).
//   - live_neighbors: Number of Rock neighbors (0–8).
//   - ruleset: Identifier for which ruleset to apply.
//
// Returns:
//   - The tile’s next state (TileType).
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    // -------------------------------------------------------------------------
    // Define Birth and Survival ranges based on ruleset.
    // -------------------------------------------------------------------------
    // Birth (B): A Void tile becomes Rock if neighbor count is within [birth_min, birth_max].
    // Survival (S): A Rock tile stays Rock if neighbor count is within [survive_min, survive_max].
    //
    // RULE_MAZE → B3/S1-4: Creates thin, winding corridors.
    // RULE_BASIC_CAVE → B4-5/S1-7: Creates large, open cave-like spaces.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),           // Maze ruleset: strict birth, narrow survival.
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // Cave ruleset: broader birth/survival ranges.
    };

    // -------------------------------------------------------------------------
    // Apply rules based on current tile type.
    // -------------------------------------------------------------------------
    match current_type {
        // Case 1: Tile is currently Rock (alive).
        TileType::Rock => {
            // Survival check: Rock survives if neighbor count is within survival range.
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                // Otherwise, Rock dies → becomes Void.
                TileType::Void
            }
        }

        // Case 2: Tile is currently Void (dead).
        TileType::Void => {
            // Birth check: Void becomes Rock if neighbor count is within birth range.
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                // Otherwise, Void remains Void.
                TileType::Void
            }
        }

        // Case 3: Any other TileType (e.g., Water, Ore).
        // These are not part of the CA simulation, so leave them unchanged.
        _ => current_type,
    }
}

<<< FILE END: rust\ssxl_generate\src\ca\rule_set.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\builder.rs (144 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Bring in conductor state and Conductor struct from the parent module.
use super::{conductor_state, Conductor};
// Internal setup struct that bundles channels, managers, and initial state.
use super::internal_setup::ConductorInternalSetup; 

// GeneratorManager: manages available generators.
// RuntimeManager: manages async runtime for request loop.
use crate::manager::{GeneratorManager, RuntimeManager};
// Task system: start_request_loop runs the async loop,
// GenerationMessage is the progress update type,
// GenerationTask (aliased as ChunkRequest) represents a single chunk generation request.
use crate::task::{start_request_loop, GenerationMessage, GenerationTask as ChunkRequest};
// ChunkCache: LRU cache for storing generated chunks.
use ssxl_cache::ChunkCache;
// Config loader: retrieves configuration from a file path.
use ssxl_shared::config::config::get_config_from_path;
// Tokio channels: async communication primitives.
use tokio::sync::mpsc::{self, Receiver, UnboundedSender};
// Logging macros.
use tracing::info;
// Standard library imports.
use std::io;
use std::sync::Arc;

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// Defines the bounded capacity for the progress channel.
// This limits how many progress messages can be queued before backpressure applies.
const PROGRESS_CHANNEL_BOUND: usize = 1024;

// -----------------------------------------------------------------------------
// Function: setup_channels_and_state
// -----------------------------------------------------------------------------
// Purpose:
//   - Initializes configuration, generator manager, channels, and conductor state.
//   - Returns a ConductorInternalSetup bundle for later spawning.
//
// Arguments:
//   - config_path: optional path to configuration file.
//
// Returns:
//   - ConductorInternalSetup on success.
//   - io::Error on failure.
pub(crate) fn setup_channels_and_state(
    config_path: Option<&str>,
) -> Result<ConductorInternalSetup, io::Error> {
    // Load configuration from path (or defaults).
    let config = get_config_from_path(config_path);

    // Initialize generator manager, mapping errors into io::Error.
    let generator_manager = GeneratorManager::new().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
    })?;

    // Create bounded progress channel for generation updates.
    let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
    // Create unbounded request channel for chunk generation tasks.
    let (request_sender_api, request_receiver) = mpsc::unbounded_channel();

    // Determine initial generator ID from config.
    let initial_id = generator_manager.get_initial_id(&config.default_generator_id());
    // Create initial conductor state with that ID.
    let initial_state = conductor_state::ConductorState::new(initial_id.clone());

    // Log initialization.
    info!("Conductor initialized. Active generator: {}", initial_id);

    // Bundle everything into ConductorInternalSetup for later use.
    Ok(ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    })
}

// -----------------------------------------------------------------------------
// Function: spawn
// -----------------------------------------------------------------------------
// Purpose:
//   - Consumes ConductorInternalSetup and spawns the async request loop.
//   - Returns a fully constructed Conductor instance, its state, and channel handles.
//
// Arguments:
//   - internal_setup: previously prepared setup bundle.
//
// Returns:
//   - Tuple: (Conductor, ConductorState, request sender, progress receiver).
//   - io::Error on failure.
pub(crate) fn spawn(
    internal_setup: ConductorInternalSetup,
) -> Result<
    (
        Conductor,
        conductor_state::ConductorState,
        UnboundedSender<ChunkRequest>,
        Receiver<GenerationMessage>,
    ),
    io::Error,
> {
    // Destructure setup bundle into components.
    let ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    } = internal_setup;

    // Create runtime manager (Tokio runtime wrapper).
    let runtime_manager = RuntimeManager::new()?;
    let handle = runtime_manager.get_handle();

    // Clone generator map for use inside async loop.
    let generators_for_loop = Arc::new(generator_manager.get_map_clone());
    // Create chunk cache with capacity 4096.
    let chunk_cache = Arc::new(ChunkCache::new(4096)?);
    let chunk_cache_for_loop = chunk_cache.clone();

    // Mark conductor state as running.
    initial_state.set_status(conductor_state::ConductorStatus::Running);
    let state_for_loop = initial_state.clone();

    // Start async request loop:
    //   - handle: runtime handle.
    //   - request_receiver: receives chunk generation tasks.
    //   - progress_sender: sends progress updates.
    //   - generators_for_loop: available generators.
    //   - chunk_cache_for_loop: cache for generated chunks.
    //   - state_for_loop: conductor state shared with loop.
    start_request_loop(
        handle,
        request_receiver,
        progress_sender.clone(),
        generators_for_loop,
        chunk_cache_for_loop,
        Arc::new(state_for_loop),
    );

    // Construct Conductor instance with runtime, managers, state, cache, and channels.
    let conductor = Conductor {
        runtime_manager,
        generator_manager,
        internal_state: initial_state.clone(),
        chunk_cache,
        progress_sender,
        _request_sender: request_sender_api.clone(),
    };

    // Return conductor, state, request sender, and progress receiver.
    Ok((conductor, initial_state, request_sender_api, progress_receiver))
}

<<< FILE END: rust\ssxl_generate\src\conductor\builder.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\conductor.rs (150 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Brings in setup and spawn functions from the builder module.
// These functions initialize channels, state, and spawn the conductor loop.
use crate::conductor::builder::{setup_channels_and_state, spawn};

use ssxl_cache::ChunkCache; // Cache for storing generated chunks.
use ssxl_shared::message::{GenerationCommand, GenerationResponse}; 
// Messages used for FFI (Foreign Function Interface) integration.
// GenerationCommand: requests from external systems.
// GenerationResponse: responses back to external systems.

use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver};
// Async channels for communication between tasks.
// - UnboundedSender/Receiver: unlimited capacity channels.
// - Receiver: bounded channel for progress updates.

use tracing::info; // Logging macro for structured runtime output.
use std::error::Error; // Trait for error handling.
use std::io; // Standard I/O error type.
use std::sync::Arc; // Thread-safe reference-counted pointer for shared ownership.

use crate::manager::runtime_manager::RuntimeManager; // Manages async runtime.
use crate::manager::generator_manager::GeneratorManager; // Manages available generators.
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
// ChunkRequest: represents a single chunk generation task.
// GenerationMessage: progress updates from generation tasks.

use crate::conductor::conductor_state::{self, ConductorState};
// ConductorState: tracks conductor’s current status and active generator.

// -----------------------------------------------------------------------------
// Struct: Conductor
// -----------------------------------------------------------------------------
// The central orchestrator for chunk generation.
// Holds runtime, generator manager, state, cache, and communication channels.
pub struct Conductor {
    pub(crate) runtime_manager: RuntimeManager,          // Async runtime manager.
    pub(crate) generator_manager: GeneratorManager,      // Manages generator instances.
    pub(crate) internal_state: conductor_state::ConductorState, // Tracks conductor status.
    pub(crate) chunk_cache: Arc<ChunkCache>,             // Shared cache for generated chunks.
    pub progress_sender: tokio::sync::mpsc::Sender<GenerationMessage>, // Sends progress updates.
    #[allow(dead_code)]
    pub(crate) _request_sender: UnboundedSender<ChunkRequest>, // Sends chunk generation requests.
}

// -----------------------------------------------------------------------------
// Implementation: Conductor
// -----------------------------------------------------------------------------
impl Conductor {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new Conductor instance with channels and state initialized.
    // Returns:
    //   - Conductor instance
    //   - ConductorState
    //   - Request sender (for chunk tasks)
    //   - Progress receiver (for updates)
    pub fn new(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<ChunkRequest>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?; // Prepare setup bundle.
        spawn(setup) // Spawn conductor loop and return tuple.
    }

    // -------------------------------------------------------------------------
    // Constructor: new_for_ffi
    // -------------------------------------------------------------------------
    // Specialized constructor for FFI (external bindings).
    // Returns:
    //   - Conductor instance
    //   - ConductorState
    //   - Command sender (external requests)
    //   - Response receiver (external responses)
    //   - Progress receiver (generation updates)
    pub fn new_for_ffi(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<GenerationCommand>,
            UnboundedReceiver<GenerationResponse>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        let (conductor, state, _req_tx, progress_rx) = spawn(setup)?;
        // Create external command/response channels.
        let (cmd_tx, _) = tokio::sync::mpsc::unbounded_channel();
        let (_, resp_rx) = tokio::sync::mpsc::unbounded_channel();
        Ok((conductor, state, cmd_tx, resp_rx, progress_rx))
    }

    // -------------------------------------------------------------------------
    // Getter: get_active_generator_id
    // -------------------------------------------------------------------------
    // Returns the ID of the currently active generator.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    // -------------------------------------------------------------------------
    // Setter: set_generator
    // -------------------------------------------------------------------------
    // Switches the active generator to a new ID.
    // Logs the change and updates internal state.
    pub fn set_generator(&mut self, id: &str) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_active_generator_id(id);
        info!("Active generator switched to: {}", id);
        Ok(())
    }

    // -------------------------------------------------------------------------
    // Control: stop_generation
    // -------------------------------------------------------------------------
    // Signals the conductor to stop generation tasks.
    // Updates state to "Stopping" and logs the request.
    pub fn stop_generation(&self) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Global stop requested.");
        Ok(())
    }

    // -------------------------------------------------------------------------
    // Control: graceful_teardown
    // -------------------------------------------------------------------------
    // Consumes the Conductor instance and shuts down gracefully.
    // Updates state to "ShuttingDown" and stops runtime.
    pub fn graceful_teardown(self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
        self.runtime_manager.shutdown_graceful();
        info!("Conductor gracefully shut down.");
    }

    // -------------------------------------------------------------------------
    // Control: signal_shutdown_graceful
    // -------------------------------------------------------------------------
    // Signals shutdown without consuming the Conductor.
    // Updates state to "ShuttingDown".
    pub fn signal_shutdown_graceful(&self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    // -------------------------------------------------------------------------
    // Control: request_shutdown
    // -------------------------------------------------------------------------
    // Requests shutdown by signaling and stopping runtime.
    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
    }
}

<<< FILE END: rust\ssxl_generate\src\conductor\conductor.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\conductor_state.rs (134 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Arc: thread-safe reference-counted pointer for shared ownership across threads.
// AtomicUsize, AtomicU64: atomic counters for safe concurrent mutation.
// Ordering: defines memory ordering semantics for atomic operations.
// AtomicResource: custom wrapper (from ssxl_sync) for atomic read/write of complex types.
use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

// -----------------------------------------------------------------------------
// Enum: ConductorStatus
// -----------------------------------------------------------------------------
// Represents the lifecycle state of the Conductor.
// Each variant corresponds to a distinct operational phase.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,   // Conductor is starting up.
    Running,        // Actively processing tasks.
    Paused,         // Temporarily halted but can resume.
    Generating,     // Actively generating chunks.
    Stopping,       // Graceful stop requested.
    ShuttingDown,   // Final shutdown in progress.
    Error,          // Fault state encountered.
}

// -----------------------------------------------------------------------------
// Struct: ConductorState
// -----------------------------------------------------------------------------
// Holds shared, thread-safe state for the Conductor.
// Designed for concurrent access across async tasks and threads.
#[derive(Clone)]
pub struct ConductorState {
    // Current status of the conductor (Initializing, Running, etc.).
    status: AtomicResource<ConductorStatus>,
    // Depth of the request queue (number of pending tasks).
    queue_depth: Arc<AtomicUsize>,
    // ID of the currently active generator.
    active_generator_id: AtomicResource<String>,
    // Counter for total tiles placed/generated.
    tile_counter: Arc<AtomicU64>,
}

// -----------------------------------------------------------------------------
// Implementation: ConductorState
// -----------------------------------------------------------------------------
impl ConductorState {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new ConductorState with default values.
    // - Status: Initializing
    // - Queue depth: 0
    // - Active generator: provided ID
    // - Tile counter: 0
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: AtomicResource::new(ConductorStatus::Initializing),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: AtomicResource::new(initial_generator_id),
            tile_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    // -------------------------------------------------------------------------
    // Getter: get_status
    // -------------------------------------------------------------------------
    // Returns the current conductor status.
    pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
    }
    
    // -------------------------------------------------------------------------
    // Helper: is_active
    // -------------------------------------------------------------------------
    // Returns true if conductor is in an "active" state (Running or Generating).
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    // -------------------------------------------------------------------------
    // Getter: get_queue_depth
    // -------------------------------------------------------------------------
    // Returns the number of tasks currently in the queue.
    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    // -------------------------------------------------------------------------
    // Getter: get_tiles_placed
    // -------------------------------------------------------------------------
    // Returns the total number of tiles placed/generated so far.
    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    // -------------------------------------------------------------------------
    // Getter: get_active_generator_id
    // -------------------------------------------------------------------------
    // Returns the ID of the currently active generator.
    pub fn get_active_generator_id(&self) -> String {
        self.active_generator_id.read().clone()
    }

    // -------------------------------------------------------------------------
    // Mutator: increment_queue_depth
    // -------------------------------------------------------------------------
    // Increases queue depth by 1 (new task added).
    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    // -------------------------------------------------------------------------
    // Mutator: decrement_queue_depth
    // -------------------------------------------------------------------------
    // Decreases queue depth by 1 (task completed).
    pub fn decrement_queue_depth(&self) {
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    // -------------------------------------------------------------------------
    // Mutator: increment_tile_count
    // -------------------------------------------------------------------------
    // Increases tile counter by a specified amount.
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    // -------------------------------------------------------------------------
    // Mutator: set_status
    // -------------------------------------------------------------------------
    // Updates conductor status to a new value.
    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
    }

    // -------------------------------------------------------------------------
    // Mutator: set_active_generator_id
    // -------------------------------------------------------------------------
    // Updates the active generator ID.
    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
    }
}

<<< FILE END: rust\ssxl_generate\src\conductor\conductor_state.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\internal_setup.rs (46 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ConductorState: Tracks the conductor’s lifecycle state (Running, Stopping, etc.),
// queue depth, active generator ID, and tile counters.
use crate::conductor::conductor_state::ConductorState;

// GeneratorManager: Manages all available generator instances and provides
// access to their configuration and execution logic.
use crate::manager::generator_manager::GeneratorManager;

// GenerationTask (aliased as ChunkRequest): Represents a single chunk generation request.
// GenerationMessage: Represents progress updates or results from generation tasks.
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};

// Tokio channels for async communication between tasks:
// - UnboundedReceiver: receives messages from an unbounded channel.
// - UnboundedSender: sends messages into an unbounded channel.
// - Receiver: bounded channel receiver.
// - Sender: bounded channel sender.
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver, Sender};

// -----------------------------------------------------------------------------
// Struct: ConductorInternalSetup
// -----------------------------------------------------------------------------
// This struct bundles together all the internal components needed to initialize
// and run the Conductor. It acts as a "setup package" that can be passed around
// between modules to ensure consistent initialization.
//
// Fields:
//   - request_receiver: Receives chunk generation requests from the API.
//   - progress_sender: Sends progress updates into the bounded channel.
//   - request_sender_api: Exposed sender for external modules to submit requests.
//   - progress_receiver: Receives progress updates for monitoring or reporting.
//   - initial_state: Tracks conductor’s current status and metadata.
//   - generator_manager: Manages generator instances and their configurations.
pub(crate) struct ConductorInternalSetup {
    // Channel receiver for incoming chunk generation requests.
    pub request_receiver: UnboundedReceiver<ChunkRequest>,

    // Channel sender for progress updates (bounded).
    pub progress_sender: Sender<GenerationMessage>,

    // Channel sender exposed to API for submitting chunk requests.
    pub request_sender_api: UnboundedSender<ChunkRequest>,

    // Channel receiver for progress updates (bounded).
    pub progress_receiver: Receiver<GenerationMessage>,

    // Initial conductor state (status, queue depth, active generator, tile counter).
    pub initial_state: ConductorState,

    // Manager for all generator instances.
    pub generator_manager: GeneratorManager,
}

<<< FILE END: rust\ssxl_generate\src\conductor\internal_setup.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\mod.rs (33 LOC) <<<
// -----------------------------------------------------------------------------
// Module: conductor (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `conductor` module.
// It organizes submodules and re-exports key items so that other parts of the
// crate can easily access them without needing to know the internal layout.
//
// Think of this file as the "table of contents" for the conductor system.

// -----------------------------------------------------------------------------
// Submodules
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the conductor system.
// These submodules are implemented in their own files (e.g., conductor.rs,
// conductor_state.rs, builder.rs, etc.).

pub mod conductor;        // Core Conductor struct and its implementation.
pub mod conductor_state;  // Tracks conductor lifecycle state (Running, Stopping, etc.).
pub mod sync;             // Synchronization utilities for thread-safe resource sharing.
pub mod builder;          // Setup and spawn logic for initializing conductor internals.
pub mod sync_get;         // Helper functions for safely retrieving synchronized values.
pub mod internal_setup;   // Internal setup struct bundling channels, state, and managers.

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::conductor` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::conductor::conductor::Conductor;`
//   With re-export    → `use crate::conductor::Conductor;`

pub use conductor::Conductor;   // Re-export the main Conductor struct.
pub use conductor_state::*;     // Re-export all items from conductor_state (status, state struct).
pub use sync::*;                // Re-export all synchronization utilities.

<<< FILE END: rust\ssxl_generate\src\conductor\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\sync.rs (54 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Tokio async channels:
// - Receiver: bounded channel receiver, used to receive messages with backpressure.
// - UnboundedSender: unbounded channel sender, used to send requests without capacity limits.
use tokio::sync::mpsc::{Receiver, UnboundedSender};

// Task queue types:
// - GenerationMessage: represents progress updates or results from generation tasks.
// - GenerationTask: represents a single chunk generation request.
use crate::task::task_queue::GenerationMessage;
use crate::task::task_queue::GenerationTask;

// -----------------------------------------------------------------------------
// Type Alias: ConductorRequestSender
// -----------------------------------------------------------------------------
// Provides a clearer name for the type of sender used to submit generation tasks.
// Instead of writing `UnboundedSender<GenerationTask>` everywhere, we can use
// `ConductorRequestSender` to make the code more readable and domain-specific.
//
// This alias represents the channel through which new chunk generation requests
// are sent into the conductor system.
pub type ConductorRequestSender = UnboundedSender<GenerationTask>;

// -----------------------------------------------------------------------------
// Struct: ConductorProgressReceiver
// -----------------------------------------------------------------------------
// Wraps a bounded Receiver for GenerationMessage.
// This struct is a thin abstraction layer that makes it explicit that the
// receiver is specifically for conductor progress updates.
//
// Fields:
//   - rx: the underlying Receiver<GenerationMessage> channel.
pub struct ConductorProgressReceiver {
    pub rx: Receiver<GenerationMessage>,
}

// -----------------------------------------------------------------------------
// Implementation: ConductorProgressReceiver
// -----------------------------------------------------------------------------
impl ConductorProgressReceiver {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new ConductorProgressReceiver from a given Receiver<GenerationMessage>.
    // This makes it easier to wrap the raw channel in a domain-specific type,
    // clarifying its purpose in the conductor system.
    //
    // Arguments:
    //   - rx: the bounded receiver channel for progress messages.
    //
    // Returns:
    //   - ConductorProgressReceiver wrapping the provided channel.
    pub fn new(rx: Receiver<GenerationMessage>) -> Self {
        ConductorProgressReceiver { rx }
    }
}

<<< FILE END: rust\ssxl_generate\src\conductor\sync.rs >>>

>>> FILE START: rust\ssxl_generate\src\conductor\sync_get.rs (87 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Bring in the Conductor struct from the parent module.
use super::Conductor;

// Task system utilities:
// - handle_chunk_unit: function that triggers chunk generation for a given coordinate.
// - GenerationMessage: enum representing messages sent back from generation tasks
//   (e.g., Generated, Progress, Error).
use crate::task::{handle_chunk_unit, GenerationMessage};

// Vec2i: integer 2D vector type for chunk coordinates.
use ssxl_math::prelude::Vec2i;

// ChunkData: struct representing the tile data for a single chunk.
use ssxl_shared::ChunkData;

// Arc: thread-safe reference-counted pointer for shared ownership across threads.
use std::sync::Arc;

// Tokio mpsc: async channels for communication between tasks.
// Here we use a bounded channel for temporary synchronous communication.
use tokio::sync::mpsc;

// Logging macros for structured runtime output.
use tracing::{info, error};

// -----------------------------------------------------------------------------
// Implementation: Conductor
// -----------------------------------------------------------------------------
// Adds synchronous chunk retrieval capability to the Conductor.
// This is useful when a caller needs immediate access to chunk data
// without waiting for async streams.
impl Conductor {
    // -------------------------------------------------------------------------
    // Method: get_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Retrieves chunk data synchronously for the given coordinates.
    //   - Internally triggers chunk generation using handle_chunk_unit.
    //   - Blocks until a GenerationMessage::Generated is received.
    //
    // Arguments:
    //   - chunk_coords: reference to Vec2i representing chunk coordinates.
    //
    // Returns:
    //   - ChunkData: the generated or cached chunk data.
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        // Get the currently active generator ID from conductor state.
        let active_generator_id = self.internal_state.get_active_generator_id();

        // Create a temporary bounded channel (capacity = 1).
        // temp_sender: used to send back the generated chunk.
        // temp_receiver: used to receive the chunk synchronously.
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        // Wrap conductor state in Arc for safe sharing across threads/tasks.
        let state_arc = Arc::new(self.internal_state.clone());

        // Log the synchronous chunk request.
        info!("Sync chunk request: {:?}", chunk_coords);

        // Trigger chunk generation for the given coordinates.
        // handle_chunk_unit will:
        //   - Check cache.
        //   - Generate chunk if missing.
        //   - Send GenerationMessage back through temp_sender.
        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        // Enter blocking loop to wait for a GenerationMessage.
        loop {
            match temp_receiver.blocking_recv() {
                // Case 1: Received a Generated message with chunk data.
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    // Try to unwrap Arc<ChunkData> into owned ChunkData.
                    // If multiple references exist, clone the inner data.
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
                }
                // Case 2: Received some other message (e.g., Progress).
                // Ignore and continue waiting.
                Some(_) => continue,
                // Case 3: Channel closed unexpectedly.
                // Log error and return an empty fallback chunk.
                None => {
                    error!("Sync channel closed for {:?}", chunk_coords);
                    return ChunkData::new_at_coords(*chunk_coords);
                }
            }
        }
    }
}

<<< FILE END: rust\ssxl_generate\src\conductor\sync_get.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\config_validator.rs (122 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros for structured runtime output.
// - info!: used for successful validation messages.
// - error!: used for validation failure messages.
use tracing::{error, info};

// fmt: provides traits and utilities for formatting output (e.g., implementing Display).
use std::fmt;

// HashMap: used to store tile overrides keyed by coordinates.
use std::collections::HashMap;

// Import constants and types directly from the ssxl_shared crate root.
// - CHUNK_SIZE: defines the dimension of a single chunk (e.g., 16x16).
// - TileCoord: coordinate type for identifying specific tiles.
// - TileType: enum representing tile states (Rock, Void, etc.).
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// Defines the maximum number of active chunks allowed in memory.
// This prevents runaway generation requests that could exhaust resources.
const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

// -----------------------------------------------------------------------------
// Struct: GeneratorConfig
// -----------------------------------------------------------------------------
// Holds configuration parameters for a generator run.
// This struct encapsulates all the metadata needed to initialize and validate
// a generation process.
//
// Fields:
//   - width: map width in tiles.
//   - height: map height in tiles.
//   - seed: string used for deterministic random generation.
//   - generator_name: identifier for which generator to use.
//   - tile_overrides: optional overrides for specific tiles (customized map edits).
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

// -----------------------------------------------------------------------------
// Trait Implementation: Display for GeneratorConfig
// -----------------------------------------------------------------------------
// Provides a human-readable string representation of GeneratorConfig.
// Useful for logging and debugging.
impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width, 
            self.height, 
            self.seed, 
            self.generator_name,
            self.tile_overrides.len() // Only log the count of overrides, not the full map.
        )
    }
}

// -----------------------------------------------------------------------------
// Struct: ConfigValidator
// -----------------------------------------------------------------------------
// Provides validation logic for GeneratorConfig.
// Ensures map dimensions are reasonable and within system limits.
pub struct ConfigValidator;

impl ConfigValidator {
    // -------------------------------------------------------------------------
    // Method: validate_map_dimensions
    // -------------------------------------------------------------------------
    // Validates the width and height of the map in terms of chunk counts.
    //
    // Steps:
    //   1. Log the incoming config for traceability.
    //   2. Convert map dimensions and chunk size to i64 for safe arithmetic.
    //   3. Compute how many chunks wide and tall the map will be.
    //      - Uses ceiling division to ensure partial chunks are counted.
    //   4. Calculate total number of chunks.
    //   5. Validate:
    //      - Total chunks must be > 0.
    //      - Total chunks must not exceed MAX_ACTIVE_CHUNKS.
    //   6. Log success or failure and return Result accordingly.
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        // Log the config being validated.
        info!("Validating batch generation command with config: {}", config);

        // Convert constants and dimensions to i64 for arithmetic.
        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        // Ceiling division formula:
        // (dividend + divisor - 1) / divisor
        // Ensures partial chunks are counted as full.
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        // Validation 1: total chunks must be positive.
        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // Validation 2: total chunks must not exceed maximum allowed.
        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // If validations pass, log success.
        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}

<<< FILE END: rust\ssxl_generate\src\manager\config_validator.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\generator.rs (62 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: The fundamental data structure representing a fully generated chunk.
//   - Contains tile information, bounds, and metadata.
//   - This is the "output" of any generator implementation.
use ssxl_shared::ChunkData;

// Vec2i: A 2D integer vector type (x, y).
//   - Used to represent chunk coordinates in the world grid.
//   - Ensures generators are deterministic based on position.
use ssxl_math::prelude::Vec2i;

// -----------------------------------------------------------------------------
// Trait: Generator
// -----------------------------------------------------------------------------
// This trait defines the **contract** for all procedural generation algorithms
// in the SSXL engine. Any generator (e.g., Cellular Automata, Perlin Noise,
// Voronoi-based, etc.) must implement this trait to be managed by the Conductor.
//
// By enforcing a common interface, the engine can:
//   - Swap generators dynamically.
//   - Treat all generators uniformly.
//   - Maintain modularity and extensibility.
//
// The #[allow(dead_code)] attribute is applied because the trait itself may not
// be directly referenced in code, but its implementors are essential.
#[allow(dead_code)]
pub trait Generator {
    // -------------------------------------------------------------------------
    // Method: id
    // -------------------------------------------------------------------------
    // Returns a unique, static string identifier for the generator.
    //
    // Purpose:
    //   - Allows the Conductor to distinguish between different generator types.
    //   - Useful for logging, debugging, and configuration.
    //   - Should be unique across all registered generators.
    //
    // Example:
    //   - "cellular_automata_basic"
    //   - "perlin_noise"
    fn id(&self) -> &str;

    // -------------------------------------------------------------------------
    // Method: generate_chunk
    // -------------------------------------------------------------------------
    // Executes the generator’s algorithm to produce a single chunk of world data.
    //
    // Arguments:
    //   - chunk_coords: Vec2i representing the global coordinates of the chunk.
    //
    // Returns:
    //   - ChunkData: the fully generated chunk, ready for caching and use.
    //
    // Requirements:
    //   - Must be deterministic: given the same coordinates and seed, the output
    //     should always be identical.
    //   - Must be self-contained: should not rely on external mutable state.
    //
    // Example:
    //   - For a cave generator, this might run a cellular automata simulation.
    //   - For a noise generator, this might sample Perlin/Simplex noise fields.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

<<< FILE END: rust\ssxl_generate\src\manager\generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\generator_manager.rs (136 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros:
// - info!: used to log successful registration of generators.
// - warn!: used to log fallback warnings when a requested generator ID is missing.
use tracing::{info, warn};

// HashMap: used to store generator instances keyed by their unique string IDs.
// Arc: thread-safe reference-counted pointer for sharing generator instances across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: integer 2D vector type for chunk coordinates.
// ChunkData: the fundamental data structure representing a fully generated chunk.
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;

// Generator trait: defines the contract all generators must implement.
// PerlinGenerator: concrete generator based on Perlin noise.
// CellularAutomataGenerator: concrete generator based on cellular automata rules.
use crate::Generator;
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;

// Rule set constants for cellular automata generators.
// Each rule defines a different birth/survival pattern for cave/maze generation.
use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

// -----------------------------------------------------------------------------
// Type Alias: DynGenerator
// -----------------------------------------------------------------------------
// Represents a dynamically dispatched Generator trait object that is both Send + Sync.
// - Box<dyn Generator>: allows storing different generator types uniformly.
// - Send + Sync: ensures thread safety when used in async/concurrent contexts.
// - Arc<DynGenerator>: wraps each generator for shared ownership across tasks.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// -----------------------------------------------------------------------------
// Struct: GeneratorManager
// -----------------------------------------------------------------------------
// Acts as a registry for all available procedural generation algorithms.
// Responsible for:
//   - Initializing concrete generators.
//   - Storing them in a HashMap keyed by ID.
//   - Providing access to generators by ID.
//   - Executing chunk generation requests.
pub struct GeneratorManager {
    // Core registry: maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    // Default Perlin generator ID, used as fallback when config ID is invalid.
    default_perlin_id: String,
}

// -----------------------------------------------------------------------------
// Implementation: GeneratorManager
// -----------------------------------------------------------------------------
impl GeneratorManager {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Initializes all generator algorithms and registers them in the HashMap.
    // Steps:
    //   1. Create empty registry.
    //   2. Register Perlin generator (base noise layer).
    //   3. Register multiple Cellular Automata generators (structured cave/maze layers).
    //   4. Log the number of registered generators.
    // Returns:
    //   - Ok(GeneratorManager) on success.
    //   - Err(String) on failure.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // Register Perlin generator.
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // Register Cellular Automata generators with different rule sets.
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        // Log how many generators were registered.
        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    // -------------------------------------------------------------------------
    // Getter: get_map_ref
    // -------------------------------------------------------------------------
    // Returns a reference to the internal generator map.
    // Useful for quick lookups without cloning.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    // -------------------------------------------------------------------------
    // Getter: get_map_clone
    // -------------------------------------------------------------------------
    // Returns a clone of the internal generator map.
    // Useful when spawning background tasks that need ownership of the map.
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    // -------------------------------------------------------------------------
    // Method: generate_single_chunk
    // -------------------------------------------------------------------------
    // Executes the generation process for a single chunk using the specified generator ID.
    // Steps:
    //   1. Look up generator by ID in the registry.
    //   2. Panic if ID is invalid (should have been validated earlier).
    //   3. Call generator’s generate_chunk method with given coordinates.
    // Returns:
    //   - ChunkData for the requested chunk.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        generator_arc.generate_chunk(chunk_coords)
    }

    // -------------------------------------------------------------------------
    // Method: get_initial_id
    // -------------------------------------------------------------------------
    // Determines the initial active generator ID.
    // Steps:
    //   1. Check if config ID exists in registry.
    //   2. If yes, return config ID.
    //   3. If no, log warning and return default Perlin ID.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!(
                "Config default generator ID '{}' not found. Falling back to Perlin: {}",
                config_id, self.default_perlin_id
            );
            self.default_perlin_id.clone()
        }
    }
}

<<< FILE END: rust\ssxl_generate\src\manager\generator_manager.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\mod.rs (33 LOC) <<<
// -----------------------------------------------------------------------------
// Module: manager (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `manager` module.
// It organizes submodules related to configuration, generator logic,
// generator registry, and runtime management. 
//
// Think of this file as the "table of contents" for all management-related
// functionality in the SSXL engine.

// -----------------------------------------------------------------------------
// Submodules
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the manager system.
// These submodules are implemented in their own files (e.g., config_validator.rs,
// generator.rs, generator_manager.rs, runtime_manager.rs).

pub mod config_validator;     // Validates generator configuration (map dimensions, chunk limits).
pub mod generator;            // Defines the Generator trait (contract for all generation algorithms).
pub mod generator_manager;    // Registry for all available generators (Perlin, Cellular Automata, etc.).
pub mod runtime_manager;      // Manages the async runtime environment for executing generation tasks.

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::manager` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::manager::generator_manager::GeneratorManager;`
//   With re-export    → `use crate::manager::GeneratorManager;`

pub use config_validator::*;   // Re-export all items from config_validator (ConfigValidator, etc.).
pub use generator::*;          // Re-export Generator trait and related items.
pub use generator_manager::*;  // Re-export GeneratorManager and type aliases.
pub use runtime_manager::*;    // Re-export RuntimeManager and related utilities.

<<< FILE END: rust\ssxl_generate\src\manager\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\manager\runtime_manager.rs (95 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Runtime: The Tokio runtime itself, which drives asynchronous tasks.
// Handle: A handle to the runtime, allowing spawning tasks without owning the runtime directly.
use tokio::runtime::{Runtime, Handle};

// Logging macro for structured runtime output.
// - info!: used to log initialization and shutdown events.
use tracing::info;

// num_cpus: Utility crate to query the number of CPU cores available.
// Used to configure the runtime with optimal worker threads.
use num_cpus;

// io: Standard library error type, used for returning initialization errors.
use std::io;

// -----------------------------------------------------------------------------
// Struct: RuntimeManager
// -----------------------------------------------------------------------------
// Wraps a Tokio runtime instance and manages its lifecycle.
// Provides methods for initialization, access, and graceful shutdown.
//
// Fields:
//   - runtime: Option<Runtime> to allow taking ownership during Drop.
//              Wrapping in Option makes it possible to "take" the runtime safely.
pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

// -----------------------------------------------------------------------------
// Implementation: RuntimeManager
// -----------------------------------------------------------------------------
impl RuntimeManager {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new multi-threaded Tokio runtime configured with the number of
    // available CPU cores. This ensures efficient parallelism.
    //
    // Steps:
    //   1. Query number of cores.
    //   2. Log initialization message.
    //   3. Build runtime with worker_threads = num_cores.
    //   4. Enable all Tokio features (I/O, time, etc.).
    //   5. Return RuntimeManager wrapping the runtime.
    //
    // Returns:
    //   - Ok(RuntimeManager) on success.
    //   - Err(io::Error) if runtime fails to build.
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?; // May return io::Error if initialization fails.

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    // -------------------------------------------------------------------------
    // Getter: get_handle
    // -------------------------------------------------------------------------
    // Provides a clone of the runtime handle.
    // This allows spawning tasks without owning the runtime itself.
    //
    // Panics:
    //   - If runtime is None (should not happen unless dropped prematurely).
    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    // -------------------------------------------------------------------------
    // Method: shutdown_graceful
    // -------------------------------------------------------------------------
    // Logs a graceful shutdown request.
    // Note: Actual shutdown is handled in Drop implementation.
    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

// -----------------------------------------------------------------------------
// Drop Implementation: RuntimeManager
// -----------------------------------------------------------------------------
// Ensures the runtime is properly shut down when RuntimeManager goes out of scope.
// This prevents dangling tasks and ensures resources are cleaned up.
//
// Steps:
//   1. Take ownership of runtime from Option (leaving None behind).
//   2. Log shutdown message.
//   3. Call shutdown_background() to stop runtime without blocking current thread.
impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped — shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}

<<< FILE END: rust\ssxl_generate\src\manager\runtime_manager.rs >>>

>>> FILE START: rust\ssxl_generate\src\perlin\mod.rs (27 LOC) <<<
// -----------------------------------------------------------------------------
// Module: perlin (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `perlin` module.
// It organizes submodules related to Perlin noise generation and re-exports
// their contents for easier access.
//
// Think of this file as the "entry point" for all Perlin-related functionality
// in the SSXL engine.

// -----------------------------------------------------------------------------
// Submodule Declaration
// -----------------------------------------------------------------------------
// Declares the `perlin_generator` submodule.
// This file (perlin_generator.rs) contains the actual implementation of the
// Perlin noise generator, which conforms to the `Generator` trait.
pub mod perlin_generator;

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// Re-export all items from the `perlin_generator` submodule.
// This allows external code to import directly from `crate::perlin` instead of
// drilling down into `crate::perlin::perlin_generator`.
//
// Example:
//   Without re-export → `use crate::perlin::perlin_generator::PerlinGenerator;`
//   With re-export    → `use crate::perlin::PerlinGenerator;`
pub use perlin_generator::*;

<<< FILE END: rust\ssxl_generate\src\perlin\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\perlin\perlin_generator.rs (151 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Generator trait: contract that all procedural generators must implement.
use crate::Generator;

// Vec2i: 2D integer vector type used to represent chunk coordinates.
use ssxl_math::prelude::Vec2i;

// Core shared data structures for chunk/tile management.
// - ChunkData: container for all tiles in a chunk.
// - CHUNK_SIZE: constant defining the dimension of a chunk (e.g., 16x16).
// - GridBounds: defines the spatial bounds of a chunk in world coordinates.
// - TileData: represents a single tile, including type and metadata.
// - TileType: enum of possible tile categories (Water, Grass, Mountain, etc.).
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};

// Noise library: provides Perlin noise function implementation.
// NoiseFn: trait for noise functions.
// Perlin: concrete Perlin noise generator.
use noise::{NoiseFn, Perlin};

// Logging macro for structured runtime output.
use tracing::info;

// -----------------------------------------------------------------------------
// Struct: PerlinGenerator
// -----------------------------------------------------------------------------
// A generator that uses the Perlin noise algorithm to create deterministic terrain.
// Fields:
//   - perlin: Perlin noise object seeded for deterministic output.
//   - scale: scaling factor applied to coordinates before sampling noise.
//            Larger scale → smoother, larger features.
//            Smaller scale → more detail, finer features.
pub struct PerlinGenerator {
    perlin: Perlin,
    scale: f64,
}

// -----------------------------------------------------------------------------
// Implementation: PerlinGenerator
// -----------------------------------------------------------------------------
impl PerlinGenerator {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new PerlinGenerator instance with a given scale.
    // Arguments:
    //   - scale: frequency/scale of the noise (e.g., 64.0).
    // Notes:
    //   - DEFAULT_SEED is hardcoded to ensure deterministic, repeatable generation.
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// -----------------------------------------------------------------------------
// Trait Implementation: Generator for PerlinGenerator
// -----------------------------------------------------------------------------
impl Generator for PerlinGenerator {
    // -------------------------------------------------------------------------
    // Method: id
    // -------------------------------------------------------------------------
    // Returns a unique identifier string for this generator.
    // Used by the Conductor and GeneratorManager to select this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    // -------------------------------------------------------------------------
    // Method: generate_chunk
    // -------------------------------------------------------------------------
    // Generates a single chunk of terrain using Perlin noise.
    //
    // Steps:
    //   1. Compute chunk size in tiles.
    //   2. Calculate world coordinates for chunk origin (bottom-left corner).
    //   3. Create a unique chunk ID by packing coordinates into a 64-bit integer.
    //   4. Define spatial bounds for the chunk.
    //   5. Initialize ChunkData container.
    //   6. Pre-allocate vector for all TileData entries.
    //   7. Iterate over each tile in the chunk:
    //        a. Compute world coordinates for tile.
    //        b. Sample Perlin noise at scaled coordinates.
    //        c. Normalize noise value from [-1, 1] → [0, 1].
    //        d. Threshold normalized value into a TileType (Water, Grass, Mountain).
    //        e. Create TileData with type + raw noise metadata.
    //        f. Push into tile vector.
    //   8. Insert generated tiles into ChunkData.
    //   9. Log completion message with chunk coordinates and tile count.
    //  10. Return fully populated ChunkData.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        // Step 1: chunk size in tiles.
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Step 2: world coordinates of chunk origin.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Step 3: unique chunk ID (pack x and y into u64).
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Step 4: define bounds of chunk in world coordinates.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        // Step 5: dimension name (for metadata).
        let dimension_name = "2D_Noise".to_string();

        // Step 6: initialize ChunkData.
        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Step 7: pre-allocate tile vector.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Step 7: iterate through all tiles in chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                // a. Compute world coordinates for tile.
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // b. Sample Perlin noise at scaled coordinates.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // c. Normalize noise value from [-1, 1] → [0, 1].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // d. Threshold normalized value into TileType.
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // e. Create TileData with type + noise metadata.
                let tile = TileData::new(tile_type, normalized_value as f32);

                // f. Push into tile vector.
                tiles.push(tile);
            }
        }

        // Step 8: insert generated tiles into ChunkData.
        chunk_data.insert_tiles(tiles);

        // Step 9: log completion message.
        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        // Step 10: return populated ChunkData.
        chunk_data
    }
}

<<< FILE END: rust\ssxl_generate\src\perlin\perlin_generator.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\batch_processor.rs (112 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Handle: A reference to the Tokio runtime, used to spawn tasks.
// Sender: A bounded channel sender for sending progress messages back to the conductor.
use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;

// Logging macros for structured runtime output.
// - info!: used for normal progress and completion logs.
// - warn!: used for warnings (e.g., dropped messages).
use tracing::{info, warn};

// HashMap: used to store generator instances keyed by their unique string IDs.
// Arc: thread-safe reference-counted pointer for sharing data across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: integer 2D vector type for chunk coordinates.
// ChunkCache: cache for storing generated chunks to avoid redundant computation.
use ssxl_math::prelude::Vec2i;
use ssxl_cache::ChunkCache;

// GeneratorConfig: configuration for generator (map dimensions, seed, etc.).
use crate::manager::config_validator::GeneratorConfig;

// ConductorState: tracks conductor lifecycle state, queue depth, and active generator ID.
use crate::conductor::conductor_state::ConductorState;

// DynGenerator: type alias for dynamically dispatched generator trait objects.
// Allows storing multiple generator types in a uniform registry.
use crate::manager::generator_manager::DynGenerator;

// handle_chunk_unit: function that processes a single chunk request.
// GenerationMessage: enum representing messages sent back from generation tasks.
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};

// CHUNK_SIZE: constant defining the dimension of a chunk (e.g., 16x16 tiles).
use ssxl_shared::CHUNK_SIZE;

// -----------------------------------------------------------------------------
// Function: spawn_batch_generation_task
// -----------------------------------------------------------------------------
// Purpose:
//   - Spawns a blocking task that processes a full batch of chunks sequentially.
//   - Ensures stability with non-thread-safe generators/caches by running in a
//     dedicated thread.
//
// Arguments:
//   - runtime_handle: handle to the Tokio runtime for spawning tasks.
//   - generators_clone: cloned registry of available generators.
//   - chunk_cache_clone: cloned cache for storing/retrieving chunks.
//   - active_generator_id: ID of the generator to use for this batch.
//   - progress_sender_clone: channel sender for progress/completion messages.
//   - internal_state_clone: cloned conductor state for tracking queue depth.
//   - config_clone: generator configuration (map dimensions, seed, etc.).
//
// Behavior:
//   1. Logs the start of batch generation.
//   2. Spawns a blocking task on the runtime.
//   3. Increments queue depth to track active tasks.
//   4. Calculates how many chunks wide/tall the map will be.
//   5. Builds a list of all chunk coordinates.
//   6. Iterates sequentially over each chunk coordinate, generating data.
//   7. Sends a completion message when finished.
//   8. Decrements queue depth.
//   9. Logs completion.
pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<ChunkCache>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: Arc<ConductorState>,
    config_clone: GeneratorConfig,
) {
    // Step 1: Log start of batch generation.
    info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

    // Step 2: Spawn blocking task on runtime.
    runtime_handle.spawn_blocking(move || {
        // Step 3: Increment queue depth to track active task.
        internal_state_clone.increment_queue_depth();

        // Step 4: Calculate chunk dimensions in terms of tiles.
        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        // Ceiling division to calculate number of chunks in each dimension.
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        // Step 5: Build list of all chunk coordinates.
        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        // Handle edge case: empty map.
        if all_chunk_coords.is_empty() {
            info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
        }

        // Step 6: Sequentially process each chunk.
        let active_generator_id_ref = &active_generator_id;
        
        for &chunk_coords in all_chunk_coords.iter() {
            handle_chunk_unit(
                chunk_coords,
                active_generator_id_ref,
                &generators_clone,
                &chunk_cache_clone,
                &progress_sender_clone,
                &internal_state_clone,
            );
        }

        // Step 7: Send completion message.
        if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
            warn!("Batch completion signal dropped (Channel full).");
        }

        // Step 8: Decrement queue depth.
        internal_state_clone.decrement_queue_depth();

        // Step 9: Log completion.
        info!("Batch generation task finished processing command: {}", config_clone);
    });
}

<<< FILE END: rust\ssxl_generate\src\task\batch_processor.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\benchmark_logic.rs (67 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros for structured runtime output.
// - info!: used to log successful completion of workload.
// - warn!: used to log warnings or notable events at the start.
use tracing::{info, warn};

// Arc: thread-safe reference-counted pointer for sharing data across threads.
// AtomicU64: atomic 64-bit unsigned integer, used for concurrent progress tracking.
// Ordering: specifies memory ordering semantics for atomic operations.
//   - Relaxed: fastest ordering, no synchronization guarantees beyond atomicity.
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

// -----------------------------------------------------------------------------
// Function: benchmark_generation_workload
// -----------------------------------------------------------------------------
// Purpose:
//   - Simulates a heavy generation workload by iterating over a large number of tiles.
//   - Performs dummy computation to mimic tile processing.
//   - Reports progress periodically using a shared atomic counter.
//   - Logs start and completion messages.
//
// Arguments:
//   - workload_tiles: total number of tiles to simulate processing.
//   - processed_tiles_counter: shared atomic counter updated periodically to report progress.
//
// Behavior:
//   1. Logs start of workload.
//   2. Defines update interval (every 10 million tiles).
//   3. Iterates over all tiles, performing dummy computation.
//   4. Updates atomic counter at each interval.
//   5. Handles final remainder update.
//   6. Logs completion with final check value.
pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64>
) {
    // Step 1: Log start of workload.
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    // Step 2: Define update interval (every 10 million tiles).
    const UPDATE_INTERVAL: u64 = 10_000_000; 

    // Step 3: Initialize result accumulator.
    // This is a dummy computation used to simulate tile processing.
    let mut result: u64 = 0;
    
    // Step 4: Iterate over all tiles.
    for i in 0..workload_tiles {
        // Dummy computation: add (i % 17) to result.
        // Using wrapping_add to avoid overflow panics.
        result = result.wrapping_add(i % 17);
        
        // Step 5: Update atomic counter every UPDATE_INTERVAL tiles.
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    // Step 6: Handle final remainder update.
    // If workload_tiles is not a multiple of UPDATE_INTERVAL,
    // add the remaining count to the atomic counter.
    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    // Step 7: Log completion with final check value.
    // The result value is a checksum-like number from dummy computation.
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}

<<< FILE END: rust\ssxl_generate\src\task\benchmark_logic.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\mod.rs (32 LOC) <<<
// -----------------------------------------------------------------------------
// Module: task (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `task` module.
// It organizes all task-related functionality in the SSXL engine, including:
//   - Batch processing of chunks
//   - Benchmarking logic for performance testing
//   - Task queue management for async/sync chunk generation
//
// Think of this file as the "table of contents" for the task system.

// -----------------------------------------------------------------------------
// Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the task system.
// These submodules are implemented in their own files (e.g., batch_processor.rs,
// benchmark_logic.rs, task_queue.rs).

pub mod batch_processor;   // Handles sequential batch generation of chunks.
pub mod benchmark_logic;   // Provides benchmarking utilities for workload simulation.
pub mod task_queue;        // Manages the queue of chunk generation tasks (async + sync).

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::task` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::task::task_queue::handle_chunk_unit;`
//   With re-export    → `use crate::task::handle_chunk_unit;`

pub use batch_processor::*;   // Re-export all items from batch_processor.
pub use benchmark_logic::*;   // Re-export all items from benchmark_logic.
pub use task_queue::*;        // Re-export all items from task_queue.

<<< FILE END: rust\ssxl_generate\src\task\mod.rs >>>

>>> FILE START: rust\ssxl_generate\src\task\task_queue.rs (191 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Handle: a reference to the Tokio runtime, used to spawn async tasks.
// mpsc: multi-producer, single-consumer channels for communication between tasks.
// JoinHandle: handle returned by spawned tasks, used to await their completion.
use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;

// Logging macros for structured runtime output.
// - info!: general lifecycle events.
// - error!: critical failures (e.g., cache save failure, task panic).
// - warn!: warnings (e.g., channel full, conductor inactive).
// - debug!: detailed diagnostic information (cache hits/misses).
use tracing::{info, error, warn, debug};

// HashMap: registry of generators keyed by ID.
// Arc: thread-safe reference-counted pointer for sharing across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: 2D integer vector type for chunk coordinates.
// ChunkKey: unique identifier for a chunk in coordinate system.
// I64Vec3: 3D integer vector type (used here with z=0 for 2D chunks).
use ssxl_math::prelude::Vec2i;
use ssxl_math::coordinate_system::ChunkKey;
use glam::I64Vec3;

// ChunkCache: cache for storing/retrieving generated chunks.
use ssxl_cache::ChunkCache;

// CHUNK_SIZE constant imported from shared crate, aliased for clarity.
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE;

// Generator trait: contract for all procedural generators.
// conductor_state: tracks conductor lifecycle, tile counts, and active status.
use crate::Generator;
use crate::conductor::conductor_state;

// Re-export message types for generation tasks and results.
// GenerationMessage: enum for messages (Generated, Complete, etc.).
// GenerationTask: struct representing a chunk generation request.
pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask};

// -----------------------------------------------------------------------------
// Type Aliases and Constants
// -----------------------------------------------------------------------------
// DynGenerator: dynamically dispatched Generator trait object, Send + Sync for concurrency.
type DynGenerator = Box<dyn Generator + Send + Sync>;

// CHUNK_SIZE: local constant as i64, derived from shared crate constant.
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;

// -----------------------------------------------------------------------------
// Function: handle_chunk_unit
// -----------------------------------------------------------------------------
// Purpose:
//   - Handles a single chunk request end-to-end.
//   - Steps: cache check → generate if needed → save to cache → send result.
//
// Arguments:
//   - chunk_coords: coordinates of the chunk to process.
//   - generator_name: ID of the generator to use.
//   - generators: registry of available generators.
//   - chunk_cache: shared cache for storing/retrieving chunks.
//   - progress_sender: channel sender for reporting progress/results.
//   - conductor_state: shared conductor state for tracking tile counts.
//
// Behavior:
//   1. Build a ChunkKey from coordinates.
//   2. Check cache for existing chunk.
//   3. If cache hit → send cached chunk.
//   4. If cache miss → generate new chunk.
//   5. Save generated chunk to cache.
//   6. Send generated chunk via progress channel.
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
    conductor_state: &Arc<conductor_state::ConductorState>,
) {
    // Step 1: Build unique chunk key.
    let chunk_key = ChunkKey(I64Vec3 {
        x: chunk_coords.x,
        y: chunk_coords.y,
        z: 0,
    });

    // Step 2: Cache HIT.
    if let Some(chunk_data_arc) = chunk_cache.load_chunk(&chunk_key) {
        debug!(?chunk_coords, "Cache HIT");

        let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
        if progress_sender.try_send(msg).is_err() {
            warn!(?chunk_coords, "Failed to send cached chunk (channel full/closed)");
        }
        return;
    }

    // Step 3: Cache MISS → generate.
    debug!(?chunk_coords, generator = %generator_name, "Cache MISS → generating");

    let generator = generators
        .get(generator_name)
        .expect("Generator must exist in map");

    // Generate new chunk data.
    let chunk_data = generator.generate_chunk(chunk_coords);

    // Update conductor state with tile count.
    let tile_count = chunk_data.tiles.len() as u64;
    conductor_state.increment_tile_count(tile_count);

    // Wrap chunk data in Arc for safe sharing.
    let chunk_data_arc = Arc::new(chunk_data);

    // Step 4: Save to cache.
    if chunk_cache.save_chunk(&chunk_key, chunk_data_arc.clone()).is_err() {
        error!(?chunk_coords, "Failed to save generated chunk to cache");
    }

    // Step 5: Send result.
    let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
    if progress_sender.try_send(msg).is_err() {
        warn!(?chunk_coords, "Failed to send generated chunk (channel full/closed)");
    } else {
        debug!(?chunk_coords, "Sent newly generated chunk");
    }
}

// -----------------------------------------------------------------------------
// Function: start_request_loop
// -----------------------------------------------------------------------------
// Purpose:
//   - Main async loop for processing incoming generation tasks.
//   - Receives tasks from channel → spawns blocking generation jobs → tracks active tasks.
//
// Arguments:
//   - rt_handle: runtime handle for spawning async tasks.
//   - request_rx: channel receiver for incoming GenerationTask requests.
//   - progress_tx: channel sender for reporting progress/results.
//   - generators: registry of available generators.
//   - chunk_cache: shared cache for storing/retrieving chunks.
//   - conductor_state: shared conductor state for lifecycle tracking.
//
// Behavior:
//   1. Spawn async loop on runtime.
//   2. Log start of task queue.
//   3. Maintain list of active tasks.
//   4. For each incoming task:
//        a. Check conductor active state.
//        b. Clone necessary resources.
//        c. Spawn blocking task to handle chunk.
//        d. Track task handle.
//   5. When channel closes, drain all active tasks.
//   6. Send GenerationComplete message.
//   7. Log clean shutdown.
pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<conductor_state::ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue started");

        // Track active blocking tasks.
        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();

        // Step 4: Process incoming tasks.
        while let Some(task) = request_rx.recv().await {
            // a. Check conductor active state.
            if !conductor_state.as_ref().is_active() {
                warn!(?task.chunk_coords, "Dropping task — Conductor not active");
                continue;
            }

            // b. Clone resources for task.
            let progress_tx = progress_tx.clone();
            let generators = generators.clone();
            let cache = chunk_cache.clone();
            let state = conductor_state.clone();

            // c. Spawn blocking task to handle chunk.
            let handle = tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators,
                    &cache,
                    &progress_tx,
                    &state,
                );
            });

            // d. Track task handle.
            active_tasks.push(handle);
        }

        // Step 5: Channel closed → drain tasks.
        info!("Request channel closed. Draining {} active tasks...", active_tasks.len());

        for handle in active_tasks {
            if let Err(e) = handle.await {
                error!("Generation task panicked: {:?}", e);
            }
        }

        // Step 6: Send completion message.
        let _ = progress_tx.send(GenerationMessage::GenerationComplete).await;

        // Step 7: Log clean shutdown.
        info!("Generation Task Queue shut down cleanly");
    });
}

<<< FILE END: rust\ssxl_generate\src\task\task_queue.rs >>>

