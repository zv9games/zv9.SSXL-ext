>>> FILE START: rust\ssxl_godot\Cargo.toml (30 LOC) <<<
[package]
name = "ssxl_godot"
version = "0.9.1"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_generate = { path = "../ssxl_generate" }
ssxl_sync = { path = "../ssxl_sync", features = ["godot-bindings"] }
# --- EXTERNAL DEPENDENCIES ---

# CORE GDExtension BINDINGS
godot = { workspace = true }
godot-ffi = { workspace = true }
# Workspace standard logging framework
tracing = { workspace = true }
tokio = { workspace = true }
rand = { workspace = true }
serde_json = { workspace = true }
once_cell = { workspace = true }
crossbeam-channel = { workspace = true }

###############################################################
# REQUIRED FIX FOR GDExtension LINKER ERROR (E0127)
###############################################################
[lib]
crate-type = ["cdylib"]
name = "ssxl_engine"
# The name "ssxl_engine" forces the creation of 
# 'ssxl_engine.dll' in the target directory,
# which Godot expects to find via the .gdextension file.
<<< FILE END: rust\ssxl_godot\Cargo.toml >>>

>>> FILE START: rust\ssxl_godot\src\lib.rs (59 LOC) <<<
// -----------------------------------------------------------------------------
// Root Manifest: ssxl_godot
// -----------------------------------------------------------------------------
// This file is the entry point for the `ssxl_godot` crate.
// It defines the top-level module structure and the GDExtension boilerplate
// required for Godot to load this Rust library.

// -----------------------------------------------------------------------------
// Public Modules
// -----------------------------------------------------------------------------
// These modules are exposed to Godot and contain the core functionality.
// Each corresponds to a directory or file in `src/`.
//
// engine   → Core engine logic (SSXLEngine, conductor, tick loop, API).
// ffi      → Godot-facing FFI adapter nodes (SSXLOracle, SSXLSignals).
// tilemap  → TileMap integration (SSXLTilemap, async_poll, status_reporter).
pub mod engine;
pub mod ffi;
pub mod tilemap; 

// -----------------------------------------------------------------------------
// Godot GDExtension Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides macros and traits for integrating Rust with Godot.
//   - Includes #[gdextension], Gd<T>, GodotClass, etc.
//
// ExtensionLibrary, InitLevel
//   - Traits and enums required to define the dynamic library’s lifecycle.
//   - InitLevel indicates which stage of Godot initialization is occurring.
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

// -----------------------------------------------------------------------------
// Struct: SSXLExtension
// -----------------------------------------------------------------------------
// Purpose:
//   - Placeholder struct required by godot-rust to implement ExtensionLibrary.
//   - Represents the extension library itself.
//   - Contains no fields because all logic is delegated to modules.
struct SSXLExtension;

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary
// -----------------------------------------------------------------------------
// #[gdextension]
//   - Marks this implementation as the entrypoint for Godot’s GDExtension system.
//   - Godot will call into this when loading the dynamic library.
//
// unsafe impl ExtensionLibrary
//   - Required by godot-rust to hook into Godot’s lifecycle.
//   - Declares how the extension behaves during initialization.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    // on_level_init
    //   - Called by Godot when a new initialization level is reached.
    //   - InitLevel indicates the stage (Core, Scene, Editor, etc.).
    //   - Currently does nothing, but can be extended to register classes,
    //     initialize resources, or set up global state.
    fn on_level_init(_level: InitLevel) {
        // No actions required at this stage.
    }
}

<<< FILE END: rust\ssxl_godot\src\lib.rs >>>

>>> FILE START: rust\ssxl_godot\src\anim\animation_api.rs (74 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Arc + Mutex: Used for thread-safe, shared ownership of the Conductor instance.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures safe, exclusive access to the Conductor when multiple threads interact.
//
// tracing macros:
//   - info!: for general lifecycle logs.
//   - error!: for critical failures.
//   - warn!: for warnings or unusual states.
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: a specialized handle for managing animation conductor state,
// typically used for coordinating animation-related tasks across threads.
use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

// -----------------------------------------------------------------------------
// Struct: AnimationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides an abstraction layer for animation-related orchestration.
//   - Holds references to conductor handles so the Rust FFI layer can manage
//     lifecycle and internal communication.
//
// Attributes:
//   - animation_conductor: optional reference to an AnimationConductorHandle.
//       * This is used to drive animation-specific orchestration.
//       * Stored as Option<&> to allow absence (None) when not needed.
//   - _conductor: optional reference to the core Conductor wrapped in Arc<Mutex>.
//       * Arc ensures shared ownership across threads.
//       * Mutex ensures safe concurrent access.
//       * Leading underscore (_) indicates this field may be unused directly,
//         but is retained for lifecycle management or future internal use.
#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// -----------------------------------------------------------------------------
// Implementation: AnimationAPI
// -----------------------------------------------------------------------------
// Provides constructor and potential extension points for animation orchestration.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Creates a new AnimationAPI instance with optional references to
    //     animation conductor and core conductor.
    //
    // Arguments:
    //   - animation_conductor: optional reference to AnimationConductorHandle.
    //   - conductor: optional reference to Arc<Mutex<Conductor>>.
    //
    // Returns:
    //   - AnimationAPI instance with provided references stored.
    //
    // Notes:
    //   - Both arguments are optional, allowing flexible initialization depending
    //     on whether animation or conductor orchestration is required.
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}

<<< FILE END: rust\ssxl_godot\src\anim\animation_api.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\api.rs (114 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary: Godot's built-in key-value container type, used here for returning
//             structured data back to the Godot engine in a format it understands.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Arc + Mutex: concurrency primitives for safe, shared ownership of the Conductor.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures exclusive access to Conductor when multiple threads interact.
use std::sync::{Arc, Mutex};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: specialized handle for animation conductor state,
// used to send animation-related commands across threads.
use ssxl_generate::Conductor;
use ssxl_shared::AnimationConductorHandle;

// GenesisHandles: struct returned by initialization routines, containing
// references to conductor, channels, and other setup artifacts.
// execute_channel_and_state_setup: function that sets up communication channels
// and conductor state during initialization.
use crate::engine::api_initializers::{execute_channel_and_state_setup, GenesisHandles};

// -----------------------------------------------------------------------------
// Struct: EngineInitializer
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a clean API for initializing the SSXL engine inside Godot.
//   - Encapsulates setup routines for channels, conductor state, and spawning
//     the conductor runtime.
//
// Notes:
//   - #[derive(Default)] allows creating an empty EngineInitializer with default values.
//   - This struct acts as a "bootstrapper" for the engine.
#[derive(Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Returns a new EngineInitializer instance.
    // Uses Default trait to simplify instantiation.
    pub fn new() -> Self { Self::default() }

    // -------------------------------------------------------------------------
    // Method: execute_channel_and_state_setup
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes communication channels and conductor state.
    //   - Delegates to the api_initializers module for actual setup logic.
    //
    // Arguments:
    //   - config_path: optional path to configuration file.
    //
    // Returns:
    //   - GenesisHandles: contains conductor, channels, and setup artifacts.
    //   - Box<dyn Error>: wraps any error that occurs during setup.
    pub fn execute_channel_and_state_setup(
        &self,
        config_path: Option<&str>,
    ) -> Result<GenesisHandles, Box<dyn Error>> {
        execute_channel_and_state_setup(config_path)
    }

    // -------------------------------------------------------------------------
    // Method: execute_conductor_setup_and_spawn
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Wraps the Conductor instance in Arc<Mutex> for safe sharing across threads.
    //   - Extracts and clones the AnimationConductorHandle for animation orchestration.
    //
    // Arguments:
    //   - handles: GenesisHandles containing conductor and channels.
    //
    // Returns:
    //   - Tuple:
    //       * Option<Arc<Mutex<Conductor>>>: shared, thread-safe conductor instance.
    //       * AnimationConductorHandle: handle for animation commands.
    pub fn execute_conductor_setup_and_spawn(
        &self,
        handles: GenesisHandles,
    ) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        let conductor_arc = Arc::new(Mutex::new(handles._gen_conductor));
        let anim_handle: AnimationConductorHandle = handles.anim_command_tx.clone();
        (Some(conductor_arc), anim_handle)
    }
}

// -----------------------------------------------------------------------------
// Struct: GenerationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing API for chunk data retrieval.
//   - Intended to be called from Godot scripts to fetch chunk data.
//   - Currently a stub implementation returning an empty Dictionary.
//
// Notes:
//   - #[derive(Default)] allows creating an empty GenerationAPI easily.
//   - MUST BE PUBLIC: ensures Godot can access this struct via FFI.
#[derive(Default)]
pub struct GenerationAPI {}

impl GenerationAPI {
    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Fetches chunk data for given coordinates (x, y).
    //   - Currently returns an empty Dictionary as a placeholder.
    //
    // Arguments:
    //   - _x, _y: chunk coordinates (unused in stub).
    //
    // Returns:
    //   - Dictionary: Godot-compatible container for chunk data.
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }
}

<<< FILE END: rust\ssxl_godot\src\engine\api.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\cleanup.rs (71 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), which is used as the return type.
//
// Arc
//   - Thread-safe reference-counted pointer for shared ownership.
//   - Used here to manage the Conductor instance across multiple threads.
use godot::prelude::*;
use std::sync::Arc;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module;
use state_module::{SSXLEngine, state};

// -----------------------------------------------------------------------------
// Function: shutdown_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing function for Godot to explicitly shut down the
//     SSXL engine, releasing all resources and background threads.
//   - Ensures the Conductor and related subsystems are gracefully torn down.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine, the core engine state.
//
// Returns:
//   - GString: a Godot-compatible string message confirming shutdown.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, attempt to unwrap and shut it down gracefully.
//   3. Clear other subsystems (conductor_state, animation_conductor, animation_state).
//   4. Clear Godot node references (signals_node, tilemap_node).
//   5. Return a confirmation message.
pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    // Step 1: Access internal state of SSXLEngine.
    let state = state!(engine);
    
    // Step 2: Gracefully shut down the Conductor if present.
    if let Some(conductor_arc) = state.conductor.take() {
        // Arc::try_unwrap attempts to consume the Arc if it is uniquely owned.
        //   - .ok(): discards error if Arc is not unique.
        //   - .and_then(|m| m.into_inner().ok()): consumes Mutex, discards poisoning errors.
        // Result: Option<Conductor> if successful.
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok()
            .and_then(|m| m.into_inner().ok())
        {
            // Call graceful_teardown on the owned Conductor instance.
            conductor.graceful_teardown();
        }
        // If Arc is not unique or Mutex is poisoned, shutdown is skipped.
    }
    
    // Step 3: Clear other subsystems.
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    // Step 4: Clear Godot node references.
    state.signals_node.take();
    state.tilemap_node.take();

    // Step 5: Return confirmation message as GString.
    "SSXLEngine resources shut down and released.".into()
}

<<< FILE END: rust\ssxl_godot\src\engine\cleanup.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\commands.rs (78 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), used for passing strings between Rust and Godot.
use godot::prelude::*;

// AnimationCommand
//   - Enum representing commands sent to the animation conductor.
//   - Examples: enabling/disabling animations, updating flow fields, particle systems, etc.
use ssxl_shared::AnimationCommand;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: stop_generation_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Gracefully stops the current generation process.
//   - Intended to be called from Godot when the user requests a halt in terrain generation.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call stop_generation() on the Conductor.
//   4. Ignore errors silently (e.g., if lock acquisition fails).
pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

// -----------------------------------------------------------------------------
// Function: set_animation_enabled_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Toggles the low-latency animation conductor (flow fields, particle systems, etc.).
//   - Allows enabling or disabling animations dynamically during gameplay.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If an animation conductor channel exists, send a SetEnabled command.
//   3. The command is sent asynchronously to the animation conductor.
//   4. Ignore errors silently (e.g., if channel is full or closed).
pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

// -----------------------------------------------------------------------------
// Function: set_generator_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Changes the active generator mid-session.
//   - Useful for dynamic biome switching or runtime experimentation with different terrain algorithms.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call set_generator() on the Conductor, passing the new generator name.
//   4. Convert Godot's GString into a Rust String before passing.
//   5. Ignore errors silently (e.g., if lock acquisition fails).
pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            let _ = c.set_generator(&name.to_string());
        }
    }
}

<<< FILE END: rust\ssxl_godot\src\engine\commands.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\init.rs (210 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<Node>, GString, Dictionary, etc., which are used to bridge
//     between Rust and Godot’s scripting layer.
use godot::prelude::*;

// UnboundedSender: asynchronous channel sender from Tokio used for communication
// between threads without backpressure (unbounded queue).
use tokio::sync::mpsc::UnboundedSender;

// Node: Godot scene graph node type, used here for signals integration.
use godot::classes::Node;

// Dictionary: Godot’s built-in key-value container, used for returning structured
// data back to Godot scripts.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Logging macros for structured runtime output.
// - info!: lifecycle events.
// - error!: critical failures.
use tracing::{info, error};

// Internal Godot FFI glue for SSXLEngine functions.
use crate::engine::__godot_SSXLEngine_Funcs;

// SSXLEngine: the core engine state struct exposed to Godot.
use super::state::SSXLEngine;

// Tick processor: updates engine state each frame.
use crate::engine::tick::process_engine_tick;

// Commands: side-effect functions for stopping generation, toggling animation,
// and switching generators.
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};

// Query functions: read-only accessors for engine state (tile count, status, active generator).
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};

// Cleanup logic: graceful shutdown of engine resources.
use crate::engine::cleanup::shutdown_logic;

// AnimationConductorHandle: handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// AnimationCommand: enum representing animation-related commands (enable/disable, etc.).
use ssxl_shared::message::AnimationCommand;

// -----------------------------------------------------------------------------
// Godot API Implementation: SSXLEngine
// -----------------------------------------------------------------------------
// This block exposes SSXLEngine methods to Godot via #[godot_api] and #[func] attributes.
// Each method can be called directly from Godot scripts.
#[godot_api]
impl SSXLEngine {

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes the entire SSXL runtime, including conductor, worker threads,
    //     and communication channels.
    //   - Logs success or failure and returns a boolean to Godot.
    #[func]
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                self.shutdown();
                false
            }
        }
    }

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell_logic (private)
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Core initialization logic separated from public API.
    //   - Sets up channels, conductor threads, and wires handles into internal state.
    //
    // Steps:
    //   1. Initialize channels and core state objects.
    //   2. Clone animation command sender and store it.
    //   3. Spawn conductor threads via initializer.
    //   4. Wire conductor, signals node, and animation handles into internal state.
    //   5. Log successful wiring.
    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        let internal_state = unsafe { &mut *self._internal_state.get() };

        // Step 1: Initialize channels and core state.
        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // Step 2: Clone animation command sender.
        let inner_sender_clone: UnboundedSender<AnimationCommand> = handles.anim_command_tx.clone();
        let anim_command_tx_for_internal_state: AnimationConductorHandle = inner_sender_clone;

        // Step 3: Spawn conductor threads.
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        // Step 4: Wire handles into internal state.
        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);

        // Step 5: Log success.
        info!("SSXL Channels successfully wired to AsyncPoller.");

        Ok(())
    }

    // -------------------------------------------------------------------------
    // Method: shutdown
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Triggers graceful shutdown of SSXL runtime.
    //   - Delegates to cleanup::shutdown_logic.
    #[func]
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: build_map
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Starts a new generation run using provided configuration.
    //   - Currently stubbed to always return true.
    #[func]
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        true
    }

    // -------------------------------------------------------------------------
    // Method: stop_generation
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Stops any current generation/animation process gracefully.
    //   - Delegates to commands::stop_generation_logic.
    #[func]
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_enabled
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Enables or disables tile animation updates.
    //   - Delegates to commands::set_animation_enabled_logic.
    #[func]
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    // -------------------------------------------------------------------------
    // Method: set_generator
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Changes active generator mid-session (dynamic biome switching).
    //   - Delegates to commands::set_generator_logic.
    #[func]
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns total number of tiles generated so far.
    //   - Delegates to query::get_current_tile_count_logic.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_status
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns human-readable engine status string.
    //   - Delegates to query::get_status_logic.
    #[func]
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_active_generator_id
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns the name of the currently active generator.
    //   - Delegates to query::get_active_generator_id_logic.
    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Provides Godot with read-only access to specific chunk data.
    //   - Currently stubbed to return an empty Dictionary.
    #[func]
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }

    // -------------------------------------------------------------------------
    // Method: process_engine_tick
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Must be called every frame to update engine state and process async messages.
    //   - Increments tick counter and delegates to tick::process_engine_tick.
    #[func]
    pub fn process_engine_tick(&mut self) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}

<<< FILE END: rust\ssxl_godot\src\engine\init.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\mod.rs (66 LOC) <<<
// -----------------------------------------------------------------------------
// Module: engine (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `engine` module in the SSXL Godot integration.
// It acts as the central hub, organizing all submodules and re-exporting key items
// so that external code can access them easily.
//
// Think of this file as the "table of contents" for the engine layer.

// -----------------------------------------------------------------------------
// Macro Import
// -----------------------------------------------------------------------------
// #[macro_use] ensures that macros defined in the `state` module (such as `state!`)
// are available throughout the entire `engine` module without needing explicit imports.
// This is critical because the `state!` macro is used in multiple files (commands.rs, init.rs, etc.).
#[macro_use] 
pub mod state;

// -----------------------------------------------------------------------------
// Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the engine system.
// These submodules are implemented in their own files and encapsulate specific concerns:
//
// - init.rs: Runtime initialization logic (channels, conductor setup, etc.).
// - api.rs: Public-facing API for Godot to interact with the engine.
// - tick.rs: Game loop integration, processes engine state each frame.
// - commands.rs: Lightweight runtime commands (stop generation, toggle animation, switch generator).
// - query.rs: Read-only queries for engine state (tile count, status, active generator).
// - cleanup.rs: Graceful shutdown and resource release logic.
// - render_batch.rs: Rendering-related batch operations (integration with Godot visuals).
// - query_data.rs: Data access layer for chunk/tile queries.
// - api_initializers.rs: Helper functions for setting up channels and conductor state.
pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
pub mod api_initializers; 

// -----------------------------------------------------------------------------
// Re-exports: Submodules
// -----------------------------------------------------------------------------
// These `pub use` statements re-export all items from the submodules.
// This flattens the API so external code can import directly from `engine`
// without drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::engine::commands::stop_generation_logic;`
//   With re-export    → `use crate::engine::stop_generation_logic;`
pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

// -----------------------------------------------------------------------------
// Re-export: SSXLEngine
// -----------------------------------------------------------------------------
// SSXLEngine is the Godot-exposed class representing the engine state.
// By re-exporting it here, external crates (like lib.rs) only need a single line
// to access the Godot class, rather than importing from deep inside the module.
//
// This makes the engine’s public API clean and ergonomic.
pub use state::SSXLEngine;

<<< FILE END: rust\ssxl_godot\src\engine\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\poller.rs (132 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// TokioReceiver: alias for tokio::sync::mpsc::Receiver, used to receive messages
// from asynchronous channels. This is the non-blocking receiver side of a channel.
use tokio::sync::mpsc::Receiver as TokioReceiver;

// GenerationMessage: enum representing messages from the generation system.
// These include progress updates, completed chunks, or completion signals.
use ssxl_generate::task_queue::GenerationMessage; 

// AnimationUpdate: struct representing lightweight, high-frequency animation updates.
// These are sent from the animation conductor to update flow fields, particles, etc.
use ssxl_shared::message::messages::AnimationUpdate; 

// VecDeque: double-ended queue, efficient for pushing/popping at both ends.
// Used here to collect batches of messages during polling.
use std::collections::VecDeque;

// warn!: logging macro for warnings, used when channels disconnect unexpectedly.
use tracing::warn; 

// TryRecvError: error type returned by try_recv() when a channel is empty or disconnected.
use tokio::sync::mpsc::error::TryRecvError;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Central struct responsible for non-blocking draining of asynchronous results.
//   - Holds two distinct channel receivers:
//       * gen_rx: for heavy generation results (chunks, progress).
//       * anim_rx: for lightweight animation updates.
//
// Notes:
//   - Both receivers are optional (Option<T>), allowing flexible initialization.
//   - If a channel disconnects, the Option is set to None to mark it permanently unavailable.
pub struct AsyncPoller {
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default AsyncPoller with no channels set.
// Useful for initializing before wiring channels in init.rs.
impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides setup methods (for wiring channels) and polling methods (for draining messages).
impl AsyncPoller {
    // -------------------------------------------------------------------------
    // Method: set_generation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for generation messages.
    //   - Called during initialization when channels are created.
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for animation updates.
    //   - Called during initialization when channels are created.
    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: poll_generation_messages
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available generation messages from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If gen_rx exists, loop until channel is empty or disconnected.
    //   3. Push messages into VecDeque.
    //   4. If disconnected, log warning and set gen_rx to None.
    //   5. Return collected messages.
    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        if let Some(rx) = &mut self.gen_rx {
            loop {
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None;
                        break;
                    }
                }
            }
        }
        messages
    }

    // -------------------------------------------------------------------------
    // Method: poll_animations
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available animation updates from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If anim_rx exists, loop until channel is empty or disconnected.
    //   3. Push updates into VecDeque.
    //   4. If disconnected, log warning and set anim_rx to None.
    //   5. Return collected updates.
    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None;
                        break;
                    }
                }
            }
        }
        updates
    }
}

<<< FILE END: rust\ssxl_godot\src\engine\poller.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\query.rs (78 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot’s string type), used for returning strings
//     back to Godot scripts in a compatible format.
use godot::prelude::*;

// StatusReporter
//   - Utility module responsible for producing human-readable status reports
//     and tile count summaries.
//   - Encapsulates logic for interpreting conductor and animation state.
use crate::tilemap::status_reporter::StatusReporter;

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: get_current_tile_count_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the total number of tiles generated so far across all chunks.
//   - Provides a read-only query with no side effects.
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call StatusReporter::get_current_tile_count_value, passing a reference
//      to the conductor_state.
//   3. Return the tile count as u64.
pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

// -----------------------------------------------------------------------------
// Function: get_status_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns a human-readable engine status string.
//   - Example: "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call StatusReporter::get_status_report, passing references to
//      conductor_state and animation_state.
//   3. Return the resulting GString.
pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

// -----------------------------------------------------------------------------
// Function: get_active_generator_id_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the name of the currently active generator.
//   - Examples: "perlin", "cellular", "simplex", "custom_my_gen"
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Check if a conductor exists (Option<Arc<Mutex<Conductor>>>).
//   3. If None → return "Not Initialized".
//   4. If Some → attempt to acquire lock on conductor.
//   5. On success → call get_active_generator_id() and convert to GString.
//   6. On failure (mutex poisoned) → return "Mutex Poisoned".
pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}

<<< FILE END: rust\ssxl_godot\src\engine\query.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\query_data.rs (38 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary
//   - Godot’s built-in key-value container type.
//   - Used here to return structured chunk data back to Godot in a format
//     that Godot scripts can easily consume.
use godot::builtin::Dictionary; 

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access to its fields.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: fetch_chunk_data_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides the external Godot layer with read-only access to specific chunk data.
//   - Acts as a query function: no mutation, no side effects, just data retrieval.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine (needed because the macro dereferences
//     internal state, even though this function itself does not mutate).
//   - x, y: integer coordinates of the chunk being requested.
//
// Returns:
//   - Dictionary: a Godot-compatible container holding the chunk’s data.
//     The actual contents depend on the implementation of generation_api.
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call generation_api.fetch_chunk_data(x, y).
//   3. Return the resulting Dictionary to Godot.
pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    state!(engine).generation_api.fetch_chunk_data(x, y)
}

<<< FILE END: rust\ssxl_godot\src\engine\query_data.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\render_batch.rs (100 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::builtin::*
//   - Provides Godot’s built-in types like Dictionary, PackedInt32Array, etc.
//   - These are essential for constructing data structures that Godot understands.
use godot::builtin::*;

// ChunkData, TileType
//   - ChunkData: represents a block of terrain tiles generated by the engine.
//   - TileType: enum/class describing the type of tile (e.g., grass, water, empty).
//     Provides helper methods like is_empty() and atlas coordinate lookup.
use ssxl_shared::{ChunkData, TileType};

// ToGodot trait
//   - Provides the to_variant() method, which converts Rust types into Godot Variant.
//   - Required for setting arrays into Dictionary fields in a Godot-compatible way.
use godot::prelude::ToGodot; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE: fixed dimension of a chunk (32x32 tiles).
// DEFAULT_SOURCE_ID: default identifier for the tile source in Godot’s TileMap.
pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

// -----------------------------------------------------------------------------
// Function: create_render_batch_dictionary
// -----------------------------------------------------------------------------
// Purpose:
//   - Converts a generated ChunkData into a Godot-ready Dictionary.
//   - This dictionary is structured specifically for Godot’s TileMap API.
//   - Acts as the translation layer between Rust’s generation system and Godot’s rendering.
//
// Arguments:
//   - chunk_data: reference to ChunkData containing tile information.
//   - chunk_x, chunk_y: coordinates of the chunk in world space.
//
// Returns:
//   - Dictionary: contains arrays of positions, source IDs, atlas coordinates, and alt tiles.
//
// Dictionary Format:
// {
//    "layer": 0,
//    "positions": PackedInt32Array [x1, y1, x2, y2, ...],
//    "source_ids": PackedInt32Array [id, id, ...],
//    "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
//    "alt_tiles": PackedInt32Array [0, 0, ...]
// }
pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    // Create the output dictionary.
    let mut dict = Dictionary::new();

    // Arrays to hold tile rendering data.
    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    // Set the rendering layer (always 0 for now).
    dict.set("layer", 0i64);

    // Counter for how many tiles are actually rendered.
    let mut tile_count = 0usize;

    // Iterate over every tile in the chunk grid (32x32).
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            // Compute linear index into chunk_data.tiles.
            let idx = (y * CHUNK_SIZE + x) as usize;

            // Fetch tile at this index.
            if let Some(tile) = chunk_data.tiles.get(idx) {
                // Skip empty tiles (no rendering needed).
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                // Compute world-space coordinates of the tile.
                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                // Push position into array (x, y).
                positions.push(world_x);
                positions.push(world_y);

                // Push default source ID (links to Godot TileSet).
                source_ids.push(DEFAULT_SOURCE_ID);

                // Lookup atlas coordinates for this tile type.
                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                // Push alt tile index (0 = default).
                alt_tiles.push(0);

                // Increment rendered tile count.
                tile_count += 1;
            }
        }
    }

    // Store arrays into dictionary (converted to Godot Variants).
    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    // Debug log if any tiles were prepared.
    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    // Return the fully constructed dictionary.
    dict
}

<<< FILE END: rust\ssxl_godot\src\engine\render_batch.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\state.rs (149 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, GString, etc., which are required to expose Rust
//     structs and methods to Godot’s scripting layer.
use godot::prelude::*;

// TileMap, Node
//   - Godot scene graph classes.
//   - TileMap: used for rendering tile-based maps.
//   - Node: base class for all Godot scene objects.
use godot::classes::{TileMap, Node};

// UnsafeCell
//   - Provides interior mutability for otherwise immutable structs.
//   - Required because Godot owns the object lifetime, not Rust.
//   - Allows us to store mutable state inside SSXLEngine safely.
use std::cell::UnsafeCell;

// Arc + Mutex
//   - Arc: atomic reference-counted pointer for shared ownership across threads.
//   - Mutex: ensures exclusive access to shared data.
//   - Together, they allow safe concurrent access to the Conductor.
use std::sync::{Arc, Mutex};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Conductor + ConductorState
//   - Conductor: central orchestrator of generation tasks.
//   - ConductorState: snapshot of conductor’s current status.
use ssxl_generate::{Conductor, conductor::ConductorState}; 

// AnimationState
//   - Snapshot of animation conductor’s current status.
use ssxl_shared::AnimationState;

// AsyncPoller
//   - Responsible for non-blocking draining of async channels (generation + animation).
use crate::tilemap::async_poll::AsyncPoller; 

// GenesisHandles
//   - Struct returned by initialization routines, containing conductor and channel handles.
//   - Aliased here as FfiGenesisHandles for clarity.
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 

// EngineInitializer + GenerationAPI
//   - EngineInitializer: bootstraps conductor threads and channels.
//   - GenerationAPI: provides public-facing API for chunk data queries.
use crate::engine::api::{GenerationAPI, EngineInitializer};

// -----------------------------------------------------------------------------
// Macro: state!
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides safe access to the _internal_state UnsafeCell inside SSXLEngine.
//   - Two forms:
//       * Expression form: state!(self) → returns mutable reference to InternalState.
//       * Statement form: state!(self, name) → binds InternalState to local variable.
//
// Notes:
//   - #[macro_export] makes the macro visible outside this module.
//   - This is the only safe way to touch _internal_state, since Godot owns object lifetime.
#[macro_export]
macro_rules! state {
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

// Re-export macro so other engine files can use it directly.
pub use state; 

// -----------------------------------------------------------------------------
// Struct: InternalState
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds all non-FFI-safe state for SSXLEngine.
//   - Encapsulates conductor, animation, nodes, and helper APIs.
//   - This struct is hidden from Godot and only accessed via the state! macro.
//
// Fields:
//   - conductor: shared Conductor instance (Arc<Mutex<Conductor>>).
//   - conductor_state: snapshot of conductor status.
//   - animation_conductor: handle for animation commands.
//   - animation_state: snapshot of animation status.
//   - signals_node: Godot Node for emitting signals.
//   - tilemap_node: Godot TileMap for rendering.
//   - initializer: EngineInitializer for bootstrapping.
//   - poller: AsyncPoller for draining async channels.
//   - genesis_handles: optional GenesisHandles from initialization.
//   - generation_api: API for chunk data queries.
//   - tick_count: frame counter for engine ticks.
pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    pub tick_count: u64,
}

// -----------------------------------------------------------------------------
// Default Implementation: InternalState
// -----------------------------------------------------------------------------
// Provides a default empty InternalState.
// All Option fields are initialized to None.
// initializer and poller are constructed with their own defaults.
// tick_count starts at 0.
impl Default for InternalState {
    fn default() -> Self {
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            tick_count: 0,
        }
    }
}

// -----------------------------------------------------------------------------
// Struct: SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - The Godot-facing class exposed to GDScript.
//   - Wraps InternalState inside UnsafeCell for interior mutability.
//   - Provides the bridge between Godot scripts and Rust engine logic.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLEngine as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: Godot Node base.
//   - _internal_state: UnsafeCell<InternalState>, hidden from Godot.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}

<<< FILE END: rust\ssxl_godot\src\engine\state.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\tick.rs (134 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, Variant conversions, etc.
use godot::prelude::*;

// SSXLEngine
//   - The Godot-facing engine struct, wrapping InternalState.
//   - Provides access to conductor, poller, signals, etc.
use super::state::SSXLEngine;

// create_render_batch_dictionary
//   - Utility function that converts ChunkData into a Godot Dictionary
//     formatted for TileMap rendering.
use super::render_batch::create_render_batch_dictionary;

// Signals FFI
//   - Provides SSXLSignals type, which defines the signals emitted to Godot.
//   - Signals are the bridge between Rust engine events and Godot script callbacks.
use crate::ffi::signals::*; 

// GString
//   - Godot’s string type, used for sending status updates back to Godot.
use godot::builtin::GString; 

// debug!
//   - Logging macro for debug-level output.
use tracing::debug;

// GenerationMessage
//   - Enum representing messages from the generation system.
//   - Variants include Generated(chunk), StatusUpdate(string), GenerationComplete.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Function: process_engine_tick
// -----------------------------------------------------------------------------
// Purpose:
//   - Called once per frame by Godot.
//   - Processes generation + animation messages from async channels.
//   - Emits signals back to Godot for rendering and status updates.
//   - Marks tick completion.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine.
//   - tick: current tick counter (frame number).
//
// Flow:
//   1. Access internal state via UnsafeCell.
//   2. Ensure conductor and signals_node exist.
//   3. Cast signals_node to SSXLSignals for emitting signals.
//   4. Poll generation messages and emit appropriate signals.
//   5. Poll animation messages and emit tile flip signals.
//   6. Emit tick_complete signal at the end.
pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    // Access the hidden InternalState inside SSXLEngine.
    let state = unsafe { &mut *engine._internal_state.get() };
    
    // Ensure conductor exists; if not, return early.
    let Some(_conductor) = &state.conductor else { return };
    
    // Ensure signals_node exists; if not, return early.
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    // Cast signals_node to SSXLSignals to allow emitting signals.
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    // -------------------------------------------------------------------------
    // Generation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available generation messages from AsyncPoller.
    let messages = state.poller.poll_generation();
    for msg in messages {
        match msg {
            // Case: A chunk has been generated.
            GenerationMessage::Generated(_, chunk) => {
                // Extract chunk coordinates.
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                // Convert chunk into Godot render batch dictionary.
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                // Emit signal if batch is non-empty.
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            // Case: Status update message.
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            // Case: Generation process complete.
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
        }
    }

    // -------------------------------------------------------------------------
    // Animation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available animation updates from AsyncPoller.
    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            // Handle frame update payloads.
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(),
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    // -------------------------------------------------------------------------
    // Tick Completion Signal
    // -------------------------------------------------------------------------
    // Emit tick_complete signal with current tick number.
    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}

<<< FILE END: rust\ssxl_godot\src\engine\tick.rs >>>

>>> FILE START: rust\ssxl_godot\src\engine\api_initializers\mod.rs (137 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Used for asynchronous communication between engine components.
//   - Provides unbounded channels for commands, responses, and updates.
use tokio::sync::mpsc;

// get_config_from_path
//   - Loads engine configuration from a file path.
//   - Provides runtime parameters for conductor initialization.
use ssxl_shared::config::config::get_config_from_path;

// Conductor + ConductorProgressReceiver + ConductorState
//   - Conductor: orchestrates generation tasks (terrain, chunks).
//   - ConductorProgressReceiver: receives progress updates from the conductor.
//   - ConductorState: snapshot of conductor’s current status.
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    conductor::ConductorState,
};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Message types
//   - AnimationCommand: commands for animation conductor.
//   - AnimationState: snapshot of animation conductor’s state.
//   - GenerationCommand: commands for generation conductor.
//   - GenerationResponse: responses from generation conductor.
//   - AnimationUpdate: updates from animation conductor.
use ssxl_shared::message::{
    AnimationCommand,
    AnimationState,
    GenerationCommand,
    GenerationResponse,
    AnimationUpdate,
};

// Error trait
//   - Used for returning boxed errors in Result types.
use std::error::Error;

// info!
//   - Logging macro for informational messages.
use tracing::info;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// These aliases simplify channel type signatures for readability.
pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;
pub type GenerationCommandTx = mpsc::UnboundedSender<GenerationCommand>;
pub type GenerationResponseRx = mpsc::UnboundedReceiver<GenerationResponse>;

// -----------------------------------------------------------------------------
// Struct: GenesisHandles
// -----------------------------------------------------------------------------
// Purpose:
//   - Bundles all handles, channels, and state objects created during initialization.
//   - Acts as the "genesis kit" for wiring the engine together.
//
// Fields:
//   - gen_state: snapshot of conductor state.
//   - anim_state: snapshot of animation state.
//   - gen_progress_rx: receiver for generation progress updates.
//   - anim_update_rx: receiver for animation updates.
//   - anim_command_tx: sender for animation commands.
//   - gen_command_tx: sender for generation commands.
//   - gen_response_rx: receiver for generation responses.
//   - _gen_conductor: internal conductor instance (not exposed).
//   - _anim_rx: internal receiver for animation commands.
//   - _anim_update_tx: internal sender for animation updates.
//   - _gen_resp_tx: internal sender for generation responses.
pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    pub gen_command_tx: GenerationCommandTx,
    pub gen_response_rx: GenerationResponseRx,
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>,
    pub(crate) _gen_resp_tx: mpsc::UnboundedSender<GenerationResponse>,
}

// -----------------------------------------------------------------------------
// Function: execute_channel_and_state_setup
// -----------------------------------------------------------------------------
// Purpose:
//   - Initializes all channels and state objects required for the engine.
//   - Returns a GenesisHandles struct bundling everything together.
//
// Arguments:
//   - config_path: optional path to configuration file.
//
// Steps:
//   1. Load configuration from path.
//   2. Create generation command + response channels.
//   3. Initialize conductor via Conductor::new_for_ffi.
//   4. Create animation command + update channels.
//   5. Initialize animation state.
//   6. Log successful initialization.
//   7. Return GenesisHandles with all handles and channels wired.
pub fn execute_channel_and_state_setup(
    config_path: Option<&str>,
) -> Result<GenesisHandles, Box<dyn Error>> {
    // Step 1: Load configuration.
    let _config = get_config_from_path(config_path);

    // Step 2: Create generation channels.
    let (gen_command_tx, _gen_cmd_rx) = mpsc::unbounded_channel::<GenerationCommand>();
    let (_gen_resp_tx, gen_response_rx) = mpsc::unbounded_channel::<GenerationResponse>();

    // Step 3: Initialize conductor.
    let (
        gen_conductor,
        gen_state,
        _internal_gen_cmd_tx,
        _internal_gen_resp_rx,
        gen_progress_rx_inner,
    ) = Conductor::new_for_ffi(config_path)?;

    // Step 4: Create animation channels.
    let (anim_command_tx_inner, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
    let (anim_update_tx, anim_update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();

    // Step 5: Initialize animation state.
    let anim_state = AnimationState::default();

    // Step 6: Log success.
    info!("Genesis engine initialized: Conductor + Animation systems ready.");

    // Step 7: Return GenesisHandles.
    Ok(GenesisHandles {
        gen_state,
        anim_state,
        gen_progress_rx: ConductorProgressReceiver::new(gen_progress_rx_inner),
        anim_update_rx,
        anim_command_tx: anim_command_tx_inner,

        gen_command_tx,
        gen_response_rx,
        _gen_conductor: gen_conductor,
        _anim_rx: anim_rx,
        _anim_update_tx: anim_update_tx,
        _gen_resp_tx,
    })
}

<<< FILE END: rust\ssxl_godot\src\engine\api_initializers\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\gde_api_defs.rs (63 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and types for Rust integration.
//   - Includes InitHandle, ExtensionLibrary, Base<T>, and macros like #[gdextension].
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - Used here as the base class for SSXLEngine.
use godot::classes::Node;

// Local engine import
//   - SSXLEngine: the Rust struct that represents the engine state and logic.
//   - This struct is exposed to Godot as a custom class.
use crate::ssxl_engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Function: ssxl_godot_init
// -----------------------------------------------------------------------------
// Purpose:
//   - Mandatory entry point for Godot’s GDExtension system.
//   - Called automatically when the dynamic library is loaded by Godot.
//   - Registers SSXLEngine as a Godot class so it can be instantiated in GDScript.
//
// Notes:
//   - #[gdextension] marks this function as the extension entry point.
//   - Declared unsafe because it interacts with Godot’s C/C++ runtime directly.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // Register SSXLEngine with Godot.
    // After this, SSXLEngine can be used in Godot scripts as a Node.
    builder.add_class::<SSXLEngine>();
}

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary for SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - Binds SSXLEngine to Godot’s Node lifecycle.
//   - Maps Godot’s virtual methods (_init, _process, _ready) to Rust implementations.
//
// Lifecycle Methods:
//   - _init: Constructor, runs when SSXLEngine is instantiated in Godot.
//   - _process: Called every frame, passes delta time to engine tick.
//   - _ready: Called once when the node enters the scene tree, used for setup.
impl ExtensionLibrary for SSXLEngine {
    // Godot’s constructor (_init).
    // base: the underlying Godot Node that SSXLEngine wraps.
    // Delegates initialization to SSXLEngine::init.
    fn _init(base: Base<Node>) -> Self {
        SSXLEngine::init(base)
    }

    // Godot’s frame update (_process).
    // delta: time elapsed since last frame (in seconds).
    // Delegates to SSXLEngine::tick, casting delta to u64 for internal use.
    fn _process(&mut self, delta: f64) {
        self.tick(delta as u64);
    }

    // Godot’s ready hook (_ready).
    // Runs once when the node enters the scene tree.
    // Delegates to SSXLEngine::on_ready for engine startup logic.
    fn _ready(&mut self) {
        self.on_ready();
    }
}

<<< FILE END: rust\ssxl_godot\src\ffi\gde_api_defs.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\mod.rs (26 LOC) <<<
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// Declares submodules within the `ffi` namespace.
// These correspond to files in `src/ffi/`.
//
// oracle.rs   → Contains the SSXLOracle struct and related logic.
// signals.rs  → Contains the SSXLSignals struct and signal definitions.
pub mod oracle;
pub mod signals;

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// Purpose:
//   - Makes selected types available directly from the `ffi` module,
//     so external code can import them without referencing submodules.
//
// Example:
//   Instead of writing:
//       use crate::ffi::oracle::SSXLOracle;
//   You can simply write:
//       use crate::ffi::SSXLOracle;
//
// This improves ergonomics and keeps external imports clean.
pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;

<<< FILE END: rust\ssxl_godot\src\ffi\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\oracle.rs (149 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and macros for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - SSXLOracle inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node;

// Base, Gd
//   - Base<Node>: wrapper around the Godot Node base class.
//   - Gd<T>: Godot reference-counted smart pointer for Rust objects exposed to Godot.
use godot::obj::{Base, Gd};

// SSXLEngine
//   - The core engine struct, containing generation and animation logic.
//   - SSXLOracle holds a reference to SSXLEngine to delegate work.
use crate::engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Struct: SSXLOracle
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as a Godot-facing "oracle" node that queries and delegates to SSXLEngine.
//   - Provides a lightweight interface for ticking the engine and retrieving status.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLOracle as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node.
//   - engine: optional reference to SSXLEngine (bound later).
//   - tick_count: counter for how many ticks have been processed.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLOracle
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLOracle.
impl SSXLOracle {
    // init
    //   - Called when SSXLOracle is constructed.
    //   - Initializes with no engine bound and tick_count = 0.
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func] attributes.
// These methods can be called from GDScript or C#.
#[godot_api]
impl SSXLOracle {
    // _ready
    //   - Godot lifecycle method.
    //   - Called once when the node enters the scene tree.
    //   - Enables processing so _process() can run each frame.
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    // set_engine
    //   - Binds an SSXLEngine instance to this oracle.
    //   - Allows delegation of tick and query methods.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    // tick
    //   - Advances the engine by one tick.
    //   - Delegates to SSXLEngine::process_engine_tick.
    //   - Increments tick_count.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {
                // No engine bound; silently skip.
            }
        }
    }

    // get_current_tile_count
    //   - Queries SSXLEngine for the total number of tiles generated.
    //   - Returns 0 if engine is not bound.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_current_tile_count()
            }
            None => {
                0
            }
        }
    }

    // get_status
    //   - Queries SSXLEngine for a human-readable status string.
    //   - Returns "Engine not bound." if no engine is attached.
    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_status()
            }
            None => {
                GString::from("Engine not bound.")
            }
        }
    }
    
    // ping
    //   - Simple test function; currently does nothing.
    //   - Can be used to verify connectivity from Godot.
    #[func]
    pub fn ping(&self) {
    }

    // reset
    //   - Resets tick_count to 0.
    //   - Useful for restarting counters during testing or reinitialization.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    // get_tick
    //   - Returns the current tick_count.
    //   - Useful for monitoring how many ticks have been processed.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}

<<< FILE END: rust\ssxl_godot\src\ffi\oracle.rs >>>

>>> FILE START: rust\ssxl_godot\src\ffi\signals.rs (100 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Base<T>, GString, Dictionary, Vector2i, and the #[godot_api] attribute.
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - SSXLSignals inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node; 

// -----------------------------------------------------------------------------
// Struct: SSXLSignals
// -----------------------------------------------------------------------------
// Purpose:
//   - Defines a Godot-facing class that emits signals from the Rust engine.
//   - Signals are the communication bridge between Rust logic and Godot scripts.
//   - This struct itself does not contain engine state; it only acts as a broadcaster.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLSignals as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node that SSXLSignals wraps.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLSignals
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLSignals.
impl SSXLSignals {
    // init
    //   - Called when SSXLSignals is constructed.
    //   - Wraps the provided Node base inside the struct.
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Defines all signals exposed to Godot via #[signal] attributes.
// These signals can be connected to GDScript or C# methods in the Godot editor.
//
// Categories:
//   - Generation lifecycle signals
//   - Animation & utility signals
#[godot_api]
impl SSXLSignals {
    // -------------------------------------------------------------------------
    // Generation Lifecycle Signals
    // -------------------------------------------------------------------------

    // Emitted when map generation begins.
    #[signal]
    fn build_map_start();

    // Emitted when chunk data is updated (coordinates provided).
    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    // Emitted when a chunk is fully generated and converted into a render batch.
    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    // Emitted when map generation completes successfully.
    #[signal]
    fn build_map_complete();

    // Emitted when map generation is stopped prematurely.
    #[signal]
    fn build_map_stopped();

    // Emitted when a generation error occurs (error message provided).
    #[signal]
    fn generation_error(error_message: GString);

    // Emitted when chunk data is ready for use (coordinates provided).
    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    // Emitted at the end of each tick (frame), with current tick count.
    #[signal]
    fn tick_complete(current_tick: u64);

    // -------------------------------------------------------------------------
    // Animation & Utility Signals
    // -------------------------------------------------------------------------

    // Emitted when a tile’s flip frame is updated (tile ID + frame index).
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    // Emitted during animation updates (percent done + new atlas coordinates).
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    // Emitted when animation state changes (enabled/disabled).
    #[signal]
    fn animation_state_changed(enabled: bool);

    // Emitted when engine status changes (status message provided).
    #[signal]
    fn engine_status_updated(status_message: GString);
}

<<< FILE END: rust\ssxl_godot\src\ffi\signals.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\async_poll.rs (144 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Receiver: bounded channel receiver (used for generation messages).
//   - UnboundedReceiver: unbounded channel receiver (used for animation updates).
//   - TryRecvError: error type returned when attempting non-blocking receive.
use tokio::sync::mpsc::{
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};

// AnimationUpdate
//   - Struct representing updates from the animation conductor.
//   - Typically contains tile coordinates and frame update payloads.
use ssxl_shared::AnimationUpdate; 

// GenerationMessage
//   - Enum representing messages from the generation conductor.
//   - Variants include Generated(chunk), StatusUpdate, GenerationComplete, etc.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// MAX_GEN_MSGS
//   - Maximum number of generation messages to process per poll.
//   - Prevents runaway loops if channel is flooded.
const MAX_GEN_MSGS: usize = 64;

// MAX_ANIM_MSGS
//   - Maximum number of animation messages to process per poll.
//   - Higher because animation updates can be more frequent.
const MAX_ANIM_MSGS: usize = 2048;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// AnimationReceiver
//   - Unbounded channel receiver for AnimationUpdate messages.
//   - Animation updates are frequent, so unbounded channel is used.
pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;

// GenerationReceiver
//   - Bounded channel receiver for GenerationMessage.
//   - Generation messages are controlled by the Conductor, so bounded channel is used.
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as the "bridge" between Tokio async channels and Godot’s main thread.
//   - Provides non-blocking polling methods to drain channels safely each frame.
//   - Stores optional receivers for generation and animation messages.
//
// Fields:
//   - generation_rx: optional bounded receiver for generation messages.
//   - animation_rx: optional unbounded receiver for animation updates.
#[derive(Default)]
pub struct AsyncPoller {
    generation_rx: Option<GenerationReceiver>,
    animation_rx: Option<AnimationReceiver>,
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides methods to set receivers, clear them, and poll messages.
impl AsyncPoller {
    // new
    //   - Creates a new AsyncPoller with default (None) receivers.
    pub fn new() -> Self {
        Self::default()
    }

    // set_animation_rx
    //   - Assigns an animation receiver to the poller.
    //   - Accepts Option<AnimationReceiver> to allow None when uninitialized.
    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        self.animation_rx = rx;
    }

    // set_generation_rx
    //   - Assigns a generation receiver to the poller.
    //   - Accepts Option<GenerationReceiver> to allow None when uninitialized.
    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        self.generation_rx = rx;
    }

    // clear_receivers
    //   - Clears both generation and animation receivers.
    //   - Useful for resetting state or shutting down channels.
    pub fn clear_receivers(&mut self) {
        self.generation_rx = None;
        self.animation_rx = None;
    }

    // poll_generation
    //   - Non-blocking poll of generation messages.
    //   - Drains up to MAX_GEN_MSGS messages from the channel.
    //   - Handles Empty (no messages) and Disconnected (channel closed).
    //   - Returns a vector of GenerationMessage.
    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.generation_rx = Some(rx);
        updates
    }

    // poll_animations
    //   - Non-blocking poll of animation updates.
    //   - Drains up to MAX_ANIM_MSGS messages from the channel.
    //   - Uses a smaller initial capacity (min(256)) for efficiency.
    //   - Returns a vector of AnimationUpdate.
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.animation_rx = Some(rx);
        updates
    }
}

<<< FILE END: rust\ssxl_godot\src\tilemap\async_poll.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\mod.rs (37 LOC) <<<
// -----------------------------------------------------------------------------
// Module: tilemap
// -----------------------------------------------------------------------------
// This file acts as the *parent module* for all tilemap-related components.
// It declares submodules and re-exports them so they can be accessed cleanly
// from other parts of the engine.
//
// Structure:
//   src/tilemap/
//     ├── mod.rs              ← this file
//     ├── ssxl_tilemap.rs     ← core tilemap logic
//     ├── async_poll.rs       ← async channel polling bridge
//     └── status_reporter.rs  ← utility for reporting tilemap status

// -----------------------------------------------------------------------------
// Submodule: ssxl_tilemap
// -----------------------------------------------------------------------------
// Contains the main SSXLTilemap implementation.
//   - Responsible for managing tile placement, rendering, and integration
//     with Godot’s TileMap node.
//   - Provides the core API for interacting with chunks and tiles.
pub mod ssxl_tilemap;

// -----------------------------------------------------------------------------
// Submodule: async_poll
// -----------------------------------------------------------------------------
// Contains AsyncPoller, the bridge between Tokio async channels and Godot.
//   - Polls generation and animation channels safely on the main thread.
//   - Ensures non-blocking, panic-free message handling.
//   - Used by the engine tick loop to drain background updates.
pub mod async_poll;

// -----------------------------------------------------------------------------
// Submodule: status_reporter
// -----------------------------------------------------------------------------
// Contains utilities for reporting tilemap status back to Godot.
//   - Provides human-readable summaries of engine/tilemap state.
//   - Emits status updates via signals for debugging and monitoring.
//   - Helps external scripts understand the tilemap’s lifecycle.
pub mod status_reporter;

<<< FILE END: rust\ssxl_godot\src\tilemap\mod.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\ssxl_tilemap.rs (201 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// TileMap, ITileMap
//   - TileMap: Godot’s built-in node for grid-based tile rendering.
//   - ITileMap: Trait that allows us to implement custom behavior for TileMap in Rust.
use godot::classes::{TileMap, ITileMap};

// Base
//   - Wrapper around the Godot base class for TileMap.
//   - Provides access to the underlying Godot object.
use godot::obj::Base;

// Vector2i, PackedVector2Array, PackedInt32Array
//   - Vector2i: integer 2D vector, used for tile coordinates.
//   - PackedVector2Array: efficient array of Vector2 values, used for batch positions.
//   - PackedInt32Array: efficient array of integers, used for alternative tile IDs.
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};

// OnceCell
//   - Thread-safe, one-time initialization cell.
//   - Used here to store the global TileMap instance ID for FFI callbacks.
use once_cell::sync::OnceCell;

// -----------------------------------------------------------------------------
// Global State
// -----------------------------------------------------------------------------
// TILEMAP_INSTANCE_ID
//   - Stores the Godot instance ID of the SSXLTilemap node.
//   - Allows external C-style FFI functions to access the TileMap safely.
pub static TILEMAP_INSTANCE_ID: OnceCell<InstanceId> = OnceCell::new(); 

// DEFAULT_LAYER
//   - Default layer index used when placing tiles via FFI callbacks.
const DEFAULT_LAYER: i32 = 0;

// -----------------------------------------------------------------------------
// Struct: SSXLTilemap
// -----------------------------------------------------------------------------
// Purpose:
//   - Custom Godot TileMap class that receives render batches from Rust signals
//     or FFI callbacks.
//   - Provides both batch rendering (signal-driven) and buffered updates (FFI-driven).
//
// Fields:
//   - base: underlying Godot TileMap node.
//   - tile_source_id: ID of the tile source used when setting cells.
//   - pending_updates: buffer of cell updates queued via FFI calls.
#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    pub tile_source_id: i32,
    pub pending_updates: Vec<(i32, i32, i32)>, // (world_x, world_y, tile_id)
}

// -----------------------------------------------------------------------------
// Implementation: ITileMap for SSXLTilemap
// -----------------------------------------------------------------------------
// Provides initialization logic when the TileMap node is created in Godot.
#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        // Store the instance ID globally for FFI access.
        let id = base.to_init_gd().instance_id();
        let _ = TILEMAP_INSTANCE_ID.set(id);

        Self {
            base,
            tile_source_id: 1,
            pending_updates: Vec::new(),
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: SSXLTilemap
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func].
#[godot_api]
impl SSXLTilemap {
    // -------------------------------------------------------------------------
    // Batch Render (Signal/GDScript)
    // -------------------------------------------------------------------------
    // batch_set_tiles
    //   - Primary entrypoint for rendering tiles in bulk.
    //   - Expects a Dictionary with keys: "layer", "positions", "atlas_coords", "alt_tiles".
    //   - Called from Rust signals or GDScript.
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        // Extract layer index.
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        // Extract positions array.
        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        // Extract atlas coordinates array.
        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        // Extract alternative tiles array (optional).
        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        // Ensure layer is enabled before placing tiles.
        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        // Iterate through all positions and place tiles.
        for i in 0..len {
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }

    // -------------------------------------------------------------------------
    // FFI Render (Callback)
    // -------------------------------------------------------------------------

    // get_instance
    //   - Retrieves the current SSXLTilemap instance using its global ID.
    //   - Allows external C functions to access the TileMap safely.
    fn get_instance() -> Option<Gd<Self>> {
        let id = TILEMAP_INSTANCE_ID.get()?;
        godot::prelude::Gd::try_from_instance_id(*id).ok()
    }

    // flush_updates
    //   - Flushes all pending updates queued via FFI calls.
    //   - Applies them to the TileMap in bulk.
    pub fn flush_updates(&mut self) {
        // Take ownership of the buffer before mutably borrowing self.base.
        let updates = std::mem::take(&mut self.pending_updates);
        let len = updates.len();

        if len == 0 {
            return;
        }

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();
        
        tilemap.set_layer_enabled(DEFAULT_LAYER, true);

        // Apply each update to the default layer.
        for (world_x, world_y, tile_id) in updates {
            let cell = Vector2i::new(world_x, world_y);
            let atlas = Vector2i::new(0, tile_id); 
            
            tilemap
                .set_cell_ex(DEFAULT_LAYER, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(0)
                .done();
        }

        godot_print!("FFI Host: Batch rendered {len} tiles via FFI callback.");
    }
}

// -----------------------------------------------------------------------------
// FFI Host Implementation
// -----------------------------------------------------------------------------
// These extern "C" functions are exposed for the ssxl_engine_ffi library.
// They allow C-style calls to queue and flush tile updates.

// ssxl_set_cell
//   - Queues a single cell update into pending_updates.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_set_cell(x: i32, y: i32, tile_id: i32) {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().pending_updates.push((x, y, tile_id));
    } else {
        godot_warn!("ssxl_set_cell: Tilemap instance not available. Update lost.");
    }
}

// ssxl_notify_tilemap_update
//   - Flushes all queued updates to the TileMap.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_notify_tilemap_update() {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().flush_updates();
    }
}

<<< FILE END: rust\ssxl_godot\src\tilemap\ssxl_tilemap.rs >>>

>>> FILE START: rust\ssxl_godot\src\tilemap\status_reporter.rs (99 LOC) <<<
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// GString
//   - Godot’s string type, used for returning status messages to the scripting layer.
//   - Ensures compatibility with GDScript and C# in Godot.
use godot::prelude::GString;

// ConductorState
//   - Represents the state of the generation conductor (map/chunk generation).
//   - Provides methods like `get_status()` and `get_tiles_placed()` for querying progress.
use ssxl_generate::conductor::ConductorState;

// AnimationState
//   - Represents the state of the animation conductor.
//   - Provides fields like `time_scale` to indicate animation speed or whether it’s running.
use ssxl_shared::AnimationState;

// -----------------------------------------------------------------------------
// Struct: StatusReporter
// -----------------------------------------------------------------------------
// Purpose:
//   - Stateless utility struct for compiling human-readable status reports.
//   - Separates reporting logic from SSXLEngine, keeping engine code clean.
//   - Provides helper methods for status strings and tile counts.
pub struct StatusReporter;

// -----------------------------------------------------------------------------
// Implementation: StatusReporter
// -----------------------------------------------------------------------------
// Provides methods for generating status reports and querying tile counts.
impl StatusReporter {
    // -------------------------------------------------------------------------
    // Method: get_status_report
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Constructs a formatted status string combining generation and animation states.
    //   - Returns a Godot GString for direct use in the scripting layer.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState (generation system).
    //   - anim_state: optional reference to AnimationState (animation system).
    //
    // Behavior:
    //   - If gen_state is present, calls `get_status()` and formats it.
    //   - If anim_state is present, derives status from `time_scale`:
    //       * > 0.0 → Running
    //       * == 0.0 → Stopped
    //       * < 0.0 → Error/Invalid
    //   - If either state is missing, defaults to "Uninitialized".
    //
    // Returns:
    //   - A GString containing: "STATUS: Generation: <gen_status> | Animation: <anim_status>"
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        // Handle generation state.
        let gen_status = gen_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Handle animation state.
        let anim_status = anim_state
            .map(|state| {
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Combine both statuses into one formatted string.
        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        // Return as Godot GString.
        GString::from(status.as_str())
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count_value
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Retrieves the total number of tiles placed by the generation conductor.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState.
    //
    // Behavior:
    //   - If gen_state is present, calls `get_tiles_placed()`.
    //   - If absent, defaults to 0.
    //
    // Returns:
    //   - u64 representing the tile count.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            .unwrap_or(0)
    }
}

<<< FILE END: rust\ssxl_godot\src\tilemap\status_reporter.rs >>>

