SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1766557032
Root Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
        64 LOC | rust/ssxl_ext/src\animate_conductor.rs
// --- START: rust/ssxl_ext/src\animate_conductor.rs ---
use flume::{Receiver, Sender};
use crate::animate_events::AnimationEvent;
use crate::animate_worker::AnimationWorker;
use crate::shared_config::AnimationConfig;

#[derive(Debug)]
pub enum ControlMessage {
    Pause,
    Stop,
    UpdateConfig(AnimationConfig),
}

pub struct AnimationConductor {
    pub event_receiver: Receiver<AnimationEvent>,
    control_senders: Vec<Sender<ControlMessage>>,
    workers: Vec<AnimationWorker>,
}

impl AnimationConductor {
    pub fn new(config: &AnimationConfig) -> Self {
        let mut num_workers = config.worker_count;

        if num_workers == 0 {
            eprintln!("WARNING: Animation worker count is 0. Forcing to 1.");
            num_workers = 1;
        }

        let (event_sender, event_receiver) = flume::unbounded();

        let mut workers = Vec::with_capacity(num_workers);
        let mut control_senders = Vec::with_capacity(num_workers);

        for id in 0..num_workers {
            let (control_sender, control_receiver) = flume::unbounded();

            let worker = AnimationWorker::new(
                id,
                event_sender.clone(),
                control_receiver,
                config.clone(),
            );

            workers.push(worker);
            control_senders.push(control_sender);
        }

        eprintln!(
            "INFO: Animation Conductor: Launched {} dedicated animation workers.",
            num_workers
        );

        Self {
            event_receiver,
            control_senders,
            workers,
        }
    }

    pub fn shutdown(self) {
        eprintln!("INFO: Animation Conductor: Initiating graceful shutdown of workers.");

        for sender in self.control_senders.iter() {
            let _ = sender.send(ControlMessage::Stop);
        }

        for worker in self.workers {
            worker.join();
        }

        eprintln!("INFO: Animation Conductor: All animation workers shut down.");
    }

    pub fn get_event_receiver(&self) -> &Receiver<AnimationEvent> {
        &self.event_receiver
    }

    pub fn pause_workers(&self) {
        for sender in self.control_senders.iter() {
            let _ = sender.try_send(ControlMessage::Pause);
        }
    }
}

// --- END: rust/ssxl_ext/src\animate_conductor.rs ---
        17 LOC | rust/ssxl_ext/src\animate_events.rs
// --- START: rust/ssxl_ext/src\animate_events.rs ---
// rust/SSXL-ext/src/animate_events.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate the Godot import
#[cfg(feature = "godot-binding")]
use godot::prelude::*; // For Vector2i and Color types

// ðŸŽ¯ CRITICAL FIX: Define mock types for the CLI build (where godot-binding is OFF)
// Vector2i is defined in tools.rs, but we need to define Color here or in a shared place.
#[cfg(not(feature = "godot-binding"))]
type Color = u32; // Placeholder for Godot's Color type

/// Represents a single, final, thread-safe animation instruction for the Godot main thread.
#[derive(Debug, Clone)]
pub enum AnimationEvent {
    /// Change the current frame index of an animated tile.
    SetTileAnimation {
        layer: i32,
        coords: (i32, i32),
        frame_index: i32,
    },
    /// Change the color property of a specific Light2D node.
    SetLightColor {
        light_id: u32,
        // The type 'Color' here will resolve to 'godot::builtin::Color' when 
        // godot-binding is on, and to the 'u32' alias when it is off.
        color: Color, 
    },
    /// Request to create a new one-shot particle effect.
    SpawnParticleEffect {
        effect_id: u32,
        position: (f32, f32),
    },
}
// --- END: rust/ssxl_ext/src\animate_events.rs ---
        85 LOC | rust/ssxl_ext/src\animate_worker.rs
// --- START: rust/ssxl_ext/src\animate_worker.rs ---
use std::thread;
use std::time::{Duration, Instant};
use flume::Sender;
use crate::animate_events::AnimationEvent;
use crate::shared_config::AnimationConfig;
use crate::animate_conductor::ControlMessage;
use crate::{ssxl_info, ssxl_warn}; // ðŸ”¥ FIX 1: Use custom logger macros
// use crate::{godot_print, godot_warn}; // REMOVED: Replaced by ssxl_*
use std::collections::VecDeque;

pub struct AnimationWorker {
    _id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl AnimationWorker {
    pub fn new(
        id: usize,
        event_sender: Sender<AnimationEvent>,
        control_receiver: flume::Receiver<ControlMessage>,
        initial_config: AnimationConfig,
    ) -> Self {
        let handle = thread::spawn(move || {
            let mut current_config = initial_config;
            let mut simulation_state = init_simulation_state(&current_config);
            
            let mut target_fps = current_config.simulation_fps;
            let mut target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
            
            // ðŸ”¥ FIX 2: Replaced godot_print! with ssxl_info!
            ssxl_info!("Anim Worker {}: Started with target FPS: {}", id, target_fps);
            
            let mut is_running = true;
            while is_running {
                let frame_start_time = Instant::now();

                if let Ok(msg) = control_receiver.try_recv() {
                    match msg {
                        ControlMessage::Pause => is_running = false,
                        ControlMessage::Stop => break,
                        ControlMessage::UpdateConfig(new_config) => {
                            // ðŸ”¥ FIX 3: Replaced godot_print! with ssxl_info!
                            ssxl_info!("Anim Worker {}: Applying new config. New FPS: {}", id, new_config.simulation_fps);
                            current_config = new_config;
                            target_fps = current_config.simulation_fps;
                            target_frame_duration = Duration::from_secs_f64(1.0 / target_fps as f64);
                        }
                    }
                }
                
                if is_running {
                    let new_events = run_simulation_step(&mut simulation_state, &current_config);
                    
                    for event in new_events {
                        if event_sender.send(event).is_err() {
                            // ðŸ”¥ FIX 4: Replaced godot_warn! with ssxl_warn!
                            ssxl_warn!("Anim Worker {}: Conductor channel disconnected. Shutting down.", id);
                            break;
                        }
                    }
                }

                let elapsed_time = frame_start_time.elapsed();
                if elapsed_time < target_frame_duration {
                    thread::sleep(target_frame_duration - elapsed_time);
                }
            }
            // ðŸ”¥ FIX 5: Replaced godot_print! with ssxl_info!
            ssxl_info!("Anim Worker {} finished loop and exiting thread.", id);
        });

        AnimationWorker { _id: id, handle: Some(handle) }
    }
    
    pub fn join(mut self) {
        if let Some(handle) = self.handle.take() {
            let _ = handle.join();
        }
    }
}

struct SimulationState {
    last_update_time: Instant,
}

fn init_simulation_state(_config: &AnimationConfig) -> SimulationState {
    SimulationState { last_update_time: Instant::now() }
}

fn run_simulation_step(state: &mut SimulationState, _config: &AnimationConfig) -> VecDeque<AnimationEvent> {
    let now = Instant::now();
    let events = if (now - state.last_update_time) > Duration::from_millis(100) {
        state.last_update_time = now;
        let event = AnimationEvent::SetTileAnimation { 
            layer: 0, 
            coords: (10, 5), 
            frame_index: (now.elapsed().as_secs() % 4) as i32 
        };
        VecDeque::from([event])
    } else {
        VecDeque::new()
    };
    
    events
}
// --- END: rust/ssxl_ext/src\animate_worker.rs ---
        15 LOC | rust/ssxl_ext/src\api_registry.rs
// --- START: rust/ssxl_ext/src\api_registry.rs ---
use std::sync::Mutex;
use once_cell::sync::Lazy;

/// Global registry of exported GDScript API methods.
pub static API_REGISTRY: Lazy<Mutex<Vec<String>>> =
    Lazy::new(|| Mutex::new(Vec::new()));

/// Called by macros to register a method signature.
pub fn register_api(method: &str) {
    API_REGISTRY.lock().unwrap().push(method.to_string());
}

/// Returns a copy of the registered API list.
pub fn list_api() -> Vec<String> {
    API_REGISTRY.lock().unwrap().clone()
}

#[macro_export]
macro_rules! export_api {
    ($sig:expr) => {{
        $crate::api_registry::register_api($sig);
    }};
}

// --- END: rust/ssxl_ext/src\api_registry.rs ---
        78 LOC | rust/ssxl_ext/src\bridge_ffi.rs
// --- START: rust/ssxl_ext/src\bridge_ffi.rs ---
// ------------------------------------------------------------
// Godot binding imports (only when building the Godot binding).
// ------------------------------------------------------------
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::obj::InstanceId;

// CLI / non-Godot builds use a simple integer ID.
#[cfg(not(feature = "godot-binding"))]
type RawInstanceId = i64;

use crate::shared_tile::TileData;

// In Plan B, we only have one logical "layer" of chunk data.
#[cfg(feature = "godot-binding")]
const CHUNK_DATA_LAYER: i32 = 0;

// âœ… Plan B: use SSXLChunkBuffer, not SSXLTileMap.
#[cfg(feature = "godot-binding")]
use crate::ssxl_chunk_buffer::SSXLChunkBuffer;

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   FFI: ssxl_get_tilemap_chunk_ptr (Plan B: SSXLChunkBuffer)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
/// Godot build: resolve an instance ID to SSXLChunkBuffer and
/// return a raw pointer to the chunk's TileData buffer.
#[cfg(feature = "godot-binding")]
#[no_mangle]
pub unsafe extern "C" fn ssxl_get_tilemap_chunk_ptr(
    tilemap_id_raw: i64,
    chunk_x: i32,
    chunk_y: i32,
) -> *mut TileData {
    let instance_id = InstanceId::from_i64(tilemap_id_raw);

    // âœ… Retrieve SSXLChunkBuffer by instance ID
    let mut chunk_buffer = match Gd::<SSXLChunkBuffer>::try_from_instance_id(instance_id) {
        Ok(cb) => cb,
        Err(_) => {
            crate::ssxl_error!(
                "SSXL FFI: Failed to retrieve SSXLChunkBuffer object for ID {}",
                tilemap_id_raw
            );
            return std::ptr::null_mut();
        }
    };

    // âœ… Call the native Rust method directly (Plan B)
    let raw_ptr = chunk_buffer
        .bind_mut()
        .get_raw_chunk_data_ptr(CHUNK_DATA_LAYER, chunk_x, chunk_y);

    if raw_ptr.is_null() {
        crate::ssxl_error!(
            "SSXL FFI: SSXLChunkBuffer returned NULL pointer for chunk ({}, {})",
            chunk_x,
            chunk_y
        );
    }

    raw_ptr as *mut TileData
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   CLI fallback (no Godot binding)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
#[cfg(not(feature = "godot-binding"))]
#[no_mangle]
pub unsafe extern "C" fn ssxl_get_tilemap_chunk_ptr(
    tilemap_id_raw: RawInstanceId,
    chunk_x: i32,
    chunk_y: i32,
) -> *mut TileData {
    let _id = tilemap_id_raw;
    let _cx = chunk_x;
    let _cy = chunk_y;

    eprintln!("FFI_EXPORT: CLI MOCK: get_tilemap_chunk_ptr() called (Godot disabled)");
    std::ptr::null_mut()
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   FFI: ssxl_notify_chunk_updated
//   Plan B: now actually triggers SSXLChunkBuffer notification
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
/// Godot build: notify that a chunk's data has changed.
/// In Plan B, the renderer reads SSXLChunkBuffer directly; this
/// hook is used to trigger renderer updates after the core write.
#[cfg(feature = "godot-binding")]
#[no_mangle]
pub unsafe extern "C" fn ssxl_notify_chunk_updated(
    tilemap_id_raw: i64,
    chunk_x: i32,
    chunk_y: i32,
) {
    let instance_id = InstanceId::from_i64(tilemap_id_raw);

    // âœ… Retrieve SSXLChunkBuffer, not TileMap
    let mut chunk_buffer = match Gd::<SSXLChunkBuffer>::try_from_instance_id(instance_id) {
        Ok(cb) => cb,
        Err(_) => {
            crate::ssxl_warn!(
                "SSXL FFI: Cannot notify update â€” invalid SSXLChunkBuffer ID {}",
                tilemap_id_raw
            );
            return;
        }
    };

    // âœ… Notify SSXLChunkBuffer that data for this chunk has changed.
    // This will emit the appropriate signal (chunk_ready/chunk_updated),
    // which your Godot side can use to call SSXLRenderer.apply_chunk(cx, cy).
    chunk_buffer
        .bind_mut()
        .notify_chunk_data_changed(chunk_x, chunk_y);
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   CLI fallback (no Godot binding)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
#[cfg(not(feature = "godot-binding"))]
#[no_mangle]
pub unsafe extern "C" fn ssxl_notify_chunk_updated(
    tilemap_id_raw: RawInstanceId,
    chunk_x: i32,
    chunk_y: i32,
) {
    let _id = tilemap_id_raw;
    let _cx = chunk_x;
    let _cy = chunk_y;

    eprintln!(
        "FFI_EXPORT: CLI MOCK: notify_chunk_updated({}, {})",
        _cx, _cy
    );
}

// --- END: rust/ssxl_ext/src\bridge_ffi.rs ---
        71 LOC | rust/ssxl_ext/src\bridge_oracle.rs
// --- START: rust/ssxl_ext/src\bridge_oracle.rs ---
use crate::shared_math::ChunkCoords;
use crate::ssxl_warn;
use flume::{Receiver, Sender};
use crate::host_state::get_host_state;
use crate::tools::Profiler;

#[derive(Debug, Clone)]
pub enum OracleQuery {
    GetChunkHardness(ChunkCoords),
    GetGlobalTimeOfDay,
    IsTileBlocked(i32, i32),
}

#[derive(Debug, Clone)]
pub enum OracleResponse {
    ChunkHardness(f64),
    GlobalTimeOfDay(f32),
    TileBlockedStatus(bool),
    Error(String),
}

pub struct OracleRequest {
    pub query: OracleQuery,
    pub response_sender: flume::Sender<OracleResponse>,
}

pub struct OracleConductor {
    pub request_receiver: Receiver<OracleRequest>,
    pub request_sender: Sender<OracleRequest>,
}

impl OracleConductor {
    pub fn new() -> Self {
        let (request_sender, request_receiver) = flume::unbounded();
        OracleConductor { request_receiver, request_sender }
    }

    pub fn poll_and_process(&self) {
        let mut processed_count = 0;
        let _p = Profiler::start("Oracle Poll");
        
        while processed_count < 10 {
            match self.request_receiver.try_recv() {
                Ok(request) => {
                    let response = self.handle_query(request.query);
                    
                    let _ = request.response_sender.send(response);
                    
                    processed_count += 1;
                },
                Err(flume::TryRecvError::Empty) => break,
                Err(flume::TryRecvError::Disconnected) => {
                    ssxl_warn!("Oracle Conductor: Request channel disconnected.");
                    break;
                }
            }
        }
    }

    fn handle_query(&self, query: OracleQuery) -> OracleResponse {
        let _host_state = get_host_state();

        match query {
            OracleQuery::GetGlobalTimeOfDay => {
                OracleResponse::GlobalTimeOfDay(0.5)
            }
            OracleQuery::IsTileBlocked(_x, _y) => {
                OracleResponse::TileBlockedStatus(false)
            }
            _ => OracleResponse::Error("Query not implemented".to_string()),
        }
    }
}

#[derive(Clone)]
pub struct OracleClient {
    request_sender: Sender<OracleRequest>,
}

impl OracleClient {
    pub fn query_blocking(&self, query: OracleQuery) -> Result<OracleResponse, String> {
        let (response_sender, response_receiver) = flume::bounded(1);
        
        let request = OracleRequest { query, response_sender };
        self.request_sender.send(request).map_err(|e| format!("Failed to send query: {}", e))?;

        response_receiver.recv().map_err(|e| format!("Failed to receive response: {}", e))
    }
}
// --- END: rust/ssxl_ext/src\bridge_oracle.rs ---
        16 LOC | rust/ssxl_ext/src\bridge_signals.rs
// --- START: rust/ssxl_ext/src\bridge_signals.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::classes::Engine;

use crate::shared_types::InstanceType;   // âœ… FIXED: correct import

#[cfg(feature = "godot-binding")]
pub fn emit_generation_finished(tilemap_id: InstanceType) {
    let mut engine_singleton: Gd<Engine> = Engine::singleton();
    engine_singleton.call("emit_signal", &[
        "generation_complete".to_variant(),
        tilemap_id.to_variant(),
    ]);
}

#[cfg(not(feature = "godot-binding"))]
pub fn emit_generation_finished(tilemap_id: InstanceType) {
    eprintln!(
        "INFO: CLI Mode - Skipped emitting generation_finished signal for ID: {}",
        tilemap_id
    );
}

// --- END: rust/ssxl_ext/src\bridge_signals.rs ---
        49 LOC | rust/ssxl_ext/src\cache.rs
// --- START: rust/ssxl_ext/src\cache.rs ---
// rust/SSXL-ext/src/cache.rs

use dashmap::DashMap; // High-performance concurrent hash map
use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords; 

// --- FIX: Import logging macros from the crate root ---
use crate::{ssxl_info, ssxl_warn}; 

// --------------------------------------------------------------------------
// --- Chunk Cache (Final Results) ---
// --------------------------------------------------------------------------

/// Stores the final, processed Chunk results (post-CA, post-refinement).
/// This is used by the Conductor to check if a chunk needs generation 
/// or is already complete.
pub struct ChunkCache {
    // Key: (ChunkX, ChunkY)
    // Value: The final Chunk struct
    cache: DashMap<ChunkCoords, Chunk>,
}

impl ChunkCache {
    pub fn new() -> Self {
        ChunkCache {
            // Initialize with a default capacity
            cache: DashMap::with_capacity(4096), 
        }
    }

    /// Attempts to retrieve a chunk from the cache.
    /// Returns None if the chunk has not been generated yet.
    pub fn get(&self, coords: ChunkCoords) -> Option<Chunk> {
        // Clone the value out of the DashMap entry
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Inserts a newly generated chunk into the cache.
    /// This is called by a worker thread right before sending the chunk to the Conductor.
    pub fn insert(&self, chunk: Chunk) {
        let coords = chunk.position;
        self.cache.insert(coords, chunk);
        ssxl_info!("Chunk Cache: Stored chunk {:?}", coords);
    }
    
    /// Checks if the cache contains the chunk at the given coordinates.
    pub fn contains(&self, coords: ChunkCoords) -> bool {
        self.cache.contains_key(&coords)
    }
    
    /// Clears all entries from the cache (e.g., on world reset).
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Chunk Cache: Cleared all stored chunks.");
    }
}

// --------------------------------------------------------------------------
// --- Noise Cache (Intermediate Data) ---
// --------------------------------------------------------------------------

/// Stores raw Perlin noise output for a chunk. 
/// Useful for neighbor queries in CA simulations without recalculating Perlin noise.
pub struct NoiseCache {
    // Key: (ChunkX, ChunkY)
    // Value: A simple vector of raw f64 noise values
    cache: DashMap<ChunkCoords, Vec<f64>>, 
}

impl NoiseCache {
    pub fn new() -> Self {
        NoiseCache {
            cache: DashMap::with_capacity(2048), // Smaller capacity than ChunkCache
        }
    }

    /// Retrieves raw noise values. Used by generate_ca.rs to peek at neighbors' initial state.
    pub fn get_noise_data(&self, coords: ChunkCoords) -> Option<Vec<f64>> {
        // Clone the noise data vector
        self.cache.get(&coords).map(|entry| entry.value().clone())
    }

    /// Stores the raw noise values immediately after generation in generate_perlin.rs.
    pub fn insert_noise_data(&self, coords: ChunkCoords, noise_data: Vec<f64>) {
        self.cache.insert(coords, noise_data);
    }

    /// Clears all entries from the cache.
    pub fn clear(&self) {
        self.cache.clear();
        ssxl_warn!("Noise Cache: Cleared all stored noise data.");
    }
}
// --- END: rust/ssxl_ext/src\cache.rs ---
        70 LOC | rust/ssxl_ext/src\config.rs
// --- START: rust/ssxl_ext/src\config.rs ---
// rust/SSXL-ext/src/config.rs

use serde::{Deserialize, Serialize};
use std::fs;
use std::default::Default; // Required for Default implementation

// --- FIX: Remove Godot-dependent macro imports ---
// We remove the imports for ssxl_info, ssxl_warn, ssxl_error
// and replace them with eprintln! in the logic below.

use crate::shared_error::SSXLCoreError;

// Import the configuration structs from the designated shared location
use crate::shared_config::{
    ThreadingConfig, MapSettingsConfig, GenerationConfig, AnimationConfig // Assuming AnimationConfig is here too
};

// --------------------------------------------------------------------------
// --- GlobalConfig Structure (The Root) ---
// --------------------------------------------------------------------------

/// The main configuration loaded at runtime by host_init.rs
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct GlobalConfig {
    #[serde(default)]
    pub threading: ThreadingConfig,
    #[serde(default)]
    pub map_settings: MapSettingsConfig,
    #[serde(default)]
    pub generation: GenerationConfig,
    // Include AnimationConfig for completeness based on the manifest
    #[serde(default)]
    pub animation: AnimationConfig,
}

impl GlobalConfig {
    const CONFIG_FILE_PATH: &'static str = "ssxl_config.toml";
    
    /// Attempts to load the configuration from a file, falling back to defaults 
    /// and saving the default if the file is missing.
    pub fn load_or_default() -> Result<Self, SSXLCoreError> {
        // FIX: Use standard console output (eprintln!) instead of ssxl_info!
        eprintln!("INFO: Attempting to load configuration from: {}.", Self::CONFIG_FILE_PATH);

        match fs::read_to_string(Self::CONFIG_FILE_PATH) {
            Ok(content) => {
                // Deserialize the TOML content into the GlobalConfig struct
                match toml::from_str(&content) {
                    Ok(config) => {
                        // FIX: Use standard console output
                        eprintln!("INFO: Successfully loaded SSXL configuration.");
                        Ok(config)
                    }
                    Err(e) => {
                        // FIX: Use standard console output
                        eprintln!("ERROR: Failed to parse TOML configuration: {}. Using default settings.", e);
                        // Use SSXLCoreError to wrap the TOML parsing failure
                        Err(SSXLCoreError::InvalidConfig(format!("TOML deserialization failed: {}", e)))
                    }
                }
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                // File not found, use default settings
                let default_config = Self::default();
                // FIX: Use standard console output
                eprintln!("WARN: Configuration file not found ({}). Using default settings.", Self::CONFIG_FILE_PATH);

                // Optionally write the default config back to disk for easy editing
                if default_config.save_to_disk().is_err() {
                    // FIX: Use standard console output
                    eprintln!("ERROR: Could not save default configuration file.");
                }
                
                Ok(default_config)
            }
            Err(e) => {
                // FIX: Use standard console output
                eprintln!("ERROR: I/O Error reading config file: {}", e);
                Err(SSXLCoreError::FFIWriteError(format!("Config file I/O failure: {}", e)))
            }
        }
    }
    
    /// Saves the current configuration structure back to the TOML file.
    pub fn save_to_disk(&self) -> Result<(), SSXLCoreError> {
        match toml::to_string_pretty(self) {
            Ok(toml_string) => {
                match fs::write(Self::CONFIG_FILE_PATH, toml_string) {
                    Ok(_) => Ok(()),
                    Err(e) => {
                        Err(SSXLCoreError::FFIWriteError(format!("Failed to write config file: {}", e)))
                    }
                }
            },
            Err(e) => {
                Err(SSXLCoreError::InvalidConfig(format!("Failed to serialize TOML: {}", e)))
            }
        }
    }
}

// Provide sensible defaults for easy startup
impl Default for GlobalConfig {
    fn default() -> Self {
        Self {
            // Note: These must rely on the Default impls being in `shared_config.rs`
            threading: ThreadingConfig::default(),
            map_settings: MapSettingsConfig::default(),
            generation: GenerationConfig::default(),
            animation: AnimationConfig::default(),
        }
    }
}
// --- END: rust/ssxl_ext/src\config.rs ---
         7 LOC | rust/ssxl_ext/src\generate_anim_conductor.rs
// --- START: rust/ssxl_ext/src\generate_anim_conductor.rs ---
// src/generate_anim_conductor.rs

// Define the public structure mentioned in host_state.rs
pub struct AnimConductor {
    // ... fields will go here
}

impl AnimConductor {
    pub fn new() -> Self {
        // Initialize fields here
        AnimConductor {}
    }
}
// --- END: rust/ssxl_ext/src\generate_anim_conductor.rs ---
       122 LOC | rust/ssxl_ext/src\generate_batch_processor.rs
// --- START: rust/ssxl_ext/src\generate_batch_processor.rs ---
use crate::shared_job::{GenerationJob, JobStep};
use crate::generate_perlin;
use crate::generate_ca;
use crate::shared_error::SSXLCoreError;
use crate::shared_config::GenerationConfig;
use std::mem;

/// Executes the next required step for the given GenerationJob.
///
/// This version is CAâ€‘ready: the CA call is isolated so we can later
/// replace it with a neighborâ€‘aware / haloâ€‘based CA without touching
/// the rest of the pipeline.
///
/// IMPORTANT: This function runs on worker threads and MUST NOT touch
/// Godot bindings or use ssxl_* logging. Only pure Rust + `eprintln!`.
pub fn process_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<GenerationJob, SSXLCoreError> {
    eprintln!(
        "[batch] ENTER job {:?} at step {:?}",
        job.id,
        job.current_step
    );

    let result = match job.current_step {
        // ------------------------------------------------------------
        // STEP 1: PERLIN NOISE GENERATION
        // ------------------------------------------------------------
        JobStep::NoiseGeneration => {
            eprintln!("[batch] job {:?} â†’ NoiseGeneration", job.id);

            let generator = generate_perlin::NoiseGenerator::new(
                config.perlin,
                config.world_seed,
            );

            // Move out chunk data for processing.
            let chunk_to_process = mem::take(&mut job.chunk_data);
            eprintln!(
                "[batch] job {:?} NoiseGeneration starting on chunk at {:?}",
                job.id,
                chunk_to_process.position
            );

            let perlin_result =
                generate_perlin::generate_noise_map(chunk_to_process, &generator);
            eprintln!(
                "[batch] job {:?} NoiseGeneration result = {:?}",
                job.id,
                perlin_result.as_ref().map(|c| c.position)
            );

            match perlin_result {
                Ok(chunk) => {
                    job.chunk_data = chunk;
                    Ok(())
                }
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!(
                    "Perlin failed: {}",
                    e
                ))),
            }
        }

        // ------------------------------------------------------------
        // STEP 2: CELLULAR AUTOMATA REFINEMENT
        // ------------------------------------------------------------
        JobStep::CARefinement => {
            eprintln!("[batch] job {:?} â†’ CARefinement", job.id);

            let chunk_to_process = mem::take(&mut job.chunk_data);
            eprintln!(
                "[batch] job {:?} CARefinement starting on chunk at {:?}",
                job.id,
                chunk_to_process.position
            );

            let ca_result = generate_ca::simulate_ca(chunk_to_process, config.ca.into());
            eprintln!(
                "[batch] job {:?} CARefinement result = {:?}",
                job.id,
                ca_result.as_ref().map(|c| c.position)
            );

            match ca_result {
                Ok(chunk) => {
                    job.chunk_data = chunk;
                    Ok(())
                }
                Err(e) => Err(SSXLCoreError::GenerationDataError(format!(
                    "CA failed: {}",
                    e
                ))),
            }
        }

        // ------------------------------------------------------------
        // STEP 3: POSTâ€‘PROCESSING
        // ------------------------------------------------------------
        JobStep::PostProcessing => {
            eprintln!(
                "[batch] job {:?} â†’ PostProcessing (no-op placeholder)",
                job.id
            );
            Ok(())
        }

        // ------------------------------------------------------------
        // TERMINAL STATES
        // ------------------------------------------------------------
        JobStep::Queued | JobStep::Finished | JobStep::Failed => {
            eprintln!(
                "[batch] job {:?} received in terminal step {:?} (ERROR)",
                job.id,
                job.current_step
            );
            Err(SSXLCoreError::InvalidConductorState(format!(
                "Job received in terminal step: {:?}",
                job.current_step
            )))
        }
    };

    match result {
        Ok(_) => {
            let prev = job.current_step;
            job.advance_step();
            eprintln!(
                "[batch] job {:?} step advanced {:?} -> {:?}",
                job.id,
                prev,
                job.current_step
            );
            eprintln!(
                "[batch] EXIT job {:?} with success at new step {:?}",
                job.id,
                job.current_step
            );
            Ok(job)
        }
        Err(e) => {
            eprintln!(
                "[batch] job {:?} failed at step {:?}, marking Failed",
                job.id,
                job.current_step
            );
            job.current_step = JobStep::Failed;
            eprintln!(
                "[batch] EXIT job {:?} with error, state = Failed",
                job.id
            );
            Err(e)
        }
    }
}

// --- END: rust/ssxl_ext/src\generate_batch_processor.rs ---
        70 LOC | rust/ssxl_ext/src\generate_ca.rs
// --- START: rust/ssxl_ext/src\generate_ca.rs ---
use crate::shared_config::CellularAutomataConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;

/// Defines the rule set for the Cellular Automata simulation.
/// Uses specific parameters for Cave/Wall generation.
#[derive(Debug, Clone, Copy)]
pub struct CaRules {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl From<CellularAutomataConfig> for CaRules {
    fn from(config: CellularAutomataConfig) -> Self {
        CaRules {
            death_limit: config.death_limit,
            birth_limit: config.birth_limit,
            steps: config.steps,
        }
    }
}

/// Public entry point: run CA on a single chunk.
/// 
/// CA is now disabled â€” the chunk is returned unchanged.
/// This prevents CA from wiping out Perlin or patternâ€‘generated tiles.
pub fn simulate_ca(chunk: Chunk, _rules: CaRules) -> Result<Chunk, String> {
    Ok(chunk)
}

/// Checks the state (e.g., TileID) to determine if a tile is "live" (a wall/solid).
fn is_live(tile: TileData) -> bool {
    tile.tile_id > 0
}

fn make_live_tile() -> TileData {
    TileData {
        tile_id: 1,
        atlas_coords: 0,
        rotation_flags: 0,
        custom_data: 0,
    }
}

fn make_dead_tile() -> TileData {
    TileData {
        tile_id: 0,
        atlas_coords: 0,
        rotation_flags: 0,
        custom_data: 0,
    }
}

/// Chunkâ€‘local neighbor count (unused now, but kept for future CA reâ€‘enable).
fn count_live_neighbors_chunk_local(
    tiles: &[TileData],
    size: usize,
    cx: i32,
    cy: i32,
) -> u8 {
    let mut count = 0;

    for dy in -1..=1 {
        for dx in -1..=1 {
            if dx == 0 && dy == 0 {
                continue;
            }

            let nx = cx + dx;
            let ny = cy + dy;

            if nx >= 0 && nx < size as i32 && ny >= 0 && ny < size as i32 {
                let idx = (ny as usize) * size + (nx as usize);
                if is_live(tiles[idx]) {
                    count += 1;
                }
            }
        }
    }

    count
}

/// Neighborâ€‘aware CA stub (unchanged).
pub fn simulate_ca_with_neighbors(
    chunk: Chunk,
    _rules: CaRules,
    _get_neighbor_tile: impl Fn(i32, i32) -> TileData,
) -> Result<Chunk, String> {
    Ok(chunk)
}

// --- END: rust/ssxl_ext/src\generate_ca.rs ---
        97 LOC | rust/ssxl_ext/src\generate_ca_simulation.rs
// --- START: rust/ssxl_ext/src\generate_ca_simulation.rs ---
// rust/SSXL-ext/src/generate_ca_simulation.rs

use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use crate::shared_config::CellularAutomataConfig;
use crate::cache::NoiseCache; // Required for boundary lookups
use crate::shared_error::SSXLCoreError;
// --- FIX: Correct module path from 'math' to 'shared_math' ---
use crate::shared_math::ChunkCoords;
// --- FIX: Import logging macro from the crate root ---
use crate::ssxl_info;

/// Runs the Cellular Automata simulation for the specified number of steps on the given chunk.
pub fn run_simulation_steps(
    mut chunk: Chunk,
    config: CellularAutomataConfig,
    // The Noise Cache is passed in so the CA can query neighbor chunks' initial states.
    noise_cache: &NoiseCache, 
    // The coordinates of the current chunk being processed.
    chunk_coords: ChunkCoords,
) -> Result<Chunk, SSXLCoreError> {
    
    // We need a secondary buffer to store the next state before applying it, 
    // ensuring all calculations use the data from the *start* of the step.
    let mut next_state_buffer = chunk.tiles.clone();
    
    ssxl_info!("CA Sim: Starting {} steps for chunk {:?}", config.steps, chunk_coords);

    for _step in 0..config.steps {
        
        for y in 0..chunk.size {
            for x in 0..chunk.size {
                
                // 1. Count Neighbors
                let live_neighbors = count_live_neighbors(
                    x as i32, 
                    y as i32, 
                    &chunk, 
                    chunk_coords, 
                    noise_cache
                );

                // 2. Apply Rules
                let current_tile = chunk.get_tile(x, y).unwrap();
                let next_state_tile = calculate_next_state(
                    current_tile, 
                    live_neighbors, 
                    &config
                );

                // 3. Stage Result in Buffer
                let index = chunk.get_index(x, y);
                next_state_buffer[index] = next_state_tile;
            }
        }
        
        // After iterating all tiles, swap the buffer to the current state for the next step.
        chunk.tiles.copy_from_slice(&next_state_buffer);
    }
    
    Ok(chunk)
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Counts the number of 'live' neighbors for a cell, handling cross-chunk boundary lookups.
fn count_live_neighbors(
    local_x: i32, 
    local_y: i32, 
    current_chunk: &Chunk,
    chunk_coords: ChunkCoords,
    noise_cache: &NoiseCache,
) -> u8 {
    let mut live_count = 0;
    let chunk_size = current_chunk.size as i32;
    
    // Iterates through a 3x3 grid centered on (local_x, local_y)
    for dy in -1..=1 {
        for dx in -1..=1 {
            if dx == 0 && dy == 0 { continue; } // Skip the center cell
            
            let neighbor_x = local_x + dx;
            let neighbor_y = local_y + dy;
            
            // --- Determine if the neighbor is INSIDE or OUTSIDE the current chunk ---
            if neighbor_x >= 0 && neighbor_x < chunk_size && neighbor_y >= 0 && neighbor_y < chunk_size {
                // INTERNAL NEIGHBOR (Fast lookup)
                if current_chunk.get_tile(neighbor_x as u32, neighbor_y as u32)
                    // The t in the closure is &TileData. We assume TileData implements Copy
                    // and is_live() takes self (by value) to force the dereference.
                    .map_or(false, |t| (*t).is_live()) 
                {
                    live_count += 1;
                }
            } else {
                // EXTERNAL NEIGHBOR (Requires a cache lookup, slower)
                // 1. Calculate the adjacent chunk coordinates
                let adjacent_chunk_coords = (
                    chunk_coords.0 + if neighbor_x < 0 { -1 } else if neighbor_x >= chunk_size { 1 } else { 0 },
                    chunk_coords.1 + if neighbor_y < 0 { -1 } else if neighbor_y >= chunk_size { 1 } else { 0 },
                );
                
                // 2. Calculate the local coordinates within the adjacent chunk
                let local_adj_x = neighbor_x.rem_euclid(chunk_size);
                let local_adj_y = neighbor_y.rem_euclid(chunk_size);

                // 3. Query the NoiseCache for the adjacent chunk's initial state
                if noise_cache.get_noise_data(adjacent_chunk_coords)
                    // FIX: Changed inner `map_or` to `map`. 
                    // and_then requires the closure to return Option<T>. 
                    // map returns Option<bool>, which satisfies and_then.
                    .and_then(|data| {
                        // Look up the tile's state in the cached noise data
                        let index = (local_adj_y * chunk_size + local_adj_x) as usize;
                        // Use map to convert Option<&NoiseValue> to Option<bool>
                        data.get(index).map(|&noise_val| noise_val > 0.5) 
                    })
                    .unwrap_or(false) 
                {
                    live_count += 1;
                }
            }
        }
    }
    live_count
}

// rust/SSXL-ext/src/generate_ca_simulation.rs

/// Applies the birth and death limits to determine the next state of a cell.
fn calculate_next_state(
    current_tile: &TileData,
    live_neighbors: u8,
    config: &CellularAutomataConfig,
) -> TileData {
    
    // Start with a copy of the current state
    let mut next_state = *current_tile;

    if current_tile.is_live() {
        // --- Live Cell (Survival/Death) ---
        // If live neighbors are LESS than the Death Limit, the cell dies (becomes 'dead').
        if live_neighbors < config.death_limit {
            next_state.set_live(false); // Method call will be found after implementing TileData::set_live
        }
    } else {
        // --- Dead Cell (Birth) ---
        // If live neighbors are GREATER than or equal to the Birth Limit, the cell is born (becomes 'live').
        if live_neighbors >= config.birth_limit {
            next_state.set_live(true); // Method call will be found after implementing TileData::set_live
        }
    }
    
    next_state
}
// --- END: rust/ssxl_ext/src\generate_ca_simulation.rs ---
       135 LOC | rust/ssxl_ext/src\generate_conductor.rs
// --- START: rust/ssxl_ext/src\generate_conductor.rs ---
use std::sync::Arc;
use std::sync::atomic::AtomicBool;
use std::sync::atomic::Ordering;
use std::collections::HashMap;

use flume::Receiver;

use crate::config::GlobalConfig;
use crate::sync_pool::SyncPool;

use crate::shared_message::GenerationDataMessage;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;

use crate::generate_conductor_state::{
    ConductorState,
    ConductorStateContainer,
    GenerationMetrics,
};

use crate::shared_math::ChunkCoords;
use crate::shared_chunk::Chunk;
use crate::shared_types::InstanceType;


pub struct GenerateConductor {
    state_container: ConductorStateContainer,
    thread_pool: SyncPool,
    chunk_receiver: Receiver<GenerationDataMessage>,

    /// NEW: stores generated chunks so CA can access neighbors.
    chunk_cache: HashMap<ChunkCoords, Chunk>,

    pub tilemap_target_id: InstanceType,   // âœ… now resolves correctly
    signal_emitted: AtomicBool,
}

impl GenerateConductor {
    pub fn new(num_workers: u32, config: Arc<GlobalConfig>) -> Self {
        let (pool, chunk_receiver) = SyncPool::new(num_workers as usize, config);
        let state_container = ConductorStateContainer::new();

        Self {
            state_container,
            thread_pool: pool,
            chunk_receiver,

            // âœ… NEW
            chunk_cache: HashMap::new(),

            tilemap_target_id: 1,
            signal_emitted: AtomicBool::new(false),
        }
    }
	
	pub fn start_generation(
		&mut self,
		tilemap_id: InstanceType,
		initial_jobs: Vec<GenerationJob>,
	) -> Result<(), SSXLCoreError> {
		if self.state_container.get_state() != ConductorState::Ready {
			eprintln!("WARN: Conductor is not ready to start generation.");
			return Err(SSXLCoreError::ConductorBusy);
		}

		self.signal_emitted.store(false, Ordering::SeqCst);
	
		self.tilemap_target_id = tilemap_id;
		let total_chunks = initial_jobs.len() as u32;
		self.state_container.set_total_chunks(total_chunks);
		self.state_container.transition_to(ConductorState::Generating);

		let mut submitted_count = 0;
		for job in initial_jobs {
			match self.thread_pool.submit_job(job) {
				Ok(_) => submitted_count += 1,
				Err(e) => {
					eprintln!("ERROR: Failed to submit job to worker pool: {:?}", e);
					return Err(SSXLCoreError::ChannelSendError(e.to_string()));
				}
			}
		}

		eprintln!("INFO: Generation started, submitted {} chunks.", submitted_count);
		Ok(())
	}

	pub fn get_metrics(&self) -> GenerationMetrics {
		self.state_container.get_metrics()
	}

	
	pub fn try_finalize_and_get_target_id(&self) -> Option<InstanceType> {
		if self.state_container.get_state() != ConductorState::Finished {
			return None;
		}

		match self.signal_emitted.swap(true, Ordering::SeqCst) {
			false => {
				let is_valid_id = self.tilemap_target_id != 0;

				if is_valid_id {
					Some(self.tilemap_target_id)
				} else {
					eprintln!("ERROR: Conductor cannot finalize: TileMap ID is invalid.");
					None
				}
			}
			true => None,
		}
	}

	
	pub fn shutdown(self) {
		eprintln!("INFO: GenerateConductor initiating shutdown (pool cleanup deferred to HostCleanup)...");
		eprintln!("INFO: GenerateConductor shut down successfully.");
	}

	pub fn get_state_container(&self) -> &ConductorStateContainer {
		&self.state_container
	}

    pub fn poll_chunks_and_render(&mut self) -> (u32, bool) {
        let mut chunks_rendered = 0;

        while let Ok(message) = self.chunk_receiver.try_recv() {
            match message {
                GenerationDataMessage::CompletedChunk(chunk) => {
                    let coords = chunk.position;

                    // âœ… NEW: store chunk for neighbor-aware CA
                    self.chunk_cache.insert(coords, chunk.clone());

                    // existing rendering logic
                    match crate::host_tilemap::render_chunk_direct(
                        self.tilemap_target_id,
                        chunk,
                    ) {
                        Ok(_) => {
                            chunks_rendered += 1;
                            self.state_container.increment_completed_chunks();
                        }
                        Err(e) => {
                            eprintln!("ERROR: Failed to directly render chunk: {:?}", e);
                        }
                    }
                }

                GenerationDataMessage::JobFailure(e) => {
                    eprintln!("ERROR: A worker job failed: {:?}", e);
                }

                GenerationDataMessage::Ack => {
                    eprintln!("WARN: Conductor received unexpected Ack message.");
                }
            }
        }

        let metrics = self.state_container.get_metrics();
        let is_finished =
            metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;

        if is_finished && self.state_container.get_state() == ConductorState::Generating {
            self.state_container.transition_to(ConductorState::Finished);

            // âœ… NEW: clear cache after generation is complete
            self.chunk_cache.clear();

            eprintln!("INFO: All chunks rendered. Generation finished.");
        }

        (chunks_rendered, is_finished)
    }

    /// NEW: expose neighbor lookup for CA
    pub fn get_chunk(&self, coords: ChunkCoords) -> Option<&Chunk> {
        self.chunk_cache.get(&coords)
    }
}

// --- END: rust/ssxl_ext/src\generate_conductor.rs ---
        65 LOC | rust/ssxl_ext/src\generate_conductor_state.rs
// --- START: rust/ssxl_ext/src\generate_conductor_state.rs ---
use std::fmt;
use std::sync::Mutex;
// --- FIX: Import logging macros from the crate root ---
use crate::ssxl_info;

// --------------------------------------------------------------------------
// --- ConductorState Enum ---
// --------------------------------------------------------------------------

/// Defines the current operational status of the Generation Conductor.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConductorState {
    /// Initial state before any build_map() call.
    Ready,          // âœ… Conductor begins ready to accept a build_map() + start_generation()
    /// The worker pool is actively generating chunks.
    Generating,
    /// Generation is complete, but the final cleanup/signals are pending.
    Finished,
    /// An unrecoverable error occurred (e.g., worker panic, channel failure).
    Error,
    /// Generation has been manually paused or terminated.
    Paused,
}

impl fmt::Display for ConductorState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

// --------------------------------------------------------------------------
// --- GenerationMetrics Struct ---
// --------------------------------------------------------------------------

/// Holds the volatile metrics of the current generation job.
#[derive(Debug, Clone, Copy)]
pub struct GenerationMetrics {
    /// The total number of chunks requested for generation.
    pub total_chunks: u32,
    /// The number of chunks successfully completed and rendered.
    pub completed_chunks: u32,
    /// The number of jobs that failed during processing.
    pub failed_jobs: u32,
    /// The instantaneous speed of processing (e.g., chunks per second).
    pub current_throughput: f32,
}

impl Default for GenerationMetrics {
    fn default() -> Self {
        GenerationMetrics {
            total_chunks: 0,
            completed_chunks: 0,
            failed_jobs: 0,
            current_throughput: 0.0,
        }
    }
}

// --------------------------------------------------------------------------
// --- ConductorStateContainer Struct (Thread-Safe Wrapper) ---
// --------------------------------------------------------------------------

/// A thread-safe container holding the Conductor's current state and metrics.
/// This is typically wrapped in an Arc<T> for shared, concurrent access.
pub struct ConductorStateContainer {
    // The current state (requires Mutex protection).
    state: Mutex<ConductorState>,
    // The current metrics (requires Mutex protection).
    metrics: Mutex<GenerationMetrics>,
}

impl ConductorStateContainer {
    pub fn new() -> Self {
        ConductorStateContainer {
            // âœ… FIX: Conductor starts in Ready state so build_map() â†’ start_generation() works
            state: Mutex::new(ConductorState::Ready),
            metrics: Mutex::new(GenerationMetrics::default()),
        }
    }

    /// Safely updates the state, logging the transition. (Main thread only)
    pub fn transition_to(&self, new_state: ConductorState) {
        let mut state = self.state.lock().unwrap();
        if *state != new_state {
            ssxl_info!("Conductor State Transition: {} -> {}", *state, new_state);
            *state = new_state;
        }
    }

    /// Safely reads the current state.
    pub fn get_state(&self) -> ConductorState {
        *self.state.lock().unwrap()
    }

    /// Safely reads the current metrics.
    pub fn get_metrics(&self) -> GenerationMetrics {
        *self.metrics.lock().unwrap()
    }

    /// Atomic update: Sets the total number of chunks to be generated.
    pub fn set_total_chunks(&self, count: u32) {
        self.metrics.lock().unwrap().total_chunks = count;
    }

    /// Atomic update: Increments the count of completed chunks.
    pub fn increment_completed_chunks(&self) {
        self.metrics.lock().unwrap().completed_chunks += 1;
    }

    /// Atomic update: Increments the count of failed jobs.
    pub fn increment_failed_jobs(&self) {
        self.metrics.lock().unwrap().failed_jobs += 1;
    }
}

// --- END: rust/ssxl_ext/src\generate_conductor_state.rs ---
        43 LOC | rust/ssxl_ext/src\generate_conductor_sync.rs
// --- START: rust/ssxl_ext/src\generate_conductor_sync.rs ---
// rust/SSXL-ext/src/generate_conductor_sync.rs

use flume::Receiver;
use crate::shared_message::{GenerationDataMessage, GenerationControlMessage};
use crate::generate_conductor_state::{ConductorStateContainer, ConductorState};
use crate::shared_chunk::Chunk;
use crate::tools::{ssxl_info, ssxl_error, Profiler};

// The maximum number of messages (completed chunks/errors) to process from the channel per frame.
// This is separate from the rendering budget but necessary to prevent channel backlog.
const MAX_MESSAGES_PER_FRAME: u32 = 32;

/// Polls the completed work channel, updates metrics, and stages chunks for rendering.
/// 
/// This is the synchronization point between the worker threads and the main thread state.
/// 
/// Returns: A vector of completed Chunks that are ready to be passed to the host_render.rs pacing layer.
pub fn poll_and_stage_completed_work(
    chunk_receiver: &Receiver<GenerationDataMessage>,
    state_container: &ConductorStateContainer,
) -> Vec<Chunk> {
    
    let mut completed_chunks_staged = Vec::new();
    let mut messages_processed = 0;
    
    // Use a profiler to track the time spent syncing channels
    let _p = Profiler::start("Conductor_Sync_Poll");

    // Loop until the channel is empty or the frame budget is hit
    while messages_processed < MAX_MESSAGES_PER_FRAME {
        
        match chunk_receiver.try_recv() {
            Ok(message) => {
                messages_processed += 1;
                
                match message {
                    GenerationDataMessage::CompletedChunk(chunk) => {
                        // 1. Update Metrics
                        state_container.increment_completed_chunks();
                        
                        // 2. Stage for Rendering
                        // The chunk is now safe on the main thread and ready for Godot API calls.
                        completed_chunks_staged.push(chunk);
                    },
                    
                    GenerationDataMessage::JobFailure(e) => {
                        // 1. Update Metrics (may or may not count as completed, depending on policy)
                        state_container.increment_failed_jobs();
                        
                        // 2. Transition State
                        state_container.transition_to(ConductorState::Error);
                        
                        ssxl_error!("Generation Worker Failed: {}", e);
                    },
                    
                    GenerationDataMessage::Ack => {
                        // Worker status acknowledgement (e.g., worker started)
                        // Ignore but count towards the budget.
                    }
                }
            },
            
            Err(flume::TryRecvError::Empty) => {
                // Channel is temporarily empty. Exit the loop.
                break;
            },
            
            Err(flume::TryRecvError::Disconnected) => {
                // Worker pool channel has been closed (workers shut down unexpectedly).
                ssxl_error!("Worker pool channel disconnected. Generation likely failed or was terminated.");
                state_container.transition_to(ConductorState::Error);
                break;
            }
        }
    }
    
    completed_chunks_staged
}
// --- END: rust/ssxl_ext/src\generate_conductor_sync.rs ---
        44 LOC | rust/ssxl_ext/src\generate_manager.rs
// --- START: rust/ssxl_ext/src\generate_manager.rs ---
// rust/SSXL-ext/src/generate_manager.rs

use crate::sync_pool::SyncPool;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_config::GenerationConfig;
use crate::shared_error::SSXLCoreError;
use crate::{ssxl_error, ssxl_info};
// FIX 1: Remove godot::prelude::* if it's not strictly necessary for the GenerationManager logic
// or keep it commented out to prevent accidental Godot-dependent calls in the CLI context.
// use godot::prelude::*; // Commented out to reduce surface area for Godot dependency checks

/// The functional engine that manages the submission of generation jobs
/// to the worker pool.
pub struct GenerationManager {
    // A reference to the thread pool implementation (held by the HostState)
    pool: SyncPool,
    // The current global generation configuration
    // âœ… FIX WARNING: Renamed to `_config` to silence the 'never read' warning.
    _config: GenerationConfig,
}

impl GenerationManager {
    /// Creates a new manager, typically called during host_init.rs.
    // Updated parameter name to match the struct field.
    pub fn new(pool: SyncPool, config: GenerationConfig) -> Self {
        GenerationManager { pool, _config: config }
    }

    /// Provides a high-level function to start processing a batch of tasks.
    /// This is called by the GenerateConductor when generation starts.
    pub fn submit_job_batch(&self, tasks: Vec<GenerationTask>) -> Result<usize, SSXLCoreError> {
        let mut jobs_submitted = 0;
        
        // --- 1. Map Tasks to Jobs and Submit ---
        for task in tasks {
            // Create the full, multi-stage GenerationJob structure
            let job = GenerationJob::new(task);
            
            // Extract the job ID before moving the job into submit_job.
            let job_id = job.id;

            // Submit the job to the worker pool's queue (job is moved here)
            match self.pool.submit_job(job) {
                Ok(_) => jobs_submitted += 1,
                Err(e) => {
                    // Uses the extracted job_id for the error log, preventing the borrow-after-move error.
                    ssxl_error!("Generation Manager: Failed to submit job {:?}. Pool likely disconnected or full: {}", job_id, e);
                    // On first error, we might stop and return the error
                    return Err(SSXLCoreError::ChannelSendError(e.to_string()));
                }
            }
        }

        // --- 2. Update Conductor State ---
        
        ssxl_info!("Generation Manager: Submitted {} multi-stage jobs to the pool.", jobs_submitted);
        Ok(jobs_submitted)
    }

    /// Retrieves the current status of the worker pool (useful for debugging).
    pub fn get_pool_status(&self) -> (u32, usize) {
        let (worker_count, queue_size) = self.pool.get_status();
        (worker_count as u32, queue_size)
    }
}


// ============================================================================
// FFI EXPORTS (MOCKS required for ssxl_cli linking) - KEEP THESE HERE!
// These must use eprintln! instead of godot_print! when run from the CLI.
// ============================================================================

/// EXPORT 3/5: Called by CLI to stress the raw computation layer.
#[no_mangle]
pub extern "C" fn ssxl_ext_generate_noise_chunk(x: i32, y: i32, size: i32, seed: u64) {
    // ðŸ”¥ FIX 2: Replaced godot_print! with eprintln! to prevent Godot runtime panic.
    eprintln!("FFI_EXPORT: CLI triggered HEAVY NOISE GENERATION MOCK for chunk ({}, {}) size {} with seed {}",
                 x, y, size, seed);
}

/// EXPORT 4/5: Called by CLI to test the boundary matching data structure.
#[no_mangle]
pub extern "C" fn ssxl_ext_verify_chunk_boundary(chunk_x: i32, chunk_y: i32, neighbor_x: i32, neighbor_y: i32) -> bool {
    // ðŸ”¥ FIX 3: Replaced godot_print! with eprintln! to prevent Godot runtime panic.
    eprintln!("FFI_EXPORT: CLI checking boundary MOCK between chunk ({}, {}) and ({}, {})",
                 chunk_x, chunk_y, neighbor_x, neighbor_y);
    true
}
// --- END: rust/ssxl_ext/src\generate_manager.rs ---
        51 LOC | rust/ssxl_ext/src\generate_perlin.rs
// --- START: rust/ssxl_ext/src\generate_perlin.rs ---
use crate::shared_config::PerlinNoiseConfig;
use crate::shared_chunk::Chunk;
use crate::shared_tile::TileData;
use noise::{Fbm, Perlin, MultiFractal};

/// Holds the initialized noise generator and configuration.
pub struct NoiseGenerator {
    fbm: Fbm<Perlin>,
    config: PerlinNoiseConfig,
}

impl NoiseGenerator {
    /// Creates a generator instance from configuration.
    pub fn new(config: PerlinNoiseConfig, seed: u64) -> Self {
        let fbm: Fbm<Perlin> = Fbm::<Perlin>::new(seed as u32)
            .set_octaves(config.octaves)
            .set_lacunarity(config.lacunarity)
            .set_persistence(config.persistence);

        NoiseGenerator { fbm, config }
    }
}

/// Checkerboard generator (replaces Perlin for debugging).
pub fn generate_noise_map(
    mut chunk: Chunk,
    _generator: &NoiseGenerator,
) -> Result<Chunk, String> {

    // Real atlas tile IDs (u16!)
    const TILE_BLACK: u16 = 430; // (14, 13)
    const TILE_BLUE:  u16 = 431; // (15, 13)

    let s = chunk.size;
    let total = (s * s) as usize;

    // Ensure tile buffer is sized
    chunk.tiles.resize(total, TileData::default());

    let mut debug_first = true;

    for ly in 0..s {
        for lx in 0..s {

            // Global checkerboard (continues across chunks)
            let world_x = chunk.position.0 * s as i32 + lx as i32;
            let world_y = chunk.position.1 * s as i32 + ly as i32;

            let is_even = ((world_x + world_y) % 2) == 0;

            let tile_data = TileData {
                tile_id: if is_even { TILE_BLACK } else { TILE_BLUE },
                atlas_coords: 0,
                rotation_flags: 0,
                custom_data: 0,
            };

            if debug_first {
                eprintln!(
                    "[Checkerboard] DEBUG first tile: world=({}, {}) local=({}, {}) tile_id={}",
                    world_x, world_y, lx, ly, tile_data.tile_id
                );
                debug_first = false;
            }

            let index = (ly * s + lx) as usize;
            chunk.tiles[index] = tile_data;
        }
    }

    Ok(chunk)
}

// --- END: rust/ssxl_ext/src\generate_perlin.rs ---
        98 LOC | rust/ssxl_ext/src\generate_runtime.rs
// --- START: rust/ssxl_ext/src\generate_runtime.rs ---
// rust/SSXL-ext/src/generate_runtime.rs

use std::time::Instant;

use crate::shared_job::{GenerationJob, JobStep};
use crate::shared_config::GenerationConfig;
use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;
use crate::generate_batch_processor;

/// Worker-thread entry point.
/// MUST NOT TOUCH GODOT BINDINGS OR GODOT LOGGING.
/// Only pure Rust + eprintln! is allowed here.
pub fn run_generation_job(
    mut job: GenerationJob,
    config: &GenerationConfig,
) -> Result<Chunk, SSXLCoreError> {
    let start = Instant::now();

    eprintln!(
        "[runtime] ENTER job {:?} at initial step {:?}",
        job.id,
        job.current_step
    );

    // Step correction
    if job.current_step == JobStep::Queued {
        eprintln!(
            "[runtime] job {:?} Queued â†’ advancing to NoiseGeneration",
            job.id
        );
        job.advance_step();
    }

    // --- Multi-step execution loop ---
    while job.current_step != JobStep::Finished && job.current_step != JobStep::Failed {
        eprintln!(
            "[runtime] loop start job {:?}, current_step = {:?}",
            job.id,
            job.current_step
        );

        let job_id = job.id;
        let step = job.current_step;

        eprintln!(
            "[runtime] calling process_generation_job for job {:?} at step {:?}",
            job_id,
            step
        );

        let result = generate_batch_processor::process_generation_job(job, config);

        match result {
            Ok(next_job) => {
                eprintln!(
                    "[runtime] process_generation_job OK for job {:?} at step {:?} â†’ next_step = {:?}",
                    job_id,
                    step,
                    next_job.current_step
                );
                job = next_job;
            }
            Err(e) => {
                eprintln!(
                    "[runtime] job {:?} FAILED at step {:?}: {:?}",
                    job_id,
                    step,
                    e
                );
                let elapsed = start.elapsed();
                eprintln!(
                    "[runtime] EXIT job {:?} with ERROR after {:.3}ms",
                    job_id,
                    elapsed.as_secs_f64() * 1000.0
                );
                return Err(e);
            }
        }
    }

    // --- Terminal state ---
    let elapsed = start.elapsed();
    eprintln!(
        "[runtime] job {:?} EXIT loop with terminal step {:?} after {:.3}ms",
        job.id,
        job.current_step,
        elapsed.as_secs_f64() * 1000.0
    );

    match job.current_step {
        JobStep::Finished => {
            eprintln!(
                "[runtime] job {:?} successfully completed; returning chunk.",
                job.id
            );
            Ok(job.chunk_data)
        }
        JobStep::Failed => {
            eprintln!("[runtime] job {:?} ended in FAILED state", job.id);
            Err(SSXLCoreError::InvalidConductorState(
                "Job loop finished but state is Failed.".to_string(),
            ))
        }
        other => {
            eprintln!(
                "[runtime] job {:?} ended in NON-TERMINAL state {:?}",
                job.id,
                other
            );
            Err(SSXLCoreError::InvalidConductorState(format!(
                "Runtime finished in non-terminal state: {:?}",
                other
            )))
        }
    }
}

// --- END: rust/ssxl_ext/src\generate_runtime.rs ---
        23 LOC | rust/ssxl_ext/src\generate_task_queue.rs
// --- START: rust/ssxl_ext/src\generate_task_queue.rs ---
use crate::shared_config::GenerationConfig;
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct GenerationTask {
    pub chunk_pos: (i32, i32),
    pub chunk_size: u32,
    pub seed: u64,
    pub config: Arc<GenerationConfig>,
}

impl GenerationTask {
    pub fn new(
        chunk_pos: (i32, i32),
        chunk_size: u32,
        seed: u64,
        config: Arc<GenerationConfig>,
    ) -> Self {
        Self {
            chunk_pos,
            chunk_size,
            seed,
            config,
        }
    }
}

// --- END: rust/ssxl_ext/src\generate_task_queue.rs ---
        81 LOC | rust/ssxl_ext/src\host_anim.rs
// --- START: rust/ssxl_ext/src\host_anim.rs ---
use godot::prelude::*;
use godot::classes::{TileMap, TileMapLayer};
use godot::obj::InstanceId;

use crate::animate_events::AnimationEvent;
use crate::animate_conductor::AnimationConductor;
use crate::host_state::GodotError;
use crate::{ssxl_error, ssxl_warn, ssxl_info};

// Define a safe maximum number of animation events to process per frame
const MAX_ANIM_EVENTS_PER_FRAME: u32 = 256;

/// Polls the animation event channel and applies visual updates to the Godot world.
/// This must be called on the Godot main thread.
pub fn apply_animation_updates(conductor: &AnimationConductor, tilemap_id: i64) -> u32 {
    let mut events_processed = 0;

    while events_processed < MAX_ANIM_EVENTS_PER_FRAME {
        match conductor.event_receiver.try_recv() {
            Ok(event) => {
                if let Err(e) = handle_animation_event(tilemap_id, event) {
                    ssxl_error!("Host Anim: Failed to handle event: {:?}", e);
                }
                events_processed += 1;
            }
            Err(flume::TryRecvError::Empty) => {
                break;
            }
            Err(flume::TryRecvError::Disconnected) => {
                ssxl_warn!("Host Anim: Conductor event channel disconnected.");
                break;
            }
        }
    }

    events_processed
}

/// Dispatches the event to the appropriate Godot TileMap or Node API call.
fn handle_animation_event(tilemap_id: i64, event: AnimationEvent) -> Result<(), GodotError> {
    // Convert numeric ID to Godot's InstanceId internally.
    let instance_id = InstanceId::from_i64(tilemap_id);

    let tilemap_node = InstanceId::get_object(instance_id)
        .ok_or(GodotError::InvalidInstance)?
        .cast::<TileMap>();

    // Temporarily handling the unwrap() if the cast fails. In production this should be handled.
    let mut tilemap = tilemap_node.unwrap();

    // Mock implementation of to_godot_vector() and set_cell_tiledata_value()
    trait MockTileMapMethods {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i;
        fn set_cell_tiledata_value(
            &mut self,
            layer: i32,
            coords: godot::builtin::Vector2i,
            data_id: TileMapLayer,
            value: Variant,
        );
    }

    impl MockTileMapMethods for (i32, i32) {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i {
            godot::builtin::Vector2i::new(self.0, self.1)
        }
    }

    impl MockTileMapMethods for Gd<TileMap> {
        fn to_godot_vector(&self) -> godot::builtin::Vector2i {
            // Not used, but required for trait completeness
            godot::builtin::Vector2i::new(0, 0)
        }

        fn set_cell_tiledata_value(
            &mut self,
            _layer: i32,
            _coords: godot::builtin::Vector2i,
            _data_id: TileMapLayer,
            _value: Variant,
        ) {
            // Placeholder: Call the actual Godot API here in a real build
        }
    }

    match event {
        AnimationEvent::SetTileAnimation { layer, coords, frame_index } => {
            tilemap.set_cell_tiledata_value(
                layer,
                coords.to_godot_vector(),
                TileMapLayer::ANIMATION_FRAME,
                frame_index.to_variant(),
            );
        }

        AnimationEvent::SetLightColor { light_id, color } => {
            ssxl_info!("Applying color {:?} to light {}", color, light_id);
        }

        AnimationEvent::SpawnParticleEffect { effect_id, position } => {
            ssxl_info!("Spawning particle {} at {:?}", effect_id, position);
        }
        // ... other event types
    }

    Ok(())
}

// --- END: rust/ssxl_ext/src\host_anim.rs ---
       147 LOC | rust/ssxl_ext/src\host_api.rs
// --- START: rust/ssxl_ext/src\host_api.rs ---
// src/host_api.rs

#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::builtin::{GString, VarDictionary};
#[cfg(feature = "godot-binding")]
use godot::classes::Node;

#[cfg(feature = "godot-binding")]
use crate::export_api;
#[cfg(feature = "godot-binding")]
use crate::host_state::{get_host_state, get_host_state_mut};
#[cfg(feature = "godot-binding")]
use crate::host_commands;
#[cfg(feature = "godot-binding")]
use crate::host_tilemap_status;
#[cfg(feature = "godot-binding")]
use crate::host_conductor::SSXLConductor;
#[cfg(feature = "godot-binding")]
use crate::generate_conductor_state::ConductorState;

#[cfg(feature = "godot-binding")]
impl SSXLConductor {
    // ----------------------------------------------------
    // Internal API helpers (called by #[func] wrappers)
    // ----------------------------------------------------

    /// Plan B: this is now a generic render target node, not a TileMap.
    pub fn api_set_tilemap(&mut self, target_node: Gd<Node>) {
        export_api!("set_tilemap(target: Node)");

        // In Plan B we do not require a specific Godot type here.
        self.tilemap_target = Some(target_node.clone());

        crate::ssxl_info!(
            "Render target node successfully registered: instance_id={:?}",
            self.tilemap_target
                .as_ref()
                .unwrap()
                .instance_id()
        );
    }

    pub fn api_initialize_runtime_shell(&mut self, signal_receiver: Gd<Node>) {
        export_api!("initialize_runtime_shell(signal_receiver: Node)");
        self.signal_target = Some(signal_receiver);
        crate::ssxl_info!("Runtime shell initialization requested. Signal target registered.");
    }

    pub fn api_set_generator(&mut self, id: GString) {
        export_api!("set_generator(id: String)");
        self.active_generator_id = id.to_string();
        crate::ssxl_info!("Generator set to: {}", self.active_generator_id);
    }

    pub fn api_build_map(&mut self, config: VarDictionary) -> bool {
        export_api!("build_map(config: Dictionary)");
        crate::ssxl_info!(
            "Received request to build map with config: {:?}",
            config
        );

        if self.tilemap_target.is_none() {
            crate::ssxl_error!("FATAL: Cannot build map. Render target node is missing.");
            self.emit_generation_error("Cannot build map: render target node is missing.");
            return false;
        }

        // âœ… Extract width/height from Godot config and store in HostState
        match get_host_state_mut() {
            Ok(host_state) => {
                if let Some(w) = config.get("width").and_then(|v| v.try_to::<i64>().ok()) {
                    host_state.world_width = w as i32;
                }
                if let Some(h) = config.get("height").and_then(|v| v.try_to::<i64>().ok()) {
                    host_state.world_height = h as i32;
                }

                crate::ssxl_info!(
                    "World size set from Godot: {} x {}",
                    host_state.world_width,
                    host_state.world_height
                );

                // âœ… Mark conductor as Ready
                let conductor = &host_state.conductor;
                let state_container = conductor.get_state_container();
                state_container.transition_to(ConductorState::Ready);

                crate::ssxl_info!("Conductor state set to Ready after build_map().");
            }
            Err(e) => {
                crate::ssxl_error!(
                    "HostState not available during build_map; cannot set conductor Ready: {:?}",
                    e
                );
                self.emit_generation_error(&format!(
                    "HostState not available during build_map: {:?}",
                    e
                ));
                return false;
            }
        }

        true
    }

    // ----------------------------------------------------
    // âœ… Real conductor state returned to Godot
    // ----------------------------------------------------

    pub fn api_get_status(&self) -> GString {
        export_api!("get_status() -> String");

        match get_host_state() {
            Ok(state) => {
                let conductor = &state.conductor;
                let real_state = conductor.get_state_container().get_state();
                GString::from(&format!("{}", real_state))
            }
            Err(e) => {
                crate::ssxl_error!(
                    "Failed to retrieve HostState in get_status(): {:?}",
                    e
                );
                GString::from("Error")
            }
        }
    }

    pub fn api_get_active_generator_id(&self) -> GString {
        export_api!("get_active_generator_id() -> String");
        (&self.active_generator_id).into()
    }

    pub fn api_oracle_tick(&self, _delta: f32) {
        export_api!("oracle_tick(delta: float)");
        if self.tilemap_target.is_some() {
            // Placeholder for future oracle_tick logic (Plan B-friendly).
        }
    }

    pub fn api_get_metrics(&self) -> VarDictionary {
        export_api!("get_metrics() -> Dictionary");
        VarDictionary::new()
    }

    /// Plan B: `target_tilemap` is now the render target node (e.g. SSXLRenderer).
    pub fn api_start_generation(&mut self, target_tilemap: Gd<Node>) -> bool {
        export_api!("start_generation(target: Node) -> bool");

        let host_state_mut = match get_host_state_mut() {
            Ok(state) => state,
            Err(e) => {
                crate::ssxl_error!(
                    "HostState not ready for start_generation command: {:?}",
                    e
                );
                self.emit_generation_error(&format!(
                    "HostState not ready for start_generation: {:?}",
                    e
                ));
                return false;
            }
        };

        let target_id = target_tilemap.instance_id().to_i64();

        match host_commands::handle_start_command(host_state_mut, target_id) {
            Ok(_) => {
                self.emit_generation_started(target_id, 0);
                true
            }
            Err(e) => {
                crate::ssxl_error!("Failed to start generation: {:?}", e);
                self.emit_generation_error(&format!(
                    "Failed to start generation: {:?}",
                    e
                ));
                false
            }
        }
    }

    pub fn api_get_status_report(&self) -> VarDictionary {
        export_api!("get_status_report() -> Dictionary");

        match get_host_state() {
            Ok(state) => host_tilemap_status::get_status_report_dict(state),
            Err(e) => {
                crate::ssxl_error!("Failed to get status report: {:?}", e);
                VarDictionary::new()
            }
        }
    }
}

// --- END: rust/ssxl_ext/src\host_api.rs ---
        36 LOC | rust/ssxl_ext/src\host_cleanup.rs
// --- START: rust/ssxl_ext/src\host_cleanup.rs ---
#[cfg(feature = "godot-binding")]
use crate::host_state::{HostState, HOST_SINGLETON};
use crate::shared_error::SSXLCoreError;

#[cfg(feature = "godot-binding")]
pub fn shutdown_ssxl_runtime() -> Result<(), SSXLCoreError> {
    cleanup_ssxl_core();
    Ok(())
}

#[cfg(feature = "godot-binding")]
pub fn cleanup_ssxl_core() {
    crate::ssxl_info!("SSXL-ext Core: Starting cleanup procedure.");

    let taken_state = unsafe {
        let host_singleton_mut: *mut once_cell::sync::OnceCell<Option<HostState>> =
            &HOST_SINGLETON as *const _ as *mut _;
        (*host_singleton_mut).take()
    };

    match taken_state {
        Some(Some(host_state)) => {
            let HostState {
                conductor,
                anim_conductor: _,
                ..
            } = host_state;

            crate::ssxl_info!("Cleanup: Instructing Conductor to shut down worker threads...");
            conductor.shutdown();

            crate::ssxl_info!("SSXL-ext Core: Cleanup complete. Resources released.");
        }
        Some(None) => {
            crate::ssxl_warn!("Cleanup called but HostState was already cleaned up.");
        }
        None => {
            crate::ssxl_warn!("Cleanup called but SSXL-ext was never initialized.");
        }
    }
}

#[cfg(not(feature = "godot-binding"))]
pub fn shutdown_ssxl_runtime() -> Result<(), SSXLCoreError> {
    Ok(())
}

#[cfg(not(feature = "godot-binding"))]
pub fn cleanup_ssxl_core() {}

// --- END: rust/ssxl_ext/src\host_cleanup.rs ---
       107 LOC | rust/ssxl_ext/src\host_commands.rs
// --- START: rust/ssxl_ext/src\host_commands.rs ---
use crate::host_state::HostState;
use crate::generate_conductor_state::ConductorState;
use crate::generate_task_queue::GenerationTask;
use crate::shared_job::GenerationJob;
use crate::shared_error::SSXLCoreError;

use std::sync::Arc;

#[cfg(feature = "godot-binding")]
use once_cell::sync::Lazy;

#[cfg(feature = "godot-binding")]
static TEST_TILEMAP_ID: Lazy<i64> = Lazy::new(|| 1337000);

#[cfg(not(feature = "godot-binding"))]
const TEST_TILEMAP_ID: i64 = 1337000;

// ----------------------------------------------------
// âœ… PLAN B HOOKS
// These are no-ops for now, but they are the correct
// architectural insertion points for your custom renderer.
// ----------------------------------------------------
fn planb_renderer_begin_world(
    _host_state: &mut HostState,
    _world_w: i32,
    _world_h: i32,
    _chunk_size: u32,
    _chunks_x: i32,
    _chunks_y: i32,
) {
    // Example future logic:
    // host_state.renderer.begin_world(world_w, world_h, chunk_size, chunks_x, chunks_y);
}

fn planb_renderer_reset(_host_state: &mut HostState) {
    // Example future logic:
    // host_state.renderer.reset();
}

// ----------------------------------------------------
// âœ… Start Command (Dynamic World Generation)
// ----------------------------------------------------
pub fn handle_start_command(
    host_state: &mut HostState,
    tilemap_id_raw: i64,
) -> Result<(), SSXLCoreError> {

    // ----------------------------------------------------
    // âœ… Safety checks
    // ----------------------------------------------------
    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        return Err(SSXLCoreError::ConductorBusy);
    }

    if tilemap_id_raw == 0 {
        return Err(SSXLCoreError::InvalidTarget);
    }

    if !host_state.is_core_ready {
        return Err(SSXLCoreError::InitializationError("Core not ready.".to_string()));
    }

    // ----------------------------------------------------
    // âœ… Dynamic world size (set by api_build_map)
    // ----------------------------------------------------
    let world_w = host_state.world_width.max(1);
    let world_h = host_state.world_height.max(1);

    // âœ… Chunk size from map_settings
    let chunk_size_i32 = host_state.config.map_settings.chunk_size as i32;
    let chunk_size_u32 = chunk_size_i32 as u32;

    // Compute number of chunks needed
    let chunks_x = (world_w + chunk_size_i32 - 1) / chunk_size_i32;
    let chunks_y = (world_h + chunk_size_i32 - 1) / chunk_size_i32;

    // ----------------------------------------------------
    // âœ… PLAN B: Reset renderer + begin world
    // ----------------------------------------------------
    planb_renderer_reset(host_state);
    planb_renderer_begin_world(
        host_state,
        world_w,
        world_h,
        chunk_size_u32,
        chunks_x,
        chunks_y,
    );

    // ----------------------------------------------------
    // âœ… Build jobs dynamically
    // ----------------------------------------------------
    let seed = host_state.config.generation.world_seed;
    let config = Arc::new(host_state.config.generation.clone());

    let mut jobs = Vec::new();

    for cx in 0..chunks_x {
        for cy in 0..chunks_y {
            let task = GenerationTask::new(
                (cx, cy),
                chunk_size_u32,
                seed,
                config.clone(),
            );
            jobs.push(GenerationJob::new(task));
        }
    }

    // ----------------------------------------------------
    // âœ… Start generation
    // ----------------------------------------------------
    let tilemap_id = tilemap_id_raw;
    host_state.conductor.start_generation(tilemap_id, jobs)
}

// ----------------------------------------------------
// âœ… Structural Test Job (1 chunk)
// ----------------------------------------------------
pub fn trigger_structural_test_job(
    host_state: &mut HostState,
) -> Result<(), SSXLCoreError> {

    if host_state.conductor.get_state_container().get_state() == ConductorState::Generating {
        return Err(SSXLCoreError::ConductorBusy);
    }

    if !host_state.is_core_ready {
        return Err(SSXLCoreError::InitializationError(
            "Core not ready for test.".to_string(),
        ));
    }

    let map_extent = 0;
    let chunk_size = 8u32;

    let tilemap_id = {
        #[cfg(feature = "godot-binding")]
        { *TEST_TILEMAP_ID }

        #[cfg(not(feature = "godot-binding"))]
        { TEST_TILEMAP_ID }
    };

    let seed = host_state.config.generation.world_seed;
    let config = Arc::new(host_state.config.generation.clone());

    // ----------------------------------------------------
    // âœ… PLAN B: Reset renderer + begin world (1 chunk)
    // ----------------------------------------------------
    planb_renderer_reset(host_state);
    planb_renderer_begin_world(
        host_state,
        1,
        1,
        chunk_size,
        1,
        1,
    );

    let mut jobs = Vec::new();
    for chunk_x in -map_extent..=map_extent {
        for chunk_y in -map_extent..=map_extent {
            let task = GenerationTask::new(
                (chunk_x, chunk_y),
                chunk_size,
                seed,
                config.clone(),
            );
            jobs.push(GenerationJob::new(task));
        }
    }

    host_state.conductor.start_generation(tilemap_id, jobs)
}

// --- END: rust/ssxl_ext/src\host_commands.rs ---
       129 LOC | rust/ssxl_ext/src\host_conductor.rs
// --- START: rust/ssxl_ext/src\host_conductor.rs ---
// ----------------------------------------------------
// Godot binding imports
// ----------------------------------------------------
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::classes::{Node};
#[cfg(feature = "godot-binding")]
use godot::builtin::{GString, VarDictionary};

// ----------------------------------------------------
// Internal engine imports
// ----------------------------------------------------
#[cfg(feature = "godot-binding")]
use crate::host_poller::{poll_conductor_status, ConductorEvents};
#[cfg(feature = "godot-binding")]
use crate::host_state::{get_host_state, HostState};
#[cfg(feature = "godot-binding")]
use crate::generate_conductor::GenerateConductor;

// ----------------------------------------------------
// Public re-export for other modules
// ----------------------------------------------------
#[cfg(feature = "godot-binding")]
pub use self::ssxl_conductor_impl::SSXLConductor;

// ----------------------------------------------------
// Stub for non-Godot builds
// ----------------------------------------------------
#[cfg(not(feature = "godot-binding"))]
pub struct SSXLConductor {}

#[cfg(not(feature = "godot-binding"))]
impl SSXLConductor {}

// ----------------------------------------------------
// Godot-facing conductor implementation
// ----------------------------------------------------
#[cfg(feature = "godot-binding")]
mod ssxl_conductor_impl {
    use super::*;

    #[derive(GodotClass)]
    #[class(base = Node)]
    pub struct SSXLConductor {
        /// Stores a generic Node, not a TileMap.
        /// In Plan B, this is expected to be an SSXL renderer node,
        /// not a Godot TileMap.
        pub tilemap_target: Option<Gd<Node>>,

        /// Optional node that receives signals/events.
        pub signal_target: Option<Gd<Node>>,

        /// Identifier for the active generator backend.
        pub active_generator_id: String,

        /// Tracks whether we've already emitted `conductor_ready`
        /// for the current generation lifecycle.
        pub has_emitted_ready: bool,

        /// Tracks whether we've already emitted `generation_finished`
        /// for the current generation lifecycle.
        pub has_emitted_finished: bool,

        #[base]
        pub base: Base<Node>,
    }

    #[godot_api]
    impl INode for SSXLConductor {
        fn init(base: Base<Node>) -> Self {
            crate::ssxl_info!("SSXLConductor initialized.");
            Self {
                tilemap_target: None,
                signal_target: None,
                active_generator_id: "none".to_owned(),
                has_emitted_ready: false,
                has_emitted_finished: false,
                base,
            }
        }

        fn ready(&mut self) {
            self.base_mut().set_process(true);
        }

        fn exit_tree(&mut self) {
            if let Err(e) = crate::host_cleanup::shutdown_ssxl_runtime() {
                crate::ssxl_error!(
                    "CRITICAL: Runtime cleanup failed during exit_tree: {:?}",
                    e
                );
            }
            self.base_mut().set_process(false);
            crate::ssxl_info!("SSXLConductor terminated.");
        }

        fn process(&mut self, _delta: f64) {
            let host_state: &mut HostState = match get_host_state() {
                Ok(state) => state,
                Err(e) => {
                    crate::ssxl_error!(
                        "SSXL Process Error: HostState not initialized in _process: {:?}",
                        e
                    );

                    self.emit_generation_error(&format!(
                        "HostState not initialized in _process: {:?}",
                        e
                    ));
                    return;
                }
            };

            if host_state.is_core_ready {
                if !self.has_emitted_ready {
                    crate::ssxl_info!("SSXLConductor: core ready, emitting conductor_ready.");
                    self.emit_conductor_ready();
                    self.has_emitted_ready = true;
                }

                let conductor: &mut GenerateConductor = &mut host_state.conductor;
                let events: ConductorEvents = poll_conductor_status(conductor);
                self.poll_and_emit_signals(conductor, &events);
            } else {
                self.emit_conductor_idle();
                self.base_mut().set_process(false);
            }
        }
    }

    #[godot_api]
    impl SSXLConductor {
        // ----------------------------------------------------
        // Signals
        // ----------------------------------------------------
        #[signal]
        fn conductor_ready();

        #[signal]
        fn conductor_idle();

        #[signal]
        fn generation_started(tilemap_id: i64, total_chunks: i32);

        #[signal]
        fn chunk_rendered(completed: i32, total: i32);

        #[signal]
        fn chunk_failed(error: GString);

        #[signal]
        fn generation_progress(
            completed: i32,
            total: i32,
            metrics: VarDictionary,
        );

        #[signal]
        fn generation_finished(tilemap_id: i64);

        #[signal]
        fn generation_error(message: GString);

        #[signal]
        fn debug_event(message: GString);

        #[signal]
        fn ssxl_event(event: VarDictionary);

        // ----------------------------------------------------
        // Test method
        // ----------------------------------------------------
        #[func]
        pub fn test_emit_event(&mut self) {
            let mut d = VarDictionary::new();
            let _ = d.insert("type", "rust_test_event");
            let _ = d.insert("ok", true);
            self.base_mut().emit_signal("ssxl_event", &[d.to_variant()]);
        }

        // ----------------------------------------------------
        // API methods
        // ----------------------------------------------------

        /// Accepts Gd<Node>, not Gd<TileMap>.
        /// In Plan B, this should be your SSXL renderer node.
        #[func]
        pub fn set_tilemap(&mut self, tilemap: Gd<Node>) {
            self.api_set_tilemap(tilemap);
        }

        #[func]
        pub fn initialize_runtime_shell(&mut self, signal_receiver: Gd<Node>) {
            self.api_initialize_runtime_shell(signal_receiver);
        }

        #[func]
        pub fn set_generator(&mut self, id: GString) {
            self.api_set_generator(id);
        }

        #[func]
        pub fn build_map(&mut self, config: VarDictionary) -> bool {
            self.api_build_map(config)
        }

        #[func]
        pub fn get_status(&self) -> GString {
            self.api_get_status()
        }

        #[func]
        pub fn get_active_generator_id(&self) -> GString {
            self.api_get_active_generator_id()
        }

        #[func]
        pub fn oracle_tick(&self, delta: f32) {
            self.api_oracle_tick(delta);
        }

        #[func]
        pub fn get_metrics(&self) -> VarDictionary {
            self.api_get_metrics()
        }

        /// Plan B hook: each new generation cycle resets the
        /// signal emission guards so `conductor_ready` and
        /// `generation_finished` are emitted once per run.
        #[func]
        pub fn start_generation(&mut self, target_tilemap: Gd<Node>) -> bool {
            self.has_emitted_ready = false;
            self.has_emitted_finished = false;
            self.api_start_generation(target_tilemap)
        }

        #[func]
        pub fn get_status_report(&self) -> VarDictionary {
            self.api_get_status_report()
        }
    }
}

// --- END: rust/ssxl_ext/src\host_conductor.rs ---
        46 LOC | rust/ssxl_ext/src\host_init.rs
// --- START: rust/ssxl_ext/src\host_init.rs ---
// ssxl_ext\src\host_init.rs (FIXED)

// Conditionally include Godot dependencies only when needed.
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use crate::host_state::init_host_state;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::config::GlobalConfig;
use std::sync::Arc;

// --- CORE LOGIC (Godot-independent and safe to call from CLI) ---

/// Internal function performing all core logic (Config loading, Conductor init, HostState init),
/// isolated from Godot-specific API calls.
fn _do_initialization() -> Result<(), String> {
    
    // 1. Load Global Configuration
    let config = match GlobalConfig::load_or_default() {
        Ok(c) => c,
        Err(e) => return Err(format!("Failed to load configuration: {}", e)),
    };
    let config = Arc::new(config);

    // 2. Initialize the Conductor
    let num_workers = config.threading.generation_worker_count;
    let conductor = GenerateConductor::new(
        num_workers,
        Arc::clone(&config),
    );

    // 3. Initialize the Animation Conductor
    let anim_conductor = AnimConductor::new();
    
    // 4. Initialize the Host State Singleton
    // FIX: Map the custom SSXLCoreError returned by init_host_state to a generic String.
    init_host_state(conductor, anim_conductor, Arc::clone(&config))
        .map_err(|e| format!("HostState initialization failed: {}", e))
}


// --- FFI ENTRY POINT (CLI-safe) ---

// ðŸŽ¯ CRITICAL FIX: Gate the C-exported function to ensure it is only compiled 
// for the CLI build, completely bypassing Godot FFI linkage.
#[cfg(not(feature = "godot-binding"))]
#[no_mangle]
pub extern "C" fn ssxl_boot_core_to_idle() -> i32 {
    match _do_initialization() { 
        Ok(_) => {
            // Use standard console output (eprintln!) for the CLI environment.
            eprintln!("âœ… SSXL-ext CLI Core: Initialization complete. Ready for FFI work.");
            0 // Success
        },
        Err(e) => {
            // Use standard console error output for the CLI environment.
            eprintln!("âŒ CLI FFI Boot Error: {}", e);
            1 // Generic error code for boot failure
        }
    }
}


// --- GODOT ENTRY POINT (Feature-gated for GDExtension hook) ---

/// The public function used by the Godot GDExtension lifecycle hook.
/// It wraps the core logic with Godot's logging API and is only compiled for the Godot target.
#[cfg(feature = "godot-binding")] // <-- CORRECTLY GATED
pub fn initialize_ssxl_core() -> Result<(), String> {
    
    godot_print!("SSXL-ext Core: Starting initialization (v9.1.seed).");
    
    match _do_initialization() { 
        Ok(_) => {
            godot_print!("SSXL-ext Core: Initialization complete. Ready for work.");
            Ok(())
        },
        Err(e) => {
            // Retain the original use of godot_print! for logging inside the Godot environment
            godot_print!("âŒ SSXL-ext Core FFI Error: {}", e);
            Err(e)
        }
    }
}

// NOTE: If your ssxl_cli::main.rs calls `ssxl_ext::host_init::initialize_ssxl_core()`, 
// you must change that call to `ssxl_ext::host_init::ssxl_boot_core_to_idle()` instead,
// to ensure the CLI uses the correct, gated entry point.
// --- END: rust/ssxl_ext/src\host_init.rs ---
        25 LOC | rust/ssxl_ext/src\host_poller.rs
// --- START: rust/ssxl_ext/src\host_poller.rs ---
use crate::generate_conductor::GenerateConductor;
use crate::ssxl_info;

pub struct ConductorEvents {
    pub chunks_rendered: u32,
    pub generation_completed: bool,
    pub finalized_tilemap_id: Option<i64>,
}

pub fn poll_conductor_status(conductor: &mut GenerateConductor) -> ConductorEvents {
    let (chunks_rendered, generation_completed) = conductor.poll_chunks_and_render();

    if chunks_rendered > 0 {
        ssxl_info!("Poller: Rendered {} chunks this frame.", chunks_rendered);
    }

    let finalized_tilemap_id = conductor.try_finalize_and_get_target_id();

    if let Some(id_for_logging) = finalized_tilemap_id {
        ssxl_info!(
            "Poller: All chunks rendered. Finalization for ID: {}",
            id_for_logging
        );
    }

    ConductorEvents {
        chunks_rendered,
        generation_completed,
        finalized_tilemap_id,
    }
}

// --- END: rust/ssxl_ext/src\host_poller.rs ---
        52 LOC | rust/ssxl_ext/src\host_render.rs
// --- START: rust/ssxl_ext/src\host_render.rs ---
use flume::Receiver;
use crate::shared_chunk::Chunk;
use crate::generate_conductor_state::ConductorStateContainer;

#[cfg(feature = "godot-binding")]
use crate::generate_conductor_state::ConductorState;

// âœ… Updated import â€” now uses the native SSXLTileMap pipeline
#[cfg(feature = "godot-binding")]
use crate::host_tilemap::render_chunk_direct;

#[cfg(feature = "godot-binding")]
const MAX_CHUNKS_PER_FRAME: u32 = 16;

#[cfg(feature = "godot-binding")]
pub fn render_available_chunks(
    tilemap_id_raw: i64,
    chunk_receiver: &Receiver<Chunk>,
    state_container: &ConductorStateContainer,
) -> (u32, bool) {
    let mut chunks_rendered_this_frame = 0;

    while chunks_rendered_this_frame < MAX_CHUNKS_PER_FRAME {
        match chunk_receiver.try_recv() {
            Ok(chunk) => {
                match render_chunk_direct(tilemap_id_raw, chunk) {
                    Ok(_) => {
                        chunks_rendered_this_frame += 1;
                        state_container.increment_completed_chunks();
                    }
                    Err(e) => {
                        crate::ssxl_error!(
                            "Render Pacing Layer: Direct write failed: {:?}",
                            e
                        );
                    }
                }
            }
            Err(flume::TryRecvError::Empty) => break,
            Err(flume::TryRecvError::Disconnected) => {
                crate::ssxl_warn!(
                    "Render Pacing Layer: Worker channel disconnected unexpectedly."
                );
                break;
            }
        }
    }

    let metrics = state_container.get_metrics();
    let is_finished =
        metrics.completed_chunks == metrics.total_chunks && metrics.total_chunks > 0;

    if is_finished && state_container.get_state() == ConductorState::Generating {
        state_container.transition_to(ConductorState::Finished);
    }

    (chunks_rendered_this_frame, is_finished)
}

#[cfg(not(feature = "godot-binding"))]
pub fn render_available_chunks(
    _tilemap_id: i64,
    _chunk_receiver: &Receiver<Chunk>,
    _state_container: &ConductorStateContainer,
) -> (u32, bool) {
    (0, false)
}

// --- END: rust/ssxl_ext/src\host_render.rs ---
       119 LOC | rust/ssxl_ext/src\host_signals.rs
// --- START: rust/ssxl_ext/src\host_signals.rs ---
#[cfg(feature = "godot-binding")]
use godot::prelude::*;
#[cfg(feature = "godot-binding")]
use godot::builtin::{GString, VarDictionary};

#[cfg(feature = "godot-binding")]
use crate::generate_conductor::GenerateConductor;
#[cfg(feature = "godot-binding")]
use crate::host_poller::ConductorEvents;
#[cfg(feature = "godot-binding")]
use crate::host_conductor::SSXLConductor;

#[cfg(feature = "godot-binding")]
impl SSXLConductor {
    pub fn emit_conductor_ready(&mut self) {
        self.base_mut().emit_signal("conductor_ready", &[]);
    }

    pub fn emit_conductor_idle(&mut self) {
        self.base_mut().emit_signal("conductor_idle", &[]);
    }

    pub fn emit_generation_started(&mut self, tilemap_id: i64, total_chunks: i32) {
        self.base_mut().emit_signal(
            "generation_started",
            &[
                tilemap_id.to_variant(),
                total_chunks.to_variant(),
            ],
        );
    }

    pub fn emit_chunk_rendered(&mut self, completed: i32, total: i32) {
        self.base_mut().emit_signal(
            "chunk_rendered",
            &[
                completed.to_variant(),
                total.to_variant(),
            ],
        );
    }

    pub fn emit_chunk_failed(&mut self, error: &str) {
        self.base_mut().emit_signal(
            "chunk_failed",
            &[GString::from(error).to_variant()],
        );
    }

    pub fn emit_generation_progress(
        &mut self,
        completed: i32,
        total: i32,
        metrics: VarDictionary,
    ) {
        self.base_mut().emit_signal(
            "generation_progress",
            &[
                completed.to_variant(),
                total.to_variant(),
                metrics.to_variant(),
            ],
        );
    }

    pub fn emit_generation_finished(&mut self, tilemap_id: i64) {
        self.base_mut().emit_signal(
            "generation_finished",
            &[tilemap_id.to_variant()],
        );
    }

    pub fn emit_generation_error(&mut self, message: &str) {
        self.base_mut().emit_signal(
            "generation_error",
            &[GString::from(message).to_variant()],
        );
    }

    pub fn emit_debug_event(&mut self, message: &str) {
        self.base_mut().emit_signal(
            "debug_event",
            &[GString::from(message).to_variant()],
        );
    }

    // ----------------------------------------------------
    // âœ… PLAN B HOOKS (SSXL Renderer Integration)
    // ----------------------------------------------------

    /// Called when a chunk has been generated and is ready for rendering.
    /// In Plan B, this will forward raw tile data to your custom renderer.
    fn push_chunk_to_renderer(
        &mut self,
        _conductor: &GenerateConductor,
        _events: &ConductorEvents,
    ) {
        // âœ… PLAN B: This is where your renderer receives chunk data.
        // Example (future):
        // if let Some(renderer) = &self.tilemap_target {
        //     renderer.bind_mut().apply_chunk_mesh(...);
        // }
    }

    /// Called once when the entire generation is complete.
    /// In Plan B, this finalizes the mesh, batching, or GPU upload.
    fn finalize_renderer_output(&mut self) {
        // âœ… PLAN B: Finalize mesh, upload to GPU, build chunk instances, etc.
    }

    // ----------------------------------------------------
    // Main signal + renderer pipeline
    // ----------------------------------------------------
    pub fn poll_and_emit_signals(
        &mut self,
        conductor: &GenerateConductor,
        events: &ConductorEvents,
    ) {
        let metrics = conductor.get_metrics();
        let total = metrics.total_chunks as i32;
        let completed = metrics.completed_chunks as i32;

        if total > 0 {
            // âœ… SPAM BLOCKER: Only emit conductor_ready once per generation cycle
            if !self.has_emitted_ready {
                self.emit_conductor_ready();
                self.has_emitted_ready = true;
            }

            // âœ… PLAN B: Forward chunk data to renderer
            if events.chunks_rendered > 0 {
                self.push_chunk_to_renderer(conductor, events);
            }

            // âœ… Emit progress
            let mut dict = VarDictionary::new();
            let _ = dict.insert("completed", completed.to_variant());
            let _ = dict.insert("total", total.to_variant());
            let _ = dict.insert(
                "chunks_rendered_this_frame",
                events.chunks_rendered.to_variant(),
            );
            let _ = dict.insert(
                "generation_completed",
                events.generation_completed.to_variant(),
            );

            self.emit_generation_progress(completed, total, dict);

            if events.chunks_rendered > 0 {
                self.emit_chunk_rendered(completed, total);
            }

            // âœ… NEW SPAM BLOCKER: Only emit generation_finished once
            if events.generation_completed && !self.has_emitted_finished {
                // âœ… PLAN B: Finalize renderer output
                self.finalize_renderer_output();

                let tilemap_id = events.finalized_tilemap_id.unwrap_or(-1);
                self.emit_generation_finished(tilemap_id);
                self.has_emitted_finished = true;
            }
        } else {
            self.emit_conductor_idle();
        }
    }
}

// --- END: rust/ssxl_ext/src\host_signals.rs ---
        76 LOC | rust/ssxl_ext/src\host_state.rs
// --- START: rust/ssxl_ext/src\host_state.rs ---
use once_cell::sync::OnceCell;
use std::sync::Arc;

use crate::config::GlobalConfig;
use crate::generate_conductor::GenerateConductor;
use crate::generate_anim_conductor::AnimConductor;
use crate::rhythm_manager::RhythmManager;
use crate::shared_error::SSXLCoreError;
use crate::{ssxl_error, ssxl_info};

pub type InstanceType = i64;

fn create_null_instance_id() -> InstanceType {
    0
}

pub static HOST_SINGLETON: OnceCell<Option<HostState>> = OnceCell::new();

/// Immutable access is no longer used by the engine, but we keep it for completeness.
/// Most systems now require mutable access (see get_host_state_mut).
pub fn get_host_state() -> Result<&'static mut HostState, SSXLCoreError> {
    unsafe {
        HOST_SINGLETON
            .get()
            .and_then(|opt| opt.as_ref())
            .ok_or_else(|| {
                ssxl_error!("Attempted to access HostState before it was initialized.");
                SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
            })?;

        let ptr = &HOST_SINGLETON as *const _ as *mut OnceCell<Option<HostState>>;
        (*ptr)
            .get_mut()
            .and_then(|opt| opt.as_mut())
            .ok_or_else(|| {
                ssxl_error!("Attempted to access HostState before it was initialized.");
                SSXLCoreError::InitializationError("HostState singleton not set.".to_string())
            })
    }
}

/// Explicit mutable accessor (same as get_host_state, but kept for clarity)
pub fn get_host_state_mut() -> Result<&'static mut HostState, SSXLCoreError> {
    get_host_state()
}

pub fn init_host_state(
    conductor: GenerateConductor,
    anim_conductor: AnimConductor,
    config: Arc<GlobalConfig>,
) -> Result<(), SSXLCoreError> {
    ssxl_info!("Initializing HostState...");

    let new_state = HostState {
        config,
        conductor,
        anim_conductor,
        rhythm_manager: RhythmManager::new(),
        is_core_ready: true,
        tilemap_id: create_null_instance_id(),

        // âœ… Default world dimensions; will be overridden by api_build_map()
        world_width: 0,
        world_height: 0,
    };

    HOST_SINGLETON.set(Some(new_state)).map_err(|_| {
        ssxl_error!("HostState initialization failed: Already initialized.");
        SSXLCoreError::InitializationError("HostState was already set.".to_string())
    })
}

pub struct HostState {
    pub config: Arc<GlobalConfig>,
    pub conductor: GenerateConductor,
    pub anim_conductor: AnimConductor,
    pub rhythm_manager: RhythmManager,
    pub is_core_ready: bool,
    pub tilemap_id: InstanceType,

    /// âœ… World dimensions in cells, driven by Godot (ssxl_controller)
    pub world_width: i32,
    pub world_height: i32,
}

pub fn shutdown_host_state() -> Result<(), SSXLCoreError> {
    let taken = unsafe {
        let ptr = &HOST_SINGLETON as *const _ as *mut OnceCell<Option<HostState>>;
        (*ptr).take()
    };

    match taken {
        Some(_) => Ok(()),
        None => Err(SSXLCoreError::NotInitialized),
    }
}

// --- END: rust/ssxl_ext/src\host_state.rs ---
        82 LOC | rust/ssxl_ext/src\host_tilemap.rs
// --- START: rust/ssxl_ext/src\host_tilemap.rs ---
use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;
use crate::shared_tile::TileData;
use crate::bridge_ffi::{ssxl_get_tilemap_chunk_ptr, ssxl_notify_chunk_updated};

/// Render a chunk by:
/// 1. Asking SSXLChunkBuffer for a raw pointer to the chunk buffer
/// 2. Copying TileData into that buffer
/// 3. Notifying SSXLChunkBuffer that the chunk changed
pub fn render_chunk_direct(tilemap_id_raw: i64, chunk: Chunk) -> Result<(), SSXLCoreError> {
    // Debug: inspect first source tile in the Chunk coming from the worker
    if let Some(first) = chunk.tiles.get(0) {
        eprintln!(
            "[host_tilemap] SRC first tile for chunk ({}, {}): {:?}",
            chunk.position.0,
            chunk.position.1,
            first
        );
    } else {
        eprintln!(
            "[host_tilemap] SRC chunk ({}, {}) has EMPTY tiles vec!",
            chunk.position.0,
            chunk.position.1
        );
    }

    // SAFETY: FFI call into Godot to retrieve the chunk pointer
    let dest_ptr = unsafe {
        ssxl_get_tilemap_chunk_ptr(
            tilemap_id_raw,
            chunk.position.0,
            chunk.position.1,
        )
    };

    if dest_ptr.is_null() {
        eprintln!(
            "[host_tilemap] ERROR: ssxl_get_tilemap_chunk_ptr returned NULL for chunk ({}, {})",
            chunk.position.0,
            chunk.position.1
        );
        return Err(SSXLCoreError::InvalidInstance(tilemap_id_raw));
    }

    let tile_count = chunk.tiles.len();

    eprintln!(
        "[host_tilemap] DEST ptr for chunk ({}, {}) = {:?}, copying {} tiles",
        chunk.position.0,
        chunk.position.1,
        dest_ptr,
        tile_count
    );

    if tile_count > 0 {
        unsafe {
            // Interpret the destination pointer as a TileData slice
            let dest_slice_before: &[TileData] =
                std::slice::from_raw_parts(dest_ptr as *const TileData, tile_count);

            eprintln!(
                "[host_tilemap] DEST first tile BEFORE copy for chunk ({}, {}): {:?}",
                chunk.position.0,
                chunk.position.1,
                dest_slice_before.get(0)
            );

            // Perform the copy
            std::ptr::copy_nonoverlapping(
                chunk.tiles.as_ptr() as *const TileData,
                dest_ptr,
                tile_count,
            );

            let dest_slice_after: &[TileData] =
                std::slice::from_raw_parts(dest_ptr as *const TileData, tile_count);

            eprintln!(
                "[host_tilemap] DEST first tile AFTER copy for chunk ({}, {}): {:?}",
                chunk.position.0,
                chunk.position.1,
                dest_slice_after.get(0)
            );
        }
    } else {
        eprintln!(
            "[host_tilemap] WARNING: chunk ({}, {}) has 0 tiles; nothing to copy.",
            chunk.position.0,
            chunk.position.1
        );
    }

    // SAFETY: Notify Godot that the chunk buffer was updated
    unsafe {
        ssxl_notify_chunk_updated(
            tilemap_id_raw,
            chunk.position.0,
            chunk.position.1,
        );
    }

    Ok(())
}

// --- END: rust/ssxl_ext/src\host_tilemap.rs ---
        31 LOC | rust/ssxl_ext/src\host_tilemap_status.rs
// --- START: rust/ssxl_ext/src\host_tilemap_status.rs ---
// rust/SSXL-ext/src/host_tilemap_status.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate Godot imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::builtin::VarDictionary;

use crate::host_state::HostState;

// NOTE: ConductorState should be visible without gating.

/// Generates a `VarDictionary` containing the current status and metrics of the SSXL core.
// ðŸŽ¯ CRITICAL FIX: Gate the entire function implementation
#[cfg(feature = "godot-binding")]
pub fn get_status_report_dict(host_state: &HostState) -> VarDictionary {
    let mut dict = VarDictionary::new();

    if !host_state.is_core_ready {
        // ssxl_error! is already feature-gated and will work correctly.
        crate::ssxl_error!("Called get_status_report_dict before core was ready.");
        let _ = dict.insert("is_core_ready", false.to_variant());
        let _ = dict.insert("conductor_state", "Uninitialized".to_variant());
        let _ = dict.insert("total_chunks", 0.to_variant());
        let _ = dict.insert("completed_chunks", 0.to_variant());
        return dict;
    }

    // 1. Get the current state and metrics from the Conductor
    let conductor = &host_state.conductor;
    let metrics = conductor.get_metrics();
    let conductor_state = conductor.get_state_container().get_state();

    // 2. Map metrics into the Dictionary
    let _ = dict.insert("is_core_ready", host_state.is_core_ready.to_variant());
    let _ = dict.insert("conductor_state", conductor_state.to_string().to_variant());
    
    // Convert GenerationMetrics into Dictionary entries
    let _ = dict.insert("total_chunks", metrics.total_chunks.to_variant());
    let _ = dict.insert("completed_chunks", metrics.completed_chunks.to_variant());
    
    // Calculate progress as a float
    let progress = if metrics.total_chunks > 0 {
        metrics.completed_chunks as f64 / metrics.total_chunks as f64
    } else {
        0.0
    };
    let _ = dict.insert("progress", progress.to_variant());

    dict
}

// ðŸŽ¯ FALLBACK: Provide a mock function for the CLI build to satisfy cross-module calls
#[cfg(not(feature = "godot-binding"))]
// Define a placeholder type for VarDictionary in the CLI context if needed, or use a simpler return type.
// Since the caller (SSXLConductor) is also gated, we can use a simpler signature.
pub fn get_status_report_dict(_host_state: &HostState) -> () {
    // No-op for the CLI build
    ()
}
// --- END: rust/ssxl_ext/src\host_tilemap_status.rs ---
        70 LOC | rust/ssxl_ext/src\lib.rs
// --- START: rust/ssxl_ext/src\lib.rs ---
// ------------------------------------------------------------
// Godot binding imports (only when building the Godot binding)
// ------------------------------------------------------------
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

#[cfg(feature = "godot-binding")]
use godot::init::{ExtensionLibrary, InitLevel};

// ------------------------------------------------------------
// Core engine modules
// ------------------------------------------------------------
pub mod tools;
pub mod math;
pub mod config;
pub mod shared_types;
pub mod cache;
pub mod sync_pool;
pub mod sync_rhythm;

pub mod shared_tile;
pub mod shared_chunk;
pub mod shared_config;
pub mod shared_error;
pub mod shared_math;
pub mod shared_message;
pub mod generate_task_queue;
pub mod shared_job;
pub mod generate_runtime;
pub mod generate_batch_processor;
pub mod generate_anim_conductor;
pub mod rhythm_manager;

pub mod generate_perlin;
pub mod generate_ca;
pub mod generate_ca_simulation;
pub mod generate_conductor;
pub mod generate_conductor_state;
pub mod generate_manager;

pub mod animate_events;
pub mod animate_worker;
pub mod animate_conductor;

pub mod bridge_ffi;
pub mod bridge_signals;
pub mod bridge_oracle;
pub mod host_conductor;
pub mod host_state;
pub mod host_init;
pub mod host_cleanup;
pub mod host_poller;
pub mod host_render;
pub mod host_commands;
pub mod host_tilemap;
pub mod host_tilemap_status;
pub mod host_signals;
pub mod host_api;
pub mod tile_conversion;

#[macro_use]
pub mod api_registry;

// ------------------------------------------------------------
// âœ… PLAN B RENDERER MODULE (must be exported for Godot to see it)
// ------------------------------------------------------------
#[cfg(feature = "godot-binding")]
pub mod renderer;

#[cfg(feature = "godot-binding")]
pub mod ssxl_chunk_buffer;


// ------------------------------------------------------------
// GDExtension entry point
// ------------------------------------------------------------
#[cfg(feature = "godot-binding")]
struct SSXLExtension;

#[cfg(feature = "godot-binding")]
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    fn on_level_init(level: InitLevel) {
        if level == InitLevel::Scene {
            match host_init::initialize_ssxl_core() {
                Ok(_) => crate::ssxl_info!(
                    "Core resources successfully initialized and workers started."
                ),
                Err(e) => crate::ssxl_error!(
                    "FATAL: SSXL Core failed to initialize. Reason: {}",
                    e
                ),
            }
        }
    }

    fn on_level_deinit(level: InitLevel) {
        if level == InitLevel::Scene {
            host_cleanup::cleanup_ssxl_core();
            crate::ssxl_info!("SSXL GDExtension terminated successfully.");
        }
    }
}

// --- END: rust/ssxl_ext/src\lib.rs ---
        40 LOC | rust/ssxl_ext/src\math.rs
// --- START: rust/ssxl_ext/src\math.rs ---
// rust/SSXL-ext/src/math.rs

use crate::shared_config::MapSettingsConfig; // To get chunk size

/// Converts continuous world coordinates (global tile coordinates) into 
/// discrete chunk coordinates.
/// 
/// This is crucial for determining which worker needs to process a given location.
pub fn world_to_chunk_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // Use floor division (integer division in Rust for positive numbers)
    // For proper handling of negative coordinates (common in large worlds), 
    // we use a correction for negative numbers.
    let chunk_x = (world_x as f32 / chunk_size as f32).floor() as i32;
    let chunk_y = (world_y as f32 / chunk_size as f32).floor() as i32;
    
    (chunk_x, chunk_y)
}

/// Converts discrete chunk coordinates and local chunk coordinates back into 
/// global world coordinates.
pub fn chunk_to_world_coords(chunk_x: i32, chunk_y: i32, local_x: i32, local_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    let world_x = (chunk_x * chunk_size) + local_x;
    let world_y = (chunk_y * chunk_size) + local_y;
    
    (world_x, world_y)
}

/// Calculates the local tile coordinate within a chunk from a global coordinate.
pub fn world_to_local_coords(world_x: i32, world_y: i32, map_settings: &MapSettingsConfig) -> (i32, i32) {
    let chunk_size = map_settings.chunk_size as i32;
    
    // The modulo operation handles the wrap-around within the chunk boundary.
    // Ensure the result is non-negative for proper indexing.
    let local_x = world_x.rem_euclid(chunk_size);
    let local_y = world_y.rem_euclid(chunk_size);
    
    (local_x, local_y)
}

// rust/SSXL-ext/src/math.rs

/// Fast, safe 32-bit integer clamping. Useful for setting bounds on noise or CA values.
pub fn clamp_i32(val: i32, min: i32, max: i32) -> i32 {
    val.max(min).min(max)
}

/// Fast, safe float clamping. Used for normalizing noise output to a [0.0, 1.0] range.
pub fn clamp_f64(val: f64, min: f64, max: f64) -> f64 {
    val.max(min).min(max)
}

/// Linearly interpolates between 'a' and 'b' by the factor 't'.
/// Used in various generation algorithms for blending values.
pub fn lerp(a: f64, b: f64, t: f64) -> f64 {
    a + (b - a) * t.max(0.0).min(1.0) // Clamp t to [0.0, 1.0]
}

/// Calculates the distance squared between two points. 
/// Used for fast proximity checks without the overhead of a square root.
pub fn distance_squared_2d(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    dx * dx + dy * dy
}

// rust/SSXL-ext/src/math.rs

/// Generates a deterministic u64 seed from a pair of chunk coordinates.
/// Ensures that the same coordinates always produce the same seed, 
/// guaranteeing continuity across chunk borders.
pub fn hash_chunk_coords(chunk_x: i32, chunk_y: i32, world_seed: u64) -> u64 {
    // A simple, fast XOR-based hash mixing method:
    let mut hash: u64 = world_seed;
    hash = hash.wrapping_add(chunk_x as u64);
    hash = hash.wrapping_mul(31); // Simple prime multiplier
    hash ^= (chunk_y as u64).wrapping_shl(32);
    hash
}
// --- END: rust/ssxl_ext/src\math.rs ---
       119 LOC | rust/ssxl_ext/src\renderer\atlas.rs
// --- START: rust/ssxl_ext/src\renderer\atlas.rs ---
use godot::prelude::*;

/// ------------------------------------------------------------
/// SSXL Atlas (Plan B)
///
/// Maps tile IDs â†’ UV rectangles inside a texture atlas.
/// ------------------------------------------------------------
#[derive(Debug, Clone)]
pub struct AtlasUV {
    pub uv_min: Vector2,   // bottom-left corner (0â€“1)
    pub uv_max: Vector2,   // top-right corner (0â€“1)
}

#[derive(Debug)]
pub struct SSXLAtlas {
    /// Map tile_id â†’ UV rectangle
    uv_map: Vec<AtlasUV>,

    /// Atlas grid dimensions (for uniform atlases)
    pub tiles_x: i32,
    pub tiles_y: i32,
}

impl SSXLAtlas {
    /// Create a new uniform grid atlas.
    pub fn new_uniform(tiles_x: i32, tiles_y: i32) -> Self {
        if tiles_x <= 0 || tiles_y <= 0 {
            godot_warn!(
                "DEBUG SSXLAtlas: INVALID atlas size {}x{} â€” materials may appear blank",
                tiles_x, tiles_y
            );
        }

        let mut uv_map = Vec::new();
        uv_map.resize(
            (tiles_x * tiles_y) as usize,
            AtlasUV {
                uv_min: Vector2::ZERO,
                uv_max: Vector2::ONE,
            },
        );

        let tile_w = 1.0 / tiles_x as f32;
        let tile_h = 1.0 / tiles_y as f32;

        for ty in 0..tiles_y {
            for tx in 0..tiles_x {
                let id = (ty * tiles_x + tx) as usize;

                let u0 = tx as f32 * tile_w;
                let v0 = ty as f32 * tile_h;

                let uv_min = Vector2::new(u0, v0);
                let uv_max = Vector2::new(u0 + tile_w, v0 + tile_h);

                // DEBUG: UV sanity check
                if uv_min.x < 0.0 || uv_min.y < 0.0 || uv_max.x > 1.0 || uv_max.y > 1.0 {
                    godot_warn!(
                        "DEBUG SSXLAtlas: UV OUT OF RANGE for tile {} -> min={:?}, max={:?}",
                        id, uv_min, uv_max
                    );
                }

                uv_map[id] = AtlasUV { uv_min, uv_max };
            }
        }

        godot_print!(
            "DEBUG SSXLAtlas: created uniform atlas {}x{} ({} tiles)",
            tiles_x,
            tiles_y,
            uv_map.len()
        );

        SSXLAtlas {
            uv_map,
            tiles_x,
            tiles_y,
        }
    }

    /// Create an empty atlas (for custom UV assignment)
    pub fn new_empty() -> Self {
        godot_warn!(
            "DEBUG SSXLAtlas: new_empty() called â€” NO UVs defined. Material will appear uniform."
        );

        SSXLAtlas {
            uv_map: Vec::new(),
            tiles_x: 0,
            tiles_y: 0,
        }
    }

    /// Assign a custom UV rect to a tile ID.
    pub fn set_custom_uv(&mut self, tile_id: usize, uv_min: Vector2, uv_max: Vector2) {
        if tile_id >= self.uv_map.len() {
            godot_warn!(
                "DEBUG SSXLAtlas: expanding atlas for custom tile_id={} (old size={})",
                tile_id,
                self.uv_map.len()
            );

            self.uv_map.resize(
                tile_id + 1,
                AtlasUV {
                    uv_min: Vector2::ZERO,
                    uv_max: Vector2::ONE,
                },
            );
        }

        // DEBUG: UV sanity check
        if uv_min.x < 0.0 || uv_min.y < 0.0 || uv_max.x > 1.0 || uv_max.y > 1.0 {
            godot_warn!(
                "DEBUG SSXLAtlas: custom UV OUT OF RANGE for tile_id={} -> min={:?}, max={:?}",
                tile_id,
                uv_min,
                uv_max
            );
        }

        self.uv_map[tile_id] = AtlasUV { uv_min, uv_max };

        godot_print!(
            "DEBUG SSXLAtlas: set_custom_uv tile_id={} min={:?} max={:?}",
            tile_id,
            uv_min,
            uv_max
        );
    }

    /// Retrieve UVs for a tile ID.
    /// If out of range, returns a fullâ€‘atlas UV (safe fallback).
    pub fn get_uv(&self, tile_id: usize) -> AtlasUV {
        if tile_id < self.uv_map.len() {
            let uv = self.uv_map[tile_id].clone();

            // DEBUG: sanity check
            if uv.uv_min == Vector2::ZERO && uv.uv_max == Vector2::ONE {
                godot_warn!(
                    "DEBUG SSXLAtlas: tile_id={} using FULL-ATLAS UVs â€” texture may appear stretched",
                    tile_id
                );
            }

            return uv;
        }

        godot_warn!(
            "DEBUG SSXLAtlas: tile_id={} OUT OF RANGE (max={}) â€” using fallback UVs",
            tile_id,
            self.uv_map.len()
        );

        AtlasUV {
            uv_min: Vector2::ZERO,
            uv_max: Vector2::ONE,
        }
    }
}

// --- END: rust/ssxl_ext/src\renderer\atlas.rs ---
        98 LOC | rust/ssxl_ext/src\renderer\chunk_mesh.rs
// --- START: rust/ssxl_ext/src\renderer\chunk_mesh.rs ---
use godot::prelude::*;

/// ------------------------------------------------------------
/// SSXL Chunk Mesh (CPU-side)
///
/// This struct represents the mesh for a single chunk in the
/// SSXL Plan B renderer. It contains:
///
/// âœ… CPU-side vertex data
/// âœ… CPU-side UV data
/// âœ… CPU-side index buffer
/// âœ… Chunk world position
/// âœ… RenderingServer RIDs (mesh + instance)
/// âœ… Dirty flag (needs rebuild)
///
/// RenderingServer upload happens in mesh_upload.rs.
/// Mesh building happens in mesh_builder.rs.
/// ------------------------------------------------------------
#[derive(Debug)]
pub struct ChunkMesh {
    /// Chunk coordinate (cx, cy)
    pub cx: i32,
    pub cy: i32,

    /// CPU-side mesh buffers
    pub vertices: Vec<Vector3>,
    pub uvs: Vec<Vector2>,
    pub indices: Vec<u32>,

    /// RenderingServer resources
    pub mesh_rid: Option<Rid>,
    pub instance_rid: Option<Rid>,

    /// Whether this chunk needs to be rebuilt or re-uploaded
    pub dirty: bool,
}

impl ChunkMesh {
    /// Create an empty chunk mesh at chunk coordinate (cx, cy)
    pub fn new(cx: i32, cy: i32) -> Self {
        let mesh = ChunkMesh {
            cx,
            cy,
            vertices: Vec::new(),
            uvs: Vec::new(),
            indices: Vec::new(),
            mesh_rid: None,
            instance_rid: None,
            dirty: true,
        };

        godot_print!(
            "DEBUG ChunkMesh::new -> ({}, {}) created (dirty=true, no RIDs yet)",
            cx,
            cy
        );

        mesh
    }

    /// Clear CPU-side buffers (used before rebuilding)
    pub fn clear(&mut self) {
        godot_print!(
            "DEBUG ChunkMesh::clear -> ({}, {}) clearing geometry (verts={}, indices={})",
            self.cx,
            self.cy,
            self.vertices.len(),
            self.indices.len()
        );

        self.vertices.clear();
        self.uvs.clear();
        self.indices.clear();
        self.dirty = true;

        godot_print!(
            "DEBUG ChunkMesh::clear -> ({}, {}) now empty, dirty=true",
            self.cx,
            self.cy
        );
    }

    /// Mark this chunk as needing a GPU upload
    pub fn mark_dirty(&mut self) {
        self.dirty = true;
        godot_print!(
            "DEBUG ChunkMesh::mark_dirty -> ({}, {}) marked dirty",
            self.cx,
            self.cy
        );
    }

    /// Mark this chunk as clean after GPU upload
    pub fn mark_clean(&mut self) {
        self.dirty = false;
        godot_print!(
            "DEBUG ChunkMesh::mark_clean -> ({}, {}) marked clean (mesh_rid={:?}, instance_rid={:?})",
            self.cx,
            self.cy,
            self.mesh_rid,
            self.instance_rid
        );
    }

    /// Returns true if this chunk has no geometry
    pub fn is_empty(&self) -> bool {
        let empty = self.vertices.is_empty();
        if empty {
            godot_print!(
                "DEBUG ChunkMesh::is_empty -> ({}, {}) EMPTY (verts=0)",
                self.cx,
                self.cy
            );
        }
        empty
    }

    /// Compute world-space offset for this chunk
    /// (used by renderer_node.rs when placing instances)
    ///
    /// Now matches MeshBuilder's XZ-plane layout: X/Z = chunk grid, Y = up.
    pub fn world_offset(&self, chunk_size: i32) -> Vector3 {
        Vector3::new(
            (self.cx * chunk_size) as f32,
            0.0,
            (self.cy * chunk_size) as f32,
        )
    }

    /// ------------------------------------------------------------
    /// Debug helper: print full state of this chunk mesh
    /// ------------------------------------------------------------
    pub fn debug_print_state(&self) {
        godot_print!(
            "DEBUG ChunkMesh STATE -> ({}, {}) verts={} uvs={} indices={} mesh_rid={:?} instance_rid={:?} dirty={}",
            self.cx,
            self.cy,
            self.vertices.len(),
            self.uvs.len(),
            self.indices.len(),
            self.mesh_rid,
            self.instance_rid,
            self.dirty
        );
    }
}

// --- END: rust/ssxl_ext/src\renderer\chunk_mesh.rs ---
       121 LOC | rust/ssxl_ext/src\renderer\mesh_builder.rs
// --- START: rust/ssxl_ext/src\renderer\mesh_builder.rs ---
use godot::prelude::*;

use crate::renderer::chunk_mesh::ChunkMesh;
use crate::renderer::atlas::SSXLAtlas;
use crate::shared_tile::TileData;

/// ------------------------------------------------------------
/// SSXL Mesh Builder (Plan B)
/// Tiles now built on the XZ plane (Y = up).
/// ------------------------------------------------------------
pub struct MeshBuilder {
    pub tile_size: f32,   // world-space tile size (usually 1.0)
}

impl MeshBuilder {
    pub fn new(tile_size: f32) -> Self {
        MeshBuilder { tile_size }
    }

    pub fn build_chunk_mesh(
        &self,
        chunk_mesh: &mut ChunkMesh,
        tiles: &[TileData],
        chunk_size: i32,
        atlas: &SSXLAtlas,
    ) {
        chunk_mesh.clear();

        let tile_size = self.tile_size;
        let tiles_per_side = chunk_size as usize;

        let mut printed_first = false;

        for local_y in 0..tiles_per_side {
            for local_x in 0..tiles_per_side {
                let idx = local_y * tiles_per_side + local_x;
                if idx >= tiles.len() {
                    continue;
                }

                let tile = tiles[idx];

                if tile.tile_id == 0 {
                    continue;
                }

                // ------------------------------------------------------------
                // DEBUG: tile ID sanity check
                // ------------------------------------------------------------
                if tile.tile_id < 0 {
                    godot_warn!(
                        "DEBUG MeshBuilder: INVALID tile_id={} at ({}, {})",
                        tile.tile_id, local_x, local_y
                    );
                }

                // ------------------------------------------------------------
                // Compute world-space quad position (XZ plane)
                // ------------------------------------------------------------
                let x0 = (local_x as f32) * tile_size;
                let z0 = (local_y as f32) * tile_size;
                let x1 = x0 + tile_size;
                let z1 = z0 + tile_size;

                // ------------------------------------------------------------
                // Fetch UVs from atlas
                // ------------------------------------------------------------
                let uv = atlas.get_uv(tile.tile_id as usize);

                // ------------------------------------------------------------
                // DEBUG: UV sanity check
                // ------------------------------------------------------------
                if uv.uv_min.x < 0.0 || uv.uv_min.y < 0.0 ||
                   uv.uv_max.x > 1.0 || uv.uv_max.y > 1.0 {
                    godot_warn!(
                        "DEBUG MeshBuilder: UV OUT OF RANGE for tile_id={} -> min={:?}, max={:?}",
                        tile.tile_id, uv.uv_min, uv.uv_max
                    );
                }

                // ------------------------------------------------------------
                // Push quad vertices (floor at y = 0)
                // ------------------------------------------------------------
                let base_index = chunk_mesh.vertices.len() as u32;

                let v0 = Vector3::new(x0, 0.0, z0);
                let v1 = Vector3::new(x1, 0.0, z0);
                let v2 = Vector3::new(x1, 0.0, z1);
                let v3 = Vector3::new(x0, 0.0, z1);

                chunk_mesh.vertices.push(v0);
                chunk_mesh.vertices.push(v1);
                chunk_mesh.vertices.push(v2);
                chunk_mesh.vertices.push(v3);

                let uv0 = uv.uv_min;
                let uv1 = Vector2::new(uv.uv_max.x, uv.uv_min.y);
                let uv2 = uv.uv_max;
                let uv3 = Vector2::new(uv.uv_min.x, uv.uv_max.y);

                chunk_mesh.uvs.push(uv0);
                chunk_mesh.uvs.push(uv1);
                chunk_mesh.uvs.push(uv2);
                chunk_mesh.uvs.push(uv3);

                // ------------------------------------------------------------
                // DEBUG: Print the first tile's geometry + UVs
                // ------------------------------------------------------------
                if !printed_first {
                    printed_first = true;

                    godot_print!(
                        "DEBUG MeshBuilder: first tile at ({}, {}), tile_id={}",
                        local_x, local_y, tile.tile_id
                    );

                    godot_print!(
                        "DEBUG MeshBuilder: atlas UV rect = min={:?}, max={:?}",
                        uv.uv_min, uv.uv_max
                    );

                    godot_print!(
                        "DEBUG MeshBuilder: first 4 vertices = {:?}, {:?}, {:?}, {:?}",
                        v0, v1, v2, v3
                    );

                    godot_print!(
                        "DEBUG MeshBuilder: first 4 UVs = {:?}, {:?}, {:?}, {:?}",
                        uv0, uv1, uv2, uv3
                    );
                }

                // ------------------------------------------------------------
                // Push indices (two triangles)
                // ------------------------------------------------------------
                chunk_mesh.indices.extend_from_slice(&[
                    base_index,
                    base_index + 1,
                    base_index + 2,
                    base_index,
                    base_index + 2,
                    base_index + 3,
                ]);
            }
        }

        // ------------------------------------------------------------
        // DEBUG: Summary of geometry
        // ------------------------------------------------------------
        godot_print!(
            "DEBUG MeshBuilder: chunk ({}, {}) built -> verts={} uvs={} indices={}",
            chunk_mesh.cx,
            chunk_mesh.cy,
            chunk_mesh.vertices.len(),
            chunk_mesh.uvs.len(),
            chunk_mesh.indices.len()
        );

        if chunk_mesh.vertices.is_empty() {
            godot_warn!(
                "DEBUG MeshBuilder: chunk ({}, {}) has NO GEOMETRY â€” material will appear NULL",
                chunk_mesh.cx,
                chunk_mesh.cy
            );
        }

        if chunk_mesh.indices.is_empty() {
            godot_warn!(
                "DEBUG MeshBuilder: chunk ({}, {}) has NO INDICES â€” surface will be empty",
                chunk_mesh.cx,
                chunk_mesh.cy
            );
        }

        chunk_mesh.mark_dirty();
    }
}

// --- END: rust/ssxl_ext/src\renderer\mesh_builder.rs ---
       122 LOC | rust/ssxl_ext/src\renderer\mesh_upload.rs
// --- START: rust/ssxl_ext/src\renderer\mesh_upload.rs ---
use godot::prelude::*;
use godot::classes::RenderingServer;
use godot::classes::rendering_server::PrimitiveType;
use godot::builtin::{
    Array as VarArray, PackedInt32Array, PackedVector2Array, PackedVector3Array, Variant,
};

use crate::renderer::chunk_mesh::ChunkMesh;

pub struct MeshUpload;

impl MeshUpload {
    pub fn upload_chunk_mesh(
        chunk_mesh: &mut ChunkMesh,
        chunk_size: i32,
        scenario: Rid,
    ) -> Rid {
        let mut rs = RenderingServer::singleton();

        // If this mesh has no geometry, free any existing RIDs and return an invalid RID.
        if chunk_mesh.is_empty() {
            godot_warn!(
                "DEBUG MeshUpload: chunk ({}, {}) EMPTY â€” freeing RIDs",
                chunk_mesh.cx, chunk_mesh.cy
            );
            MeshUpload::free_chunk_mesh(chunk_mesh);
            return Rid::new(0);
        }

        // ------------------------------------------------------------
        // Ensure ArrayMesh RID exists
        // ------------------------------------------------------------
        let mesh_rid = match chunk_mesh.mesh_rid {
            Some(rid) => {
                godot_print!(
                    "DEBUG MeshUpload: reusing mesh_rid={:?} for chunk ({}, {})",
                    rid, chunk_mesh.cx, chunk_mesh.cy
                );
                rid
            }
            None => {
                let rid = rs.mesh_create();
                chunk_mesh.mesh_rid = Some(rid);
                godot_print!(
                    "DEBUG MeshUpload: created NEW mesh_rid={:?} for chunk ({}, {})",
                    rid, chunk_mesh.cx, chunk_mesh.cy
                );
                rid
            }
        };

        // ------------------------------------------------------------
        // Build PackedArrays
        // ------------------------------------------------------------
        let verts = PackedVector3Array::from_iter(chunk_mesh.vertices.iter().copied());
        let uvs = PackedVector2Array::from_iter(chunk_mesh.uvs.iter().copied());
        let indices = PackedInt32Array::from_iter(chunk_mesh.indices.iter().map(|i| *i as i32));

        let verts_var = Variant::from(verts);
        let uvs_var = Variant::from(uvs);
        let indices_var = Variant::from(indices);
        let nil = Variant::nil();

        // ------------------------------------------------------------
        // Build surface array for mesh_add_surface_from_arrays
        // ------------------------------------------------------------
        const ARRAY_MAX: usize = 13;
        const ARRAY_VERTEX: usize = 0;
        const ARRAY_TEX_UV: usize = 4;
        const ARRAY_INDEX: usize = 12;

        let mut surface = VarArray::new();
        surface.resize(ARRAY_MAX, &nil);
        surface.set(ARRAY_VERTEX, &verts_var);
        surface.set(ARRAY_TEX_UV, &uvs_var);
        surface.set(ARRAY_INDEX, &indices_var);

        // ------------------------------------------------------------
        // Upload to GPU
        // ------------------------------------------------------------
        rs.mesh_clear(mesh_rid);
        rs.mesh_add_surface_from_arrays(mesh_rid, PrimitiveType::TRIANGLES, &surface);

        // DEBUG: surface count after upload
        let surf_count = rs.mesh_get_surface_count(mesh_rid);
        godot_print!(
            "DEBUG MeshUpload: mesh_rid={:?} now has {} surfaces (verts={}, indices={})",
            mesh_rid,
            surf_count,
            chunk_mesh.vertices.len(),
            chunk_mesh.indices.len()
        );

        if surf_count == 0 {
            godot_warn!(
                "DEBUG MeshUpload: WARNING â€” mesh_rid={:?} has NO SURFACES. Material will appear NULL.",
                mesh_rid
            );
        }

        // ------------------------------------------------------------
        // Ensure instance RID exists
        // ------------------------------------------------------------
        let instance_rid = match chunk_mesh.instance_rid {
            Some(rid) => {
                godot_print!(
                    "DEBUG MeshUpload: reusing instance_rid={:?} for chunk ({}, {})",
                    rid, chunk_mesh.cx, chunk_mesh.cy
                );
                rid
            }
            None => {
                let rid = rs.instance_create();
                chunk_mesh.instance_rid = Some(rid);
                godot_print!(
                    "DEBUG MeshUpload: created NEW instance_rid={:?} for chunk ({}, {})",
                    rid, chunk_mesh.cx, chunk_mesh.cy
                );
                rs.instance_set_base(rid, mesh_rid);
                rs.instance_set_scenario(rid, scenario);
                rid
            }
        };

        // ------------------------------------------------------------
        // Position chunk
        // ------------------------------------------------------------
        let offset = chunk_mesh.world_offset(chunk_size);
        let transform = Transform3D::new(Basis::IDENTITY, offset);
        rs.instance_set_transform(instance_rid, transform);

        godot_print!(
            "DEBUG MeshUpload: instance_rid={:?} transform set to {:?}",
            instance_rid,
            offset
        );

        chunk_mesh.mark_clean();
        mesh_rid
    }

    pub fn free_chunk_mesh(chunk_mesh: &mut ChunkMesh) {
        let mut rs = RenderingServer::singleton();

        if let Some(inst) = chunk_mesh.instance_rid.take() {
            godot_print!(
                "DEBUG MeshUpload: freeing instance_rid={:?} for chunk ({}, {})",
                inst, chunk_mesh.cx, chunk_mesh.cy
            );
            rs.free_rid(inst);
        }
        if let Some(mesh) = chunk_mesh.mesh_rid.take() {
            godot_print!(
                "DEBUG MeshUpload: freeing mesh_rid={:?} for chunk ({}, {})",
                mesh, chunk_mesh.cx, chunk_mesh.cy
            );
            rs.free_rid(mesh);
        }
    }
}

// --- END: rust/ssxl_ext/src\renderer\mesh_upload.rs ---
         6 LOC | rust/ssxl_ext/src\renderer\mod.rs
// --- START: rust/ssxl_ext/src\renderer\mod.rs ---
// ------------------------------------------------------------
// SSXL Renderer (Plan B)
// ------------------------------------------------------------
//
// This module owns the entire rendering pipeline for SSXL.
//
// Responsibilities:
// âœ… Read raw chunk buffers from SSXLChunkBuffer
// âœ… Build perâ€‘chunk meshes (CPU)
// âœ… Upload meshes to Godot's RenderingServer (GPU)
// âœ… Manage chunk instances, visibility, and culling
// âœ… Replace TileMap entirely
//
// Submodules:
// - chunk_mesh.rs:     CPU-side mesh representation
// - mesh_builder.rs:   Converts TileData â†’ vertices/UVs/indices
// - atlas.rs:          UV atlas mapping for tiles
// - mesh_upload.rs:    RenderingServer mesh creation + updates
// - renderer_node.rs:  Godot-facing node that owns the renderer
//
// ------------------------------------------------------------

pub mod chunk_mesh;
pub mod mesh_builder;
pub mod atlas;
pub mod mesh_upload;
pub mod renderer_node;

// Re-export the main renderer node for easy access
pub use renderer_node::SSXLRenderer;

// --- END: rust/ssxl_ext/src\renderer\mod.rs ---
       129 LOC | rust/ssxl_ext/src\renderer\renderer_node.rs
// --- START: rust/ssxl_ext/src\renderer\renderer_node.rs ---
use godot::prelude::*;
use std::collections::HashMap;

use crate::renderer::chunk_mesh::ChunkMesh;
use crate::renderer::mesh_builder::MeshBuilder;
use crate::renderer::mesh_upload::MeshUpload;
use crate::renderer::atlas::SSXLAtlas;

use crate::ssxl_chunk_buffer::SSXLChunkBuffer;

/// ------------------------------------------------------------
/// SSXLRenderer (Plan B)
/// ------------------------------------------------------------
#[derive(GodotClass)]
#[class(base = Node3D)]
pub struct SSXLRenderer {
    #[base]
    base: Base<Node3D>,

    /// Source of tile data (Plan B buffer).
    chunk_buffer: Option<Gd<SSXLChunkBuffer>>,
    /// CPU-side meshes per chunk coord.
    chunk_meshes: HashMap<(i32, i32), ChunkMesh>,

    /// CPU-side mesh builder.
    mesh_builder: MeshBuilder,
    /// UV atlas for tiles.
    atlas: SSXLAtlas,

    /// Chunk size in tiles.
    chunk_size: i32,
    /// Scenario RID used for instances (lazy-initialized).
    scenario_rid: Option<Rid>,
}

#[godot_api]
impl INode3D for SSXLRenderer {
    fn init(base: Base<Node3D>) -> Self {
        SSXLRenderer {
            base,
            chunk_buffer: None,
            chunk_meshes: HashMap::new(),
            mesh_builder: MeshBuilder::new(1.0),
            atlas: SSXLAtlas::new_uniform(32, 32),
            chunk_size: 32,
            scenario_rid: None,
        }
    }

    fn ready(&mut self) {
        if let Some(world) = self.base().get_world_3d() {
            self.scenario_rid = Some(world.get_scenario());
            godot_print!(
                "SSXLRenderer ready, scenario RID = {:?}",
                self.scenario_rid
            );
        } else {
            godot_warn!("SSXLRenderer: No World3D available in ready().");
        }
    }
}

#[godot_api]
impl SSXLRenderer {
    // ------------------------------------------------------------
    // Configuration
    // ------------------------------------------------------------
    #[func]
    pub fn set_chunk_buffer(&mut self, buffer: Gd<SSXLChunkBuffer>) {
        self.chunk_buffer = Some(buffer);
    }

    #[func]
    pub fn set_chunk_size(&mut self, size: i32) {
        self.chunk_size = size;
        self.mesh_builder = MeshBuilder::new(1.0);
    }

    #[func]
    pub fn set_uniform_atlas(&mut self, tiles_x: i32, tiles_y: i32) {
        self.atlas = SSXLAtlas::new_uniform(tiles_x, tiles_y);
    }

    // ------------------------------------------------------------
    // Expose instance RID (first valid chunk)
    // ------------------------------------------------------------
    #[func]
    pub fn get_instance_rid(&self) -> Rid {
        self.chunk_meshes
            .values()
            .find_map(|m| m.instance_rid)
            .unwrap_or(Rid::new(0))
    }

    // ------------------------------------------------------------
    // Expose mesh RID (first valid chunk)
    // ------------------------------------------------------------
    #[func]
    pub fn get_mesh_rid(&self) -> Rid {
        self.chunk_meshes
            .values()
            .find_map(|m| m.mesh_rid)
            .unwrap_or(Rid::new(0))
    }

    // ------------------------------------------------------------
    // PLAN B: Reset world
    // ------------------------------------------------------------
    #[func]
    pub fn reset_world(&mut self) {
        for (_, mesh) in self.chunk_meshes.iter_mut() {
            MeshUpload::free_chunk_mesh(mesh);
        }

        self.chunk_meshes.clear();
        godot_print!("SSXLRenderer: world reset.");
    }

    // ------------------------------------------------------------
    // PLAN B: Begin world
    // ------------------------------------------------------------
    #[func]
    pub fn begin_world(&mut self, world_w: i32, world_h: i32, chunk_size: i32) {
        self.chunk_size = chunk_size;
        godot_print!(
            "SSXLRenderer: begin world {}x{} (chunk_size={})",
            world_w,
            world_h,
            chunk_size
        );
    }

    // ------------------------------------------------------------
    // PLAN B: Apply chunk data
    // ------------------------------------------------------------
    #[func]
    pub fn apply_chunk(&mut self, cx: i32, cy: i32) {
        let buffer = match &self.chunk_buffer {
            Some(b) => b,
            None => {
                godot_error!("SSXLRenderer: No chunk buffer set.");
                return;
            }
        };

        let binding = buffer.bind();
        let tiles = match binding.get_chunk_slice(cx, cy) {
            Some(slice) => slice,
            None => {
                godot_warn!("SSXLRenderer: No tiles for chunk ({}, {}).", cx, cy);
                return;
            }
        };

        // Ensure scenario RID exists
        if self.scenario_rid.is_none() {
            if let Some(world) = self.base().get_world_3d() {
                self.scenario_rid = Some(world.get_scenario());
            } else {
                godot_error!("SSXLRenderer: No World3D at apply_chunk.");
                return;
            }
        }

        let scenario = self.scenario_rid.unwrap();

        // Build mesh
        let mesh_key = (cx, cy);
        let mesh = self
            .chunk_meshes
            .entry(mesh_key)
            .or_insert_with(|| ChunkMesh::new(cx, cy));

        self.mesh_builder
            .build_chunk_mesh(mesh, tiles, self.chunk_size, &self.atlas);

        // DEBUG: print geometry info
        godot_print!(
            "DEBUG: Chunk ({}, {}) verts={} indices={}",
            cx,
            cy,
            mesh.vertices.len(),
            mesh.indices.len()
        );

        // Upload via RenderingServer
        MeshUpload::upload_chunk_mesh(mesh, self.chunk_size, scenario);

        godot_print!(
            "SSXLRenderer: applied chunk ({}, {}), mesh uploaded.",
            cx,
            cy
        );
    }

    // ------------------------------------------------------------
    // PLAN B: Finalize world
    // ------------------------------------------------------------
    #[func]
    pub fn finalize_world(&mut self) {
        godot_print!("SSXLRenderer: finalize world.");
    }
}

// --- END: rust/ssxl_ext/src\renderer\renderer_node.rs ---
        19 LOC | rust/ssxl_ext/src\rhythm_manager.rs
// --- START: rust/ssxl_ext/src\rhythm_manager.rs ---
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq)]
#[allow(dead_code)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

pub struct RhythmManager {
    _last_check_time: Instant,
    _current_phase: RhythmPhase,
}

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            _last_check_time: Instant::now(),
            _current_phase: RhythmPhase::Idle,
        }
    }
}
// --- END: rust/ssxl_ext/src\rhythm_manager.rs ---
        51 LOC | rust/ssxl_ext/src\shared_chunk.rs
// --- START: rust/ssxl_ext/src\shared_chunk.rs ---
use crate::shared_math::ChunkCoords;
use crate::shared_tile::TileData;

/// Represents a single, self-contained, generated block of the world map.
/// This structure is the primary payload sent from worker threads to the conductor.
#[derive(Debug, Clone, Default)]
pub struct Chunk {
    /// The discrete coordinates (X, Y) identifying this chunk in the world grid.
    pub position: ChunkCoords,

    /// The edge length of the chunk (e.g., 32 for a 32x32 chunk).
    pub size: u32,

    /// The flat, contiguous array of tile data for the chunk.
    /// Storage is in Row-Major order (Y is outer loop, X is inner loop).
    pub tiles: Vec<TileData>,

    /// Metadata flag indicating if this chunk contains dynamic assets (entities, lights, etc.).
    pub contains_assets: bool,
}

impl Chunk {
    /// Initializes a new, empty chunk with the required size and position.
    pub fn new(position: ChunkCoords, size: u32) -> Self {
        let capacity = (size * size) as usize;

        Self {
            position,
            size,
            // IMPORTANT FIX:
            // Pre-fill the tile buffer so generator steps can safely write into it.
            tiles: vec![TileData::default(); capacity],
            contains_assets: false,
        }
    }

    /// Calculates the 1D index from 2D local coordinates (X, Y).
    #[inline]
    pub fn get_index(&self, x: u32, y: u32) -> usize {
        (y * self.size + x) as usize
    }

    /// Gets an immutable reference to the TileData at the specified local coordinates.
    #[inline]
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        self.tiles.get(self.get_index(x, y))
    }

    /// Gets a mutable reference to the TileData for modification during generation.
    #[inline]
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        let idx = self.get_index(x, y);
        self.tiles.get_mut(idx)
    }

    // -------------------------------------------------------------------------
    // Helpers for halo-based CA
    // -------------------------------------------------------------------------

    /// Converts local chunk coordinates (0..size) into world coordinates.
    #[inline]
    pub fn local_to_world(&self, lx: i32, ly: i32) -> (i32, i32) {
        let base_x = self.position.0 * self.size as i32;
        let base_y = self.position.1 * self.size as i32;
        (base_x + lx, base_y + ly)
    }

    /// Converts world coordinates back into local chunk coordinates.
    /// Returns None if the world coordinate is not inside this chunk.
    #[inline]
    pub fn world_to_local(&self, wx: i32, wy: i32) -> Option<(u32, u32)> {
        let base_x = self.position.0 * self.size as i32;
        let base_y = self.position.1 * self.size as i32;

        let lx = wx - base_x;
        let ly = wy - base_y;

        if lx >= 0 && ly >= 0 && lx < self.size as i32 && ly < self.size as i32 {
            Some((lx as u32, ly as u32))
        } else {
            None
        }
    }

    /// Computes the world coordinate of the chunkâ€™s top-left tile.
    #[inline]
    pub fn world_origin(&self) -> (i32, i32) {
        (
            self.position.0 * self.size as i32,
            self.position.1 * self.size as i32,
        )
    }
}

// --- END: rust/ssxl_ext/src\shared_chunk.rs ---
        89 LOC | rust/ssxl_ext/src\shared_config.rs
// --- START: rust/ssxl_ext/src\shared_config.rs ---
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct GenerationConfig {
    pub perlin: PerlinNoiseConfig,
    pub ca: CellularAutomataConfig,
    pub world_seed: u64,
}

impl Default for GenerationConfig {
    fn default() -> Self {
        Self {
            perlin: PerlinNoiseConfig::default(),
            ca: CellularAutomataConfig::default(),
            world_seed: 5011993,
        }
    }
}

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct PerlinNoiseConfig {
    pub scale: f64,
    pub octaves: usize,
    pub persistence: f64,
    pub lacunarity: f64,
    pub threshold: f64,
}

impl Default for PerlinNoiseConfig {
    fn default() -> Self {
        Self {
            scale: 250.0,
            octaves: 3,
            persistence: 0.5,
            lacunarity: 2.0,
            threshold: 0.0,
        }
    }
}

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct CellularAutomataConfig {
    pub death_limit: u8,
    pub birth_limit: u8,
    pub steps: u8,
}

impl Default for CellularAutomataConfig {
    fn default() -> Self {
        Self {
            death_limit: 4,
            birth_limit: 5,
            steps: 5,
        }
    }
}

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct ThreadingConfig {
    pub generation_worker_count: u32,
    pub animation_worker_count: u32,
    pub task_channel_capacity: usize,
}

impl Default for ThreadingConfig {
    fn default() -> Self {
        Self {
            generation_worker_count: 4,
            animation_worker_count: 2,
            task_channel_capacity: 4096,
        }
    }
}

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct MapSettingsConfig {
    pub chunk_size: u32,
    pub map_extent_chunks: i32,
    pub tile_scale_factor: f32,
}

impl Default for MapSettingsConfig {
    fn default() -> Self {
        Self {
            chunk_size: 32,
            map_extent_chunks: 8,
            tile_scale_factor: 1.0,
        }
    }
}

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct AnimationConfig {
    pub worker_count: usize,
    pub simulation_fps: u32,
    pub fluid_damping_factor: f32,
}

impl Default for AnimationConfig {
    fn default() -> Self {
        Self {
            worker_count: 2,
            simulation_fps: 30,
            fluid_damping_factor: 0.95,
        }
    }
}

// --- END: rust/ssxl_ext/src\shared_config.rs ---
        36 LOC | rust/ssxl_ext/src\shared_error.rs
// --- START: rust/ssxl_ext/src\shared_error.rs ---
use thiserror::Error;

#[derive(Debug, Error, Clone)]
pub enum SSXLCoreError {
    #[error("Core state uninitialized: HostState singleton is not yet set.")]
    UninitializedState,

    #[error("Core state uninitialized: HostState singleton is not yet set.")]
    NotInitialized,

    #[error("Core initialization failed: {0}")]
    InitializationError(String),

    #[error("Conductor lifecycle error: Conductor is currently busy and cannot accept new jobs.")]
    ConductorBusy,

    #[error("Conductor lifecycle error: System is currently in state '{0}'.")]
    InvalidConductorState(String),

    #[error("Configuration error: Invalid value for '{0}'.")]
    InvalidConfig(String),

    #[error("Channel sending failed: {0}")]
    ChannelSendError(String),

    #[error("Channel receiving failed: {0}")]
    ChannelRecvError(String),

    #[error("Thread management error: Worker thread join failed.")]
    ThreadJoinError,

    #[error("Generation data error: {0}")]
    GenerationDataError(String),

    #[error("Mathematical boundary error: {0}")]
    MathError(String),

    #[error("Target TileMap ID is invalid (0).")]
    InvalidTarget,

    #[error("TileMap ID '{0}' is invalid or null.")]
    InvalidInstance(i64),

    #[error("FFI Bridge error: Direct memory write failed: {0}")]
    FFIWriteError(String),

    #[error("Godot API failure on '{0}': {1}")]
    GodotAPIFailure(String, String),
}

impl SSXLCoreError {
    pub fn to_ffi_code(&self) -> isize {
        match self {
            SSXLCoreError::UninitializedState => -2,
            SSXLCoreError::NotInitialized => -2,
            SSXLCoreError::InvalidTarget => -5,
            SSXLCoreError::ConductorBusy => -6,
            _ => {
                crate::ssxl_warn!(
                    "Unhandled critical error in SSXLCoreError::to_ffi_code. \
                     Mapping to FFI -3 (ConductorStopped): {:?}",
                    self
                );
                -3
            }
        }
    }
}

// --- END: rust/ssxl_ext/src\shared_error.rs ---
        37 LOC | rust/ssxl_ext/src\shared_job.rs
// --- START: rust/ssxl_ext/src\shared_job.rs ---
// rust/SSXL-ext/src/shared_job.rs

use crate::generate_task_queue::GenerationTask;

/// Defines the sequential steps required to fully process a single chunk.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum JobStep {
    /// Initial state: The task has been queued.
    Queued,
    /// Step 1: Raw Perlin noise generation is running.
    NoiseGeneration,
    /// Step 2: Cellular Automata refinement is running.
    CARefinement,
    /// Step 3: Post-processing and refinement (e.g., placing entities, blending).
    PostProcessing,
    /// Final state: The chunk data is ready to be sent to the Conductor's finisher queue.
    Finished,
    /// Error state: A worker encountered an unrecoverable error.
    Failed,
}

// rust/SSXL-ext/src/shared_job.rs

use crate::shared_chunk::Chunk;
use crate::shared_math::ChunkCoords;

/// Represents a complete, multi-stage task for generating a single world chunk.
#[derive(Debug, Clone)]
pub struct GenerationJob {
    /// The unique identifier for this job (e.g., the chunk's coordinates).
    pub id: ChunkCoords,
    /// The core data and parameters for the job.
    pub task: GenerationTask,
    /// The current stage of processing for this job.
    pub current_step: JobStep,
    /// The partially or fully completed chunk data.
    pub chunk_data: Chunk,
}

impl GenerationJob {
    /// Creates a new job, initializing its state.
    pub fn new(task: GenerationTask) -> Self {
        let chunk_data = Chunk::new(task.chunk_pos, task.chunk_size);
        
        GenerationJob {
            id: task.chunk_pos,
            task,
            current_step: JobStep::Queued,
            chunk_data,
        }
    }

    /// Advances the job to the next sequential step.
    pub fn advance_step(&mut self) {
        self.current_step = match self.current_step {
            JobStep::Queued => JobStep::NoiseGeneration,
            JobStep::NoiseGeneration => JobStep::CARefinement,
            JobStep::CARefinement => JobStep::PostProcessing,
            JobStep::PostProcessing => JobStep::Finished,
            // Finished and Failed are terminal states
            _ => self.current_step,
        };
    }
}
// --- END: rust/ssxl_ext/src\shared_job.rs ---
        43 LOC | rust/ssxl_ext/src\shared_math.rs
// --- START: rust/ssxl_ext/src\shared_math.rs ---
// --------------------------------------------------------------------------
// --- Type Aliases ---
// --------------------------------------------------------------------------

/// Type alias for 2D chunk coordinates (X, Y).
/// Used as the primary key for chunk addressing across the system (e.g., in cache.rs).
pub type ChunkCoords = (i32, i32);

/// Type alias for 2D coordinates used to identify a single tile within a chunk.
pub type LocalTileCoords = (i32, i32);

/// Type alias for 2D coordinates identifying a single tile in the entire world.
pub type WorldTileCoords = (i32, i32);


// --------------------------------------------------------------------------
// --- Constants ---
// --------------------------------------------------------------------------

pub const CA_NEIGHBOR_COUNT: u8 = 8;
pub const WORLD_GRAVITY_FACTOR: f32 = 9.81;
pub const F32_EPSILON: f32 = 0.00001;


// --------------------------------------------------------------------------
// --- Shared Structures ---
// --------------------------------------------------------------------------

#[derive(Debug, Clone, Copy, Default)]
#[repr(C)]
pub struct EntityMovementState {
    pub position_x: f32,
    pub position_y: f32,
    pub velocity_x: f32,
    pub velocity_y: f32,
}


// --------------------------------------------------------------------------
// --- NEW: Chunk / Tile Coordinate Helpers (for halo CA) ---
// --------------------------------------------------------------------------

/// Extension helpers for ChunkCoords.
/// These do not change any existing behavior; they simply provide
/// the math needed for halo-based CA and neighbor lookup.
pub trait ChunkCoordsExt {
    /// Returns the coordinates of a neighboring chunk.
    /// Example: (cx, cy).neighbor(1, 0) â†’ (cx+1, cy)
    fn neighbor(self, dx: i32, dy: i32) -> ChunkCoords;

    /// Converts world tile coordinates into chunk coordinates.
    /// Example: world (65, 10) with chunk_size 32 â†’ chunk (2, 0)
    fn world_to_chunk(world: WorldTileCoords, chunk_size: i32) -> ChunkCoords;

    /// Converts world tile coordinates into local tile coordinates inside a chunk.
    /// Returns None if the world coordinate is not inside this chunk.
    fn world_to_local(self, world: WorldTileCoords, chunk_size: i32) -> Option<LocalTileCoords>;

    /// Computes the world-space origin (top-left tile) of this chunk.
    fn world_origin(self, chunk_size: i32) -> WorldTileCoords;
}

impl ChunkCoordsExt for ChunkCoords {
    #[inline]
    fn neighbor(self, dx: i32, dy: i32) -> ChunkCoords {
        (self.0 + dx, self.1 + dy)
    }

    #[inline]
    fn world_to_chunk(world: WorldTileCoords, chunk_size: i32) -> ChunkCoords {
        (
            world.0.div_euclid(chunk_size),
            world.1.div_euclid(chunk_size),
        )
    }

    #[inline]
    fn world_to_local(self, world: WorldTileCoords, chunk_size: i32) -> Option<LocalTileCoords> {
        let origin_x = self.0 * chunk_size;
        let origin_y = self.1 * chunk_size;

        let lx = world.0 - origin_x;
        let ly = world.1 - origin_y;

        if lx >= 0 && ly >= 0 && lx < chunk_size && ly < chunk_size {
            Some((lx, ly))
        } else {
            None
        }
    }

    #[inline]
    fn world_origin(self, chunk_size: i32) -> WorldTileCoords {
        (self.0 * chunk_size, self.1 * chunk_size)
    }
}

// --- END: rust/ssxl_ext/src\shared_math.rs ---
        23 LOC | rust/ssxl_ext/src\shared_message.rs
// --- START: rust/ssxl_ext/src\shared_message.rs ---
// rust/SSXL-ext/src/shared_message.rs

/// Control messages sent to the generation workers (sync_pool.rs).
#[derive(Debug, Clone, Copy)]
pub enum GenerationControlMessage {
    /// Instructs the workers to stop processing new tasks but finish current ones.
    Pause,
    /// Instructs the workers to stop immediately and shut down the thread.
    Stop,
    /// Forces a worker to reload its configuration from the global state.
    ReloadConfig,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_chunk::Chunk;
use crate::shared_error::SSXLCoreError;

/// Data messages sent from the generation workers back to the main thread Conductor.
#[derive(Debug)]
pub enum GenerationDataMessage {
    /// A completed chunk ready for direct writing to the TileMap.
    CompletedChunk(Chunk),
    /// A fatal error occurred during the processing of a specific chunk.
    JobFailure(SSXLCoreError),
    /// A simple acknowledgement that a worker is initialized or has cleared its state.
    Ack,
}

// rust/SSXL-ext/src/shared_message.rs

use crate::shared_config::AnimationConfig;

/// Control messages sent to the animation workers (animate_worker.rs).
#[derive(Debug, Clone, Copy)]
pub enum AnimationControlMessage {
    Pause,
    Stop,
    UpdateConfig(AnimationConfig), 
}

// rust/SSXL-ext/src/shared_message.rs

use crate::animate_events::AnimationEvent;

/// Data messages sent from the animation workers back to the main thread Conductor.
#[derive(Debug, Clone)]
pub enum AnimationDataMessage {
    /// A single, ready-to-render visual event.
    Event(AnimationEvent),
    /// A worker encountered an unrecoverable error during simulation.
    WorkerPanic(SSXLCoreError),
}
// --- END: rust/ssxl_ext/src\shared_message.rs ---
        33 LOC | rust/ssxl_ext/src\shared_tile.rs
// --- START: rust/ssxl_ext/src\shared_tile.rs ---
// rust/SSXL-ext/src/shared_tile.rs

/// The minimal data required to represent a single tile in the Godot TileMap.
///
/// #[repr(C)] ensures FFI-compatibility for direct memory writing 
/// to Godot's C++ data structures, making the chunk rendering extremely fast.
///
/// Total size: 6 bytes.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TileData {
    pub tile_id: u16,        // ID corresponding to a tile in the Godot TileSet (source ID)
    pub atlas_coords: u16,   // Packed coords within the TileSet Atlas
    pub rotation_flags: u8,  // Rotation, flip, and custom flags
    pub custom_data: u8,     // Used for dynamic data (e.g., fluid level, density score)
}

impl Default for TileData {
    fn default() -> Self {
        // Default "Air" / empty tile
        Self {
            tile_id: 0,
            atlas_coords: 0,
            rotation_flags: 0,
            custom_data: 0,
        }
    }
}

impl TileData {
    /// Returns true if this tile is considered "live" (non-zero tile_id).
    pub fn is_live(&self) -> bool {
        self.tile_id != 0
    }

    /// Sets the tile to live (tile_id = 1) or dead (tile_id = 0).
    pub fn set_live(&mut self, live: bool) {
        if live {
            if self.tile_id == 0 {
                self.tile_id = 1;
            }
        } else {
            self.tile_id = 0;
            self.atlas_coords = 0;
            self.rotation_flags = 0;
            self.custom_data = 0;
        }
    }
}

// --- END: rust/ssxl_ext/src\shared_tile.rs ---
         1 LOC | rust/ssxl_ext/src\shared_types.rs
// --- START: rust/ssxl_ext/src\shared_types.rs ---
pub type InstanceType = i64;

// --- END: rust/ssxl_ext/src\shared_types.rs ---
       112 LOC | rust/ssxl_ext/src\ssxl_chunk_buffer.rs
// --- START: rust/ssxl_ext/src\ssxl_chunk_buffer.rs ---
use std::collections::HashMap;

use godot::prelude::*;
use crate::shared_tile::TileData;

/// ------------------------------------------------------------
/// PLAN B VERSION:
/// SSXLChunkBuffer (formerly SSXLTileMap)
///
/// This node:
/// âœ… Owns perâ€‘chunk TileData buffers
/// âœ… Exposes raw pointers for SSXL core writes
/// â— Emits signals *only after data is written*, not on allocation
/// ------------------------------------------------------------
#[derive(GodotClass)]
#[class(base = Node)]
pub struct SSXLChunkBuffer {
    #[base]
    base: Base<Node>,

    /// Map of (cx, cy) -> flat tile buffer for that chunk.
    chunk_buffers: HashMap<(i32, i32), Vec<TileData>>,

    /// Cached chunk size in cells (must match SSXL config / host_state).
    chunk_size: i32,
}

#[godot_api]
impl INode for SSXLChunkBuffer {
    fn init(base: Base<Node>) -> Self {
        SSXLChunkBuffer {
            base,
            chunk_buffers: HashMap::new(),
            chunk_size: 32,
        }
    }
}

#[godot_api]
impl SSXLChunkBuffer {
    // ------------------------------------------------------------
    // Signals
    // ------------------------------------------------------------
    #[signal]
    fn chunk_ready(cx: i32, cy: i32);

    #[signal]
    fn chunk_updated(cx: i32, cy: i32);

    #[signal]
    fn chunk_cleared(cx: i32, cy: i32);

    #[signal]
    fn all_chunks_cleared();

    // ------------------------------------------------------------
    // Chunk size configuration
    // ------------------------------------------------------------
    #[func]
    pub fn set_chunk_size(&mut self, size: i32) {
        if size > 0 {
            self.chunk_size = size;
        }
    }

    #[func]
    pub fn get_chunk_size(&self) -> i32 {
        self.chunk_size
    }

    // ------------------------------------------------------------
    // Raw pointer access for SSXL core
    // (NO SIGNALS EMITTED HERE ANYMORE)
    // ------------------------------------------------------------
    #[func]
    pub fn get_raw_chunk_data_ptr(&mut self, _layer: i32, cx: i32, cy: i32) -> *mut u8 {
        let key = (cx, cy);
        let chunk_area = (self.chunk_size * self.chunk_size) as usize;

        let buf = self
            .chunk_buffers
            .entry(key)
            .or_insert_with(|| Vec::with_capacity(chunk_area));

        if buf.len() < chunk_area {
            buf.resize(chunk_area, TileData::default());
            godot_print!(
                "DEBUG: Allocated chunk buffer ({}, {}) with {} tiles",
                cx,
                cy,
                chunk_area
            );
        }

        let ptr = buf.as_mut_ptr() as *mut u8;

        godot_print!(
            "DEBUG: get_raw_chunk_data_ptr -> chunk ({}, {}) ptr={:?}",
            cx,
            cy,
            ptr
        );

        // âŒ Removed early chunk_ready signal
        // (Renderer must NOT react before data is written)

        ptr
    }

    // ------------------------------------------------------------
    // Post-copy notification (called from ssxl_notify_chunk_updated)
    // ------------------------------------------------------------
    #[func]
    pub fn notify_chunk_data_changed(&mut self, cx: i32, cy: i32) {
        // Emit chunk_ready for first-time creation,
        // or chunk_updated for subsequent writes.
        if self.chunk_buffers.contains_key(&(cx, cy)) {
            self.base_mut().emit_signal(
                "chunk_updated",
                &[Variant::from(cx), Variant::from(cy)],
            );
        } else {
            self.base_mut().emit_signal(
                "chunk_ready",
                &[Variant::from(cx), Variant::from(cy)],
            );
        }
    }

    // ------------------------------------------------------------
    // Clear all chunk buffers
    // ------------------------------------------------------------
    #[func]
    pub fn clear_chunks(&mut self) {
        self.chunk_buffers.clear();
        self.base_mut().emit_signal("all_chunks_cleared", &[]);
    }

    // ------------------------------------------------------------
    // Optional: Clear a single chunk
    // ------------------------------------------------------------
    #[func]
    pub fn clear_chunk(&mut self, cx: i32, cy: i32) {
        if self.chunk_buffers.remove(&(cx, cy)).is_some() {
            self.base_mut().emit_signal(
                "chunk_cleared",
                &[Variant::from(cx), Variant::from(cy)],
            );
        }
    }
}

impl SSXLChunkBuffer {
    // ------------------------------------------------------------
    // Rust-only accessors for the renderer
    // ------------------------------------------------------------
    pub fn get_chunk_slice(&self, cx: i32, cy: i32) -> Option<&[TileData]> {
        let slice = self.chunk_buffers.get(&(cx, cy))?;

        godot_print!(
            "DEBUG: get_chunk_slice ({}, {}) -> {} tiles",
            cx,
            cy,
            slice.len()
        );

        let first = slice.get(0).cloned().unwrap_or_default();
        godot_print!(
            "DEBUG: first tile in chunk ({}, {}) = {:?}",
            cx,
            cy,
            first
        );

        Some(slice.as_slice())
    }

    pub fn get_chunk_slice_mut(&mut self, cx: i32, cy: i32) -> Option<&mut [TileData]> {
        let existed = self.chunk_buffers.contains_key(&(cx, cy));

        if existed {
            self.base_mut().emit_signal(
                "chunk_updated",
                &[Variant::from(cx), Variant::from(cy)],
            );
        }

        self.chunk_buffers
            .get_mut(&(cx, cy))
            .map(|v| v.as_mut_slice())
    }
}

// --- END: rust/ssxl_ext/src\ssxl_chunk_buffer.rs ---
       135 LOC | rust/ssxl_ext/src\sync_pool.rs
// --- START: rust/ssxl_ext/src\sync_pool.rs ---
// rust/SSXL-ext/src/sync_pool.rs

use std::thread;
use std::sync::Arc;
use flume::{Receiver, Sender};

// Shared types used for concurrent operations
use crate::shared_job::GenerationJob; 
use crate::shared_message::GenerationDataMessage;
use crate::config::GlobalConfig;
use crate::generate_runtime;

// --------------------------------------------------------------------------
// --- Worker Structures ---
// --------------------------------------------------------------------------

/// A wrapper around a dedicated worker thread handle.
struct Worker {
    id: usize,
    handle: Option<thread::JoinHandle<()>>,
}

impl Worker {
    /// Spawns a new thread and starts the worker's execution loop.
    fn new(
        id: usize, 
        task_receiver: Arc<Receiver<GenerationJob>>, 
        chunk_sender: Sender<GenerationDataMessage>,
        // The worker needs a reference to the global configuration
        config: Arc<GlobalConfig>,
    ) -> Worker {
        let sender_clone = chunk_sender.clone();
        
        let handle = thread::spawn(move || {
            eprintln!("[worker {}] spawned and entering loop.", id);

            // Loop until the channel is disconnected (which signals shutdown)
            while let Ok(job) = task_receiver.recv() {
                eprintln!(
                    "[worker {}] received job for chunk {:?}, step {:?}",
                    id,
                    job.id,
                    job.current_step
                );

                // --- EXECUTE FULL GENERATION RUNTIME ---
                eprintln!(
                    "[worker {}] starting run_generation_job for chunk {:?}",
                    id,
                    job.id
                );
                let final_result = generate_runtime::run_generation_job(job, &config.generation);
                eprintln!(
                    "[worker {}] run_generation_job finished with result: {:?}",
                    id,
                    final_result.as_ref().map(|c| c.position)
                );

                // --- FINISHER DELIVERY ---
                let message = match final_result {
                    Ok(completed_chunk) => {
                        eprintln!(
                            "[worker {}] completed job for chunk {:?}",
                            id,
                            completed_chunk.position
                        );
                        GenerationDataMessage::CompletedChunk(completed_chunk)
                    }
                    Err(e) => {
                        eprintln!("[worker {}] failed job: {:?}", id, e);
                        GenerationDataMessage::JobFailure(e)
                    }
                };

                // Non-blocking delivery of the result back to the Conductor's main thread poller.
                if let Err(e) = sender_clone.send(message) {
                    eprintln!(
                        "[worker {}] failed to send result: {}. Conductor likely shut down.",
                        id,
                        e
                    );
                    break; 
                }

                eprintln!("[worker {}] finished cycle and waiting for next job.", id);
            }

            eprintln!("[worker {}] shutting down (task channel closed).", id);
        });

        Worker { id, handle: Some(handle) }
    }
}


// --------------------------------------------------------------------------
// --- ThreadPool Structure ---
// --------------------------------------------------------------------------

/// Manages the pool of worker threads dedicated to procedural generation.
pub struct SyncPool {
    workers: Vec<Worker>,
    // The pool holds the sender end of the channel for task submission
    task_sender: Sender<GenerationJob>,
    // The pool sends completed messages back to the Conductor
    chunk_sender: Sender<GenerationDataMessage>,
    // This handle ensures the Receiver stays alive while the workers are running.
    _task_receiver_final_handle: Receiver<GenerationJob>,
}

impl SyncPool {
    /// Creates a new SyncPool and spawns the specified number of workers.
    /// Returns the Conductor's receiving channel for completed work.
    ///
    /// Returns: (SyncPool instance, Receiver for completed chunks)
    pub fn new(num_workers: usize, config: Arc<GlobalConfig>) -> (Self, Receiver<GenerationDataMessage>) {
        // --- 1. Setup Channels ---
        let (task_sender, task_receiver_final_handle) = flume::unbounded();
        let task_receiver_arc = Arc::new(task_receiver_final_handle.clone());
        let (chunk_sender, chunk_receiver) = flume::unbounded();

        // --- 2. Spawn Workers ---
        let mut workers = Vec::with_capacity(num_workers);
        for id in 0..num_workers {
            workers.push(Worker::new(
                id,
                Arc::clone(&task_receiver_arc),
                chunk_sender.clone(),
                Arc::clone(&config),
            ));
        }

        // This one runs on the main thread, so SSXL logging is safe if you want:
        eprintln!(
            "INFO: Started SyncPool with {} dedicated workers.",
            num_workers
        );
        
        let pool = SyncPool { 
            workers, 
            task_sender, 
            chunk_sender,
            _task_receiver_final_handle: task_receiver_final_handle,
        };
        
        (pool, chunk_receiver)
    }
    
    /// Submits a new generation job to the worker pool.
    pub fn submit_job(&self, job: GenerationJob) -> Result<(), flume::SendError<GenerationJob>> {
        eprintln!(
            "DEBUG: Submitting job for chunk {:?} at step {:?} to worker pool.",
            job.id,
            job.current_step
        );
        self.task_sender.send(job)
    }
    
    /// Retrieves the current status of the worker pool (worker count and queue size).
    pub fn get_status(&self) -> (usize, usize) {
        let worker_count = self.workers.len();
        let queue_size = self.task_sender.len();
        (worker_count, queue_size)
    }
}

impl SyncPool {
    /// Signals workers to stop and waits for all threads to finish (clean shutdown).
    /// This method takes ownership and is intended to be called when the pool is 
    /// no longer needed by the owning structure.
    pub fn cleanup(self) {
        eprintln!("INFO: SyncPool.cleanup() called. Dropping channels and joining workers...");

        // Drop all senders and the receiver handle. This signals to workers to exit their loops.
        drop(self.task_sender);
        drop(self._task_receiver_final_handle);
        drop(self.chunk_sender);
        
        // Wait for all worker threads to finish.
        for mut worker in self.workers.into_iter() {
            if let Some(handle) = worker.handle.take() {
                match handle.join() {
                    Ok(()) => {
                        eprintln!("INFO: Worker {} thread joined successfully.", worker.id);
                    }
                    Err(e) => {
                        eprintln!("ERROR: Worker {} thread join failed: {:?}", worker.id, e);
                    }
                }
            }
        }
        eprintln!("INFO: SyncPool shut down successfully.");
    }
}

// --- END: rust/ssxl_ext/src\sync_pool.rs ---
        57 LOC | rust/ssxl_ext/src\sync_rhythm.rs
// --- START: rust/ssxl_ext/src\sync_rhythm.rs ---
use std::time::{Instant, Duration};
use crate::generate_conductor_state::ConductorState;
use crate::host_state::get_host_state;
use crate::{ssxl_info, ssxl_error};

const RHYTHM_CHECK_INTERVAL: Duration = Duration::from_millis(250);

pub struct RhythmManager {
    last_check_time: Instant,
    current_phase: RhythmPhase,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum RhythmPhase {
    Idle,
    CheckGenerationStatus,
    CleanUpStaleCaches,
    SyncAnimationStarts,
}

impl RhythmManager {
    pub fn new() -> Self {
        RhythmManager {
            last_check_time: Instant::now(),
            current_phase: RhythmPhase::Idle,
        }
    }

    pub fn poll_rhythm(&mut self) {
        if self.last_check_time.elapsed() >= RHYTHM_CHECK_INTERVAL {
            self.last_check_time = Instant::now();
            self.execute_rhythm_check();
        }
    }

    fn execute_rhythm_check(&mut self) {
        let host_state = match get_host_state() {
            Ok(state) => state,
            Err(_) => {
                ssxl_error!("RhythmManager tried to poll but HostState is uninitialized.");
                return;
            }
        };

        let generation_state = host_state.conductor.get_state_container();

        match self.current_phase {
            RhythmPhase::Idle => {
                if generation_state.get_state() == ConductorState::Finished {
                    self.current_phase = RhythmPhase::CheckGenerationStatus;
                }
            }

            RhythmPhase::CheckGenerationStatus => {
                ssxl_info!("Rhythm Check: Generation finished. Starting post-gen cleanup.");
                self.current_phase = RhythmPhase::SyncAnimationStarts;
            }

            RhythmPhase::SyncAnimationStarts => {
                ssxl_info!("Rhythm Check: Starting animation workers...");
                self.current_phase = RhythmPhase::CleanUpStaleCaches;
            }

            RhythmPhase::CleanUpStaleCaches => {
                self.current_phase = RhythmPhase::Idle;
            }
        }
    }
}

// --- END: rust/ssxl_ext/src\sync_rhythm.rs ---
        35 LOC | rust/ssxl_ext/src\tile_conversion.rs
// --- START: rust/ssxl_ext/src\tile_conversion.rs ---
use once_cell::sync::Lazy;

/// SSXL-optimized bitmask â†’ tile ID mapping.
/// Built once at runtime, then reused forever.
pub fn bitmask_to_id(bitmask: u8) -> i32 {
    static LUT: Lazy<[i32; 256]> = Lazy::new(|| {
        let mut table = [0i32; 256];

        for mask in 0..=255 {
            table[mask as usize] = match mask {
                0 => 0, // isolated

                // cardinal edges
                0b00001000 => 1, // top
                0b00000010 => 2, // right
                0b00000100 => 3, // bottom
                0b00000001 => 4, // left

                // outer corners
                0b00011000 => 5, // UL
                0b00101000 => 6, // UR
                0b01000100 => 7, // DR
                0b10000001 => 8, // DL

                // inner corners
                0b00001111 => 9,  // UL
                0b00011110 => 10, // UR
                0b00111100 => 11, // DR
                0b11110000 => 12, // DL

                // T-junctions
                0b00001110 => 13, // missing left
                0b00011100 => 14, // missing top
                0b00111000 => 15, // missing right
                0b01110000 => 16, // missing bottom

                // cross junctions
                0b00011111 => 17,
                0b00111110 => 18,
                0b01111100 => 19,
                0b11111000 => 20,

                // full surrounded
                0b11111111 => 21,

                // fallback
                _ => (mask % 48) as i32,
            };
        }

        table
    });

    LUT[bitmask as usize]
}

// --- END: rust/ssxl_ext/src\tile_conversion.rs ---
        56 LOC | rust/ssxl_ext/src\tools.rs
// --- START: rust/ssxl_ext/src\tools.rs ---
// rust/SSXL-ext/src/tools.rs (FIXED)

// ðŸŽ¯ CRITICAL FIX: Gate all Godot-related imports
#[cfg(feature = "godot-binding")]
use godot::prelude::*;

use std::time::Instant;

// ----------------------------------------------------
// 1. CUSTOM LOGGING MACROS (CONDITIONALLY COMPILED)
// ----------------------------------------------------

// NOTE: These macros are already correctly feature-gated internally.

/// Prints a standard information message.
#[macro_export]
macro_rules! ssxl_info {
    ($($arg:tt)*) => ({
        // === GDExtension IMPLEMENTATION ===
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_print!("INFO [SSXL]: {}", format!($($arg)*));
        
        // === CLI/STANDARD IMPLEMENTATION (Fallback) ===
        #[cfg(not(feature = "godot-binding"))]
        println!("INFO [SSXL]: {}", format!($($arg)*));
    });
}

/// Prints a warning message.
#[macro_export]
macro_rules! ssxl_warn {
    ($($arg:tt)*) => ({
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_warn!("WARN [SSXL]: {}", format!($($arg)*));
        
        #[cfg(not(feature = "godot-binding"))]
        eprintln!("WARN [SSXL]: {}", format!($($arg)*));
    });
}

/// Prints an error message.
#[macro_export]
macro_rules! ssxl_error {
    ($($arg:tt)*) => ({
        #[cfg(feature = "godot-binding")]
        godot::prelude::godot_error!("ERROR [SSXL]: {}", format!($($arg)*));
        
        #[cfg(not(feature = "godot-binding"))]
        eprintln!("ERROR [SSXL]: {}", format!($($arg)*));
    });
}

// ----------------------------------------------------
// 2. COORDINATE UTILITIES
// ----------------------------------------------------

// ðŸŽ¯ CRITICAL FIX: Define a mock type for the CLI build (where Vector2i is missing).
// This is necessary because 'ToGodotVector' is not gated.
#[cfg(not(feature = "godot-binding"))]
pub type Vector2i = (i32, i32);


/// Trait for converting Rust coordinate types to Godot Vector2i.
// NOTE: Since this trait is used across the crate (impls are below) but its function 
// only makes sense in Godot, we keep the trait declaration ungated but the implementation gated.
pub trait ToGodotVector {
    fn to_godot_vector(&self) -> Vector2i;
}

// ðŸŽ¯ CRITICAL FIX: Gate the implementation, as it uses Godot's Vector2i::new.
// If this is not gated, the compiler gets E0433: use of undeclared type `Vector2i`.
#[cfg(feature = "godot-binding")]
impl ToGodotVector for (i32, i32) {
    /// Converts a (x, y) tuple into a Godot Vector2i.
    fn to_godot_vector(&self) -> Vector2i {
        Vector2i::new(self.0, self.1)
    }
}

// ----------------------------------------------------
// 3. PROFILER UTILITY
// ----------------------------------------------------

/// A simple struct for timing code execution blocks.
pub struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    /// Starts a new profiler instance if profiling is globally enabled.
    pub fn start(name: &'static str) -> Self {
        // NOTE: In a real project, 'is_profiling_enabled' would be read from config.rs
        const IS_PROFILING_ENABLED: bool = true;
        
        Profiler {
            start: Instant::now(),
            name,
            enabled: IS_PROFILING_ENABLED,
        }
    }
}

/// The Drop implementation automatically logs the duration when the scope is exited.
impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            // This already correctly uses eprintln! and does not require macro conditionalization.
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms",
                self.name,
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}
// --- END: rust/ssxl_ext/src\tools.rs ---
        37 LOC | rust/ssxl_cli/src\godot_headless.rs
// --- START: rust/ssxl_cli/src\godot_headless.rs ---
use std::process::Command;
use std::path::Path;
use crate::ssxl_config::SsxlConfig;

pub fn run_godot_headless_tests() -> Result<(), String> {
    // Load config
    let config = SsxlConfig::load();

    // Allow override via environment variable
    let godot = std::env::var("SSXL_GODOT_PATH")
        .unwrap_or_else(|_| config.godot.binary.clone());

    // âœ… Your Godot project directory (where project.godot lives)
    let project_dir = "C:/zv9/zv9.SSXL-ext/SSXLtester2";

    // Validate the binary exists
    if !Path::new(&godot).exists() {
        return Err(format!(
            "âŒ Godot binary not found at: {}\n\
             Set SSXL_GODOT_PATH or update ssxl_config.toml",
            godot
        ));
    }

    // âœ… Run Godot headless from the correct project directory
    let output = Command::new(&godot)
        .current_dir(project_dir)   // âœ… THIS FIXES THE FILE-NOT-FOUND ERROR
        .args(["--headless", "--script", "res://ssxl_test_runner.gd"])
        .output()
        .map_err(|e| format!("Failed to launch Godot ('{}'): {}", godot, e))?;

    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);

    // If Godot failed, dump everything
    if !output.status.success() {
        return Err(format!(
            "âŒ Godot headless tests FAILED\n\
             --- STDOUT ---\n{}\n\
             --- STDERR ---\n{}\n\
             Exit code: {:?}",
            stdout,
            stderr,
            output.status.code()
        ));
    }

    println!("âœ… Godot headless tests passed.");
    println!("--- Godot STDOUT ---\n{}", stdout);

    Ok(())
}

// --- END: rust/ssxl_cli/src\godot_headless.rs ---
       198 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
pub mod ssxl_menu;
pub mod ssxl_source_scan;
pub mod ssxl_api_scan;
pub mod ssxl_testing;
pub mod ssxl_godot;
pub mod godot_headless;
pub mod ssxl_config;

pub use ssxl_godot::launch_godot_project;
pub use ssxl_testing::run_grand_unified_test;

use std::{fs, io, process::Command};
use tracing::{error, info};
use tracing_subscriber::{filter::LevelFilter, prelude::*};
use std::io::Write;
use std::{io::stdout, thread, time::Duration};
use rand::Rng;
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};
use crossterm::{
    cursor::MoveTo,
    terminal::{Clear, ClearType},
    execute,
};

// -----------------------------------------------------------------------------
// NEW PIPELINE CONSTANTS
// -----------------------------------------------------------------------------

const DLL_SRC: &str = "C:/zv9/zv9.SSXL-ext/rust/target/release/ssxl_ext.dll";
const DLL_DST_TESTER2: &str = "C:/zv9/zv9.SSXL-ext/SSXLtester2/ssxl_ext.dll";
const DLL_DST_ENGINE: &str = "C:/zv9/zv9.SSXL-ext/SSXL_engine_tester/ssxl_ext.dll";

// -----------------------------------------------------------------------------
// PIPELINE HELPERS
// -----------------------------------------------------------------------------

fn kill_stale_godot() {
    let _ = Command::new("taskkill")
        .args(&["/IM", "godot.exe", "/F"])
        .status();
}

fn build_extension() {
    info!("Building ssxl_ext (release, godot-binding)...");

    let status = Command::new("cargo")
        .args([
            "build",
            "-p",
            "ssxl_ext",
            "--release",
            "--features",
            "godot-binding",
        ])
        .status()
        .expect("Failed to run cargo build");

    if !status.success() {
        error!("ssxl_ext build failed.");
        std::process::exit(1);
    }
}

fn deploy_dll() {
    info!("Deploying DLL to both Godot projects...");

    if let Err(e) = fs::copy(DLL_SRC, DLL_DST_TESTER2) {
        error!("Failed to copy to SSXLtester2: {}", e);
    }

    if let Err(e) = fs::copy(DLL_SRC, DLL_DST_ENGINE) {
        error!("Failed to copy to SSXL_engine_tester: {}", e);
    }

    info!("âœ… DLL deployed to SSXLtester2 and SSXL_engine_tester");
}

fn ensure_extension_fresh() {
    kill_stale_godot();
    build_extension();
    deploy_dll();
}

// -----------------------------------------------------------------------------
// ENGINE RUNTIME
// -----------------------------------------------------------------------------

pub fn start_runtime() -> bool {
    true
}

// -----------------------------------------------------------------------------
// INIT + MAIN
// -----------------------------------------------------------------------------

fn init() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stderr)
                .with_filter(LevelFilter::INFO),
        )
        .init();

    info!("SSXL CLI initializing...");
    ensure_extension_fresh();
}

fn main() {
    init();
    ssxl_source_scan::scan_and_report_loc();

    let mut stdout_main = stdout();
    execute!(
        &mut stdout_main,
        Clear(ClearType::All),
        MoveTo(0, 0)
    ).unwrap();

    // ---------- Scene constants ----------
    const WIDTH: usize = 80;
    const HEIGHT: usize = 13;
    const SNOW_COUNT: usize = 45;
    const SCENE_Y: u16 = 0;

    // ---------- Animation control flag ----------
    let anim_running = Arc::new(AtomicBool::new(true));

    // ---------- Background layer ----------
    let mut background = vec![vec![' '; WIDTH]; HEIGHT];
    let mut put_str = |x: usize, y: usize, s: &str| {
        if y < HEIGHT {
            for (i, ch) in s.chars().enumerate() {
                let xx = x + i;
                if xx < WIDTH {
                    background[y][xx] = ch;
                }
            }
        }
    };

    // âœ… ASCII ART (Bull + Tree)
    put_str(12, 1, " (__)");
    put_str(12, 2, " (oo)");
    put_str(6,  3, "/------ \\/");
    put_str(5,  4, "/ |     ||");
    put_str(4,  5, "*  ||----||");
    put_str(7,  6, "~~    ~~");

    put_str(28, 1, "     *");
    put_str(28, 2, "    ***");
    put_str(28, 3, "   *****");
    put_str(28, 4, "  *******");
    put_str(28, 5, " *********");
    put_str(30, 6, "  |||");

    put_str(0, 10, "SSXL-ext Engine Console Initialized");
    put_str(16, 12, "Merry Christmas from the SSXL TEAM!");

    // ---------- Snow + Light layer ----------
    #[derive(Clone, Copy)]
    struct Snow { x: usize, y: usize }
    #[derive(Clone, Copy)]
    struct Bulb { x: usize, y: usize }

    let mut rng = rand::thread_rng();
    let snowflakes: Vec<Snow> = (0..SNOW_COUNT)
        .map(|_| Snow {
            x: rng.gen_range(0..WIDTH),
            y: rng.gen_range(0..HEIGHT),
        })
        .collect();

    let bulbs = vec![
        Bulb { x: 32, y: 2 }, Bulb { x: 34, y: 2 },
        Bulb { x: 31, y: 3 }, Bulb { x: 35, y: 3 },
        Bulb { x: 30, y: 4 }, Bulb { x: 36, y: 4 },
        Bulb { x: 29, y: 5 }, Bulb { x: 37, y: 5 },
    ];

    // ---------- Spawn render thread ----------
    let background_clone = background.clone();
    let bulbs_clone = bulbs.clone();
    let anim_flag = anim_running.clone();

    thread::spawn(move || {
        let mut stdout = stdout();
        let mut rng = rand::thread_rng();
        let mut snowflakes = snowflakes;

        while anim_flag.load(Ordering::Relaxed) {
            for flake in &mut snowflakes {
                if flake.y + 1 >= HEIGHT {
                    flake.y = 0;
                    flake.x = rng.gen_range(0..WIDTH);
                } else {
                    flake.y += 1;
                    let drift: i32 = rng.gen_range(-1..=1);
                    let new_x = flake.x as i32 + drift;
                    if new_x >= 0 && new_x < WIDTH as i32 {
                        flake.x = new_x as usize;
                    }
                }
            }

            let mut frame = background_clone.clone();

            for flake in &snowflakes {
                if flake.y < HEIGHT && flake.x < WIDTH {
                    frame[flake.y][flake.x] = '*';
                }
            }

            for bulb in &bulbs_clone {
                if rng.gen_bool(0.6) {
                    let symbols = ['*', 'o', 'O', '@'];
                    let ch = symbols[rng.gen_range(0..symbols.len())];
                    if bulb.y < HEIGHT && bulb.x < WIDTH {
                        frame[bulb.y][bulb.x] = ch;
                    }
                }
            }

            for (i, row) in frame.iter().enumerate() {
                let y = SCENE_Y + i as u16;
                if y >= SCENE_Y + HEIGHT as u16 {
                    continue;
                }

                let line: String = row.iter().collect();
                let padded = format!("{:<width$}", line, width = WIDTH);
                execute!(&mut stdout, MoveTo(0, y)).unwrap();
                write!(stdout, "{padded}").unwrap();
            }

            stdout.flush().unwrap();
            thread::sleep(Duration::from_millis(140));
        }
    });

    // ---------- Launch menu below the scene ----------
    let menu_y: u16 = SCENE_Y + HEIGHT as u16 + 1;

    // âœ… Clear prompt area to remove any leftover snowflakes or bulbs
    execute!(
        &mut stdout_main,
        MoveTo(0, menu_y),
        Clear(ClearType::FromCursorDown)
    ).unwrap();

    execute!(&mut stdout_main, MoveTo(0, menu_y - 1)).unwrap();
    println!();

    execute!(&mut stdout_main, MoveTo(0, menu_y)).unwrap();

    ssxl_menu::run_interactive_loop_with_anim_flag(
        ssxl_menu::build_menu(),
        menu_y,
        anim_running,
    );
}
// --- END: rust/ssxl_cli/src\main.rs ---
        21 LOC | rust/ssxl_cli/src\pipeline.rs
// --- START: rust/ssxl_cli/src\pipeline.rs ---
use std::fs;
use std::process::Command;
use std::path::PathBuf;

pub fn run_pipeline() -> anyhow::Result<()> {
    // 1. Kill stale Godot processes
    let _ = Command::new("taskkill")
        .args(&["/IM", "godot.exe", "/F"])
        .status();

    // 2. Build DLL
    Command::new("cargo")
        .args(&["build", "-p", "ssxl_ext", "--release", "--features", "godot-binding"])
        .status()?;

    // 3. Locate DLL
    let dll_src = PathBuf::from("rust/target/release/ssxl_ext.dll");

    // 4. Copy into both Godot project roots
    let tester2 = PathBuf::from("SSXLtester2/SSXL_ext.dll");
    let engine_tester = PathBuf::from("SSXL_engine_tester/SSXL_ext.dll");

    fs::copy(&dll_src, &tester2)?;
    fs::copy(&dll_src, &engine_tester)?;

    println!("âœ… DLL deployed to both Godot projects");

    // 5. Optionally launch Godot (example: SSXLtester2)
    Command::new("godot")
        .current_dir("SSXLtester2")
        .status()?;

    Ok(())
}

// --- END: rust/ssxl_cli/src\pipeline.rs ---
       258 LOC | rust/ssxl_cli/src\ssxl_api_scan.rs
// --- START: rust/ssxl_cli/src\ssxl_api_scan.rs ---
use std::collections::HashMap;
use crossterm::{cursor::MoveTo};

use tracing::info;
use walkdir::WalkDir;
use syn::{
    visit::Visit,
    Attribute,
    File,
    FnArg,
    ImplItem,
    ItemImpl,
    ItemMod,
    ItemStruct,
    ReturnType,
    Type,
    Expr,
    ExprLit,
    ExprMethodCall,
    ExprReference,
    Lit,
    Meta,
    punctuated::Punctuated,
    token::Comma,
};

/// Represents the API surface of a single Godot-exposed class.
#[derive(Default)]
struct ClassApi {
    methods: Vec<String>,
    signals: Vec<String>,
}

/// âœ… Top-level scanner: walks ssxl_ext/src and reports the Godot API surface.
/// Now anchored so it never overwrites the scene or menu.
pub fn print_godot_api_surface(menu_y: u16) {
    use crossterm::{cursor::MoveTo, execute, terminal::{Clear, ClearType}};
    use std::io::{self, Write};

    info!("Scanning SSXL-ext source for exported Godot API...");

    let mut stdout = io::stdout();
    let mut y = menu_y + 4; // âœ… safely below menu + prompt

    // Clear action area before printing
    execute!(
        &mut stdout,
        MoveTo(0, y),
        Clear(ClearType::FromCursorDown)
    ).unwrap();

    let ext_src_path = format!(
        "{}/../ssxl_ext/src",
        env!("CARGO_MANIFEST_DIR")
    );
    let mut visitor = ApiScanVisitor::default();

    for entry in WalkDir::new(&ext_src_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map(|x| x == "rs").unwrap_or(false))
    {
        let content = match std::fs::read_to_string(entry.path()) {
            Ok(c) => c,
            Err(_) => continue,
        };
        let parsed: File = match syn::parse_file(&content) {
            Ok(f) => f,
            Err(_) => continue,
        };
        visitor.visit_file(&parsed);
    }

    if visitor.classes.is_empty() && visitor.global_signals.is_empty() {
        execute!(&mut stdout, MoveTo(0, y)).unwrap();
        println!("(No exported #[func] methods or signals found in ssxl_ext source.)");
        return;
    }

    execute!(&mut stdout, MoveTo(0, y)).unwrap();
    println!("--- SSXL-ext Godot API Surface (Source Scan) ---");
    y += 1;

    let mut class_names: Vec<_> = visitor.classes.keys().cloned().collect();
    class_names.sort();

    for class_name in class_names {
        let class_api = &visitor.classes[&class_name];

        execute!(&mut stdout, MoveTo(0, y)).unwrap();
        println!("Class: {class_name}");
        y += 1;

        if !class_api.signals.is_empty() {
            execute!(&mut stdout, MoveTo(0, y)).unwrap();
            println!(" Signals:");
            y += 1;

            for sig in &class_api.signals {
                execute!(&mut stdout, MoveTo(0, y)).unwrap();
                println!("  â€¢ {}", sig);
                y += 1;
            }
        }

        if !class_api.methods.is_empty() {
            if !class_api.signals.is_empty() {
                y += 1;
            }

            execute!(&mut stdout, MoveTo(0, y)).unwrap();
            println!(" Methods:");
            y += 1;

            for method in &class_api.methods {
                execute!(&mut stdout, MoveTo(0, y)).unwrap();
                println!("  â€¢ {}", method);
                y += 1;
            }
        }

        y += 1;
    }

    if !visitor.global_signals.is_empty() {
        execute!(&mut stdout, MoveTo(0, y)).unwrap();
        println!("Global signals (manual Engine.emit_signal calls):");
        y += 1;

        for sig in &visitor.global_signals {
            execute!(&mut stdout, MoveTo(0, y)).unwrap();
            println!("  â€¢ {}", sig);
            y += 1;
        }

        y += 1;
    }

    execute!(&mut stdout, MoveTo(0, y)).unwrap();
    println!("--- End of API ---");
}


/// Visitor that discovers Godot classes and exported methods/signals.
#[derive(Default)]
struct ApiScanVisitor {
    classes: HashMap<String, ClassApi>,
    global_signals: Vec<String>,
}

impl<'ast> Visit<'ast> for ApiScanVisitor {
    fn visit_item_mod(&mut self, node: &'ast ItemMod) {
        if let Some((_, items)) = &node.content {
            for item in items {
                self.visit_item(item);
            }
        }
        syn::visit::visit_item_mod(self, node);
    }

    fn visit_item_struct(&mut self, node: &'ast ItemStruct) {
        let is_godot_class = node.attrs.iter().any(derive_has_godot_class);
        if is_godot_class {
            let name = node.ident.to_string();
            self.classes.entry(name).or_default();
        }
        syn::visit::visit_item_struct(self, node);
    }

    fn visit_item_impl(&mut self, node: &'ast ItemImpl) {
        let type_name = match &*node.self_ty {
            Type::Path(tp) => tp.path.segments.last().map(|s| s.ident.to_string()),
            _ => None,
        };

        if let Some(type_name) = type_name {
            if let Some(class_api) = self.classes.get_mut(&type_name) {
                for item in &node.items {
                    if let ImplItem::Fn(m) = item {
                        let has_func = m.attrs.iter().any(|a| attr_contains(a, "func"));
                        if has_func {
                            let sig = format_method_signature(
                                m.sig.inputs.iter().collect(),
                                &m.sig.output,
                                &m.sig.ident.to_string(),
                            );
                            class_api.methods.push(sig);
                        }

                        let has_signal = m.attrs.iter().any(|a| attr_contains(a, "signal"));
                        if has_signal {
                            class_api
                                .signals
                                .push(format!("{}(...)", m.sig.ident.to_string()));
                        }
                    }
                }
            }
        }

        syn::visit::visit_item_impl(self, node);
    }

    fn visit_expr_method_call(&mut self, node: &'ast ExprMethodCall) {
        if node.method == "call" && !node.args.is_empty() {
            if let Some(signal_name) = extract_engine_signal_name(node) {
                let formatted = format!("Engine.emit_signal(\"{}\", ...)", signal_name);
                if !self.global_signals.contains(&formatted) {
                    self.global_signals.push(formatted);
                }
            }
        }
        syn::visit::visit_expr_method_call(self, node);
    }
}

/// Detect #[derive(GodotClass)]
fn derive_has_godot_class(attr: &Attribute) -> bool {
    if !attr.path().is_ident("derive") {
        return false;
    }

    if let Meta::List(meta_list) = &attr.meta {
        if let Ok(derives) =
            meta_list.parse_args_with(Punctuated::<Meta, Comma>::parse_terminated)
        {
            return derives.iter().any(|meta| {
                matches!(meta, Meta::Path(path) if path.is_ident("GodotClass"))
            });
        }
    }

    false
}

/// Format a pretty method signature
fn format_method_signature(inputs: Vec<&FnArg>, output: &ReturnType, name: &str) -> String {
    let mut args = Vec::new();

    for arg in inputs {
        if let FnArg::Typed(pat) = arg {
            let arg_name = match &*pat.pat {
                syn::Pat::Ident(id) => id.ident.to_string(),
                _ => "_".to_string(),
            };
            let arg_ty = match &*pat.ty {
                Type::Path(tp) => tp.path.segments.last().unwrap().ident.to_string(),
                _ => "Unknown".to_string(),
            };
            args.push(format!("{}: {}", arg_name, arg_ty));
        }
    }

    let args_joined = args.join(", ");

    let ret = match output {
        ReturnType::Default => "".to_string(),
        ReturnType::Type(_, ty) => {
            let ty_str = match &**ty {
                Type::Path(tp) => tp.path.segments.last().unwrap().ident.to_string(),
                _ => "Unknown".to_string(),
            };
            format!(" -> {}", ty_str)
        }
    };

    format!("{}({}){}", name, args_joined, ret)
}

/// Extract signal name from Engine::singleton().call("emit_signal", [...])
fn extract_engine_signal_name(call: &ExprMethodCall) -> Option<String> {
    let first_arg = call.args.first()?;
    let is_emit_signal = matches!(
        first_arg,
        Expr::Lit(ExprLit { lit: Lit::Str(s), .. }) if s.value() == "emit_signal"
    );
    if !is_emit_signal {
        return None;
    }

    let second_arg = call.args.iter().nth(1)?;
    let array_expr = match second_arg {
        Expr::Reference(ExprReference { expr, .. }) => match &**expr {
            Expr::Array(arr) => arr,
            _ => return None,
        },
        Expr::Array(arr) => arr,
        _ => return None,
    };

    array_expr.elems.first().and_then(extract_string_literal)
}

/// Recursively extract a string literal from an expression
fn extract_string_literal(expr: &Expr) -> Option<String> {
    match expr {
        Expr::Lit(ExprLit { lit: Lit::Str(s), .. }) => Some(s.value()),
        Expr::MethodCall(m) => extract_string_literal(&m.receiver),
        Expr::Reference(r) => extract_string_literal(&r.expr),
        Expr::Array(arr) => arr.elems.iter().find_map(extract_string_literal),
        _ => None,
    }
}

/// Helper: detect simple or nested attributes containing a given name
fn attr_contains(attr: &Attribute, name: &str) -> bool {
    if attr.path().is_ident(name) {
        return true;
    }

    if let Meta::List(list) = &attr.meta {
        let tokens = list.tokens.to_string();
        return tokens.contains(name);
    }

    false
}

// --- END: rust/ssxl_cli/src\ssxl_api_scan.rs ---
        16 LOC | rust/ssxl_cli/src\ssxl_config.rs
// --- START: rust/ssxl_cli/src\ssxl_config.rs ---
use serde::Deserialize;
use std::fs;

#[derive(Debug, Deserialize)]
pub struct SsxlConfig {
    pub godot: GodotConfig,
}

#[derive(Debug, Deserialize)]
pub struct GodotConfig {
    pub binary: String,
}

impl SsxlConfig {
    pub fn load() -> Self {
        let raw = fs::read_to_string("ssxl_config.toml")
            .expect("Failed to read ssxl_config.toml");

        toml::from_str(&raw)
            .expect("Failed to parse ssxl_config.toml")
    }
}

// --- END: rust/ssxl_cli/src\ssxl_config.rs ---
        36 LOC | rust/ssxl_cli/src\ssxl_godot.rs
// --- START: rust/ssxl_cli/src\ssxl_godot.rs ---
use std::{path::PathBuf, process::Command};
use tracing::{error, info};

const GODOT_EXE: &str = "../SSXLtester2/Godot_v4.5.1-stable_win64.exe";
const GODOT_PROJECT: &str = "../SSXLtester2/project.godot";

pub fn launch_godot_project() {
    let project_path = PathBuf::from(GODOT_PROJECT);
    let godot_exe_path = PathBuf::from(GODOT_EXE);

    // âœ… Validate Godot executable exists
    if !godot_exe_path.exists() {
        error!("Godot executable not found at {}.", GODOT_EXE);
        return;
    }

    // âœ… Validate project file exists
    if !project_path.exists() {
        error!("Godot project not found at {}.", GODOT_PROJECT);
        return;
    }

    // âœ… Compute project directory safely
    let project_dir = project_path
        .parent()
        .map(|p| p.to_path_buf())
        .unwrap_or_else(|| PathBuf::from(".."));

    info!("Launching Godot editor...");

    let spawn_result = Command::new(&godot_exe_path)
        .arg("--editor")
        .arg(&project_dir)
        .spawn();

    match spawn_result {
        Ok(mut child) => {
            info!("Godot launched. Waiting for editor to close...");
            if let Err(e) = child.wait() {
                error!("Error waiting for Godot: {}", e);
            }
        }
        Err(e) => {
            error!("Failed to launch Godot: {}", e);
        }
    }
}

// --- END: rust/ssxl_cli/src\ssxl_godot.rs ---
       146 LOC | rust/ssxl_cli/src\ssxl_menu.rs
// --- START: rust/ssxl_cli/src\ssxl_menu.rs ---
use std::collections::HashSet;
use std::io::{self, Write};
use std::time::Duration;
use std::thread;
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};
use crossterm::{cursor::MoveTo, execute};
use crossterm::event::{self, Event, KeyCode};
use tracing::info;

// Import actions from crate root (main.rs re-exports them)
use crate::{
    run_grand_unified_test,
    launch_godot_project,
};

// âœ… Import start_runtime so L can load the engine on demand
use crate::start_runtime;

// âœ… NEW: Import tankâ€‘mode headless Godot runner
use crate::godot_headless::run_godot_headless_tests;

/// Structure representing a single menu item and its action.
/// âœ… Updated: action now receives action_y
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn(u16)>,
}

/// âœ… Updated menu with new TANK MODE option
pub fn build_menu() -> Vec<CliAction> {
    vec![
        CliAction {
            key: 'A',
            label: "ðŸ“˜ press A: Show GDScript API (Auto-Generated)",
            id: "show_gdscript_api",
            action: Box::new(|action_y| {
                crate::ssxl_api_scan::print_godot_api_surface(action_y);
            }),
        },

        CliAction {
            key: 'L',
            label: "ðŸš€ press L: Launch Godot Project (Full Integration Test)",
            id: "launch_godot",
            action: Box::new(|_action_y| {
                if start_runtime() {
                    launch_godot_project();
                } else {
                    println!("âŒ Runtime failed to start. Cannot launch Godot.");
                }
            }),
        },

        CliAction {
            key: 'G',
            label: "âœ… press G: Run Grand Unified Test (GUT)",
            id: "grand_unified_test",
            action: Box::new(|_action_y| {
                run_grand_unified_test();
            }),
        },

        CliAction {
            key: 'T',
            label: "ðŸ§ª press T: Run Godot Headless Tests (Tank Mode)",
            id: "godot_headless_tests",
            action: Box::new(|action_y| {
                let mut stdout = io::stdout();
                execute!(&mut stdout, MoveTo(0, action_y)).unwrap();

                println!("=== SSXL Headless Godot Test (Tank Mode) ===");
                match run_godot_headless_tests() {
                    Ok(_) => println!("âœ… Godot headless tests passed."),
                    Err(e) => println!("âŒ Godot headless tests failed:\n{}", e),
                }
            }),
        },

        CliAction {
            key: 'U',
            label: "âœ… press U: EXIT Console",
            id: "exit",
            action: Box::new(|_action_y| {}),
        },
    ]
}

/// âœ… Print menu at a fixed anchored Y position
fn print_menu(menu: &[CliAction], menu_y: u16) {
    let mut stdout = io::stdout();
    execute!(&mut stdout, MoveTo(0, menu_y)).unwrap();

    println!("--- SSXL-ext Main Menu ---");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
}

/// âœ… Wait prompt also anchored
fn wait_for_enter(menu_y: u16) {
    let mut stdout = io::stdout();
    let wait_y = menu_y + 20;
    execute!(&mut stdout, MoveTo(0, wait_y)).unwrap();
    println!("Press Enter to return to menu...");
    let _ = io::stdin().read_line(&mut String::new());
}

/// âœ… MAIN LOOP â€” now anchored safely below the scene
/// âœ… NEW: accepts anim_flag so we can shut down the animation thread
pub fn run_interactive_loop_with_anim_flag(
    menu: Vec<CliAction>,
    menu_y: u16,
    anim_flag: Arc<AtomicBool>,
) {
    let mut last_keys = HashSet::new();

    loop {
        // Print menu at anchored position
        print_menu(&menu, menu_y);

        let mut stdout = io::stdout();
        let prompt_y = menu_y + menu.len() as u16 + 2;

        // âœ… Clear prompt area AND everything below it
        use crossterm::terminal::{Clear, ClearType};
        execute!(
            &mut stdout,
            MoveTo(0, prompt_y),
            Clear(ClearType::FromCursorDown)
        ).unwrap();

        // âœ… Anchor and print prompt block cleanly
        execute!(&mut stdout, MoveTo(0, prompt_y)).unwrap();
        println!("Awaiting menu selection...");
        execute!(&mut stdout, MoveTo(0, prompt_y + 1)).unwrap();
        print!("> ");
        io::stdout().flush().unwrap();

        loop {
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase();

                        if last_keys.insert(c) {
                            if let Some(item) = menu.iter().find(|m| m.key == c) {

                                // âœ… STOP ANIMATION IMMEDIATELY
                                anim_flag.store(false, Ordering::Relaxed);

                                // âœ… Dynamic action anchor
                                let action_y = menu_y + menu.len() as u16 + 4;

                                // âœ… Clear action area before printing
                                execute!(
                                    &mut stdout,
                                    MoveTo(0, action_y),
                                    Clear(ClearType::FromCursorDown)
                                ).unwrap();

                                // âœ… Print selection label at fixed anchor
                                execute!(&mut stdout, MoveTo(0, action_y)).unwrap();

                                // âœ… FIX: ensure stderr logs don't collide with stdout
                                eprintln!(); // newline for stderr safety
                                info!("Menu: Selected: {}", item.label);

                                println!("[{}] {}", c, item.label);

                                // âœ… Run action with action_y
                                (item.action)(action_y);

                                if c == 'U' {
                                    return;
                                }

                                wait_for_enter(menu_y);
                                break;
                            }
                        }
                    }
                }
            } else {
                last_keys.clear();
            }

            thread::sleep(Duration::from_millis(10));
        }
    }
}

// --- END: rust/ssxl_cli/src\ssxl_menu.rs ---
       107 LOC | rust/ssxl_cli/src\ssxl_source_scan.rs
// --- START: rust/ssxl_cli/src\ssxl_source_scan.rs ---
// ssxl_source_scan.rs
use walkdir::WalkDir;
use std::path::PathBuf;
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// --- CONSTANTS ---
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
const LOC_REPORTS_DIR: &str = "../loc_reports";
// Note: Relative paths are assumed to be run from the 'rust' directory.

// --- LOC COUNTING LOGIC ---

/// Counts non-empty, non-comment lines of code.
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        // Ignores lines starting with '//' (Rust) or '#' (GDScript).
        let trimmed = line.trim();
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Writes the total Rust LOC count to the fixed-name file for Godot's boot parser.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level from 'rust' to the project root for the output file.
    let root_dir = PathBuf::from("../"); 
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE);

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("ðŸ”¥ SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("âŒ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                       output_path, e);
        }
    }
}

// --- MAIN SCAN FUNCTION ---

pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // UPDATED DIRECTORIES for the consolidated ssxl-ext structure (as per manifest).
    // Scans the main GDExtension library and the CLI tool itself.
    let rust_dirs = [
        "ssxl_ext/src", // Contains all core logic (host, generate, shared).
        "ssxl_cli/src", // Contains CLI tool logic (like this file).
    ];

    // --- SCAN RUST FILES ---
    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- SCAN GDSCRIPT FILES ---
    // Assuming the GDScript test directory remains the same relative path.
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        let path_str = path.display().to_string();
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // --- WRITE REPORTS ---
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("âŒ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: ssxl_ext, ssxl_cli, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n        {} LOC | *.rs (Rust Total)\n        {} LOC | *.gd (GDScript Total)\n        {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("âœ… Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("âŒ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // --- CRITICAL STEP FOR GODOT ---
    write_final_loc_total(total_rs_loc);

    // Final sleep to ensure writes/logs are flushed
    thread::sleep(Duration::from_millis(100));
}
// --- END: rust/ssxl_cli/src\ssxl_source_scan.rs ---
       249 LOC | rust/ssxl_cli/src\ssxl_testing.rs
// --- START: rust/ssxl_cli/src\ssxl_testing.rs ---
// ssxl_cli/src/ssxl_testing.rs
// ============================================================================
// ðŸ§ª SSXL-ext CLI Testing Harness - PURE RUST IMPLEMENTATION (v4)
// ============================================================================

use std::thread;
use std::time::Instant;

use rand::{thread_rng, Rng};
use tracing::{error, info, warn};

// Bring in core engine types and logic from ssxl_ext.
use ssxl_ext::shared_chunk::Chunk;
use ssxl_ext::shared_config::PerlinNoiseConfig;
use ssxl_ext::shared_tile::TileData;
use ssxl_ext::generate_perlin::{NoiseGenerator, generate_noise_map};
use ssxl_ext::tile_conversion::bitmask_to_id;

// --- Module-Level Constants ---
const CHUNK_SIZE: u32 = 64;
const GRID_SIZE: u32 = 2048;
const ITERATIONS: u32 = 50;
const MAX_TILE_ID: i32 = 47;

// --- Profiler Stub ---
struct Profiler {
    start: Instant,
    name: &'static str,
    enabled: bool,
}

impl Profiler {
    pub fn start(name: &'static str) -> Self {
    Profiler {
            start: Instant::now(),
            name,
            enabled: true,
        }
    }
}

impl Drop for Profiler {
    fn drop(&mut self) {
        if self.enabled {
            let duration = self.start.elapsed();
            eprintln!(
                "PERF [{}]: Execution time: {:.3}ms",
                self.name,
                duration.as_secs_f64() * 1000.0
            );
        }
    }
}

// --- Helper: Create a standard Perlin config for tests ---
fn default_perlin_config() -> PerlinNoiseConfig {
    PerlinNoiseConfig {
        octaves: 4,
        lacunarity: 2.0,
        persistence: 0.5,
        scale: 64.0,
        threshold: 0.0,
    }
}

// --- Helper: Run noise generation for a chunk and return it ---
fn generate_chunk_at(chunk_x: i32, chunk_y: i32, size: u32, seed: u64) -> Chunk {
    let config = default_perlin_config();
    let generator = NoiseGenerator::new(config, seed);

    let position = (chunk_x, chunk_y);
    let chunk = Chunk::new(position, size);

    match generate_noise_map(chunk, &generator) {
        Ok(chunk) => chunk,
        Err(err) => {
            panic!(
                "Noise generation failed at chunk ({}, {}): {}",
                chunk_x, chunk_y, err
            );
        }
    }
}

// --- Helper: Compare the touching edges of two chunks ---
// In tank mode we verify *geometry* (no gaps/overlaps, correct adjacency),
// not that tiles are identical across different world coordinates.
fn chunks_share_boundary(a: &Chunk, b: &Chunk, dir: (i32, i32)) -> bool {
    // dir = (1, 0) means b is to the right of a
    // dir = (0, 1) means b is below a

    let size = a.size;
    if a.size != b.size {
        error!(
            "Chunk size mismatch: a.size={} b.size={}",
            a.size, b.size
        );
        return false;
    }

    match dir {
        (1, 0) => {
            // Geometry check: right edge of `a` must be immediately left of left edge of `b`.
            for y in 0..size {
                let (ax, ay) = a.local_to_world((size - 1) as i32, y as i32);
                let (bx, by) = b.local_to_world(0, y as i32);

                if ay != by || bx != ax + 1 {
                    error!(
                        "Boundary geometry mismatch (dir=(1,0)) at local y={}: \
                         a.pos={:?}, b.pos={:?}, \
                         a_world=({},{}) b_world=({},{})",
                        y,
                        a.position,
                        b.position,
                        ax, ay,
                        bx, by,
                    );
                    return false;
                }
            }
            true
        }
        (0, 1) => {
            // Geometry check: bottom edge of `a` must be immediately above top edge of `b`.
            for x in 0..size {
                let (ax, ay) = a.local_to_world(x as i32, (size - 1) as i32);
                let (bx, by) = b.local_to_world(x as i32, 0);

                if ax != bx || by != ay + 1 {
                    error!(
                        "Boundary geometry mismatch (dir=(0,1)) at local x={}: \
                         a.pos={:?}, b.pos={:?}, \
                         a_world=({},{}) b_world=({},{})",
                        x,
                        a.position,
                        b.position,
                        ax, ay,
                        bx, by,
                    );
                    return false;
                }
            }
            true
        }
        _ => {
            warn!("Unsupported boundary direction: {:?}", dir);
            false
        }
    }
}

// --- Helper: Approximate tile equality for boundary tests --- TODO
#[allow(dead_code)]
fn tiles_approx_equal(a: Option<&TileData>, b: Option<&TileData>) -> bool {
    match (a, b) {
        (Some(ta), Some(tb)) => {
            ta.tile_id == tb.tile_id &&
            ta.atlas_coords == tb.atlas_coords &&
            ta.rotation_flags == tb.rotation_flags
            // We intentionally ignore custom_data for boundary coherence.
        }
        (None, None) => true,
        _ => false,
    }
}

// ----------------------------------------------------------------------------
// I. Component Tests (Pure Rust)
// ----------------------------------------------------------------------------

/// 1. Concurrency Stress Test: Spawns many threads to hammer noise generation.
fn run_fast_test() {
    info!("Starting Fast Test (Concurrency Stress on Noise Generator)...");
    let _p = Profiler::start("FastTest_Concurrency");

    const NUM_THREADS: u32 = 500;
    const CHUNK_LOCAL_SIZE: u32 = 16;

    let handles = (0..NUM_THREADS)
        .map(|i| {
            thread::spawn(move || {
                let seed_base = i as u64;
                for j in 0..20u32 {
                    let seed = seed_base + j as u64;
                    let _chunk = generate_chunk_at(i as i32, j as i32, CHUNK_LOCAL_SIZE, seed);
                }
            })
        })
        .collect::<Vec<_>>();

    for handle in handles {
        handle.join().unwrap();
    }

    info!(
        "âœ… Fast Test Complete: {} threads exercised concurrent noise generation.",
        NUM_THREADS
    );
}

/// 2. Full Integration Test: Chunk generation + boundary checks.
fn run_full_test() {
    info!("Starting Full Integration Test (Chunk Boundary Coherence)...");
    let _p = Profiler::start("FullTest_Integration");

    let seed: u64 = thread_rng().gen();

    let c00 = generate_chunk_at(0, 0, CHUNK_SIZE, seed);
    let c10 = generate_chunk_at(1, 0, CHUNK_SIZE, seed);
    let c01 = generate_chunk_at(0, 1, CHUNK_SIZE, seed);
    let c11 = generate_chunk_at(1, 1, CHUNK_SIZE, seed);

    let mut failures = 0;

    // Right of c00
    if !chunks_share_boundary(&c00, &c10, (1, 0)) {
        error!("âŒ Boundary Fail: Chunk (0,0) and (1,0) mismatch.");
        failures += 1;
    }

    // Below c00
    if !chunks_share_boundary(&c00, &c01, (0, 1)) {
        error!("âŒ Boundary Fail: Chunk (0,0) and (0,1) mismatch.");
        failures += 1;
    }

    // Below c10
    if !chunks_share_boundary(&c10, &c11, (0, 1)) {
        error!("âŒ Boundary Fail: Chunk (1,0) and (1,1) mismatch.");
        failures += 1;
    }

    // Right of c01
    if !chunks_share_boundary(&c01, &c11, (1, 0)) {
        error!("âŒ Boundary Fail: Chunk (0,1) and (1,1) mismatch.");
        failures += 1;
    }

    if failures == 0 {
        info!("âœ… Full Test Passed: Boundary geometry verified across 4 chunks.");
    } else {
        panic!(
            "âŒ Full Test FAILED: {} boundary mismatches detected.",
            failures
        );
    }
}

/// 3. Max Grid Benchmark: Heavy compute load on a huge chunk.
fn run_max_grid_benchmark() {
    info!("Starting Max Grid Benchmark (Heavy Noise Compute Iterations)...");
    let _p = Profiler::start("MaxGrid_HeavyNoise");

    info!(
        "Generating {} x {} noise field {} times (single large chunk)...",
        GRID_SIZE, GRID_SIZE, ITERATIONS
    );

    for i in 0..ITERATIONS {
        let seed = thread_rng().gen();
        let _chunk = generate_chunk_at(0, i as i32, GRID_SIZE, seed);
    }

    info!(
        "âœ… Max Grid Benchmark Complete: {} heavy generation calls finished.",
        ITERATIONS
    );
}

/// 4. Bitmask Conversion Test: Exhaustive 256-case validation (pure Rust).
fn run_bitmask_conversion() {
    info!("Starting Bitmask Conversion Test (256/256 Exhaustive Coverage)...");
    let _p = Profiler::start("Bitmask_Exhaustive");

    let mut failures = 0;

    for bitmask in 0u8..=255 {
        let result_id = bitmask_to_id(bitmask);

        if result_id < 0 || result_id > MAX_TILE_ID {
            error!(
                "âŒ Bitmask Fail: Input {} resulted in invalid Tile ID {}.",
                bitmask, result_id
            );
            failures += 1;
        }

        // SSXL canon: bitmask 255 should map to full tile ID 21.
        if bitmask == 255 && result_id != 21 {
            warn!(
                "Bitmask 255 not mapping to SSXL 'Full' Tile ID (21). Got: {}.",
                result_id
            );
            failures += 1;
        }
    }

    if failures == 0 {
        info!("âœ… Bitmask Conversion Test Passed: 256/256 combinations verified (0 failures).");
    } else {
        panic!(
            "âŒ Bitmask Conversion Test FAILED: {} failures detected! (MAX_TILE_ID={})",
            failures, MAX_TILE_ID
        );
    }
}


// ----------------------------------------------------------------------------
// II. Grand Unified Test (G-action)
// ----------------------------------------------------------------------------

/// Chains together the most critical tests for a full smoke test.
pub fn run_grand_unified_test() {
    println!("\n==================================================");
    println!("=== SSXL-ext GRAND UNIFIED TEST (GUT) STARTING ===");
    println!("==================================================");

    run_bitmask_conversion();
    println!("--------------------------------------------------");

    run_max_grid_benchmark();
    println!("--------------------------------------------------");

    run_fast_test();
    println!("--------------------------------------------------");

    run_full_test();

    println!("\n==================================================");
    println!("=== SSXL-ext GRAND UNIFIED TEST (GUT) COMPLETE ===");
    println!("==================================================");
}

// --- END: rust/ssxl_cli/src\ssxl_testing.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("ðŸŒ™ Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("ðŸ§¿ Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("âš ï¸ No idle method found. Skipping ticker.")

func start_idle():
    print("ðŸª¶ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("âš¡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("ðŸ§º Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("ðŸŒ€ SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("âœ¨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("âš ï¸ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("âŒ Failed to instantiate SSXL script.")
        else:
            push_error("âŒ Invalid script resource at: %s" % script_path)
    else:
        push_error("âŒ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("ðŸ§¹ SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("ðŸ§º SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("ðŸŒ™ SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("ðŸ§¿ Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("âš ï¸ No idle method found. Skipping ticker.")

func start_idle():
    print("ðŸª¶ Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("âš¡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("ðŸ§º SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## ðŸ§­ NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## âš™ï¸ CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## ðŸ”— LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("âŒ CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("âœ… Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## âŒ¨ï¸ INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## ðŸ–¼ï¸ CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## ðŸ“¡ PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("âš ï¸ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("âž¡ï¸ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("âž¡ï¸ Switched to Camera 2 (Map View).")
	else:
		push_warning("âš ï¸ Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED â†’ (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid â€” cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature â€” set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated â†’", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error â†’", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated â†’ (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete â†’", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine â†’ Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine â†’ SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle â†’ Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected â†’", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected â†’", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("âŒ FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "âŒ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("âš™ï¸ FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "ðŸ•’ " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # â† THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # â† Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # â† Chunk data holder

# Old reference â€” we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX â€” only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready â†’ CONNECTED (first time)")
		else:
			print("chunk_data_ready â†’ already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\nðŸŽ¶ Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("âŒ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("âŒ Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\nðŸ“œ Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd â€” FINAL VERSION (2025 SSXL FFI Sync) â€” RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle â†’ Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle â†’ Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine â†’ SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing â€” no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED â€” EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready â†’ tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready â†’ _on_chunk_data_ready CONNECTED â€” RENDERING ENABLED")
		else:
			print("chunk_data_ready â†’ already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd â€” Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("ðŸ“¢ SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("âŒ FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("ðŸ“¢ SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("âœ… SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("âœ… GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("âŒ GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("âœ… FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("âŒ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
        4651 LOC | *.rs (Rust Total)
        961 LOC | *.gd (GDScript Total)
        5612 LOC | TOTALS
