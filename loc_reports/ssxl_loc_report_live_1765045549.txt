SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1765045549
Root Directories: rust, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       130 LOC | rust/ssxl_cache/src\lib.rs
// --- START: rust/ssxl_cache/src\lib.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

use ssxl_math::coordinate_system::ChunkKey;   // Unique identifier for a chunk (x,y,z coordinates).
use ssxl_shared::ChunkData;                   // Struct holding all tile data for a chunk.
use ssxl_sync::AtomicResource;                // Thread-safe wrapper for atomic resource access.

use std::collections::{HashMap, HashSet};     // HashMap for region storage, HashSet for chunk membership.
use std::sync::{
    Arc,                                      // Arc: atomic reference-counted pointer for shared ownership.
    atomic::{AtomicUsize, Ordering}           // Atomic counters for metrics (hits, misses, evictions).
};
use std::io;                                  // For returning I/O results.
use std::num::NonZeroUsize;                   // Non-zero integer type for cache capacity.

use parking_lot::{Mutex, RwLock};             // High-performance locks for cache and region index.
use tracing::info;                            // Logging utility.
use glam::I64Vec3;                            // Vector type for integer coordinates.
use lru::LruCache;                            // Least Recently Used cache implementation.

// -----------------------------------------------------------------------------
// Constants and Type Aliases
// -----------------------------------------------------------------------------

const REGION_SIZE: i64 = 64;                  // Defines how many chunks fit into one region.
type RegionKey = ChunkKey;                    // RegionKey is just a ChunkKey at region granularity.
type RegionList = RwLock<HashSet<ChunkKey>>;  // Each region stores a set of chunk keys, protected by RwLock.

// -----------------------------------------------------------------------------
// CacheMetrics: Tracks hits, misses, and evictions
// -----------------------------------------------------------------------------

#[derive(Debug, Default)]
pub struct CacheMetrics {
    pub hits: AtomicUsize,        // Number of successful cache lookups.
    pub misses: AtomicUsize,      // Number of failed cache lookups.
    pub evictions: AtomicUsize,   // Number of chunks evicted due to LRU policy.
}

impl CacheMetrics {
    #[inline(always)]
    pub fn hit(&self) { self.hits.fetch_add(1, Ordering::Relaxed); }     // Increment hit counter.
    #[inline(always)]
    pub fn miss(&self) { self.misses.fetch_add(1, Ordering::Relaxed); }  // Increment miss counter.
    #[inline(always)]
    pub fn evict(&self) { self.evictions.fetch_add(1, Ordering::Relaxed);} // Increment eviction counter.
}

// -----------------------------------------------------------------------------
// RegionIndex: Maps regions to sets of chunks
// -----------------------------------------------------------------------------

#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<HashMap<RegionKey, Arc<RegionList>>>, // Thread-safe map of region -> chunk set.
}

impl RegionIndex {
    pub fn new() -> Self {
        Self {
            storage: AtomicResource::new(HashMap::new()),          // Initialize empty region map.
        }
    }

    // Convert a chunk key into its region key by dividing coordinates by REGION_SIZE.
    #[inline(always)]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let p = chunk_key.0;
        let rx = p.x / REGION_SIZE;
        let ry = p.y / REGION_SIZE;
        let rz = p.z / REGION_SIZE;
        ChunkKey(I64Vec3::new(rx, ry, rz))
    }

    // Insert a chunk into its region’s set.
    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = {
            let mut map = self.storage.write();                     // Lock map for writing.
            map.entry(region_key)
                .or_insert_with(|| Arc::new(RwLock::new(HashSet::new())))
                .clone()
        };
        let mut list = list_arc.write();                            // Lock region set for writing.
        list.insert(chunk_key);                                     // Add chunk to region.
    }

    // Remove a chunk from its region’s set.
    // If the region becomes empty, remove the region entirely.
    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = self.storage.read().get(&region_key).cloned();

        if let Some(list_arc) = list_arc {
            let mut list = list_arc.write();
            if list.remove(&chunk_key) {
                if list.is_empty() {
                    drop(list);                                     // Release lock before modifying map.
                    self.storage.write().remove(&region_key);       // Remove empty region.
                    info!("Removed empty region from index: {:?}", region_key);
                }
                return true;
            }
        }
        false
    }
}

// -----------------------------------------------------------------------------
// ChunkCache: Main cache structure with LRU eviction
// -----------------------------------------------------------------------------

#[derive(Debug)]
pub struct ChunkCache {
    storage: Mutex<LruCache<ChunkKey, Arc<ChunkData>>>, // LRU cache storing chunks.
    region_index: RegionIndex,                         // Region index for quick lookup.
    capacity: NonZeroUsize,                            // Maximum number of chunks allowed.
    pub metrics: Arc<CacheMetrics>,                    // Shared metrics tracker.
}

impl ChunkCache {
    // Create a new cache with a maximum number of chunks.
    pub fn new(max_chunks: usize) -> io::Result<Self> {
        let capacity = NonZeroUsize::new(max_chunks.max(1))
            .unwrap_or(NonZeroUsize::new(1024).unwrap()); // Ensure non-zero capacity.
        
        info!("ChunkCache initialized with LRU eviction (capacity: {})", capacity);

        Ok(Self {
            storage: Mutex::new(LruCache::new(capacity)), // Initialize LRU cache.
            region_index: RegionIndex::new(),             // Initialize region index.
            capacity,
            metrics: Arc::new(CacheMetrics::default()),   // Initialize metrics tracker.
        })
    }

    // Load a chunk from the cache.
    // Returns Some(chunk) if found, None otherwise.
    pub fn load_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let mut guard = self.storage.lock();             // Lock cache for reading.
        let result = guard.get(key).map(Arc::clone);     // Clone Arc if chunk exists.
        
        if result.is_some() {
            self.metrics.hit();                          // Track hit.
        } else {
            self.metrics.miss();                         // Track miss.
        }

        result
    }

    // Save a chunk into the cache.
    // If capacity exceeded, evict least recently used chunk.
    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> io::Result<()> {
        let key = *key;
        let mut guard = self.storage.lock();

        self.region_index.insert_key(key);               // Update region index.

        let _old_data = guard.put(key, data);            // Insert chunk into LRU cache.
        
        if let Some((evicted_key, _)) = guard.pop_lru() { // Evict least recently used chunk if needed.
            self.metrics.evict();                        // Track eviction.
            self.region_index.remove_key(evicted_key);   // Remove evicted chunk from region index.
            info!(
                "LRU evicted chunk: {:?} (cache size: {})",
                evicted_key,
                guard.len()
            );
        }

        Ok(())
    }

    // Remove a chunk manually from the cache.
    pub fn remove_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let removed = self.storage.lock().pop(key);      // Remove chunk from cache.
        if removed.is_some() {
            self.region_index.remove_key(*key);          // Update region index.
            info!("Manually removed chunk from cache: {:?}", key);
        }
        removed
    }

    // Return current number of chunks in cache.
    pub fn len(&self) -> usize {
        self.storage.lock().len()
    }

    // Return maximum capacity of cache.
    pub fn capacity(&self) -> usize {
        self.capacity.get()
    }
}

// --- END: rust/ssxl_cache/src\lib.rs ---
       139 LOC | rust/ssxl_engine_ffi/src\lib.rs
// --- START: rust/ssxl_engine_ffi/src\lib.rs ---
// -----------------------------------------------------------------------------
// Feature Flags
// -----------------------------------------------------------------------------
// Enables nightly Rust feature `int_roundings`, which provides integer division
// methods like `div_ceil` (rounding up division results).
#![feature(int_roundings)]

// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

use godot::{
    prelude::*,                         // Core Godot prelude: macros, traits, and types for GDExtension.
    classes::{Node, TileMap, INode},    // Godot classes: Node (base scene object), TileMap (grid-based map), INode trait.
    obj::{Base, Gd},                    // Base: wrapper for Godot objects, Gd: smart pointer for Godot-managed objects.
};

use std::sync::Arc;                     // Arc: atomic reference-counted pointer for shared ownership.
use tokio::sync::mpsc::{                // Tokio channels for async communication.
    channel,                            // Bounded channel.
    Receiver,                           // Receiver side of a channel.
    UnboundedSender,                    // Unbounded sender side of a channel.
    unbounded_channel,                  // Unbounded channel constructor.
    error::TryRecvError                 // Error type for non-blocking receive attempts.
};
use tracing::{info, error, Level, span}; // Structured logging utilities.

use ssxl_generate::Conductor;           // Conductor: orchestrates generation tasks.
use ssxl_generate::conductor::ConductorState; // ConductorState: tracks conductor’s internal state.
use ssxl_generate::task::task_queue::{GenerationMessage, GenerationTask}; 
// GenerationMessage: messages from generation tasks (updates, completion).
// GenerationTask: represents a single generation job.

use ssxl_math::prelude::Vec2i;          // Vec2i: integer 2D vector type.
use ssxl_shared::{initialize_shared_data, CHUNK_SIZE}; 
// initialize_shared_data: sets up shared resources.
// CHUNK_SIZE: constant defining chunk dimensions (e.g., 16x16 tiles).

// -----------------------------------------------------------------------------
// Helper: Dummy Engine State
// -----------------------------------------------------------------------------
// Provides a fallback SSXLEngine when the Conductor fails to start.
// Creates dummy channels and a default ConductorState.
fn create_dummy_engine_state(base: Base<Node>) -> SSXLEngine {
    let (dummy_tx, _) = unbounded_channel(); // Dummy sender.
    let (_, dummy_rx) = channel(1);          // Dummy receiver.

    SSXLEngine {
        base,
        conductor: None,                     // No conductor available.
        state: ConductorState::new(String::new()), // Default empty state.
        request_sender: dummy_tx,
        progress_rx: dummy_rx,
        tilemap: None,
    }
}

// -----------------------------------------------------------------------------
// Struct: SSXLEngine
// -----------------------------------------------------------------------------
// Represents the Godot-facing engine node.
// Manages conductor, communication channels, tilemap, and state.
#[derive(GodotClass)]
#[class(base = Node)]
pub struct SSXLEngine {
    base: Base<Node>,                        // Base Godot node.

    conductor: Option<Conductor>,            // Optional conductor instance.
    request_sender: UnboundedSender<GenerationTask>, // Channel to send generation tasks.
    progress_rx: Receiver<GenerationMessage>,        // Channel to receive progress updates.

    tilemap: Option<Gd<TileMap>>,            // Optional TileMap reference for rendering.
    state: ConductorState,                   // Current conductor state.
}

// -----------------------------------------------------------------------------
// Implementation: INode Trait
// -----------------------------------------------------------------------------
// Defines lifecycle methods for SSXLEngine as a Godot node.
#[godot_api]
impl INode for SSXLEngine {
    // Initialization: called when the node is created.
    fn init(base: Base<Node>) -> Self {
        let _span = span!(Level::INFO, "SSXLEngine::init").entered(); // Start tracing span.

        initialize_shared_data(); // Prepare shared resources.

        // Attempt to start conductor.
        match Conductor::new(None) {
            Ok((conductor, state, request_sender, progress_rx)) => {
                info!("SSXLEngine → Conductor ONLINE");
                Self {
                    base,
                    conductor: Some(conductor),
                    state,
                    request_sender,
                    progress_rx,
                    tilemap: None,
                }
            }
            Err(e) => {
                error!("Failed to start Conductor: {:?}", e);
                create_dummy_engine_state(base) // Fallback to dummy state.
            }
        }
    }

    // Process loop: runs every frame.
    fn process(&mut self, _delta: f64) {
        loop {
            // Try to receive a progress message without blocking.
            let message = match self.progress_rx.try_recv() {
                Ok(msg) => msg,
                Err(TryRecvError::Empty) => break, // No messages → exit loop.
                Err(e) => {
                    error!("Progress channel error: {:?}", e);
                    break;
                }
            };

            // Handle different message types.
            match message {
                GenerationMessage::Generated(key, chunk_data) => {
                    // Ensure tilemap exists.
                    let Some(tilemap) = self.tilemap.as_mut() else { continue; };

                    // Compute chunk origin in world coordinates.
                    let origin_x = (key.x as i32) * CHUNK_SIZE as i32;
                    let origin_y = (key.y as i32) * CHUNK_SIZE as i32;
                    let layer = 0;

                    // Extract tiles from Arc (consume or clone).
                    let tiles = Arc::try_unwrap(chunk_data)
                        .unwrap_or_else(|arc| (*arc).clone())
                        .tiles;

                    // Iterate over tiles and place them in the TileMap.
                    for (idx, _tile) in tiles.iter().enumerate() {
                        let local_x = (idx as u32 % CHUNK_SIZE) as i32;
                        let local_y = (idx as u32 / CHUNK_SIZE) as i32;

                        let world_x = origin_x + local_x;
                        let world_y = origin_y + local_y;

                        tilemap.set_cell(
                            layer,
                            Vector2i::new(world_x, world_y),
                        );
                    }

                    // Emit signal to Godot: chunk applied.
                    self.base_mut().emit_signal(
                        "chunk_applied",
                        &[key.x.to_variant(), key.y.to_variant()],
                    );
                }

                GenerationMessage::GenerationComplete => {
                    info!("Generation Task Queue signaled completion.");
                }

                GenerationMessage::StatusUpdate(status) => {
                    info!("Generation status update: {}", status);
                }
            }
        }
    }

    // Exit tree: called when node is removed from scene.
    fn exit_tree(&mut self) {
        if let Some(conductor) = self.conductor.take() {
            conductor.signal_shutdown_graceful(); // Gracefully shut down conductor.
        }
    }
}

// -----------------------------------------------------------------------------
// Public Godot-exposed Methods
// -----------------------------------------------------------------------------
// These methods can be called from Godot scripts.
#[godot_api]
impl SSXLEngine {
    // Assign a TileMap to the engine.
    #[func]
    pub fn set_tilemap(&mut self, tilemap: Gd<TileMap>) {
        self.tilemap = Some(tilemap);
    }

    // Build a map of given width/height using specified generator.
    #[func]
    pub fn build_map(&self, width: i32, height: i32, generator_id: GString) {
        if self.request_sender.is_closed() {
            error!("Conductor is shut down. Cannot request map.");
            return;
        }

        // Compute number of chunks needed (ceil division).
        let chunks_x = width.div_ceil(CHUNK_SIZE as i32);
        let chunks_y = height.div_ceil(CHUNK_SIZE as i32);

        // Send generation tasks for each chunk.
        for x in 0..chunks_x {
            for y in 0..chunks_y {
                let task = GenerationTask {
                    chunk_coords: Vec2i::new(x as i64, y as i64),
                    generator_id: generator_id.to_string(),
                };
                let _ = self.request_sender.send(task);
            }
        }

        info!("Sent {} generation tasks.", chunks_x * chunks_y);
    }

    // Check if conductor is active.
    #[func]
    pub fn is_active(&self) -> bool {
        self.state.is_active()
    }

    // Signal emitted when a chunk is applied to the TileMap.
    #[signal]
    fn chunk_applied(key_x: i64, key_y: i64);
}

// -----------------------------------------------------------------------------
// GDExtension Entry Point
// -----------------------------------------------------------------------------
// Registers SSXLEngine as a Godot extension library.
struct SSXLExtension;

#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {}

// --- END: rust/ssxl_engine_ffi/src\lib.rs ---
       123 LOC | rust/ssxl_generate/src\ca\cellular_automata_generator.rs
// --- START: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

use crate::Generator;                         // Trait: defines the generator API contract.
use ssxl_math::prelude::Vec2i;                // Vec2i: integer 2D vector type for chunk coordinates.
use fastrand;                                 // Fast, lightweight PRNG for deterministic seeding.
use ssxl_shared::{
    ChunkData,                                // Struct: holds all tile data for a chunk.
    CHUNK_SIZE,                               // Constant: defines chunk dimensions (e.g., 16x16).
    GridBounds,                               // Struct: defines world-space boundaries of a chunk.
    TileData,                                 // Struct: represents a single tile’s data (type + noise).
    TileType,                                 // Enum: defines tile types (Rock, Void, etc.).
};
use tracing::{info, warn};                    // Logging macros for structured runtime output.

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
// RULE_SOLID, RULE_CHECKERBOARD: constants for static rulesets.
// get_next_tile_type: function that applies CA rules to determine next tile type.

use crate::ca::neighbor_check::count_live_neighbors;
// Function: counts how many neighboring tiles are "alive" (Rock) for CA rules.

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const CA_ITERATIONS: u8 = 4;                  // Number of CA iterations to stabilize the pattern.
const INITIAL_FILL_PERCENT: u8 = 45;          // Initial percentage of tiles seeded as Rock.

// -----------------------------------------------------------------------------
// Struct: CellularAutomataGenerator
// -----------------------------------------------------------------------------

pub struct CellularAutomataGenerator {
    ruleset: u8,                              // Numeric ID for which ruleset to apply.
}

impl CellularAutomataGenerator {
    // Constructor: create a new generator with a given ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// -----------------------------------------------------------------------------
// Helper Function: generate_static_pattern
// -----------------------------------------------------------------------------
// Generates non-iterative static patterns (Solid fill or Checkerboard).
// Bypasses CA simulation entirely for efficiency.
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;

    // Compute world-space boundaries for this chunk.
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;

    // Unique chunk ID: combine x and y into a 64-bit integer.
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

    // Define bounding box for the chunk.
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );

    // Dimension name based on ruleset.
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };

    // Initialize chunk data.
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

    // Temporary vector to hold tile states before inserting into fixed-size array.
    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    // Fill tiles according to ruleset.
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    if (x + y) % 2 == 0 { TileType::Rock } else { TileType::Void }
                }
                _ => TileType::Void,
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    // Insert tiles into chunk data.
    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

// -----------------------------------------------------------------------------
// Helper Function: run_ca_simulation
// -----------------------------------------------------------------------------
// Runs iterative Cellular Automata simulation using double-buffering.
// Reads from source buffer, writes to target buffer, then swaps.
fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    // Clone initial tile state into target buffer.
    let mut target_tiles = chunk_data.tiles.clone();

    // Perform CA iterations.
    for i in 0..CA_ITERATIONS {
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;

                // Current tile from source buffer.
                let current_tile = &chunk_data.tiles[index];

                // Count live neighbors.
                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                // Apply ruleset to determine next tile type.
                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                // Write new tile into target buffer.
                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }

        // Swap source and target buffers (O(1) pointer swap).
        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        info!("CA Generator: Iteration {} complete.", i + 1);
    }

    // Final state resides in chunk_data.tiles.
    chunk_data
}

// -----------------------------------------------------------------------------
// Trait Implementation: Generator
// -----------------------------------------------------------------------------
// Implements the Generator trait for CellularAutomataGenerator.
// Provides ID and chunk generation logic.
impl Generator for CellularAutomataGenerator {
    // Return string identifier for this generator.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    // Generate a chunk at given coordinates.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns directly.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // Seed PRNG deterministically based on chunk coordinates.
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);

        // Compute world-space boundaries and chunk ID.
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        // Initialize chunk data.
        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Build initial randomized tile state.
        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;
            let tile_type = if is_rock { TileType::Rock } else { TileType::Void };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles_vec);

        // Run CA simulation to evolve chunk state.
        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}

// --- END: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
         3 LOC | rust/ssxl_generate/src\ca\mod.rs
// --- START: rust/ssxl_generate/src\ca\mod.rs ---
// -----------------------------------------------------------------------------
// Cellular Automata Module Declaration
// -----------------------------------------------------------------------------
// This file (`mod.rs`) acts as the entry point for the `ca` module in your
// project. It organizes and exposes submodules that implement different parts
// of the Cellular Automata (CA) generation system. By declaring them here,
// other parts of the crate can access them via `crate::ca::<submodule>`.

// -----------------------------------------------------------------------------
// Submodule: cellular_automata_generator
// -----------------------------------------------------------------------------
// Contains the main generator struct (`CellularAutomataGenerator`) and its
// implementation of the `Generator` trait. This is the high-level orchestrator
// that:
//   - Seeds chunks with initial random tile states.
//   - Runs CA iterations to evolve those states.
//   - Produces final `ChunkData` ready for use in the engine.
// Essentially, this is the "front door" for CA-based generation.
pub mod cellular_automata_generator;

// -----------------------------------------------------------------------------
// Submodule: rule_set
// -----------------------------------------------------------------------------
// Defines the specific Cellular Automata rulesets (e.g., Survival/Birth rules).
// Examples include:
//   - RULE_SOLID: fills all tiles with Rock.
//   - RULE_CHECKERBOARD: alternates Rock/Void tiles.
//   - RULE_BASIC_CAVE: cave-like generation rules.
//   - RULE_MAZE: maze/dungeon-like rules.
// This module abstracts the logic for determining the next tile type given
// the current state and neighbor counts, making it easy to swap or experiment
// with different rule sets.
pub mod rule_set;

// -----------------------------------------------------------------------------
// Submodule: neighbor_check
// -----------------------------------------------------------------------------
// Provides low-level functions for inspecting a tile’s neighbors in the grid.
// Example: `count_live_neighbors` counts how many adjacent tiles are Rock.
// This is the "microscope" of the CA system, feeding local state into the
// rule_set logic. By separating neighbor checks from rule application, you
// keep the design modular and easier to extend (e.g., different neighborhood
// definitions like Moore vs. Von Neumann).
pub mod neighbor_check;

// --- END: rust/ssxl_generate/src\ca\mod.rs ---
        25 LOC | rust/ssxl_generate/src\ca\neighbor_check.rs
// --- START: rust/ssxl_generate/src\ca\neighbor_check.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: holds all tile data for a chunk.
// CHUNK_SIZE: constant defining the width/height of a chunk (e.g., 16).
// TileType: enum representing tile states (Rock, Void, etc.).
use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

// -----------------------------------------------------------------------------
// Function: count_live_neighbors
// -----------------------------------------------------------------------------
// Purpose:
//   - Counts how many neighboring tiles around a given cell are "live"
//     (defined here as TileType::Rock).
//   - Uses a 3x3 Moore neighborhood (the 8 surrounding cells).
//   - Handles boundary conditions to avoid indexing outside the chunk.
//
// Arguments:
//   - chunk_data: reference to the chunk’s tile data.
//   - cx: X coordinate of the center cell (0..CHUNK_SIZE-1).
//   - cy: Y coordinate of the center cell (0..CHUNK_SIZE-1).
//
// Returns:
//   - u8 count of live neighbors (0–8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    // Initialize neighbor count.
    let mut count = 0;

    // Cache chunk size as i32 for safe signed arithmetic.
    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    // Convert center coordinates to i32 for arithmetic with dx/dy offsets.
    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    // Iterate over relative offsets in the 3x3 neighborhood.
    // dx, dy range from -1 to +1.
    for dx in -1..=1 {
        for dy in -1..=1 {
            // Skip the center cell itself.
            if dx == 0 && dy == 0 {
                continue;
            }

            // Compute neighbor coordinates.
            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            // Boundary check: ensure neighbor is inside chunk bounds.
            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                // Safe to cast back to u32 for indexing.
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;

                // Compute linear index into tiles array.
                // Formula: index = y * CHUNK_SIZE + x
                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                // Check if neighbor tile is "live" (Rock).
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }

    // Return total live neighbor count.
    count
}

// --- END: rust/ssxl_generate/src\ca\neighbor_check.rs ---
        28 LOC | rust/ssxl_generate/src\ca\rule_set.rs
// --- START: rust/ssxl_generate/src\ca\rule_set.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// TileType: Enum representing the type of a tile (e.g., Rock, Void, Water, Ore).
// This is the fundamental state that Cellular Automata rules will evolve.
use ssxl_shared::TileType;

// -----------------------------------------------------------------------------
// Rule Set Identifiers
// -----------------------------------------------------------------------------
// These constants define which ruleset to apply when running the CA simulation.
// Each ruleset corresponds to a different "Birth/Survival" (B/S) configuration.
//
// RULE_BASIC_CAVE: Standard cave-like generation rules.
// RULE_MAZE: Maze/dungeon-like rules.
// RULE_SOLID: Static rule that fills everything with Rock.
// RULE_CHECKERBOARD: Static rule that alternates Rock/Void in a checkerboard pattern.
pub const RULE_BASIC_CAVE: u8 = 0;
pub const RULE_MAZE: u8 = 1;
pub const RULE_SOLID: u8 = 2;
pub const RULE_CHECKERBOARD: u8 = 3;

// -----------------------------------------------------------------------------
// Function: get_next_tile_type
// -----------------------------------------------------------------------------
// Purpose:
//   - Determines the next state of a tile (Rock or Void) based on:
//       1. Its current state.
//       2. The number of live neighbors (Rock tiles).
//       3. The chosen ruleset.
//
// Arguments:
//   - current_type: The tile’s current state (TileType).
//   - live_neighbors: Number of Rock neighbors (0–8).
//   - ruleset: Identifier for which ruleset to apply.
//
// Returns:
//   - The tile’s next state (TileType).
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {
    // -------------------------------------------------------------------------
    // Define Birth and Survival ranges based on ruleset.
    // -------------------------------------------------------------------------
    // Birth (B): A Void tile becomes Rock if neighbor count is within [birth_min, birth_max].
    // Survival (S): A Rock tile stays Rock if neighbor count is within [survive_min, survive_max].
    //
    // RULE_MAZE → B3/S1-4: Creates thin, winding corridors.
    // RULE_BASIC_CAVE → B4-5/S1-7: Creates large, open cave-like spaces.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),           // Maze ruleset: strict birth, narrow survival.
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // Cave ruleset: broader birth/survival ranges.
    };

    // -------------------------------------------------------------------------
    // Apply rules based on current tile type.
    // -------------------------------------------------------------------------
    match current_type {
        // Case 1: Tile is currently Rock (alive).
        TileType::Rock => {
            // Survival check: Rock survives if neighbor count is within survival range.
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                TileType::Rock
            } else {
                // Otherwise, Rock dies → becomes Void.
                TileType::Void
            }
        }

        // Case 2: Tile is currently Void (dead).
        TileType::Void => {
            // Birth check: Void becomes Rock if neighbor count is within birth range.
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                TileType::Rock
            } else {
                // Otherwise, Void remains Void.
                TileType::Void
            }
        }

        // Case 3: Any other TileType (e.g., Water, Ore).
        // These are not part of the CA simulation, so leave them unchanged.
        _ => current_type,
    }
}

// --- END: rust/ssxl_generate/src\ca\rule_set.rs ---
        76 LOC | rust/ssxl_generate/src\conductor\builder.rs
// --- START: rust/ssxl_generate/src\conductor\builder.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Bring in conductor state and Conductor struct from the parent module.
use super::{conductor_state, Conductor};
// Internal setup struct that bundles channels, managers, and initial state.
use super::internal_setup::ConductorInternalSetup; 

// GeneratorManager: manages available generators.
// RuntimeManager: manages async runtime for request loop.
use crate::manager::{GeneratorManager, RuntimeManager};
// Task system: start_request_loop runs the async loop,
// GenerationMessage is the progress update type,
// GenerationTask (aliased as ChunkRequest) represents a single chunk generation request.
use crate::task::{start_request_loop, GenerationMessage, GenerationTask as ChunkRequest};
// ChunkCache: LRU cache for storing generated chunks.
use ssxl_cache::ChunkCache;
// Config loader: retrieves configuration from a file path.
use ssxl_shared::config::config::get_config_from_path;
// Tokio channels: async communication primitives.
use tokio::sync::mpsc::{self, Receiver, UnboundedSender};
// Logging macros.
use tracing::info;
// Standard library imports.
use std::io;
use std::sync::Arc;

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// Defines the bounded capacity for the progress channel.
// This limits how many progress messages can be queued before backpressure applies.
const PROGRESS_CHANNEL_BOUND: usize = 1024;

// -----------------------------------------------------------------------------
// Function: setup_channels_and_state
// -----------------------------------------------------------------------------
// Purpose:
//   - Initializes configuration, generator manager, channels, and conductor state.
//   - Returns a ConductorInternalSetup bundle for later spawning.
//
// Arguments:
//   - config_path: optional path to configuration file.
//
// Returns:
//   - ConductorInternalSetup on success.
//   - io::Error on failure.
pub(crate) fn setup_channels_and_state(
    config_path: Option<&str>,
) -> Result<ConductorInternalSetup, io::Error> {
    // Load configuration from path (or defaults).
    let config = get_config_from_path(config_path);

    // Initialize generator manager, mapping errors into io::Error.
    let generator_manager = GeneratorManager::new().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
    })?;

    // Create bounded progress channel for generation updates.
    let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
    // Create unbounded request channel for chunk generation tasks.
    let (request_sender_api, request_receiver) = mpsc::unbounded_channel();

    // Determine initial generator ID from config.
    let initial_id = generator_manager.get_initial_id(&config.default_generator_id());
    // Create initial conductor state with that ID.
    let initial_state = conductor_state::ConductorState::new(initial_id.clone());

    // Log initialization.
    info!("Conductor initialized. Active generator: {}", initial_id);

    // Bundle everything into ConductorInternalSetup for later use.
    Ok(ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    })
}

// -----------------------------------------------------------------------------
// Function: spawn
// -----------------------------------------------------------------------------
// Purpose:
//   - Consumes ConductorInternalSetup and spawns the async request loop.
//   - Returns a fully constructed Conductor instance, its state, and channel handles.
//
// Arguments:
//   - internal_setup: previously prepared setup bundle.
//
// Returns:
//   - Tuple: (Conductor, ConductorState, request sender, progress receiver).
//   - io::Error on failure.
pub(crate) fn spawn(
    internal_setup: ConductorInternalSetup,
) -> Result<
    (
        Conductor,
        conductor_state::ConductorState,
        UnboundedSender<ChunkRequest>,
        Receiver<GenerationMessage>,
    ),
    io::Error,
> {
    // Destructure setup bundle into components.
    let ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    } = internal_setup;

    // Create runtime manager (Tokio runtime wrapper).
    let runtime_manager = RuntimeManager::new()?;
    let handle = runtime_manager.get_handle();

    // Clone generator map for use inside async loop.
    let generators_for_loop = Arc::new(generator_manager.get_map_clone());
    // Create chunk cache with capacity 4096.
    let chunk_cache = Arc::new(ChunkCache::new(4096)?);
    let chunk_cache_for_loop = chunk_cache.clone();

    // Mark conductor state as running.
    initial_state.set_status(conductor_state::ConductorStatus::Running);
    let state_for_loop = initial_state.clone();

    // Start async request loop:
    //   - handle: runtime handle.
    //   - request_receiver: receives chunk generation tasks.
    //   - progress_sender: sends progress updates.
    //   - generators_for_loop: available generators.
    //   - chunk_cache_for_loop: cache for generated chunks.
    //   - state_for_loop: conductor state shared with loop.
    start_request_loop(
        handle,
        request_receiver,
        progress_sender.clone(),
        generators_for_loop,
        chunk_cache_for_loop,
        Arc::new(state_for_loop),
    );

    // Construct Conductor instance with runtime, managers, state, cache, and channels.
    let conductor = Conductor {
        runtime_manager,
        generator_manager,
        internal_state: initial_state.clone(),
        chunk_cache,
        progress_sender,
        _request_sender: request_sender_api.clone(),
    };

    // Return conductor, state, request sender, and progress receiver.
    Ok((conductor, initial_state, request_sender_api, progress_receiver))
}

// --- END: rust/ssxl_generate/src\conductor\builder.rs ---
        79 LOC | rust/ssxl_generate/src\conductor\conductor.rs
// --- START: rust/ssxl_generate/src\conductor\conductor.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Brings in setup and spawn functions from the builder module.
// These functions initialize channels, state, and spawn the conductor loop.
use crate::conductor::builder::{setup_channels_and_state, spawn};

use ssxl_cache::ChunkCache; // Cache for storing generated chunks.
use ssxl_shared::message::{GenerationCommand, GenerationResponse}; 
// Messages used for FFI (Foreign Function Interface) integration.
// GenerationCommand: requests from external systems.
// GenerationResponse: responses back to external systems.

use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver};
// Async channels for communication between tasks.
// - UnboundedSender/Receiver: unlimited capacity channels.
// - Receiver: bounded channel for progress updates.

use tracing::info; // Logging macro for structured runtime output.
use std::error::Error; // Trait for error handling.
use std::io; // Standard I/O error type.
use std::sync::Arc; // Thread-safe reference-counted pointer for shared ownership.

use crate::manager::runtime_manager::RuntimeManager; // Manages async runtime.
use crate::manager::generator_manager::GeneratorManager; // Manages available generators.
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
// ChunkRequest: represents a single chunk generation task.
// GenerationMessage: progress updates from generation tasks.

use crate::conductor::conductor_state::{self, ConductorState};
// ConductorState: tracks conductor’s current status and active generator.

// -----------------------------------------------------------------------------
// Struct: Conductor
// -----------------------------------------------------------------------------
// The central orchestrator for chunk generation.
// Holds runtime, generator manager, state, cache, and communication channels.
pub struct Conductor {
    pub(crate) runtime_manager: RuntimeManager,          // Async runtime manager.
    pub(crate) generator_manager: GeneratorManager,      // Manages generator instances.
    pub(crate) internal_state: conductor_state::ConductorState, // Tracks conductor status.
    pub(crate) chunk_cache: Arc<ChunkCache>,             // Shared cache for generated chunks.
    pub progress_sender: tokio::sync::mpsc::Sender<GenerationMessage>, // Sends progress updates.
    #[allow(dead_code)]
    pub(crate) _request_sender: UnboundedSender<ChunkRequest>, // Sends chunk generation requests.
}

// -----------------------------------------------------------------------------
// Implementation: Conductor
// -----------------------------------------------------------------------------
impl Conductor {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new Conductor instance with channels and state initialized.
    // Returns:
    //   - Conductor instance
    //   - ConductorState
    //   - Request sender (for chunk tasks)
    //   - Progress receiver (for updates)
    pub fn new(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<ChunkRequest>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?; // Prepare setup bundle.
        spawn(setup) // Spawn conductor loop and return tuple.
    }

    // -------------------------------------------------------------------------
    // Constructor: new_for_ffi
    // -------------------------------------------------------------------------
    // Specialized constructor for FFI (external bindings).
    // Returns:
    //   - Conductor instance
    //   - ConductorState
    //   - Command sender (external requests)
    //   - Response receiver (external responses)
    //   - Progress receiver (generation updates)
    pub fn new_for_ffi(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<GenerationCommand>,
            UnboundedReceiver<GenerationResponse>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        let (conductor, state, _req_tx, progress_rx) = spawn(setup)?;
        // Create external command/response channels.
        let (cmd_tx, _) = tokio::sync::mpsc::unbounded_channel();
        let (_, resp_rx) = tokio::sync::mpsc::unbounded_channel();
        Ok((conductor, state, cmd_tx, resp_rx, progress_rx))
    }

    // -------------------------------------------------------------------------
    // Getter: get_active_generator_id
    // -------------------------------------------------------------------------
    // Returns the ID of the currently active generator.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    // -------------------------------------------------------------------------
    // Setter: set_generator
    // -------------------------------------------------------------------------
    // Switches the active generator to a new ID.
    // Logs the change and updates internal state.
    pub fn set_generator(&mut self, id: &str) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_active_generator_id(id);
        info!("Active generator switched to: {}", id);
        Ok(())
    }

    // -------------------------------------------------------------------------
    // Control: stop_generation
    // -------------------------------------------------------------------------
    // Signals the conductor to stop generation tasks.
    // Updates state to "Stopping" and logs the request.
    pub fn stop_generation(&self) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Global stop requested.");
        Ok(())
    }

    // -------------------------------------------------------------------------
    // Control: graceful_teardown
    // -------------------------------------------------------------------------
    // Consumes the Conductor instance and shuts down gracefully.
    // Updates state to "ShuttingDown" and stops runtime.
    pub fn graceful_teardown(self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
        self.runtime_manager.shutdown_graceful();
        info!("Conductor gracefully shut down.");
    }

    // -------------------------------------------------------------------------
    // Control: signal_shutdown_graceful
    // -------------------------------------------------------------------------
    // Signals shutdown without consuming the Conductor.
    // Updates state to "ShuttingDown".
    pub fn signal_shutdown_graceful(&self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    // -------------------------------------------------------------------------
    // Control: request_shutdown
    // -------------------------------------------------------------------------
    // Requests shutdown by signaling and stopping runtime.
    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor.rs ---
        58 LOC | rust/ssxl_generate/src\conductor\conductor_state.rs
// --- START: rust/ssxl_generate/src\conductor\conductor_state.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Arc: thread-safe reference-counted pointer for shared ownership across threads.
// AtomicUsize, AtomicU64: atomic counters for safe concurrent mutation.
// Ordering: defines memory ordering semantics for atomic operations.
// AtomicResource: custom wrapper (from ssxl_sync) for atomic read/write of complex types.
use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

// -----------------------------------------------------------------------------
// Enum: ConductorStatus
// -----------------------------------------------------------------------------
// Represents the lifecycle state of the Conductor.
// Each variant corresponds to a distinct operational phase.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    Initializing,   // Conductor is starting up.
    Running,        // Actively processing tasks.
    Paused,         // Temporarily halted but can resume.
    Generating,     // Actively generating chunks.
    Stopping,       // Graceful stop requested.
    ShuttingDown,   // Final shutdown in progress.
    Error,          // Fault state encountered.
}

// -----------------------------------------------------------------------------
// Struct: ConductorState
// -----------------------------------------------------------------------------
// Holds shared, thread-safe state for the Conductor.
// Designed for concurrent access across async tasks and threads.
#[derive(Clone)]
pub struct ConductorState {
    // Current status of the conductor (Initializing, Running, etc.).
    status: AtomicResource<ConductorStatus>,
    // Depth of the request queue (number of pending tasks).
    queue_depth: Arc<AtomicUsize>,
    // ID of the currently active generator.
    active_generator_id: AtomicResource<String>,
    // Counter for total tiles placed/generated.
    tile_counter: Arc<AtomicU64>,
}

// -----------------------------------------------------------------------------
// Implementation: ConductorState
// -----------------------------------------------------------------------------
impl ConductorState {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new ConductorState with default values.
    // - Status: Initializing
    // - Queue depth: 0
    // - Active generator: provided ID
    // - Tile counter: 0
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: AtomicResource::new(ConductorStatus::Initializing),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: AtomicResource::new(initial_generator_id),
            tile_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    // -------------------------------------------------------------------------
    // Getter: get_status
    // -------------------------------------------------------------------------
    // Returns the current conductor status.
    pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
    }
    
    // -------------------------------------------------------------------------
    // Helper: is_active
    // -------------------------------------------------------------------------
    // Returns true if conductor is in an "active" state (Running or Generating).
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    // -------------------------------------------------------------------------
    // Getter: get_queue_depth
    // -------------------------------------------------------------------------
    // Returns the number of tasks currently in the queue.
    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    // -------------------------------------------------------------------------
    // Getter: get_tiles_placed
    // -------------------------------------------------------------------------
    // Returns the total number of tiles placed/generated so far.
    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    // -------------------------------------------------------------------------
    // Getter: get_active_generator_id
    // -------------------------------------------------------------------------
    // Returns the ID of the currently active generator.
    pub fn get_active_generator_id(&self) -> String {
        self.active_generator_id.read().clone()
    }

    // -------------------------------------------------------------------------
    // Mutator: increment_queue_depth
    // -------------------------------------------------------------------------
    // Increases queue depth by 1 (new task added).
    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    // -------------------------------------------------------------------------
    // Mutator: decrement_queue_depth
    // -------------------------------------------------------------------------
    // Decreases queue depth by 1 (task completed).
    pub fn decrement_queue_depth(&self) {
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    // -------------------------------------------------------------------------
    // Mutator: increment_tile_count
    // -------------------------------------------------------------------------
    // Increases tile counter by a specified amount.
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    // -------------------------------------------------------------------------
    // Mutator: set_status
    // -------------------------------------------------------------------------
    // Updates conductor status to a new value.
    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
    }

    // -------------------------------------------------------------------------
    // Mutator: set_active_generator_id
    // -------------------------------------------------------------------------
    // Updates the active generator ID.
    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
    }
}

// --- END: rust/ssxl_generate/src\conductor\conductor_state.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\internal_setup.rs
// --- START: rust/ssxl_generate/src\conductor\internal_setup.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ConductorState: Tracks the conductor’s lifecycle state (Running, Stopping, etc.),
// queue depth, active generator ID, and tile counters.
use crate::conductor::conductor_state::ConductorState;

// GeneratorManager: Manages all available generator instances and provides
// access to their configuration and execution logic.
use crate::manager::generator_manager::GeneratorManager;

// GenerationTask (aliased as ChunkRequest): Represents a single chunk generation request.
// GenerationMessage: Represents progress updates or results from generation tasks.
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};

// Tokio channels for async communication between tasks:
// - UnboundedReceiver: receives messages from an unbounded channel.
// - UnboundedSender: sends messages into an unbounded channel.
// - Receiver: bounded channel receiver.
// - Sender: bounded channel sender.
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver, Sender};

// -----------------------------------------------------------------------------
// Struct: ConductorInternalSetup
// -----------------------------------------------------------------------------
// This struct bundles together all the internal components needed to initialize
// and run the Conductor. It acts as a "setup package" that can be passed around
// between modules to ensure consistent initialization.
//
// Fields:
//   - request_receiver: Receives chunk generation requests from the API.
//   - progress_sender: Sends progress updates into the bounded channel.
//   - request_sender_api: Exposed sender for external modules to submit requests.
//   - progress_receiver: Receives progress updates for monitoring or reporting.
//   - initial_state: Tracks conductor’s current status and metadata.
//   - generator_manager: Manages generator instances and their configurations.
pub(crate) struct ConductorInternalSetup {
    // Channel receiver for incoming chunk generation requests.
    pub request_receiver: UnboundedReceiver<ChunkRequest>,

    // Channel sender for progress updates (bounded).
    pub progress_sender: Sender<GenerationMessage>,

    // Channel sender exposed to API for submitting chunk requests.
    pub request_sender_api: UnboundedSender<ChunkRequest>,

    // Channel receiver for progress updates (bounded).
    pub progress_receiver: Receiver<GenerationMessage>,

    // Initial conductor state (status, queue depth, active generator, tile counter).
    pub initial_state: ConductorState,

    // Manager for all generator instances.
    pub generator_manager: GeneratorManager,
}

// --- END: rust/ssxl_generate/src\conductor\internal_setup.rs ---
         9 LOC | rust/ssxl_generate/src\conductor\mod.rs
// --- START: rust/ssxl_generate/src\conductor\mod.rs ---
// -----------------------------------------------------------------------------
// Module: conductor (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `conductor` module.
// It organizes submodules and re-exports key items so that other parts of the
// crate can easily access them without needing to know the internal layout.
//
// Think of this file as the "table of contents" for the conductor system.

// -----------------------------------------------------------------------------
// Submodules
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the conductor system.
// These submodules are implemented in their own files (e.g., conductor.rs,
// conductor_state.rs, builder.rs, etc.).

pub mod conductor;        // Core Conductor struct and its implementation.
pub mod conductor_state;  // Tracks conductor lifecycle state (Running, Stopping, etc.).
pub mod sync;             // Synchronization utilities for thread-safe resource sharing.
pub mod builder;          // Setup and spawn logic for initializing conductor internals.
pub mod sync_get;         // Helper functions for safely retrieving synchronized values.
pub mod internal_setup;   // Internal setup struct bundling channels, state, and managers.

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::conductor` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::conductor::conductor::Conductor;`
//   With re-export    → `use crate::conductor::Conductor;`

pub use conductor::Conductor;   // Re-export the main Conductor struct.
pub use conductor_state::*;     // Re-export all items from conductor_state (status, state struct).
pub use sync::*;                // Re-export all synchronization utilities.

// --- END: rust/ssxl_generate/src\conductor\mod.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\sync.rs
// --- START: rust/ssxl_generate/src\conductor\sync.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Tokio async channels:
// - Receiver: bounded channel receiver, used to receive messages with backpressure.
// - UnboundedSender: unbounded channel sender, used to send requests without capacity limits.
use tokio::sync::mpsc::{Receiver, UnboundedSender};

// Task queue types:
// - GenerationMessage: represents progress updates or results from generation tasks.
// - GenerationTask: represents a single chunk generation request.
use crate::task::task_queue::GenerationMessage;
use crate::task::task_queue::GenerationTask;

// -----------------------------------------------------------------------------
// Type Alias: ConductorRequestSender
// -----------------------------------------------------------------------------
// Provides a clearer name for the type of sender used to submit generation tasks.
// Instead of writing `UnboundedSender<GenerationTask>` everywhere, we can use
// `ConductorRequestSender` to make the code more readable and domain-specific.
//
// This alias represents the channel through which new chunk generation requests
// are sent into the conductor system.
pub type ConductorRequestSender = UnboundedSender<GenerationTask>;

// -----------------------------------------------------------------------------
// Struct: ConductorProgressReceiver
// -----------------------------------------------------------------------------
// Wraps a bounded Receiver for GenerationMessage.
// This struct is a thin abstraction layer that makes it explicit that the
// receiver is specifically for conductor progress updates.
//
// Fields:
//   - rx: the underlying Receiver<GenerationMessage> channel.
pub struct ConductorProgressReceiver {
    pub rx: Receiver<GenerationMessage>,
}

// -----------------------------------------------------------------------------
// Implementation: ConductorProgressReceiver
// -----------------------------------------------------------------------------
impl ConductorProgressReceiver {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new ConductorProgressReceiver from a given Receiver<GenerationMessage>.
    // This makes it easier to wrap the raw channel in a domain-specific type,
    // clarifying its purpose in the conductor system.
    //
    // Arguments:
    //   - rx: the bounded receiver channel for progress messages.
    //
    // Returns:
    //   - ConductorProgressReceiver wrapping the provided channel.
    pub fn new(rx: Receiver<GenerationMessage>) -> Self {
        ConductorProgressReceiver { rx }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync.rs ---
        35 LOC | rust/ssxl_generate/src\conductor\sync_get.rs
// --- START: rust/ssxl_generate/src\conductor\sync_get.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Bring in the Conductor struct from the parent module.
use super::Conductor;

// Task system utilities:
// - handle_chunk_unit: function that triggers chunk generation for a given coordinate.
// - GenerationMessage: enum representing messages sent back from generation tasks
//   (e.g., Generated, Progress, Error).
use crate::task::{handle_chunk_unit, GenerationMessage};

// Vec2i: integer 2D vector type for chunk coordinates.
use ssxl_math::prelude::Vec2i;

// ChunkData: struct representing the tile data for a single chunk.
use ssxl_shared::ChunkData;

// Arc: thread-safe reference-counted pointer for shared ownership across threads.
use std::sync::Arc;

// Tokio mpsc: async channels for communication between tasks.
// Here we use a bounded channel for temporary synchronous communication.
use tokio::sync::mpsc;

// Logging macros for structured runtime output.
use tracing::{info, error};

// -----------------------------------------------------------------------------
// Implementation: Conductor
// -----------------------------------------------------------------------------
// Adds synchronous chunk retrieval capability to the Conductor.
// This is useful when a caller needs immediate access to chunk data
// without waiting for async streams.
impl Conductor {
    // -------------------------------------------------------------------------
    // Method: get_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Retrieves chunk data synchronously for the given coordinates.
    //   - Internally triggers chunk generation using handle_chunk_unit.
    //   - Blocks until a GenerationMessage::Generated is received.
    //
    // Arguments:
    //   - chunk_coords: reference to Vec2i representing chunk coordinates.
    //
    // Returns:
    //   - ChunkData: the generated or cached chunk data.
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        // Get the currently active generator ID from conductor state.
        let active_generator_id = self.internal_state.get_active_generator_id();

        // Create a temporary bounded channel (capacity = 1).
        // temp_sender: used to send back the generated chunk.
        // temp_receiver: used to receive the chunk synchronously.
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        // Wrap conductor state in Arc for safe sharing across threads/tasks.
        let state_arc = Arc::new(self.internal_state.clone());

        // Log the synchronous chunk request.
        info!("Sync chunk request: {:?}", chunk_coords);

        // Trigger chunk generation for the given coordinates.
        // handle_chunk_unit will:
        //   - Check cache.
        //   - Generate chunk if missing.
        //   - Send GenerationMessage back through temp_sender.
        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        // Enter blocking loop to wait for a GenerationMessage.
        loop {
            match temp_receiver.blocking_recv() {
                // Case 1: Received a Generated message with chunk data.
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    // Try to unwrap Arc<ChunkData> into owned ChunkData.
                    // If multiple references exist, clone the inner data.
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
                }
                // Case 2: Received some other message (e.g., Progress).
                // Ignore and continue waiting.
                Some(_) => continue,
                // Case 3: Channel closed unexpectedly.
                // Log error and return an empty fallback chunk.
                None => {
                    error!("Sync channel closed for {:?}", chunk_coords);
                    return ChunkData::new_at_coords(*chunk_coords);
                }
            }
        }
    }
}

// --- END: rust/ssxl_generate/src\conductor\sync_get.rs ---
        33 LOC | rust/ssxl_generate/src\lib.rs
// --- START: rust/ssxl_generate/src\lib.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: the fundamental data structure representing a fully generated chunk.
// Vec2i: 2D integer vector type for chunk coordinates.
// info!, error!: logging macros for structured runtime output.
// mem: provides utilities for memory management (e.g., forgetting values).
use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;
use tracing::{info, error};
use std::mem;

// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// These modules organize the engine into distinct subsystems:
//   - ca: cellular automata generators.
//   - conductor: orchestrates generation tasks and runtime.
//   - manager: registry and configuration validation for generators.
//   - perlin: Perlin noise generator implementation.
//   - task: task queue, batch processor, benchmarking logic.
pub mod ca;
pub mod conductor;
pub mod manager;
pub mod perlin;
pub mod task;

// -----------------------------------------------------------------------------
// Trait: Generator
// -----------------------------------------------------------------------------
// Defines the contract for all procedural generation algorithms.
// Any generator (Perlin, Cellular Automata, etc.) must implement this trait.
//
// Methods:
//   - id(): returns a unique identifier string for the generator.
//   - generate_chunk(): generates a chunk of terrain at given coordinates.
pub trait Generator {
    fn id(&self) -> &str;
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

// -----------------------------------------------------------------------------
// Re-exports: Generators
// -----------------------------------------------------------------------------
// Re-export concrete generator implementations so they can be accessed directly
// from the crate root without drilling into submodules.
pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

// -----------------------------------------------------------------------------
// Re-exports: Conductor and Config
// -----------------------------------------------------------------------------
// Conductor: orchestrates generator execution, task queue, and runtime lifecycle.
// GeneratorConfig: validates map dimensions and generator settings.
pub use conductor::conductor::Conductor;
pub use manager::config_validator::GeneratorConfig;

// -----------------------------------------------------------------------------
// Re-exports: Conductor Sync Interfaces
// -----------------------------------------------------------------------------
// ConductorProgressReceiver: channel receiver for progress updates.
// ConductorRequestSender: channel sender for generation requests.
pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;

// -----------------------------------------------------------------------------
// Re-exports: Task Interfaces
// -----------------------------------------------------------------------------
// GenerationTask: represents a single chunk generation request.
// benchmark_generation_workload: benchmarking utility for simulating workloads.
pub use task::task_queue::GenerationTask;
pub use task::benchmark_logic::benchmark_generation_workload;

// -----------------------------------------------------------------------------
// Function: start_runtime_placeholder
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a placeholder entry point for testing runtime initialization.
//   - Demonstrates how to create a Conductor and immediately tear it down.
//
// Steps:
//   1. Attempt to create a new Conductor with no configuration (None).
//   2. If successful:
//        a. Log that runtime was created.
//        b. Forget the progress_receiver (to avoid drop/shutdown side effects).
//        c. Call graceful_teardown() on the Conductor.
//   3. If failed:
//        a. Log error with failure details.
pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _request_sender, progress_receiver)) => {
            // Step 2a: Log successful runtime creation.
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Step 2b: Forget progress_receiver to prevent automatic drop behavior.
            mem::forget(progress_receiver);
            
            // Step 2c: Gracefully shut down the conductor.
            conductor.graceful_teardown();
        }
        Err(e) => {
            // Step 3a: Log error if runtime initialization fails.
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}

// --- END: rust/ssxl_generate/src\lib.rs ---
        58 LOC | rust/ssxl_generate/src\manager\config_validator.rs
// --- START: rust/ssxl_generate/src\manager\config_validator.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros for structured runtime output.
// - info!: used for successful validation messages.
// - error!: used for validation failure messages.
use tracing::{error, info};

// fmt: provides traits and utilities for formatting output (e.g., implementing Display).
use std::fmt;

// HashMap: used to store tile overrides keyed by coordinates.
use std::collections::HashMap;

// Import constants and types directly from the ssxl_shared crate root.
// - CHUNK_SIZE: defines the dimension of a single chunk (e.g., 16x16).
// - TileCoord: coordinate type for identifying specific tiles.
// - TileType: enum representing tile states (Rock, Void, etc.).
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// Defines the maximum number of active chunks allowed in memory.
// This prevents runaway generation requests that could exhaust resources.
const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

// -----------------------------------------------------------------------------
// Struct: GeneratorConfig
// -----------------------------------------------------------------------------
// Holds configuration parameters for a generator run.
// This struct encapsulates all the metadata needed to initialize and validate
// a generation process.
//
// Fields:
//   - width: map width in tiles.
//   - height: map height in tiles.
//   - seed: string used for deterministic random generation.
//   - generator_name: identifier for which generator to use.
//   - tile_overrides: optional overrides for specific tiles (customized map edits).
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

// -----------------------------------------------------------------------------
// Trait Implementation: Display for GeneratorConfig
// -----------------------------------------------------------------------------
// Provides a human-readable string representation of GeneratorConfig.
// Useful for logging and debugging.
impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width, 
            self.height, 
            self.seed, 
            self.generator_name,
            self.tile_overrides.len() // Only log the count of overrides, not the full map.
        )
    }
}

// -----------------------------------------------------------------------------
// Struct: ConfigValidator
// -----------------------------------------------------------------------------
// Provides validation logic for GeneratorConfig.
// Ensures map dimensions are reasonable and within system limits.
pub struct ConfigValidator;

impl ConfigValidator {
    // -------------------------------------------------------------------------
    // Method: validate_map_dimensions
    // -------------------------------------------------------------------------
    // Validates the width and height of the map in terms of chunk counts.
    //
    // Steps:
    //   1. Log the incoming config for traceability.
    //   2. Convert map dimensions and chunk size to i64 for safe arithmetic.
    //   3. Compute how many chunks wide and tall the map will be.
    //      - Uses ceiling division to ensure partial chunks are counted.
    //   4. Calculate total number of chunks.
    //   5. Validate:
    //      - Total chunks must be > 0.
    //      - Total chunks must not exceed MAX_ACTIVE_CHUNKS.
    //   6. Log success or failure and return Result accordingly.
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        // Log the config being validated.
        info!("Validating batch generation command with config: {}", config);

        // Convert constants and dimensions to i64 for arithmetic.
        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        // Ceiling division formula:
        // (dividend + divisor - 1) / divisor
        // Ensures partial chunks are counted as full.
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        // Validation 1: total chunks must be positive.
        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // Validation 2: total chunks must not exceed maximum allowed.
        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // If validations pass, log success.
        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}

// --- END: rust/ssxl_generate/src\manager\config_validator.rs ---
         6 LOC | rust/ssxl_generate/src\manager\generator.rs
// --- START: rust/ssxl_generate/src\manager\generator.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// ChunkData: The fundamental data structure representing a fully generated chunk.
//   - Contains tile information, bounds, and metadata.
//   - This is the "output" of any generator implementation.
use ssxl_shared::ChunkData;

// Vec2i: A 2D integer vector type (x, y).
//   - Used to represent chunk coordinates in the world grid.
//   - Ensures generators are deterministic based on position.
use ssxl_math::prelude::Vec2i;

// -----------------------------------------------------------------------------
// Trait: Generator
// -----------------------------------------------------------------------------
// This trait defines the **contract** for all procedural generation algorithms
// in the SSXL engine. Any generator (e.g., Cellular Automata, Perlin Noise,
// Voronoi-based, etc.) must implement this trait to be managed by the Conductor.
//
// By enforcing a common interface, the engine can:
//   - Swap generators dynamically.
//   - Treat all generators uniformly.
//   - Maintain modularity and extensibility.
//
// The #[allow(dead_code)] attribute is applied because the trait itself may not
// be directly referenced in code, but its implementors are essential.
#[allow(dead_code)]
pub trait Generator {
    // -------------------------------------------------------------------------
    // Method: id
    // -------------------------------------------------------------------------
    // Returns a unique, static string identifier for the generator.
    //
    // Purpose:
    //   - Allows the Conductor to distinguish between different generator types.
    //   - Useful for logging, debugging, and configuration.
    //   - Should be unique across all registered generators.
    //
    // Example:
    //   - "cellular_automata_basic"
    //   - "perlin_noise"
    fn id(&self) -> &str;

    // -------------------------------------------------------------------------
    // Method: generate_chunk
    // -------------------------------------------------------------------------
    // Executes the generator’s algorithm to produce a single chunk of world data.
    //
    // Arguments:
    //   - chunk_coords: Vec2i representing the global coordinates of the chunk.
    //
    // Returns:
    //   - ChunkData: the fully generated chunk, ready for caching and use.
    //
    // Requirements:
    //   - Must be deterministic: given the same coordinates and seed, the output
    //     should always be identical.
    //   - Must be self-contained: should not rely on external mutable state.
    //
    // Example:
    //   - For a cave generator, this might run a cellular automata simulation.
    //   - For a noise generator, this might sample Perlin/Simplex noise fields.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

// --- END: rust/ssxl_generate/src\manager\generator.rs ---
        54 LOC | rust/ssxl_generate/src\manager\generator_manager.rs
// --- START: rust/ssxl_generate/src\manager\generator_manager.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros:
// - info!: used to log successful registration of generators.
// - warn!: used to log fallback warnings when a requested generator ID is missing.
use tracing::{info, warn};

// HashMap: used to store generator instances keyed by their unique string IDs.
// Arc: thread-safe reference-counted pointer for sharing generator instances across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: integer 2D vector type for chunk coordinates.
// ChunkData: the fundamental data structure representing a fully generated chunk.
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;

// Generator trait: defines the contract all generators must implement.
// PerlinGenerator: concrete generator based on Perlin noise.
// CellularAutomataGenerator: concrete generator based on cellular automata rules.
use crate::Generator;
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;

// Rule set constants for cellular automata generators.
// Each rule defines a different birth/survival pattern for cave/maze generation.
use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

// -----------------------------------------------------------------------------
// Type Alias: DynGenerator
// -----------------------------------------------------------------------------
// Represents a dynamically dispatched Generator trait object that is both Send + Sync.
// - Box<dyn Generator>: allows storing different generator types uniformly.
// - Send + Sync: ensures thread safety when used in async/concurrent contexts.
// - Arc<DynGenerator>: wraps each generator for shared ownership across tasks.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// -----------------------------------------------------------------------------
// Struct: GeneratorManager
// -----------------------------------------------------------------------------
// Acts as a registry for all available procedural generation algorithms.
// Responsible for:
//   - Initializing concrete generators.
//   - Storing them in a HashMap keyed by ID.
//   - Providing access to generators by ID.
//   - Executing chunk generation requests.
pub struct GeneratorManager {
    // Core registry: maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    // Default Perlin generator ID, used as fallback when config ID is invalid.
    default_perlin_id: String,
}

// -----------------------------------------------------------------------------
// Implementation: GeneratorManager
// -----------------------------------------------------------------------------
impl GeneratorManager {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Initializes all generator algorithms and registers them in the HashMap.
    // Steps:
    //   1. Create empty registry.
    //   2. Register Perlin generator (base noise layer).
    //   3. Register multiple Cellular Automata generators (structured cave/maze layers).
    //   4. Log the number of registered generators.
    // Returns:
    //   - Ok(GeneratorManager) on success.
    //   - Err(String) on failure.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // Register Perlin generator.
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // Register Cellular Automata generators with different rule sets.
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        // Log how many generators were registered.
        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    // -------------------------------------------------------------------------
    // Getter: get_map_ref
    // -------------------------------------------------------------------------
    // Returns a reference to the internal generator map.
    // Useful for quick lookups without cloning.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    // -------------------------------------------------------------------------
    // Getter: get_map_clone
    // -------------------------------------------------------------------------
    // Returns a clone of the internal generator map.
    // Useful when spawning background tasks that need ownership of the map.
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    // -------------------------------------------------------------------------
    // Method: generate_single_chunk
    // -------------------------------------------------------------------------
    // Executes the generation process for a single chunk using the specified generator ID.
    // Steps:
    //   1. Look up generator by ID in the registry.
    //   2. Panic if ID is invalid (should have been validated earlier).
    //   3. Call generator’s generate_chunk method with given coordinates.
    // Returns:
    //   - ChunkData for the requested chunk.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        generator_arc.generate_chunk(chunk_coords)
    }

    // -------------------------------------------------------------------------
    // Method: get_initial_id
    // -------------------------------------------------------------------------
    // Determines the initial active generator ID.
    // Steps:
    //   1. Check if config ID exists in registry.
    //   2. If yes, return config ID.
    //   3. If no, log warning and return default Perlin ID.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!(
                "Config default generator ID '{}' not found. Falling back to Perlin: {}",
                config_id, self.default_perlin_id
            );
            self.default_perlin_id.clone()
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\generator_manager.rs ---
         8 LOC | rust/ssxl_generate/src\manager\mod.rs
// --- START: rust/ssxl_generate/src\manager\mod.rs ---
// -----------------------------------------------------------------------------
// Module: manager (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `manager` module.
// It organizes submodules related to configuration, generator logic,
// generator registry, and runtime management. 
//
// Think of this file as the "table of contents" for all management-related
// functionality in the SSXL engine.

// -----------------------------------------------------------------------------
// Submodules
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the manager system.
// These submodules are implemented in their own files (e.g., config_validator.rs,
// generator.rs, generator_manager.rs, runtime_manager.rs).

pub mod config_validator;     // Validates generator configuration (map dimensions, chunk limits).
pub mod generator;            // Defines the Generator trait (contract for all generation algorithms).
pub mod generator_manager;    // Registry for all available generators (Perlin, Cellular Automata, etc.).
pub mod runtime_manager;      // Manages the async runtime environment for executing generation tasks.

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::manager` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::manager::generator_manager::GeneratorManager;`
//   With re-export    → `use crate::manager::GeneratorManager;`

pub use config_validator::*;   // Re-export all items from config_validator (ConfigValidator, etc.).
pub use generator::*;          // Re-export Generator trait and related items.
pub use generator_manager::*;  // Re-export GeneratorManager and type aliases.
pub use runtime_manager::*;    // Re-export RuntimeManager and related utilities.

// --- END: rust/ssxl_generate/src\manager\mod.rs ---
        34 LOC | rust/ssxl_generate/src\manager\runtime_manager.rs
// --- START: rust/ssxl_generate/src\manager\runtime_manager.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Runtime: The Tokio runtime itself, which drives asynchronous tasks.
// Handle: A handle to the runtime, allowing spawning tasks without owning the runtime directly.
use tokio::runtime::{Runtime, Handle};

// Logging macro for structured runtime output.
// - info!: used to log initialization and shutdown events.
use tracing::info;

// num_cpus: Utility crate to query the number of CPU cores available.
// Used to configure the runtime with optimal worker threads.
use num_cpus;

// io: Standard library error type, used for returning initialization errors.
use std::io;

// -----------------------------------------------------------------------------
// Struct: RuntimeManager
// -----------------------------------------------------------------------------
// Wraps a Tokio runtime instance and manages its lifecycle.
// Provides methods for initialization, access, and graceful shutdown.
//
// Fields:
//   - runtime: Option<Runtime> to allow taking ownership during Drop.
//              Wrapping in Option makes it possible to "take" the runtime safely.
pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

// -----------------------------------------------------------------------------
// Implementation: RuntimeManager
// -----------------------------------------------------------------------------
impl RuntimeManager {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new multi-threaded Tokio runtime configured with the number of
    // available CPU cores. This ensures efficient parallelism.
    //
    // Steps:
    //   1. Query number of cores.
    //   2. Log initialization message.
    //   3. Build runtime with worker_threads = num_cores.
    //   4. Enable all Tokio features (I/O, time, etc.).
    //   5. Return RuntimeManager wrapping the runtime.
    //
    // Returns:
    //   - Ok(RuntimeManager) on success.
    //   - Err(io::Error) if runtime fails to build.
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?; // May return io::Error if initialization fails.

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    // -------------------------------------------------------------------------
    // Getter: get_handle
    // -------------------------------------------------------------------------
    // Provides a clone of the runtime handle.
    // This allows spawning tasks without owning the runtime itself.
    //
    // Panics:
    //   - If runtime is None (should not happen unless dropped prematurely).
    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    // -------------------------------------------------------------------------
    // Method: shutdown_graceful
    // -------------------------------------------------------------------------
    // Logs a graceful shutdown request.
    // Note: Actual shutdown is handled in Drop implementation.
    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

// -----------------------------------------------------------------------------
// Drop Implementation: RuntimeManager
// -----------------------------------------------------------------------------
// Ensures the runtime is properly shut down when RuntimeManager goes out of scope.
// This prevents dangling tasks and ensures resources are cleaned up.
//
// Steps:
//   1. Take ownership of runtime from Option (leaving None behind).
//   2. Log shutdown message.
//   3. Call shutdown_background() to stop runtime without blocking current thread.
impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped — shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}

// --- END: rust/ssxl_generate/src\manager\runtime_manager.rs ---
         2 LOC | rust/ssxl_generate/src\perlin\mod.rs
// --- START: rust/ssxl_generate/src\perlin\mod.rs ---
// -----------------------------------------------------------------------------
// Module: perlin (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `perlin` module.
// It organizes submodules related to Perlin noise generation and re-exports
// their contents for easier access.
//
// Think of this file as the "entry point" for all Perlin-related functionality
// in the SSXL engine.

// -----------------------------------------------------------------------------
// Submodule Declaration
// -----------------------------------------------------------------------------
// Declares the `perlin_generator` submodule.
// This file (perlin_generator.rs) contains the actual implementation of the
// Perlin noise generator, which conforms to the `Generator` trait.
pub mod perlin_generator;

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// Re-export all items from the `perlin_generator` submodule.
// This allows external code to import directly from `crate::perlin` instead of
// drilling down into `crate::perlin::perlin_generator`.
//
// Example:
//   Without re-export → `use crate::perlin::perlin_generator::PerlinGenerator;`
//   With re-export    → `use crate::perlin::PerlinGenerator;`
pub use perlin_generator::*;

// --- END: rust/ssxl_generate/src\perlin\mod.rs ---
        68 LOC | rust/ssxl_generate/src\perlin\perlin_generator.rs
// --- START: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Generator trait: contract that all procedural generators must implement.
use crate::Generator;

// Vec2i: 2D integer vector type used to represent chunk coordinates.
use ssxl_math::prelude::Vec2i;

// Core shared data structures for chunk/tile management.
// - ChunkData: container for all tiles in a chunk.
// - CHUNK_SIZE: constant defining the dimension of a chunk (e.g., 16x16).
// - GridBounds: defines the spatial bounds of a chunk in world coordinates.
// - TileData: represents a single tile, including type and metadata.
// - TileType: enum of possible tile categories (Water, Grass, Mountain, etc.).
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};

// Noise library: provides Perlin noise function implementation.
// NoiseFn: trait for noise functions.
// Perlin: concrete Perlin noise generator.
use noise::{NoiseFn, Perlin};

// Logging macro for structured runtime output.
use tracing::info;

// -----------------------------------------------------------------------------
// Struct: PerlinGenerator
// -----------------------------------------------------------------------------
// A generator that uses the Perlin noise algorithm to create deterministic terrain.
// Fields:
//   - perlin: Perlin noise object seeded for deterministic output.
//   - scale: scaling factor applied to coordinates before sampling noise.
//            Larger scale → smoother, larger features.
//            Smaller scale → more detail, finer features.
pub struct PerlinGenerator {
    perlin: Perlin,
    scale: f64,
}

// -----------------------------------------------------------------------------
// Implementation: PerlinGenerator
// -----------------------------------------------------------------------------
impl PerlinGenerator {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new PerlinGenerator instance with a given scale.
    // Arguments:
    //   - scale: frequency/scale of the noise (e.g., 64.0).
    // Notes:
    //   - DEFAULT_SEED is hardcoded to ensure deterministic, repeatable generation.
    pub fn new(scale: f64) -> Self {
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// -----------------------------------------------------------------------------
// Trait Implementation: Generator for PerlinGenerator
// -----------------------------------------------------------------------------
impl Generator for PerlinGenerator {
    // -------------------------------------------------------------------------
    // Method: id
    // -------------------------------------------------------------------------
    // Returns a unique identifier string for this generator.
    // Used by the Conductor and GeneratorManager to select this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    // -------------------------------------------------------------------------
    // Method: generate_chunk
    // -------------------------------------------------------------------------
    // Generates a single chunk of terrain using Perlin noise.
    //
    // Steps:
    //   1. Compute chunk size in tiles.
    //   2. Calculate world coordinates for chunk origin (bottom-left corner).
    //   3. Create a unique chunk ID by packing coordinates into a 64-bit integer.
    //   4. Define spatial bounds for the chunk.
    //   5. Initialize ChunkData container.
    //   6. Pre-allocate vector for all TileData entries.
    //   7. Iterate over each tile in the chunk:
    //        a. Compute world coordinates for tile.
    //        b. Sample Perlin noise at scaled coordinates.
    //        c. Normalize noise value from [-1, 1] → [0, 1].
    //        d. Threshold normalized value into a TileType (Water, Grass, Mountain).
    //        e. Create TileData with type + raw noise metadata.
    //        f. Push into tile vector.
    //   8. Insert generated tiles into ChunkData.
    //   9. Log completion message with chunk coordinates and tile count.
    //  10. Return fully populated ChunkData.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        // Step 1: chunk size in tiles.
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Step 2: world coordinates of chunk origin.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Step 3: unique chunk ID (pack x and y into u64).
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Step 4: define bounds of chunk in world coordinates.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        // Step 5: dimension name (for metadata).
        let dimension_name = "2D_Noise".to_string();

        // Step 6: initialize ChunkData.
        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Step 7: pre-allocate tile vector.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Step 7: iterate through all tiles in chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                // a. Compute world coordinates for tile.
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // b. Sample Perlin noise at scaled coordinates.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // c. Normalize noise value from [-1, 1] → [0, 1].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // d. Threshold normalized value into TileType.
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // e. Create TileData with type + noise metadata.
                let tile = TileData::new(tile_type, normalized_value as f32);

                // f. Push into tile vector.
                tiles.push(tile);
            }
        }

        // Step 8: insert generated tiles into ChunkData.
        chunk_data.insert_tiles(tiles);

        // Step 9: log completion message.
        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        // Step 10: return populated ChunkData.
        chunk_data
    }
}

// --- END: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
        53 LOC | rust/ssxl_generate/src\task\batch_processor.rs
// --- START: rust/ssxl_generate/src\task\batch_processor.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Handle: A reference to the Tokio runtime, used to spawn tasks.
// Sender: A bounded channel sender for sending progress messages back to the conductor.
use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;

// Logging macros for structured runtime output.
// - info!: used for normal progress and completion logs.
// - warn!: used for warnings (e.g., dropped messages).
use tracing::{info, warn};

// HashMap: used to store generator instances keyed by their unique string IDs.
// Arc: thread-safe reference-counted pointer for sharing data across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: integer 2D vector type for chunk coordinates.
// ChunkCache: cache for storing generated chunks to avoid redundant computation.
use ssxl_math::prelude::Vec2i;
use ssxl_cache::ChunkCache;

// GeneratorConfig: configuration for generator (map dimensions, seed, etc.).
use crate::manager::config_validator::GeneratorConfig;

// ConductorState: tracks conductor lifecycle state, queue depth, and active generator ID.
use crate::conductor::conductor_state::ConductorState;

// DynGenerator: type alias for dynamically dispatched generator trait objects.
// Allows storing multiple generator types in a uniform registry.
use crate::manager::generator_manager::DynGenerator;

// handle_chunk_unit: function that processes a single chunk request.
// GenerationMessage: enum representing messages sent back from generation tasks.
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};

// CHUNK_SIZE: constant defining the dimension of a chunk (e.g., 16x16 tiles).
use ssxl_shared::CHUNK_SIZE;

// -----------------------------------------------------------------------------
// Function: spawn_batch_generation_task
// -----------------------------------------------------------------------------
// Purpose:
//   - Spawns a blocking task that processes a full batch of chunks sequentially.
//   - Ensures stability with non-thread-safe generators/caches by running in a
//     dedicated thread.
//
// Arguments:
//   - runtime_handle: handle to the Tokio runtime for spawning tasks.
//   - generators_clone: cloned registry of available generators.
//   - chunk_cache_clone: cloned cache for storing/retrieving chunks.
//   - active_generator_id: ID of the generator to use for this batch.
//   - progress_sender_clone: channel sender for progress/completion messages.
//   - internal_state_clone: cloned conductor state for tracking queue depth.
//   - config_clone: generator configuration (map dimensions, seed, etc.).
//
// Behavior:
//   1. Logs the start of batch generation.
//   2. Spawns a blocking task on the runtime.
//   3. Increments queue depth to track active tasks.
//   4. Calculates how many chunks wide/tall the map will be.
//   5. Builds a list of all chunk coordinates.
//   6. Iterates sequentially over each chunk coordinate, generating data.
//   7. Sends a completion message when finished.
//   8. Decrements queue depth.
//   9. Logs completion.
pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<ChunkCache>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: Arc<ConductorState>,
    config_clone: GeneratorConfig,
) {
    // Step 1: Log start of batch generation.
    info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

    // Step 2: Spawn blocking task on runtime.
    runtime_handle.spawn_blocking(move || {
        // Step 3: Increment queue depth to track active task.
        internal_state_clone.increment_queue_depth();

        // Step 4: Calculate chunk dimensions in terms of tiles.
        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        // Ceiling division to calculate number of chunks in each dimension.
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        // Step 5: Build list of all chunk coordinates.
        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        // Handle edge case: empty map.
        if all_chunk_coords.is_empty() {
            info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
        }

        // Step 6: Sequentially process each chunk.
        let active_generator_id_ref = &active_generator_id;
        
        for &chunk_coords in all_chunk_coords.iter() {
            handle_chunk_unit(
                chunk_coords,
                active_generator_id_ref,
                &generators_clone,
                &chunk_cache_clone,
                &progress_sender_clone,
                &internal_state_clone,
            );
        }

        // Step 7: Send completion message.
        if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
            warn!("Batch completion signal dropped (Channel full).");
        }

        // Step 8: Decrement queue depth.
        internal_state_clone.decrement_queue_depth();

        // Step 9: Log completion.
        info!("Batch generation task finished processing command: {}", config_clone);
    });
}

// --- END: rust/ssxl_generate/src\task\batch_processor.rs ---
        21 LOC | rust/ssxl_generate/src\task\benchmark_logic.rs
// --- START: rust/ssxl_generate/src\task\benchmark_logic.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Logging macros for structured runtime output.
// - info!: used to log successful completion of workload.
// - warn!: used to log warnings or notable events at the start.
use tracing::{info, warn};

// Arc: thread-safe reference-counted pointer for sharing data across threads.
// AtomicU64: atomic 64-bit unsigned integer, used for concurrent progress tracking.
// Ordering: specifies memory ordering semantics for atomic operations.
//   - Relaxed: fastest ordering, no synchronization guarantees beyond atomicity.
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

// -----------------------------------------------------------------------------
// Function: benchmark_generation_workload
// -----------------------------------------------------------------------------
// Purpose:
//   - Simulates a heavy generation workload by iterating over a large number of tiles.
//   - Performs dummy computation to mimic tile processing.
//   - Reports progress periodically using a shared atomic counter.
//   - Logs start and completion messages.
//
// Arguments:
//   - workload_tiles: total number of tiles to simulate processing.
//   - processed_tiles_counter: shared atomic counter updated periodically to report progress.
//
// Behavior:
//   1. Logs start of workload.
//   2. Defines update interval (every 10 million tiles).
//   3. Iterates over all tiles, performing dummy computation.
//   4. Updates atomic counter at each interval.
//   5. Handles final remainder update.
//   6. Logs completion with final check value.
pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64>
) {
    // Step 1: Log start of workload.
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    // Step 2: Define update interval (every 10 million tiles).
    const UPDATE_INTERVAL: u64 = 10_000_000; 

    // Step 3: Initialize result accumulator.
    // This is a dummy computation used to simulate tile processing.
    let mut result: u64 = 0;
    
    // Step 4: Iterate over all tiles.
    for i in 0..workload_tiles {
        // Dummy computation: add (i % 17) to result.
        // Using wrapping_add to avoid overflow panics.
        result = result.wrapping_add(i % 17);
        
        // Step 5: Update atomic counter every UPDATE_INTERVAL tiles.
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    // Step 6: Handle final remainder update.
    // If workload_tiles is not a multiple of UPDATE_INTERVAL,
    // add the remaining count to the atomic counter.
    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    // Step 7: Log completion with final check value.
    // The result value is a checksum-like number from dummy computation.
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}

// --- END: rust/ssxl_generate/src\task\benchmark_logic.rs ---
         6 LOC | rust/ssxl_generate/src\task\mod.rs
// --- START: rust/ssxl_generate/src\task\mod.rs ---
// -----------------------------------------------------------------------------
// Module: task (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `task` module.
// It organizes all task-related functionality in the SSXL engine, including:
//   - Batch processing of chunks
//   - Benchmarking logic for performance testing
//   - Task queue management for async/sync chunk generation
//
// Think of this file as the "table of contents" for the task system.

// -----------------------------------------------------------------------------
// Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the task system.
// These submodules are implemented in their own files (e.g., batch_processor.rs,
// benchmark_logic.rs, task_queue.rs).

pub mod batch_processor;   // Handles sequential batch generation of chunks.
pub mod benchmark_logic;   // Provides benchmarking utilities for workload simulation.
pub mod task_queue;        // Manages the queue of chunk generation tasks (async + sync).

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// These `pub use` statements re-export selected items from submodules.
// This simplifies the public API: external code can import directly from
// `crate::task` instead of drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::task::task_queue::handle_chunk_unit;`
//   With re-export    → `use crate::task::handle_chunk_unit;`

pub use batch_processor::*;   // Re-export all items from batch_processor.
pub use benchmark_logic::*;   // Re-export all items from benchmark_logic.
pub use task_queue::*;        // Re-export all items from task_queue.

// --- END: rust/ssxl_generate/src\task\mod.rs ---
        97 LOC | rust/ssxl_generate/src\task\task_queue.rs
// --- START: rust/ssxl_generate/src\task\task_queue.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Handle: a reference to the Tokio runtime, used to spawn async tasks.
// mpsc: multi-producer, single-consumer channels for communication between tasks.
// JoinHandle: handle returned by spawned tasks, used to await their completion.
use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;

// Logging macros for structured runtime output.
// - info!: general lifecycle events.
// - error!: critical failures (e.g., cache save failure, task panic).
// - warn!: warnings (e.g., channel full, conductor inactive).
// - debug!: detailed diagnostic information (cache hits/misses).
use tracing::{info, error, warn, debug};

// HashMap: registry of generators keyed by ID.
// Arc: thread-safe reference-counted pointer for sharing across threads.
use std::collections::HashMap;
use std::sync::Arc;

// Vec2i: 2D integer vector type for chunk coordinates.
// ChunkKey: unique identifier for a chunk in coordinate system.
// I64Vec3: 3D integer vector type (used here with z=0 for 2D chunks).
use ssxl_math::prelude::Vec2i;
use ssxl_math::coordinate_system::ChunkKey;
use glam::I64Vec3;

// ChunkCache: cache for storing/retrieving generated chunks.
use ssxl_cache::ChunkCache;

// CHUNK_SIZE constant imported from shared crate, aliased for clarity.
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE;

// Generator trait: contract for all procedural generators.
// conductor_state: tracks conductor lifecycle, tile counts, and active status.
use crate::Generator;
use crate::conductor::conductor_state;

// Re-export message types for generation tasks and results.
// GenerationMessage: enum for messages (Generated, Complete, etc.).
// GenerationTask: struct representing a chunk generation request.
pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask};

// -----------------------------------------------------------------------------
// Type Aliases and Constants
// -----------------------------------------------------------------------------
// DynGenerator: dynamically dispatched Generator trait object, Send + Sync for concurrency.
type DynGenerator = Box<dyn Generator + Send + Sync>;

// CHUNK_SIZE: local constant as i64, derived from shared crate constant.
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;

// -----------------------------------------------------------------------------
// Function: handle_chunk_unit
// -----------------------------------------------------------------------------
// Purpose:
//   - Handles a single chunk request end-to-end.
//   - Steps: cache check → generate if needed → save to cache → send result.
//
// Arguments:
//   - chunk_coords: coordinates of the chunk to process.
//   - generator_name: ID of the generator to use.
//   - generators: registry of available generators.
//   - chunk_cache: shared cache for storing/retrieving chunks.
//   - progress_sender: channel sender for reporting progress/results.
//   - conductor_state: shared conductor state for tracking tile counts.
//
// Behavior:
//   1. Build a ChunkKey from coordinates.
//   2. Check cache for existing chunk.
//   3. If cache hit → send cached chunk.
//   4. If cache miss → generate new chunk.
//   5. Save generated chunk to cache.
//   6. Send generated chunk via progress channel.
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
    conductor_state: &Arc<conductor_state::ConductorState>,
) {
    // Step 1: Build unique chunk key.
    let chunk_key = ChunkKey(I64Vec3 {
        x: chunk_coords.x,
        y: chunk_coords.y,
        z: 0,
    });

    // Step 2: Cache HIT.
    if let Some(chunk_data_arc) = chunk_cache.load_chunk(&chunk_key) {
        debug!(?chunk_coords, "Cache HIT");

        let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
        if progress_sender.try_send(msg).is_err() {
            warn!(?chunk_coords, "Failed to send cached chunk (channel full/closed)");
        }
        return;
    }

    // Step 3: Cache MISS → generate.
    debug!(?chunk_coords, generator = %generator_name, "Cache MISS → generating");

    let generator = generators
        .get(generator_name)
        .expect("Generator must exist in map");

    // Generate new chunk data.
    let chunk_data = generator.generate_chunk(chunk_coords);

    // Update conductor state with tile count.
    let tile_count = chunk_data.tiles.len() as u64;
    conductor_state.increment_tile_count(tile_count);

    // Wrap chunk data in Arc for safe sharing.
    let chunk_data_arc = Arc::new(chunk_data);

    // Step 4: Save to cache.
    if chunk_cache.save_chunk(&chunk_key, chunk_data_arc.clone()).is_err() {
        error!(?chunk_coords, "Failed to save generated chunk to cache");
    }

    // Step 5: Send result.
    let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
    if progress_sender.try_send(msg).is_err() {
        warn!(?chunk_coords, "Failed to send generated chunk (channel full/closed)");
    } else {
        debug!(?chunk_coords, "Sent newly generated chunk");
    }
}

// -----------------------------------------------------------------------------
// Function: start_request_loop
// -----------------------------------------------------------------------------
// Purpose:
//   - Main async loop for processing incoming generation tasks.
//   - Receives tasks from channel → spawns blocking generation jobs → tracks active tasks.
//
// Arguments:
//   - rt_handle: runtime handle for spawning async tasks.
//   - request_rx: channel receiver for incoming GenerationTask requests.
//   - progress_tx: channel sender for reporting progress/results.
//   - generators: registry of available generators.
//   - chunk_cache: shared cache for storing/retrieving chunks.
//   - conductor_state: shared conductor state for lifecycle tracking.
//
// Behavior:
//   1. Spawn async loop on runtime.
//   2. Log start of task queue.
//   3. Maintain list of active tasks.
//   4. For each incoming task:
//        a. Check conductor active state.
//        b. Clone necessary resources.
//        c. Spawn blocking task to handle chunk.
//        d. Track task handle.
//   5. When channel closes, drain all active tasks.
//   6. Send GenerationComplete message.
//   7. Log clean shutdown.
pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<conductor_state::ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue started");

        // Track active blocking tasks.
        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();

        // Step 4: Process incoming tasks.
        while let Some(task) = request_rx.recv().await {
            // a. Check conductor active state.
            if !conductor_state.as_ref().is_active() {
                warn!(?task.chunk_coords, "Dropping task — Conductor not active");
                continue;
            }

            // b. Clone resources for task.
            let progress_tx = progress_tx.clone();
            let generators = generators.clone();
            let cache = chunk_cache.clone();
            let state = conductor_state.clone();

            // c. Spawn blocking task to handle chunk.
            let handle = tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators,
                    &cache,
                    &progress_tx,
                    &state,
                );
            });

            // d. Track task handle.
            active_tasks.push(handle);
        }

        // Step 5: Channel closed → drain tasks.
        info!("Request channel closed. Draining {} active tasks...", active_tasks.len());

        for handle in active_tasks {
            if let Err(e) = handle.await {
                error!("Generation task panicked: {:?}", e);
            }
        }

        // Step 6: Send completion message.
        let _ = progress_tx.send(GenerationMessage::GenerationComplete).await;

        // Step 7: Log clean shutdown.
        info!("Generation Task Queue shut down cleanly");
    });
}

// --- END: rust/ssxl_generate/src\task\task_queue.rs ---
        19 LOC | rust/ssxl_godot/src\anim\animation_api.rs
// --- START: rust/ssxl_godot/src\anim\animation_api.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Arc + Mutex: Used for thread-safe, shared ownership of the Conductor instance.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures safe, exclusive access to the Conductor when multiple threads interact.
//
// tracing macros:
//   - info!: for general lifecycle logs.
//   - error!: for critical failures.
//   - warn!: for warnings or unusual states.
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: a specialized handle for managing animation conductor state,
// typically used for coordinating animation-related tasks across threads.
use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

// -----------------------------------------------------------------------------
// Struct: AnimationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides an abstraction layer for animation-related orchestration.
//   - Holds references to conductor handles so the Rust FFI layer can manage
//     lifecycle and internal communication.
//
// Attributes:
//   - animation_conductor: optional reference to an AnimationConductorHandle.
//       * This is used to drive animation-specific orchestration.
//       * Stored as Option<&> to allow absence (None) when not needed.
//   - _conductor: optional reference to the core Conductor wrapped in Arc<Mutex>.
//       * Arc ensures shared ownership across threads.
//       * Mutex ensures safe concurrent access.
//       * Leading underscore (_) indicates this field may be unused directly,
//         but is retained for lifecycle management or future internal use.
#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// -----------------------------------------------------------------------------
// Implementation: AnimationAPI
// -----------------------------------------------------------------------------
// Provides constructor and potential extension points for animation orchestration.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Creates a new AnimationAPI instance with optional references to
    //     animation conductor and core conductor.
    //
    // Arguments:
    //   - animation_conductor: optional reference to AnimationConductorHandle.
    //   - conductor: optional reference to Arc<Mutex<Conductor>>.
    //
    // Returns:
    //   - AnimationAPI instance with provided references stored.
    //
    // Notes:
    //   - Both arguments are optional, allowing flexible initialization depending
    //     on whether animation or conductor orchestration is required.
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}

// --- END: rust/ssxl_godot/src\anim\animation_api.rs ---
        30 LOC | rust/ssxl_godot/src\engine\api.rs
// --- START: rust/ssxl_godot/src\engine\api.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary: Godot's built-in key-value container type, used here for returning
//             structured data back to the Godot engine in a format it understands.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Arc + Mutex: concurrency primitives for safe, shared ownership of the Conductor.
//   - Arc: atomic reference-counted pointer for sharing across threads.
//   - Mutex: ensures exclusive access to Conductor when multiple threads interact.
use std::sync::{Arc, Mutex};

// Conductor: the central orchestrator of generation tasks and runtime lifecycle.
// AnimationConductorHandle: specialized handle for animation conductor state,
// used to send animation-related commands across threads.
use ssxl_generate::Conductor;
use ssxl_shared::AnimationConductorHandle;

// GenesisHandles: struct returned by initialization routines, containing
// references to conductor, channels, and other setup artifacts.
// execute_channel_and_state_setup: function that sets up communication channels
// and conductor state during initialization.
use crate::engine::api_initializers::{execute_channel_and_state_setup, GenesisHandles};

// -----------------------------------------------------------------------------
// Struct: EngineInitializer
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a clean API for initializing the SSXL engine inside Godot.
//   - Encapsulates setup routines for channels, conductor state, and spawning
//     the conductor runtime.
//
// Notes:
//   - #[derive(Default)] allows creating an empty EngineInitializer with default values.
//   - This struct acts as a "bootstrapper" for the engine.
#[derive(Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Returns a new EngineInitializer instance.
    // Uses Default trait to simplify instantiation.
    pub fn new() -> Self { Self::default() }

    // -------------------------------------------------------------------------
    // Method: execute_channel_and_state_setup
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes communication channels and conductor state.
    //   - Delegates to the api_initializers module for actual setup logic.
    //
    // Arguments:
    //   - config_path: optional path to configuration file.
    //
    // Returns:
    //   - GenesisHandles: contains conductor, channels, and setup artifacts.
    //   - Box<dyn Error>: wraps any error that occurs during setup.
    pub fn execute_channel_and_state_setup(
        &self,
        config_path: Option<&str>,
    ) -> Result<GenesisHandles, Box<dyn Error>> {
        execute_channel_and_state_setup(config_path)
    }

    // -------------------------------------------------------------------------
    // Method: execute_conductor_setup_and_spawn
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Wraps the Conductor instance in Arc<Mutex> for safe sharing across threads.
    //   - Extracts and clones the AnimationConductorHandle for animation orchestration.
    //
    // Arguments:
    //   - handles: GenesisHandles containing conductor and channels.
    //
    // Returns:
    //   - Tuple:
    //       * Option<Arc<Mutex<Conductor>>>: shared, thread-safe conductor instance.
    //       * AnimationConductorHandle: handle for animation commands.
    pub fn execute_conductor_setup_and_spawn(
        &self,
        handles: GenesisHandles,
    ) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        let conductor_arc = Arc::new(Mutex::new(handles._gen_conductor));
        let anim_handle: AnimationConductorHandle = handles.anim_command_tx.clone();
        (Some(conductor_arc), anim_handle)
    }
}

// -----------------------------------------------------------------------------
// Struct: GenerationAPI
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing API for chunk data retrieval.
//   - Intended to be called from Godot scripts to fetch chunk data.
//   - Currently a stub implementation returning an empty Dictionary.
//
// Notes:
//   - #[derive(Default)] allows creating an empty GenerationAPI easily.
//   - MUST BE PUBLIC: ensures Godot can access this struct via FFI.
#[derive(Default)]
pub struct GenerationAPI {}

impl GenerationAPI {
    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Fetches chunk data for given coordinates (x, y).
    //   - Currently returns an empty Dictionary as a placeholder.
    //
    // Arguments:
    //   - _x, _y: chunk coordinates (unused in stub).
    //
    // Returns:
    //   - Dictionary: Godot-compatible container for chunk data.
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }
}

// --- END: rust/ssxl_godot/src\engine\api.rs ---
        64 LOC | rust/ssxl_godot/src\engine\api_initializers\mod.rs
// --- START: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------

// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Used for asynchronous communication between engine components.
//   - Provides unbounded channels for commands, responses, and updates.
use tokio::sync::mpsc;

// get_config_from_path
//   - Loads engine configuration from a file path.
//   - Provides runtime parameters for conductor initialization.
use ssxl_shared::config::config::get_config_from_path;

// Conductor + ConductorProgressReceiver + ConductorState
//   - Conductor: orchestrates generation tasks (terrain, chunks).
//   - ConductorProgressReceiver: receives progress updates from the conductor.
//   - ConductorState: snapshot of conductor’s current status.
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    conductor::ConductorState,
};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Message types
//   - AnimationCommand: commands for animation conductor.
//   - AnimationState: snapshot of animation conductor’s state.
//   - GenerationCommand: commands for generation conductor.
//   - GenerationResponse: responses from generation conductor.
//   - AnimationUpdate: updates from animation conductor.
use ssxl_shared::message::{
    AnimationCommand,
    AnimationState,
    GenerationCommand,
    GenerationResponse,
    AnimationUpdate,
};

// Error trait
//   - Used for returning boxed errors in Result types.
use std::error::Error;

// info!
//   - Logging macro for informational messages.
use tracing::info;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// These aliases simplify channel type signatures for readability.
pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;
pub type GenerationCommandTx = mpsc::UnboundedSender<GenerationCommand>;
pub type GenerationResponseRx = mpsc::UnboundedReceiver<GenerationResponse>;

// -----------------------------------------------------------------------------
// Struct: GenesisHandles
// -----------------------------------------------------------------------------
// Purpose:
//   - Bundles all handles, channels, and state objects created during initialization.
//   - Acts as the "genesis kit" for wiring the engine together.
//
// Fields:
//   - gen_state: snapshot of conductor state.
//   - anim_state: snapshot of animation state.
//   - gen_progress_rx: receiver for generation progress updates.
//   - anim_update_rx: receiver for animation updates.
//   - anim_command_tx: sender for animation commands.
//   - gen_command_tx: sender for generation commands.
//   - gen_response_rx: receiver for generation responses.
//   - _gen_conductor: internal conductor instance (not exposed).
//   - _anim_rx: internal receiver for animation commands.
//   - _anim_update_tx: internal sender for animation updates.
//   - _gen_resp_tx: internal sender for generation responses.
pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    pub gen_command_tx: GenerationCommandTx,
    pub gen_response_rx: GenerationResponseRx,
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>,
    pub(crate) _gen_resp_tx: mpsc::UnboundedSender<GenerationResponse>,
}

// -----------------------------------------------------------------------------
// Function: execute_channel_and_state_setup
// -----------------------------------------------------------------------------
// Purpose:
//   - Initializes all channels and state objects required for the engine.
//   - Returns a GenesisHandles struct bundling everything together.
//
// Arguments:
//   - config_path: optional path to configuration file.
//
// Steps:
//   1. Load configuration from path.
//   2. Create generation command + response channels.
//   3. Initialize conductor via Conductor::new_for_ffi.
//   4. Create animation command + update channels.
//   5. Initialize animation state.
//   6. Log successful initialization.
//   7. Return GenesisHandles with all handles and channels wired.
pub fn execute_channel_and_state_setup(
    config_path: Option<&str>,
) -> Result<GenesisHandles, Box<dyn Error>> {
    // Step 1: Load configuration.
    let _config = get_config_from_path(config_path);

    // Step 2: Create generation channels.
    let (gen_command_tx, _gen_cmd_rx) = mpsc::unbounded_channel::<GenerationCommand>();
    let (_gen_resp_tx, gen_response_rx) = mpsc::unbounded_channel::<GenerationResponse>();

    // Step 3: Initialize conductor.
    let (
        gen_conductor,
        gen_state,
        _internal_gen_cmd_tx,
        _internal_gen_resp_rx,
        gen_progress_rx_inner,
    ) = Conductor::new_for_ffi(config_path)?;

    // Step 4: Create animation channels.
    let (anim_command_tx_inner, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
    let (anim_update_tx, anim_update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();

    // Step 5: Initialize animation state.
    let anim_state = AnimationState::default();

    // Step 6: Log success.
    info!("Genesis engine initialized: Conductor + Animation systems ready.");

    // Step 7: Return GenesisHandles.
    Ok(GenesisHandles {
        gen_state,
        anim_state,
        gen_progress_rx: ConductorProgressReceiver::new(gen_progress_rx_inner),
        anim_update_rx,
        anim_command_tx: anim_command_tx_inner,

        gen_command_tx,
        gen_response_rx,
        _gen_conductor: gen_conductor,
        _anim_rx: anim_rx,
        _anim_update_tx: anim_update_tx,
        _gen_resp_tx,
    })
}

// --- END: rust/ssxl_godot/src\engine\api_initializers\mod.rs ---
        21 LOC | rust/ssxl_godot/src\engine\cleanup.rs
// --- START: rust/ssxl_godot/src\engine\cleanup.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), which is used as the return type.
//
// Arc
//   - Thread-safe reference-counted pointer for shared ownership.
//   - Used here to manage the Conductor instance across multiple threads.
use godot::prelude::*;
use std::sync::Arc;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module;
use state_module::{SSXLEngine, state};

// -----------------------------------------------------------------------------
// Function: shutdown_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a public-facing function for Godot to explicitly shut down the
//     SSXL engine, releasing all resources and background threads.
//   - Ensures the Conductor and related subsystems are gracefully torn down.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine, the core engine state.
//
// Returns:
//   - GString: a Godot-compatible string message confirming shutdown.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, attempt to unwrap and shut it down gracefully.
//   3. Clear other subsystems (conductor_state, animation_conductor, animation_state).
//   4. Clear Godot node references (signals_node, tilemap_node).
//   5. Return a confirmation message.
pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    // Step 1: Access internal state of SSXLEngine.
    let state = state!(engine);
    
    // Step 2: Gracefully shut down the Conductor if present.
    if let Some(conductor_arc) = state.conductor.take() {
        // Arc::try_unwrap attempts to consume the Arc if it is uniquely owned.
        //   - .ok(): discards error if Arc is not unique.
        //   - .and_then(|m| m.into_inner().ok()): consumes Mutex, discards poisoning errors.
        // Result: Option<Conductor> if successful.
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok()
            .and_then(|m| m.into_inner().ok())
        {
            // Call graceful_teardown on the owned Conductor instance.
            conductor.graceful_teardown();
        }
        // If Arc is not unique or Mutex is poisoned, shutdown is skipped.
    }
    
    // Step 3: Clear other subsystems.
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    // Step 4: Clear Godot node references.
    state.signals_node.take();
    state.tilemap_node.take();

    // Step 5: Return confirmation message as GString.
    "SSXLEngine resources shut down and released.".into()
}

// --- END: rust/ssxl_godot/src\engine\cleanup.rs ---
        26 LOC | rust/ssxl_godot/src\engine\commands.rs
// --- START: rust/ssxl_godot/src\engine\commands.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot's string type), used for passing strings between Rust and Godot.
use godot::prelude::*;

// AnimationCommand
//   - Enum representing commands sent to the animation conductor.
//   - Examples: enabling/disabling animations, updating flow fields, particle systems, etc.
use ssxl_shared::AnimationCommand;

// -----------------------------------------------------------------------------
// State Module Imports
// -----------------------------------------------------------------------------
// The engine::state module holds the SSXLEngine struct and the `state!` macro.
// - SSXLEngine: represents the engine state exposed to Godot.
// - state!: macro for safely accessing the internal state of SSXLEngine.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: stop_generation_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Gracefully stops the current generation process.
//   - Intended to be called from Godot when the user requests a halt in terrain generation.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call stop_generation() on the Conductor.
//   4. Ignore errors silently (e.g., if lock acquisition fails).
pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

// -----------------------------------------------------------------------------
// Function: set_animation_enabled_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Toggles the low-latency animation conductor (flow fields, particle systems, etc.).
//   - Allows enabling or disabling animations dynamically during gameplay.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If an animation conductor channel exists, send a SetEnabled command.
//   3. The command is sent asynchronously to the animation conductor.
//   4. Ignore errors silently (e.g., if channel is full or closed).
pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

// -----------------------------------------------------------------------------
// Function: set_generator_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Changes the active generator mid-session.
//   - Useful for dynamic biome switching or runtime experimentation with different terrain algorithms.
//
// Steps:
//   1. Access the engine's internal state via the `state!` macro.
//   2. If a Conductor exists, acquire its lock (Arc<Mutex<Conductor>>).
//   3. Call set_generator() on the Conductor, passing the new generator name.
//   4. Convert Godot's GString into a Rust String before passing.
//   5. Ignore errors silently (e.g., if lock acquisition fails).
pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            let _ = c.set_generator(&name.to_string());
        }
    }
}

// --- END: rust/ssxl_godot/src\engine\commands.rs ---
        83 LOC | rust/ssxl_godot/src\engine\init.rs
// --- START: rust/ssxl_godot/src\engine\init.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<Node>, GString, Dictionary, etc., which are used to bridge
//     between Rust and Godot’s scripting layer.
use godot::prelude::*;

// UnboundedSender: asynchronous channel sender from Tokio used for communication
// between threads without backpressure (unbounded queue).
use tokio::sync::mpsc::UnboundedSender;

// Node: Godot scene graph node type, used here for signals integration.
use godot::classes::Node;

// Dictionary: Godot’s built-in key-value container, used for returning structured
// data back to Godot scripts.
use godot::builtin::Dictionary;

// Error: trait for error handling, used to wrap errors in Result types.
use std::error::Error;

// Logging macros for structured runtime output.
// - info!: lifecycle events.
// - error!: critical failures.
use tracing::{info, error};

// Internal Godot FFI glue for SSXLEngine functions.
use crate::engine::__godot_SSXLEngine_Funcs;

// SSXLEngine: the core engine state struct exposed to Godot.
use super::state::SSXLEngine;

// Tick processor: updates engine state each frame.
use crate::engine::tick::process_engine_tick;

// Commands: side-effect functions for stopping generation, toggling animation,
// and switching generators.
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};

// Query functions: read-only accessors for engine state (tile count, status, active generator).
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};

// Cleanup logic: graceful shutdown of engine resources.
use crate::engine::cleanup::shutdown_logic;

// AnimationConductorHandle: handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// AnimationCommand: enum representing animation-related commands (enable/disable, etc.).
use ssxl_shared::message::AnimationCommand;

// -----------------------------------------------------------------------------
// Godot API Implementation: SSXLEngine
// -----------------------------------------------------------------------------
// This block exposes SSXLEngine methods to Godot via #[godot_api] and #[func] attributes.
// Each method can be called directly from Godot scripts.
#[godot_api]
impl SSXLEngine {

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Initializes the entire SSXL runtime, including conductor, worker threads,
    //     and communication channels.
    //   - Logs success or failure and returns a boolean to Godot.
    #[func]
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                self.shutdown();
                false
            }
        }
    }

    // -------------------------------------------------------------------------
    // Method: initialize_runtime_shell_logic (private)
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Core initialization logic separated from public API.
    //   - Sets up channels, conductor threads, and wires handles into internal state.
    //
    // Steps:
    //   1. Initialize channels and core state objects.
    //   2. Clone animation command sender and store it.
    //   3. Spawn conductor threads via initializer.
    //   4. Wire conductor, signals node, and animation handles into internal state.
    //   5. Log successful wiring.
    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        let internal_state = unsafe { &mut *self._internal_state.get() };

        // Step 1: Initialize channels and core state.
        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // Step 2: Clone animation command sender.
        let inner_sender_clone: UnboundedSender<AnimationCommand> = handles.anim_command_tx.clone();
        let anim_command_tx_for_internal_state: AnimationConductorHandle = inner_sender_clone;

        // Step 3: Spawn conductor threads.
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        // Step 4: Wire handles into internal state.
        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);

        // Step 5: Log success.
        info!("SSXL Channels successfully wired to AsyncPoller.");

        Ok(())
    }

    // -------------------------------------------------------------------------
    // Method: shutdown
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Triggers graceful shutdown of SSXL runtime.
    //   - Delegates to cleanup::shutdown_logic.
    #[func]
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: build_map
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Starts a new generation run using provided configuration.
    //   - Currently stubbed to always return true.
    #[func]
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        true
    }

    // -------------------------------------------------------------------------
    // Method: stop_generation
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Stops any current generation/animation process gracefully.
    //   - Delegates to commands::stop_generation_logic.
    #[func]
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_enabled
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Enables or disables tile animation updates.
    //   - Delegates to commands::set_animation_enabled_logic.
    #[func]
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    // -------------------------------------------------------------------------
    // Method: set_generator
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Changes active generator mid-session (dynamic biome switching).
    //   - Delegates to commands::set_generator_logic.
    #[func]
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns total number of tiles generated so far.
    //   - Delegates to query::get_current_tile_count_logic.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_status
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns human-readable engine status string.
    //   - Delegates to query::get_status_logic.
    #[func]
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: get_active_generator_id
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Returns the name of the currently active generator.
    //   - Delegates to query::get_active_generator_id_logic.
    #[func]
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    // -------------------------------------------------------------------------
    // Method: fetch_chunk_data
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Provides Godot with read-only access to specific chunk data.
    //   - Currently stubbed to return an empty Dictionary.
    #[func]
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }

    // -------------------------------------------------------------------------
    // Method: process_engine_tick
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Must be called every frame to update engine state and process async messages.
    //   - Increments tick counter and delegates to tick::process_engine_tick.
    #[func]
    pub fn process_engine_tick(&mut self) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}

// --- END: rust/ssxl_godot/src\engine\init.rs ---
        18 LOC | rust/ssxl_godot/src\engine\mod.rs
// --- START: rust/ssxl_godot/src\engine\mod.rs ---
// -----------------------------------------------------------------------------
// Module: engine (root)
// -----------------------------------------------------------------------------
// This `mod.rs` file defines the structure of the `engine` module in the SSXL Godot integration.
// It acts as the central hub, organizing all submodules and re-exporting key items
// so that external code can access them easily.
//
// Think of this file as the "table of contents" for the engine layer.

// -----------------------------------------------------------------------------
// Macro Import
// -----------------------------------------------------------------------------
// #[macro_use] ensures that macros defined in the `state` module (such as `state!`)
// are available throughout the entire `engine` module without needing explicit imports.
// This is critical because the `state!` macro is used in multiple files (commands.rs, init.rs, etc.).
#[macro_use] 
pub mod state;

// -----------------------------------------------------------------------------
// Submodule Declarations
// -----------------------------------------------------------------------------
// Each `pub mod` declaration exposes a submodule of the engine system.
// These submodules are implemented in their own files and encapsulate specific concerns:
//
// - init.rs: Runtime initialization logic (channels, conductor setup, etc.).
// - api.rs: Public-facing API for Godot to interact with the engine.
// - tick.rs: Game loop integration, processes engine state each frame.
// - commands.rs: Lightweight runtime commands (stop generation, toggle animation, switch generator).
// - query.rs: Read-only queries for engine state (tile count, status, active generator).
// - cleanup.rs: Graceful shutdown and resource release logic.
// - render_batch.rs: Rendering-related batch operations (integration with Godot visuals).
// - query_data.rs: Data access layer for chunk/tile queries.
// - api_initializers.rs: Helper functions for setting up channels and conductor state.
pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
pub mod api_initializers; 

// -----------------------------------------------------------------------------
// Re-exports: Submodules
// -----------------------------------------------------------------------------
// These `pub use` statements re-export all items from the submodules.
// This flattens the API so external code can import directly from `engine`
// without drilling down into submodules.
//
// Example:
//   Without re-export → `use crate::engine::commands::stop_generation_logic;`
//   With re-export    → `use crate::engine::stop_generation_logic;`
pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

// -----------------------------------------------------------------------------
// Re-export: SSXLEngine
// -----------------------------------------------------------------------------
// SSXLEngine is the Godot-exposed class representing the engine state.
// By re-exporting it here, external crates (like lib.rs) only need a single line
// to access the Godot class, rather than importing from deep inside the module.
//
// This makes the engine’s public API clean and ergonomic.
pub use state::SSXLEngine;

// --- END: rust/ssxl_godot/src\engine\mod.rs ---
        60 LOC | rust/ssxl_godot/src\engine\poller.rs
// --- START: rust/ssxl_godot/src\engine\poller.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// TokioReceiver: alias for tokio::sync::mpsc::Receiver, used to receive messages
// from asynchronous channels. This is the non-blocking receiver side of a channel.
use tokio::sync::mpsc::Receiver as TokioReceiver;

// GenerationMessage: enum representing messages from the generation system.
// These include progress updates, completed chunks, or completion signals.
use ssxl_generate::task_queue::GenerationMessage; 

// AnimationUpdate: struct representing lightweight, high-frequency animation updates.
// These are sent from the animation conductor to update flow fields, particles, etc.
use ssxl_shared::message::messages::AnimationUpdate; 

// VecDeque: double-ended queue, efficient for pushing/popping at both ends.
// Used here to collect batches of messages during polling.
use std::collections::VecDeque;

// warn!: logging macro for warnings, used when channels disconnect unexpectedly.
use tracing::warn; 

// TryRecvError: error type returned by try_recv() when a channel is empty or disconnected.
use tokio::sync::mpsc::error::TryRecvError;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Central struct responsible for non-blocking draining of asynchronous results.
//   - Holds two distinct channel receivers:
//       * gen_rx: for heavy generation results (chunks, progress).
//       * anim_rx: for lightweight animation updates.
//
// Notes:
//   - Both receivers are optional (Option<T>), allowing flexible initialization.
//   - If a channel disconnects, the Option is set to None to mark it permanently unavailable.
pub struct AsyncPoller {
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default AsyncPoller with no channels set.
// Useful for initializing before wiring channels in init.rs.
impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides setup methods (for wiring channels) and polling methods (for draining messages).
impl AsyncPoller {
    // -------------------------------------------------------------------------
    // Method: set_generation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for generation messages.
    //   - Called during initialization when channels are created.
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: set_animation_receiver
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Assigns the receiver for animation updates.
    //   - Called during initialization when channels are created.
    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    // -------------------------------------------------------------------------
    // Method: poll_generation_messages
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available generation messages from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If gen_rx exists, loop until channel is empty or disconnected.
    //   3. Push messages into VecDeque.
    //   4. If disconnected, log warning and set gen_rx to None.
    //   5. Return collected messages.
    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        if let Some(rx) = &mut self.gen_rx {
            loop {
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None;
                        break;
                    }
                }
            }
        }
        messages
    }

    // -------------------------------------------------------------------------
    // Method: poll_animations
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Drains ALL available animation updates from the channel instantly.
    //   - Uses a non-blocking loop with try_recv().
    //
    // Behavior:
    //   1. Initialize empty VecDeque.
    //   2. If anim_rx exists, loop until channel is empty or disconnected.
    //   3. Push updates into VecDeque.
    //   4. If disconnected, log warning and set anim_rx to None.
    //   5. Return collected updates.
    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None;
                        break;
                    }
                }
            }
        }
        updates
    }
}

// --- END: rust/ssxl_godot/src\engine\poller.rs ---
        24 LOC | rust/ssxl_godot/src\engine\query.rs
// --- START: rust/ssxl_godot/src\engine\query.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes GString (Godot’s string type), used for returning strings
//     back to Godot scripts in a compatible format.
use godot::prelude::*;

// StatusReporter
//   - Utility module responsible for producing human-readable status reports
//     and tile count summaries.
//   - Encapsulates logic for interpreting conductor and animation state.
use crate::tilemap::status_reporter::StatusReporter;

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: get_current_tile_count_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the total number of tiles generated so far across all chunks.
//   - Provides a read-only query with no side effects.
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call StatusReporter::get_current_tile_count_value, passing a reference
//      to the conductor_state.
//   3. Return the tile count as u64.
pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

// -----------------------------------------------------------------------------
// Function: get_status_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns a human-readable engine status string.
//   - Example: "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call StatusReporter::get_status_report, passing references to
//      conductor_state and animation_state.
//   3. Return the resulting GString.
pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

// -----------------------------------------------------------------------------
// Function: get_active_generator_id_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Returns the name of the currently active generator.
//   - Examples: "perlin", "cellular", "simplex", "custom_my_gen"
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Check if a conductor exists (Option<Arc<Mutex<Conductor>>>).
//   3. If None → return "Not Initialized".
//   4. If Some → attempt to acquire lock on conductor.
//   5. On success → call get_active_generator_id() and convert to GString.
//   6. On failure (mutex poisoned) → return "Mutex Poisoned".
pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}

// --- END: rust/ssxl_godot/src\engine\query.rs ---
         6 LOC | rust/ssxl_godot/src\engine\query_data.rs
// --- START: rust/ssxl_godot/src\engine\query_data.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Dictionary
//   - Godot’s built-in key-value container type.
//   - Used here to return structured chunk data back to Godot in a format
//     that Godot scripts can easily consume.
use godot::builtin::Dictionary; 

// State module imports
//   - SSXLEngine: the core engine struct exposed to Godot.
//   - state!: macro for safely accessing the internal state of SSXLEngine.
//     This macro expands to code that dereferences the internal state pointer
//     and provides scoped access to its fields.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// -----------------------------------------------------------------------------
// Function: fetch_chunk_data_logic
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides the external Godot layer with read-only access to specific chunk data.
//   - Acts as a query function: no mutation, no side effects, just data retrieval.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine (needed because the macro dereferences
//     internal state, even though this function itself does not mutate).
//   - x, y: integer coordinates of the chunk being requested.
//
// Returns:
//   - Dictionary: a Godot-compatible container holding the chunk’s data.
//     The actual contents depend on the implementation of generation_api.
//
// Steps:
//   1. Use the `state!` macro to access the engine’s internal state.
//   2. Call generation_api.fetch_chunk_data(x, y).
//   3. Return the resulting Dictionary to Godot.
pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    state!(engine).generation_api.fetch_chunk_data(x, y)
}

// --- END: rust/ssxl_godot/src\engine\query_data.rs ---
        42 LOC | rust/ssxl_godot/src\engine\render_batch.rs
// --- START: rust/ssxl_godot/src\engine\render_batch.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::builtin::*
//   - Provides Godot’s built-in types like Dictionary, PackedInt32Array, etc.
//   - These are essential for constructing data structures that Godot understands.
use godot::builtin::*;

// ChunkData, TileType
//   - ChunkData: represents a block of terrain tiles generated by the engine.
//   - TileType: enum/class describing the type of tile (e.g., grass, water, empty).
//     Provides helper methods like is_empty() and atlas coordinate lookup.
use ssxl_shared::{ChunkData, TileType};

// ToGodot trait
//   - Provides the to_variant() method, which converts Rust types into Godot Variant.
//   - Required for setting arrays into Dictionary fields in a Godot-compatible way.
use godot::prelude::ToGodot; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE: fixed dimension of a chunk (32x32 tiles).
// DEFAULT_SOURCE_ID: default identifier for the tile source in Godot’s TileMap.
pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

// -----------------------------------------------------------------------------
// Function: create_render_batch_dictionary
// -----------------------------------------------------------------------------
// Purpose:
//   - Converts a generated ChunkData into a Godot-ready Dictionary.
//   - This dictionary is structured specifically for Godot’s TileMap API.
//   - Acts as the translation layer between Rust’s generation system and Godot’s rendering.
//
// Arguments:
//   - chunk_data: reference to ChunkData containing tile information.
//   - chunk_x, chunk_y: coordinates of the chunk in world space.
//
// Returns:
//   - Dictionary: contains arrays of positions, source IDs, atlas coordinates, and alt tiles.
//
// Dictionary Format:
// {
//    "layer": 0,
//    "positions": PackedInt32Array [x1, y1, x2, y2, ...],
//    "source_ids": PackedInt32Array [id, id, ...],
//    "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
//    "alt_tiles": PackedInt32Array [0, 0, ...]
// }
pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    // Create the output dictionary.
    let mut dict = Dictionary::new();

    // Arrays to hold tile rendering data.
    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    // Set the rendering layer (always 0 for now).
    dict.set("layer", 0i64);

    // Counter for how many tiles are actually rendered.
    let mut tile_count = 0usize;

    // Iterate over every tile in the chunk grid (32x32).
    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            // Compute linear index into chunk_data.tiles.
            let idx = (y * CHUNK_SIZE + x) as usize;

            // Fetch tile at this index.
            if let Some(tile) = chunk_data.tiles.get(idx) {
                // Skip empty tiles (no rendering needed).
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                // Compute world-space coordinates of the tile.
                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                // Push position into array (x, y).
                positions.push(world_x);
                positions.push(world_y);

                // Push default source ID (links to Godot TileSet).
                source_ids.push(DEFAULT_SOURCE_ID);

                // Lookup atlas coordinates for this tile type.
                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                // Push alt tile index (0 = default).
                alt_tiles.push(0);

                // Increment rendered tile count.
                tile_count += 1;
            }
        }
    }

    // Store arrays into dictionary (converted to Godot Variants).
    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    // Debug log if any tiles were prepared.
    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    // Return the fully constructed dictionary.
    dict
}

// --- END: rust/ssxl_godot/src\engine\render_batch.rs ---
        49 LOC | rust/ssxl_godot/src\engine\state.rs
// --- START: rust/ssxl_godot/src\engine\state.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, GString, etc., which are required to expose Rust
//     structs and methods to Godot’s scripting layer.
use godot::prelude::*;

// TileMap, Node
//   - Godot scene graph classes.
//   - TileMap: used for rendering tile-based maps.
//   - Node: base class for all Godot scene objects.
use godot::classes::{TileMap, Node};

// UnsafeCell
//   - Provides interior mutability for otherwise immutable structs.
//   - Required because Godot owns the object lifetime, not Rust.
//   - Allows us to store mutable state inside SSXLEngine safely.
use std::cell::UnsafeCell;

// Arc + Mutex
//   - Arc: atomic reference-counted pointer for shared ownership across threads.
//   - Mutex: ensures exclusive access to shared data.
//   - Together, they allow safe concurrent access to the Conductor.
use std::sync::{Arc, Mutex};

// AnimationConductorHandle
//   - Handle for sending animation commands across threads.
use ssxl_shared::AnimationConductorHandle;

// Conductor + ConductorState
//   - Conductor: central orchestrator of generation tasks.
//   - ConductorState: snapshot of conductor’s current status.
use ssxl_generate::{Conductor, conductor::ConductorState}; 

// AnimationState
//   - Snapshot of animation conductor’s current status.
use ssxl_shared::AnimationState;

// AsyncPoller
//   - Responsible for non-blocking draining of async channels (generation + animation).
use crate::tilemap::async_poll::AsyncPoller; 

// GenesisHandles
//   - Struct returned by initialization routines, containing conductor and channel handles.
//   - Aliased here as FfiGenesisHandles for clarity.
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 

// EngineInitializer + GenerationAPI
//   - EngineInitializer: bootstraps conductor threads and channels.
//   - GenerationAPI: provides public-facing API for chunk data queries.
use crate::engine::api::{GenerationAPI, EngineInitializer};

// -----------------------------------------------------------------------------
// Macro: state!
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides safe access to the _internal_state UnsafeCell inside SSXLEngine.
//   - Two forms:
//       * Expression form: state!(self) → returns mutable reference to InternalState.
//       * Statement form: state!(self, name) → binds InternalState to local variable.
//
// Notes:
//   - #[macro_export] makes the macro visible outside this module.
//   - This is the only safe way to touch _internal_state, since Godot owns object lifetime.
#[macro_export]
macro_rules! state {
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

// Re-export macro so other engine files can use it directly.
pub use state; 

// -----------------------------------------------------------------------------
// Struct: InternalState
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds all non-FFI-safe state for SSXLEngine.
//   - Encapsulates conductor, animation, nodes, and helper APIs.
//   - This struct is hidden from Godot and only accessed via the state! macro.
//
// Fields:
//   - conductor: shared Conductor instance (Arc<Mutex<Conductor>>).
//   - conductor_state: snapshot of conductor status.
//   - animation_conductor: handle for animation commands.
//   - animation_state: snapshot of animation status.
//   - signals_node: Godot Node for emitting signals.
//   - tilemap_node: Godot TileMap for rendering.
//   - initializer: EngineInitializer for bootstrapping.
//   - poller: AsyncPoller for draining async channels.
//   - genesis_handles: optional GenesisHandles from initialization.
//   - generation_api: API for chunk data queries.
//   - tick_count: frame counter for engine ticks.
pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    pub tick_count: u64,
}

// -----------------------------------------------------------------------------
// Default Implementation: InternalState
// -----------------------------------------------------------------------------
// Provides a default empty InternalState.
// All Option fields are initialized to None.
// initializer and poller are constructed with their own defaults.
// tick_count starts at 0.
impl Default for InternalState {
    fn default() -> Self {
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            tick_count: 0,
        }
    }
}

// -----------------------------------------------------------------------------
// Struct: SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - The Godot-facing class exposed to GDScript.
//   - Wraps InternalState inside UnsafeCell for interior mutability.
//   - Provides the bridge between Godot scripts and Rust engine logic.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLEngine as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: Godot Node base.
//   - _internal_state: UnsafeCell<InternalState>, hidden from Godot.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}

// --- END: rust/ssxl_godot/src\engine\state.rs ---
        65 LOC | rust/ssxl_godot/src\engine\tick.rs
// --- START: rust/ssxl_godot/src\engine\tick.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific types and traits for Rust integration.
//   - Includes Gd<T>, Base<T>, Variant conversions, etc.
use godot::prelude::*;

// SSXLEngine
//   - The Godot-facing engine struct, wrapping InternalState.
//   - Provides access to conductor, poller, signals, etc.
use super::state::SSXLEngine;

// create_render_batch_dictionary
//   - Utility function that converts ChunkData into a Godot Dictionary
//     formatted for TileMap rendering.
use super::render_batch::create_render_batch_dictionary;

// Signals FFI
//   - Provides SSXLSignals type, which defines the signals emitted to Godot.
//   - Signals are the bridge between Rust engine events and Godot script callbacks.
use crate::ffi::signals::*; 

// GString
//   - Godot’s string type, used for sending status updates back to Godot.
use godot::builtin::GString; 

// debug!
//   - Logging macro for debug-level output.
use tracing::debug;

// GenerationMessage
//   - Enum representing messages from the generation system.
//   - Variants include Generated(chunk), StatusUpdate(string), GenerationComplete.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Function: process_engine_tick
// -----------------------------------------------------------------------------
// Purpose:
//   - Called once per frame by Godot.
//   - Processes generation + animation messages from async channels.
//   - Emits signals back to Godot for rendering and status updates.
//   - Marks tick completion.
//
// Arguments:
//   - engine: mutable reference to SSXLEngine.
//   - tick: current tick counter (frame number).
//
// Flow:
//   1. Access internal state via UnsafeCell.
//   2. Ensure conductor and signals_node exist.
//   3. Cast signals_node to SSXLSignals for emitting signals.
//   4. Poll generation messages and emit appropriate signals.
//   5. Poll animation messages and emit tile flip signals.
//   6. Emit tick_complete signal at the end.
pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    // Access the hidden InternalState inside SSXLEngine.
    let state = unsafe { &mut *engine._internal_state.get() };
    
    // Ensure conductor exists; if not, return early.
    let Some(_conductor) = &state.conductor else { return };
    
    // Ensure signals_node exists; if not, return early.
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    // Cast signals_node to SSXLSignals to allow emitting signals.
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    // -------------------------------------------------------------------------
    // Generation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available generation messages from AsyncPoller.
    let messages = state.poller.poll_generation();
    for msg in messages {
        match msg {
            // Case: A chunk has been generated.
            GenerationMessage::Generated(_, chunk) => {
                // Extract chunk coordinates.
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                // Convert chunk into Godot render batch dictionary.
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                // Emit signal if batch is non-empty.
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            // Case: Status update message.
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            // Case: Generation process complete.
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
        }
    }

    // -------------------------------------------------------------------------
    // Animation Message Polling
    // -------------------------------------------------------------------------
    // Poll all available animation updates from AsyncPoller.
    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            // Handle frame update payloads.
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(),
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    // -------------------------------------------------------------------------
    // Tick Completion Signal
    // -------------------------------------------------------------------------
    // Emit tick_complete signal with current tick number.
    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}

// --- END: rust/ssxl_godot/src\engine\tick.rs ---
        17 LOC | rust/ssxl_godot/src\ffi\gde_api_defs.rs
// --- START: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and types for Rust integration.
//   - Includes InitHandle, ExtensionLibrary, Base<T>, and macros like #[gdextension].
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - Used here as the base class for SSXLEngine.
use godot::classes::Node;

// Local engine import
//   - SSXLEngine: the Rust struct that represents the engine state and logic.
//   - This struct is exposed to Godot as a custom class.
use crate::ssxl_engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Function: ssxl_godot_init
// -----------------------------------------------------------------------------
// Purpose:
//   - Mandatory entry point for Godot’s GDExtension system.
//   - Called automatically when the dynamic library is loaded by Godot.
//   - Registers SSXLEngine as a Godot class so it can be instantiated in GDScript.
//
// Notes:
//   - #[gdextension] marks this function as the extension entry point.
//   - Declared unsafe because it interacts with Godot’s C/C++ runtime directly.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // Register SSXLEngine with Godot.
    // After this, SSXLEngine can be used in Godot scripts as a Node.
    builder.add_class::<SSXLEngine>();
}

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary for SSXLEngine
// -----------------------------------------------------------------------------
// Purpose:
//   - Binds SSXLEngine to Godot’s Node lifecycle.
//   - Maps Godot’s virtual methods (_init, _process, _ready) to Rust implementations.
//
// Lifecycle Methods:
//   - _init: Constructor, runs when SSXLEngine is instantiated in Godot.
//   - _process: Called every frame, passes delta time to engine tick.
//   - _ready: Called once when the node enters the scene tree, used for setup.
impl ExtensionLibrary for SSXLEngine {
    // Godot’s constructor (_init).
    // base: the underlying Godot Node that SSXLEngine wraps.
    // Delegates initialization to SSXLEngine::init.
    fn _init(base: Base<Node>) -> Self {
        SSXLEngine::init(base)
    }

    // Godot’s frame update (_process).
    // delta: time elapsed since last frame (in seconds).
    // Delegates to SSXLEngine::tick, casting delta to u64 for internal use.
    fn _process(&mut self, delta: f64) {
        self.tick(delta as u64);
    }

    // Godot’s ready hook (_ready).
    // Runs once when the node enters the scene tree.
    // Delegates to SSXLEngine::on_ready for engine startup logic.
    fn _ready(&mut self) {
        self.on_ready();
    }
}

// --- END: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
         4 LOC | rust/ssxl_godot/src\ffi\mod.rs
// --- START: rust/ssxl_godot/src\ffi\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// Declares submodules within the `ffi` namespace.
// These correspond to files in `src/ffi/`.
//
// oracle.rs   → Contains the SSXLOracle struct and related logic.
// signals.rs  → Contains the SSXLSignals struct and signal definitions.
pub mod oracle;
pub mod signals;

// -----------------------------------------------------------------------------
// Re-exports
// -----------------------------------------------------------------------------
// Purpose:
//   - Makes selected types available directly from the `ffi` module,
//     so external code can import them without referencing submodules.
//
// Example:
//   Instead of writing:
//       use crate::ffi::oracle::SSXLOracle;
//   You can simply write:
//       use crate::ffi::SSXLOracle;
//
// This improves ergonomics and keeps external imports clean.
pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;

// --- END: rust/ssxl_godot/src\ffi\mod.rs ---
        64 LOC | rust/ssxl_godot/src\ffi\oracle.rs
// --- START: rust/ssxl_godot/src\ffi\oracle.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits and macros for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - SSXLOracle inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node;

// Base, Gd
//   - Base<Node>: wrapper around the Godot Node base class.
//   - Gd<T>: Godot reference-counted smart pointer for Rust objects exposed to Godot.
use godot::obj::{Base, Gd};

// SSXLEngine
//   - The core engine struct, containing generation and animation logic.
//   - SSXLOracle holds a reference to SSXLEngine to delegate work.
use crate::engine::SSXLEngine;

// -----------------------------------------------------------------------------
// Struct: SSXLOracle
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as a Godot-facing "oracle" node that queries and delegates to SSXLEngine.
//   - Provides a lightweight interface for ticking the engine and retrieving status.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLOracle as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node.
//   - engine: optional reference to SSXLEngine (bound later).
//   - tick_count: counter for how many ticks have been processed.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLOracle
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLOracle.
impl SSXLOracle {
    // init
    //   - Called when SSXLOracle is constructed.
    //   - Initializes with no engine bound and tick_count = 0.
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func] attributes.
// These methods can be called from GDScript or C#.
#[godot_api]
impl SSXLOracle {
    // _ready
    //   - Godot lifecycle method.
    //   - Called once when the node enters the scene tree.
    //   - Enables processing so _process() can run each frame.
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    // set_engine
    //   - Binds an SSXLEngine instance to this oracle.
    //   - Allows delegation of tick and query methods.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    // tick
    //   - Advances the engine by one tick.
    //   - Delegates to SSXLEngine::process_engine_tick.
    //   - Increments tick_count.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {
                // No engine bound; silently skip.
            }
        }
    }

    // get_current_tile_count
    //   - Queries SSXLEngine for the total number of tiles generated.
    //   - Returns 0 if engine is not bound.
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_current_tile_count()
            }
            None => {
                0
            }
        }
    }

    // get_status
    //   - Queries SSXLEngine for a human-readable status string.
    //   - Returns "Engine not bound." if no engine is attached.
    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_status()
            }
            None => {
                GString::from("Engine not bound.")
            }
        }
    }
    
    // ping
    //   - Simple test function; currently does nothing.
    //   - Can be used to verify connectivity from Godot.
    #[func]
    pub fn ping(&self) {
    }

    // reset
    //   - Resets tick_count to 0.
    //   - Useful for restarting counters during testing or reinitialization.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    // get_tick
    //   - Returns the current tick_count.
    //   - Useful for monitoring how many ticks have been processed.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}

// --- END: rust/ssxl_godot/src\ffi\oracle.rs ---
        24 LOC | rust/ssxl_godot/src\ffi\signals.rs
// --- START: rust/ssxl_godot/src\ffi\signals.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Base<T>, GString, Dictionary, Vector2i, and the #[godot_api] attribute.
use godot::prelude::*;

// Node
//   - Godot’s fundamental scene graph class.
//   - SSXLSignals inherits from Node so it can exist in the Godot scene tree.
use godot::classes::Node; 

// -----------------------------------------------------------------------------
// Struct: SSXLSignals
// -----------------------------------------------------------------------------
// Purpose:
//   - Defines a Godot-facing class that emits signals from the Rust engine.
//   - Signals are the communication bridge between Rust logic and Godot scripts.
//   - This struct itself does not contain engine state; it only acts as a broadcaster.
//
// Attributes:
//   - #[derive(GodotClass)] + #[class(tool, base = Node, init)]
//       * Marks SSXLSignals as a Godot class.
//       * tool: usable in Godot editor.
//       * base = Node: inherits from Godot’s Node.
//       * init: ensures proper initialization.
//
// Fields:
//   - base: the underlying Godot Node that SSXLSignals wraps.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

// -----------------------------------------------------------------------------
// Implementation: SSXLSignals
// -----------------------------------------------------------------------------
// Provides initialization logic for SSXLSignals.
impl SSXLSignals {
    // init
    //   - Called when SSXLSignals is constructed.
    //   - Wraps the provided Node base inside the struct.
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

// -----------------------------------------------------------------------------
// Godot API Implementation
// -----------------------------------------------------------------------------
// Defines all signals exposed to Godot via #[signal] attributes.
// These signals can be connected to GDScript or C# methods in the Godot editor.
//
// Categories:
//   - Generation lifecycle signals
//   - Animation & utility signals
#[godot_api]
impl SSXLSignals {
    // -------------------------------------------------------------------------
    // Generation Lifecycle Signals
    // -------------------------------------------------------------------------

    // Emitted when map generation begins.
    #[signal]
    fn build_map_start();

    // Emitted when chunk data is updated (coordinates provided).
    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    // Emitted when a chunk is fully generated and converted into a render batch.
    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    // Emitted when map generation completes successfully.
    #[signal]
    fn build_map_complete();

    // Emitted when map generation is stopped prematurely.
    #[signal]
    fn build_map_stopped();

    // Emitted when a generation error occurs (error message provided).
    #[signal]
    fn generation_error(error_message: GString);

    // Emitted when chunk data is ready for use (coordinates provided).
    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    // Emitted at the end of each tick (frame), with current tick count.
    #[signal]
    fn tick_complete(current_tick: u64);

    // -------------------------------------------------------------------------
    // Animation & Utility Signals
    // -------------------------------------------------------------------------

    // Emitted when a tile’s flip frame is updated (tile ID + frame index).
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    // Emitted during animation updates (percent done + new atlas coordinates).
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    // Emitted when animation state changes (enabled/disabled).
    #[signal]
    fn animation_state_changed(enabled: bool);

    // Emitted when engine status changes (status message provided).
    #[signal]
    fn engine_status_updated(status_message: GString);
}

// --- END: rust/ssxl_godot/src\ffi\signals.rs ---
        10 LOC | rust/ssxl_godot/src\lib.rs
// --- START: rust/ssxl_godot/src\lib.rs ---
// -----------------------------------------------------------------------------
// Root Manifest: ssxl_godot
// -----------------------------------------------------------------------------
// This file is the entry point for the `ssxl_godot` crate.
// It defines the top-level module structure and the GDExtension boilerplate
// required for Godot to load this Rust library.

// -----------------------------------------------------------------------------
// Public Modules
// -----------------------------------------------------------------------------
// These modules are exposed to Godot and contain the core functionality.
// Each corresponds to a directory or file in `src/`.
//
// engine   → Core engine logic (SSXLEngine, conductor, tick loop, API).
// ffi      → Godot-facing FFI adapter nodes (SSXLOracle, SSXLSignals).
// tilemap  → TileMap integration (SSXLTilemap, async_poll, status_reporter).
pub mod engine;
pub mod ffi;
pub mod tilemap; 

// -----------------------------------------------------------------------------
// Godot GDExtension Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides macros and traits for integrating Rust with Godot.
//   - Includes #[gdextension], Gd<T>, GodotClass, etc.
//
// ExtensionLibrary, InitLevel
//   - Traits and enums required to define the dynamic library’s lifecycle.
//   - InitLevel indicates which stage of Godot initialization is occurring.
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};

// -----------------------------------------------------------------------------
// Struct: SSXLExtension
// -----------------------------------------------------------------------------
// Purpose:
//   - Placeholder struct required by godot-rust to implement ExtensionLibrary.
//   - Represents the extension library itself.
//   - Contains no fields because all logic is delegated to modules.
struct SSXLExtension;

// -----------------------------------------------------------------------------
// Trait Implementation: ExtensionLibrary
// -----------------------------------------------------------------------------
// #[gdextension]
//   - Marks this implementation as the entrypoint for Godot’s GDExtension system.
//   - Godot will call into this when loading the dynamic library.
//
// unsafe impl ExtensionLibrary
//   - Required by godot-rust to hook into Godot’s lifecycle.
//   - Declares how the extension behaves during initialization.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    // on_level_init
    //   - Called by Godot when a new initialization level is reached.
    //   - InitLevel indicates the stage (Core, Scene, Editor, etc.).
    //   - Currently does nothing, but can be extended to register classes,
    //     initialize resources, or set up global state.
    fn on_level_init(_level: InitLevel) {
        // No actions required at this stage.
    }
}

// --- END: rust/ssxl_godot/src\lib.rs ---
        72 LOC | rust/ssxl_godot/src\tilemap\async_poll.rs
// --- START: rust/ssxl_godot/src\tilemap\async_poll.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// Tokio MPSC (multi-producer, single-consumer) channels.
//   - Receiver: bounded channel receiver (used for generation messages).
//   - UnboundedReceiver: unbounded channel receiver (used for animation updates).
//   - TryRecvError: error type returned when attempting non-blocking receive.
use tokio::sync::mpsc::{
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};

// AnimationUpdate
//   - Struct representing updates from the animation conductor.
//   - Typically contains tile coordinates and frame update payloads.
use ssxl_shared::AnimationUpdate; 

// GenerationMessage
//   - Enum representing messages from the generation conductor.
//   - Variants include Generated(chunk), StatusUpdate, GenerationComplete, etc.
use ssxl_shared::message::generation_message::GenerationMessage; 

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// MAX_GEN_MSGS
//   - Maximum number of generation messages to process per poll.
//   - Prevents runaway loops if channel is flooded.
const MAX_GEN_MSGS: usize = 64;

// MAX_ANIM_MSGS
//   - Maximum number of animation messages to process per poll.
//   - Higher because animation updates can be more frequent.
const MAX_ANIM_MSGS: usize = 2048;

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------
// AnimationReceiver
//   - Unbounded channel receiver for AnimationUpdate messages.
//   - Animation updates are frequent, so unbounded channel is used.
pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;

// GenerationReceiver
//   - Bounded channel receiver for GenerationMessage.
//   - Generation messages are controlled by the Conductor, so bounded channel is used.
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

// -----------------------------------------------------------------------------
// Struct: AsyncPoller
// -----------------------------------------------------------------------------
// Purpose:
//   - Acts as the "bridge" between Tokio async channels and Godot’s main thread.
//   - Provides non-blocking polling methods to drain channels safely each frame.
//   - Stores optional receivers for generation and animation messages.
//
// Fields:
//   - generation_rx: optional bounded receiver for generation messages.
//   - animation_rx: optional unbounded receiver for animation updates.
#[derive(Default)]
pub struct AsyncPoller {
    generation_rx: Option<GenerationReceiver>,
    animation_rx: Option<AnimationReceiver>,
}

// -----------------------------------------------------------------------------
// Implementation: AsyncPoller
// -----------------------------------------------------------------------------
// Provides methods to set receivers, clear them, and poll messages.
impl AsyncPoller {
    // new
    //   - Creates a new AsyncPoller with default (None) receivers.
    pub fn new() -> Self {
        Self::default()
    }

    // set_animation_rx
    //   - Assigns an animation receiver to the poller.
    //   - Accepts Option<AnimationReceiver> to allow None when uninitialized.
    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        self.animation_rx = rx;
    }

    // set_generation_rx
    //   - Assigns a generation receiver to the poller.
    //   - Accepts Option<GenerationReceiver> to allow None when uninitialized.
    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        self.generation_rx = rx;
    }

    // clear_receivers
    //   - Clears both generation and animation receivers.
    //   - Useful for resetting state or shutting down channels.
    pub fn clear_receivers(&mut self) {
        self.generation_rx = None;
        self.animation_rx = None;
    }

    // poll_generation
    //   - Non-blocking poll of generation messages.
    //   - Drains up to MAX_GEN_MSGS messages from the channel.
    //   - Handles Empty (no messages) and Disconnected (channel closed).
    //   - Returns a vector of GenerationMessage.
    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.generation_rx = Some(rx);
        updates
    }

    // poll_animations
    //   - Non-blocking poll of animation updates.
    //   - Drains up to MAX_ANIM_MSGS messages from the channel.
    //   - Uses a smaller initial capacity (min(256)) for efficiency.
    //   - Returns a vector of AnimationUpdate.
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // Temporarily take ownership of the receiver.
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break, // no more messages
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        // Put receiver back into struct for next poll.
        self.animation_rx = Some(rx);
        updates
    }
}

// --- END: rust/ssxl_godot/src\tilemap\async_poll.rs ---
         3 LOC | rust/ssxl_godot/src\tilemap\mod.rs
// --- START: rust/ssxl_godot/src\tilemap\mod.rs ---
// -----------------------------------------------------------------------------
// Module: tilemap
// -----------------------------------------------------------------------------
// This file acts as the *parent module* for all tilemap-related components.
// It declares submodules and re-exports them so they can be accessed cleanly
// from other parts of the engine.
//
// Structure:
//   src/tilemap/
//     ├── mod.rs              ← this file
//     ├── ssxl_tilemap.rs     ← core tilemap logic
//     ├── async_poll.rs       ← async channel polling bridge
//     └── status_reporter.rs  ← utility for reporting tilemap status

// -----------------------------------------------------------------------------
// Submodule: ssxl_tilemap
// -----------------------------------------------------------------------------
// Contains the main SSXLTilemap implementation.
//   - Responsible for managing tile placement, rendering, and integration
//     with Godot’s TileMap node.
//   - Provides the core API for interacting with chunks and tiles.
pub mod ssxl_tilemap;

// -----------------------------------------------------------------------------
// Submodule: async_poll
// -----------------------------------------------------------------------------
// Contains AsyncPoller, the bridge between Tokio async channels and Godot.
//   - Polls generation and animation channels safely on the main thread.
//   - Ensures non-blocking, panic-free message handling.
//   - Used by the engine tick loop to drain background updates.
pub mod async_poll;

// -----------------------------------------------------------------------------
// Submodule: status_reporter
// -----------------------------------------------------------------------------
// Contains utilities for reporting tilemap status back to Godot.
//   - Provides human-readable summaries of engine/tilemap state.
//   - Emits status updates via signals for debugging and monitoring.
//   - Helps external scripts understand the tilemap’s lifecycle.
pub mod status_reporter;

// --- END: rust/ssxl_godot/src\tilemap\mod.rs ---
       108 LOC | rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs
// --- START: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// godot::prelude::*
//   - Provides Godot-specific traits, macros, and types for Rust integration.
//   - Includes Gd<T>, Base<T>, GodotClass derive, and GString.
use godot::prelude::*;

// TileMap, ITileMap
//   - TileMap: Godot’s built-in node for grid-based tile rendering.
//   - ITileMap: Trait that allows us to implement custom behavior for TileMap in Rust.
use godot::classes::{TileMap, ITileMap};

// Base
//   - Wrapper around the Godot base class for TileMap.
//   - Provides access to the underlying Godot object.
use godot::obj::Base;

// Vector2i, PackedVector2Array, PackedInt32Array
//   - Vector2i: integer 2D vector, used for tile coordinates.
//   - PackedVector2Array: efficient array of Vector2 values, used for batch positions.
//   - PackedInt32Array: efficient array of integers, used for alternative tile IDs.
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};

// OnceCell
//   - Thread-safe, one-time initialization cell.
//   - Used here to store the global TileMap instance ID for FFI callbacks.
use once_cell::sync::OnceCell;

// -----------------------------------------------------------------------------
// Global State
// -----------------------------------------------------------------------------
// TILEMAP_INSTANCE_ID
//   - Stores the Godot instance ID of the SSXLTilemap node.
//   - Allows external C-style FFI functions to access the TileMap safely.
pub static TILEMAP_INSTANCE_ID: OnceCell<InstanceId> = OnceCell::new(); 

// DEFAULT_LAYER
//   - Default layer index used when placing tiles via FFI callbacks.
const DEFAULT_LAYER: i32 = 0;

// -----------------------------------------------------------------------------
// Struct: SSXLTilemap
// -----------------------------------------------------------------------------
// Purpose:
//   - Custom Godot TileMap class that receives render batches from Rust signals
//     or FFI callbacks.
//   - Provides both batch rendering (signal-driven) and buffered updates (FFI-driven).
//
// Fields:
//   - base: underlying Godot TileMap node.
//   - tile_source_id: ID of the tile source used when setting cells.
//   - pending_updates: buffer of cell updates queued via FFI calls.
#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    pub tile_source_id: i32,
    pub pending_updates: Vec<(i32, i32, i32)>, // (world_x, world_y, tile_id)
}

// -----------------------------------------------------------------------------
// Implementation: ITileMap for SSXLTilemap
// -----------------------------------------------------------------------------
// Provides initialization logic when the TileMap node is created in Godot.
#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        // Store the instance ID globally for FFI access.
        let id = base.to_init_gd().instance_id();
        let _ = TILEMAP_INSTANCE_ID.set(id);

        Self {
            base,
            tile_source_id: 1,
            pending_updates: Vec::new(),
        }
    }
}

// -----------------------------------------------------------------------------
// Implementation: SSXLTilemap
// -----------------------------------------------------------------------------
// Provides methods exposed to Godot via #[godot_api] and #[func].
#[godot_api]
impl SSXLTilemap {
    // -------------------------------------------------------------------------
    // Batch Render (Signal/GDScript)
    // -------------------------------------------------------------------------
    // batch_set_tiles
    //   - Primary entrypoint for rendering tiles in bulk.
    //   - Expects a Dictionary with keys: "layer", "positions", "atlas_coords", "alt_tiles".
    //   - Called from Rust signals or GDScript.
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        // Extract layer index.
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        // Extract positions array.
        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        // Extract atlas coordinates array.
        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        // Extract alternative tiles array (optional).
        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        // Ensure layer is enabled before placing tiles.
        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        // Iterate through all positions and place tiles.
        for i in 0..len {
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }

    // -------------------------------------------------------------------------
    // FFI Render (Callback)
    // -------------------------------------------------------------------------

    // get_instance
    //   - Retrieves the current SSXLTilemap instance using its global ID.
    //   - Allows external C functions to access the TileMap safely.
    fn get_instance() -> Option<Gd<Self>> {
        let id = TILEMAP_INSTANCE_ID.get()?;
        godot::prelude::Gd::try_from_instance_id(*id).ok()
    }

    // flush_updates
    //   - Flushes all pending updates queued via FFI calls.
    //   - Applies them to the TileMap in bulk.
    pub fn flush_updates(&mut self) {
        // Take ownership of the buffer before mutably borrowing self.base.
        let updates = std::mem::take(&mut self.pending_updates);
        let len = updates.len();

        if len == 0 {
            return;
        }

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();
        
        tilemap.set_layer_enabled(DEFAULT_LAYER, true);

        // Apply each update to the default layer.
        for (world_x, world_y, tile_id) in updates {
            let cell = Vector2i::new(world_x, world_y);
            let atlas = Vector2i::new(0, tile_id); 
            
            tilemap
                .set_cell_ex(DEFAULT_LAYER, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(0)
                .done();
        }

        godot_print!("FFI Host: Batch rendered {len} tiles via FFI callback.");
    }
}

// -----------------------------------------------------------------------------
// FFI Host Implementation
// -----------------------------------------------------------------------------
// These extern "C" functions are exposed for the ssxl_engine_ffi library.
// They allow C-style calls to queue and flush tile updates.

// ssxl_set_cell
//   - Queues a single cell update into pending_updates.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_set_cell(x: i32, y: i32, tile_id: i32) {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().pending_updates.push((x, y, tile_id));
    } else {
        godot_warn!("ssxl_set_cell: Tilemap instance not available. Update lost.");
    }
}

// ssxl_notify_tilemap_update
//   - Flushes all queued updates to the TileMap.
//   - Called from external FFI code.
#[no_mangle]
pub extern "C" fn ssxl_notify_tilemap_update() {
    if let Some(mut map) = SSXLTilemap::get_instance() {
        map.bind_mut().flush_updates();
    }
}

// --- END: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
        36 LOC | rust/ssxl_godot/src\tilemap\status_reporter.rs
// --- START: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// GString
//   - Godot’s string type, used for returning status messages to the scripting layer.
//   - Ensures compatibility with GDScript and C# in Godot.
use godot::prelude::GString;

// ConductorState
//   - Represents the state of the generation conductor (map/chunk generation).
//   - Provides methods like `get_status()` and `get_tiles_placed()` for querying progress.
use ssxl_generate::conductor::ConductorState;

// AnimationState
//   - Represents the state of the animation conductor.
//   - Provides fields like `time_scale` to indicate animation speed or whether it’s running.
use ssxl_shared::AnimationState;

// -----------------------------------------------------------------------------
// Struct: StatusReporter
// -----------------------------------------------------------------------------
// Purpose:
//   - Stateless utility struct for compiling human-readable status reports.
//   - Separates reporting logic from SSXLEngine, keeping engine code clean.
//   - Provides helper methods for status strings and tile counts.
pub struct StatusReporter;

// -----------------------------------------------------------------------------
// Implementation: StatusReporter
// -----------------------------------------------------------------------------
// Provides methods for generating status reports and querying tile counts.
impl StatusReporter {
    // -------------------------------------------------------------------------
    // Method: get_status_report
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Constructs a formatted status string combining generation and animation states.
    //   - Returns a Godot GString for direct use in the scripting layer.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState (generation system).
    //   - anim_state: optional reference to AnimationState (animation system).
    //
    // Behavior:
    //   - If gen_state is present, calls `get_status()` and formats it.
    //   - If anim_state is present, derives status from `time_scale`:
    //       * > 0.0 → Running
    //       * == 0.0 → Stopped
    //       * < 0.0 → Error/Invalid
    //   - If either state is missing, defaults to "Uninitialized".
    //
    // Returns:
    //   - A GString containing: "STATUS: Generation: <gen_status> | Animation: <anim_status>"
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        // Handle generation state.
        let gen_status = gen_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Handle animation state.
        let anim_status = anim_state
            .map(|state| {
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        // Combine both statuses into one formatted string.
        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        // Return as Godot GString.
        GString::from(status.as_str())
    }

    // -------------------------------------------------------------------------
    // Method: get_current_tile_count_value
    // -------------------------------------------------------------------------
    // Purpose:
    //   - Retrieves the total number of tiles placed by the generation conductor.
    //
    // Arguments:
    //   - gen_state: optional reference to ConductorState.
    //
    // Behavior:
    //   - If gen_state is present, calls `get_tiles_placed()`.
    //   - If absent, defaults to 0.
    //
    // Returns:
    //   - u64 representing the tile count.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            .unwrap_or(0)
    }
}

// --- END: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
        58 LOC | rust/ssxl_math/src\coordinate_system.rs
// --- START: rust/ssxl_math/src\coordinate_system.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// serde::{Serialize, Deserialize}
//   - Enables serialization and deserialization of structs (WorldPos, ChunkKey, TileOffset).
//   - Useful for saving/loading world state or transmitting coordinates across systems.
use serde::{Serialize, Deserialize};

// CHUNK_SIZE_I64
//   - Constant defining the cubic dimension of a chunk (e.g., 32).
//   - Used to calculate chunk boundaries and offsets.
use crate::primitives::CHUNK_SIZE_I64;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows extremely large coordinate ranges, far beyond i32 limits.
use glam::I64Vec3;

// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------
// These structs define the fundamental coordinate system for the engine.
// They wrap I64Vec3 to provide semantic meaning (WorldPos vs ChunkKey vs TileOffset).

// WorldPos
//   - Represents a specific point in the infinite 3D world.
//   - Stored as a 64-bit vector to handle huge coordinates safely.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

// ChunkKey
//   - Identifies a chunk in the world.
//   - Each chunk is a cubic volume of size CHUNK_SIZE_I64.
//   - Acts as the "index" of the chunk in world space.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

// TileOffset
//   - Represents the local position of a tile inside its parent chunk.
//   - Always non-negative, ranging from 0 to CHUNK_SIZE_I64 - 1.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);

// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------
// Provides conversion from global coordinates to chunk-local coordinates.
impl WorldPos {
    // to_chunk_coords
    //   - Splits a global WorldPos into (ChunkKey, TileOffset).
    //   - Uses Euclidean division to handle negative coordinates correctly.
    //   - Ensures TileOffset is always non-negative.
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {
        let chunk_size = CHUNK_SIZE_I64;

        // Compute tile offset using rem_euclid (always non-negative).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // Compute chunk index by subtracting offset and dividing by chunk size.
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------
// Provides conversion from chunk-local coordinates back to global coordinates.
impl ChunkKey {
    // to_world_pos
    //   - Reconstructs a WorldPos from a ChunkKey and TileOffset.
    //   - Formula: World = (Chunk Index * Chunk Size) + Tile Offset.
    //   - Ensures round-trip consistency with WorldPos::to_chunk_coords.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates correctness of conversions, especially for large and negative coordinates.
#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    #[test]
    fn test_world_to_chunk_positive() {
        // Large positive coordinate (well beyond i32::MAX).
        let huge_coord = 5_000_000_000i64;
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64;
        let expected_offset = huge_coord % CHUNK_SIZE_I64;

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // Verify chunk index and offset.
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    fn test_world_to_chunk_negative_crucial() {
        // Case 1: (-1, -1, -1) → ChunkKey = -1, Offset = 31.
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Case 2: (-33, -64, -100) → deeper negative coordinates.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    fn test_round_trip() {
        // Round-trip test: WorldPos → (ChunkKey, TileOffset) → WorldPos.
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();
        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}

// --- END: rust/ssxl_math/src\coordinate_system.rs ---
        14 LOC | rust/ssxl_math/src\generation_utils.rs
// --- START: rust/ssxl_math/src\generation_utils.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLData
//   - Trait defined in the primitives module.
//   - Provides two essential methods:
//       * get_id() -> u64: returns a unique identifier for the data.
//       * get_value_len() -> usize: returns the length of the associated value.
//   - Used here to process data objects generically.
use crate::primitives::SSXLData;

// rand::Rng
//   - Trait from the `rand` crate that provides random number generation utilities.
//   - Enables us to call gen_range() for chance rolls.
use rand::Rng;

// -----------------------------------------------------------------------------
// Function: generate_percent_roll
// -----------------------------------------------------------------------------
// Purpose:
//   - Performs a probabilistic roll against a given percentage chance.
//   - Used in procedural generation to decide whether an event occurs (e.g., spawning resources).
//
// Arguments:
//   - target_percent: u8 (0–100), representing the probability of success.
//
// Behavior:
//   - Generates a random integer between 0 and 99 inclusive.
//   - Compares it against target_percent.
//   - Returns 0 if success (random < target_percent).
//   - Returns 1 if failure (random >= target_percent).
//
// Example:
//   - generate_percent_roll(25) → 25% chance of returning 0 (success).
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the range [0, 99].
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Compare against target_percent.
    if rand_val < target_percent {
        0 // Success
    } else {
        1 // Failure
    }
}

// -----------------------------------------------------------------------------
// Function: process_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Processes an object implementing SSXLData to derive a simple aggregate identifier.
//   - Combines the object's unique ID with the length of its value payload.
//   - Useful for lightweight hashing, checksums, or quick uniqueness checks.
//
// Arguments:
//   - data: reference to any object implementing SSXLData.
//
// Behavior:
//   - Calls get_id() to retrieve the object’s unique identifier.
//   - Calls get_value_len() to retrieve the length of its payload.
//   - Adds them together to produce a u64 aggregate value.
//
// Returns:
//   - u64 representing the combined identifier + payload length.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine ID and payload length into a single value.
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}

// --- END: rust/ssxl_math/src\generation_utils.rs ---
        42 LOC | rust/ssxl_math/src\hashing.rs
// --- START: rust/ssxl_math/src\hashing.rs ---
// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// SSXLResult
//   - A custom result type defined in the primitives module.
//   - Used here to wrap hashing results, ensuring consistency with the rest of the engine.
use crate::primitives::SSXLResult;

// I64Vec3
//   - A 3D vector type using 64-bit integers.
//   - Allows chunk coordinates to span extremely large worlds without overflow.
use glam::I64Vec3;

// sha2::{Digest, Sha256}
//   - Digest: trait providing hashing functionality.
//   - Sha256: implementation of the SHA-256 cryptographic hash algorithm.
//   - Used to generate deterministic, collision-resistant hashes.
use sha2::{Digest, Sha256};

// -----------------------------------------------------------------------------
// Function: hash_chunk_coords
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a given 3D chunk coordinate.
//   - Ensures that identical coordinates always produce the same hash string.
//   - Used as a unique identifier for chunks in caching and procedural generation.
//
// Arguments:
//   - coords: I64Vec3 representing the chunk’s world-space coordinates.
//
// Behavior:
//   - Serializes coordinates into a canonical string format ("x:y:z").
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string.
//
// Returns:
//   - SSXLResult<String> containing the hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // Serialize coordinates into a deterministic string.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // Convert hash bytes into lowercase hex string.
    Ok(format!("{:x}", result))
}

// -----------------------------------------------------------------------------
// Function: hash_content_data
// -----------------------------------------------------------------------------
// Purpose:
//   - Generates a deterministic SHA-256 hash for a generic u64 data key.
//   - Used for content caching (e.g., assets, seeds, configurations).
//   - Adds a "content_" prefix for easy identification in cache systems.
//
// Arguments:
//   - data_key: u64 identifier for the content.
//
// Behavior:
//   - Converts the key into a string.
//   - Feeds the string into a SHA-256 hasher.
//   - Produces a 64-character hexadecimal string prefixed with "content_".
//
// Returns:
//   - SSXLResult<String> containing the prefixed hash.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // Convert numeric key into string.
    let key_string = data_key.to_string();

    // Initialize SHA-256 hasher and feed in the string.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // Prefix with "content_" and return.
    Ok(format!("content_{:x}", result))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------
// Validates determinism, uniqueness, and formatting of the hashing functions.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chunk_coords_determinism() {
        // Same coordinates should always produce identical hashes.
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    fn test_chunk_coords_uniqueness_and_format() {
        // Adjacent coordinates should produce different hashes.
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        // Verify hash length and uniqueness.
        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    fn test_content_data_determinism_and_format() {
        // Same content key should always produce identical hashes.
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        // Verify prefix and total length.
        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}

// --- END: rust/ssxl_math/src\hashing.rs ---
        30 LOC | rust/ssxl_math/src\lib.rs
// --- START: rust/ssxl_math/src\lib.rs ---
// -----------------------------------------------------------------------------
// Module Declarations
// -----------------------------------------------------------------------------
// These modules define the mathematical foundation of the SSXL engine.
// Each module is declared here so they can be accessed throughout the crate.

// coordinate_system
//   - Defines core coordinate types (WorldPos, ChunkKey, TileOffset).
//   - Handles conversion between global world positions and chunk-local offsets.
pub mod coordinate_system;

// generation_utils
//   - Provides utility functions for procedural generation.
//   - Includes randomness utilities (percent rolls) and data processing helpers.
pub mod generation_utils;

// hashing
//   - Provides deterministic hashing functions.
//   - Used for chunk IDs, cache keys, and ensuring stable procedural generation.
pub mod hashing;

// primitives
//   - Defines core mathematical constants, types, and result/error handling.
//   - Acts as the foundation for other modules.
pub mod primitives;

// -----------------------------------------------------------------------------
// Fast Inverse Square Root (q_rsqrt)
// -----------------------------------------------------------------------------
// Purpose:
//   - Approximates 1/sqrt(number) extremely quickly using bit-level operations.
//   - Famous algorithm from Quake III Arena, adapted here for safe use.
//   - Used for vector normalization and other math-heavy operations.
//
// Arguments:
//   - number: f32, the value to invert square root.
//
// Behavior:
//   - Returns 0.0 if input is <= 0.0 (safety guard).
//   - Uses bit manipulation to approximate inverse square root.
//   - Refines result with one Newton-Raphson iteration.
//
// Returns:
//   - Approximate 1/sqrt(number).
#[inline(always)]
pub fn q_rsqrt(number: f32) -> f32 {
    // Safety guard: prevent NaN or undefined behavior.
    if number <= 0.0 { 
        return 0.0;
    }

    // Constant used in Newton-Raphson iteration.
    const THREEHALFS: f32 = 1.5;

    // Half of the input number.
    let x2 = number * 0.5;
    let y = number;
    
    // Bit-level hack: reinterpret float bits as integer.
    let i = y.to_bits();
    // Magic constant (0x5f3759df) minus half of exponent bits.
    let j_bits = 0x5f3759df_u32.wrapping_sub(i >> 1);

    // Reinterpret back into float.
    let mut y = f32::from_bits(j_bits);
    
    // One iteration of Newton-Raphson refinement.
    y = y * (THREEHALFS - (x2 * y * y));
    y
}

// -----------------------------------------------------------------------------
// Vector Normalization
// -----------------------------------------------------------------------------
// Purpose:
//   - Computes the unit vector (normalized vector) of a 3D vector.
//   - Uses q_rsqrt for fast inverse square root approximation.
//
// Arguments:
//   - x, y, z: f32 components of the vector.
//
// Behavior:
//   - Computes squared magnitude (x² + y² + z²).
//   - Uses q_rsqrt to approximate 1/sqrt(mag_sq).
//   - Multiplies each component by inverse magnitude.
//
// Returns:
//   - Tuple (f32, f32, f32) representing normalized vector.
pub fn normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32) {
    let mag_sq = x * x + y * y + z * z;
    let inv_mag = q_rsqrt(mag_sq); 
    
    (x * inv_mag, y * inv_mag, z * inv_mag)
}

// -----------------------------------------------------------------------------
// Prelude Module
// -----------------------------------------------------------------------------
// Purpose:
//   - Provides a convenience re-export of all essential types and functions.
//   - Allows other crates to import `ssxl_math::prelude::*` for quick access.
//
// Contents:
//   - Re-exports coordinate_system, generation_utils, hashing, primitives.
//   - Re-exports q_rsqrt and normalize_vector_3d.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
    
    pub use super::q_rsqrt;
    pub use super::normalize_vector_3d;
}

// --- END: rust/ssxl_math/src\lib.rs ---
        19 LOC | rust/ssxl_math/src\primitives.rs
// --- START: rust/ssxl_math/src\primitives.rs ---
// -----------------------------------------------------------------------------
// Primitives: low-level types, aliases, traits, and constants
// -----------------------------------------------------------------------------
// serde::{Deserialize, Serialize}
//   - Derive macros to allow this crate’s basic types to be serialized/deserialized
//     for persistence, networking, and inter-crate messaging.
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Vec2i: a 2D integer vector
// -----------------------------------------------------------------------------
// Purpose:
//   - Canonical 2D coordinate used across the engine for tiles and chunk indexing.
// Design notes:
//   - Uses i64 to align with the engine’s 64-bit world coordinates (I64Vec3),
//     preventing silent overflow if values are promoted or combined with i64 math.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    // X component (horizontal axis)
    pub x: i64,
    // Y component (vertical axis)
    pub y: i64,
}

impl Vec2i {
    // Constructor for Vec2i, emphasizing explicitness and avoiding field-order mistakes.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// -----------------------------------------------------------------------------
// Type aliases: semantic clarity with zero runtime cost
// -----------------------------------------------------------------------------
// TileCoord
//   - Semantic alias for a tile’s coordinate in 2D space (world or local).
//   - Keeps API readable and intent-focused while reusing Vec2i’s layout.
pub type TileCoord = Vec2i; 

// ChunkId
//   - Semantic alias for a chunk’s 2D identifier in a world grid.
//   - Mirrors TileCoord’s layout for consistency across APIs and storage.
pub type ChunkId = Vec2i; 

// SSXLResult<T>
//   - Project-wide lightweight Result alias with String errors.
//   - Favoring human-readable messages across crate boundaries without custom error enums.
pub type SSXLResult<T> = Result<T, String>;

// -----------------------------------------------------------------------------
// Trait: SSXLData
// -----------------------------------------------------------------------------
// Purpose:
//   - Minimal contract for data managed by the engine (task queues, caches, workers).
// Concurrency:
//   - Send + Sync required to safely move/share implementors across thread boundaries.
pub trait SSXLData: Send + Sync {
    // Unique, stable identifier used for indexing, caching, and deduplication.
    fn get_id(&self) -> u64;

    // Size of the core payload (bytes or elements), useful for diagnostics and limits.
    fn get_value_len(&self) -> usize;
}

// -----------------------------------------------------------------------------
// Global constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE_I64
//   - Canonical cubic side length for procedural chunks.
//   - i64 type matches engine math and avoids cross-type casting pitfalls.
pub const CHUNK_SIZE_I64: i64 = 32;

// F32_EPSILON
//   - Small tolerance for floating-point comparisons in math-heavy routines
//     (e.g., noise interpolation, normalization).
pub const F32_EPSILON: f32 = 1.0e-6;

// --- END: rust/ssxl_math/src\primitives.rs ---
       133 LOC | rust/ssxl_shared/src\chunk\chunk_data.rs
// --- START: rust/ssxl_shared/src\chunk\chunk_data.rs ---
use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto;
use std::ptr; 

use super::grid_bounds::GridBounds;
use crate::tile::tile_data::TileData; 
use crate::math::math_primitives;
use ssxl_math::prelude::Vec2i;
use serde_big_array::BigArray;

pub const CHUNK_SIZE: u32 = 32;
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    pub id: u64,
    pub bounds: GridBounds,
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    pub dimension_tag: String,
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}

impl ChunkData {
    pub const SIZE: u32 = CHUNK_SIZE;

    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    #[inline(always)]
    pub const fn zigzag_encode(n: i64) -> u64 {
        ((n << 1) ^ (n >> 63)) as u64
    }

    #[inline(always)]
    pub const fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);
        ux | (uy << 32)
    }
    
    #[inline(always)]
    fn coord_to_index_checked(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    #[inline(always)]
    pub const fn coord_to_index_unchecked(x: u32, y: u32) -> usize {
        (y * Self::SIZE + x) as usize
    }

    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    #[inline(always)]
    pub unsafe fn get_tile_unchecked(&self, x: u32, y: u32) -> &TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &self.tiles[index]
    }
    
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        match tiles_vec.try_into() {
            Ok(arr) => {
                unsafe { ptr::write(&mut self.tiles, arr) };
            }
            Err(vec) => {
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }

    #[inline(always)]
    pub unsafe fn get_tile_mut_unchecked(&mut self, x: u32, y: u32) -> &mut TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        &mut self.tiles[index]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_coord_to_index() {
        assert_eq!(ChunkData::coord_to_index_checked(0, 0), Some(0));
        assert_eq!(ChunkData::coord_to_index_checked(16, 16), Some(528));
        assert_eq!(ChunkData::coord_to_index_checked(31, 31), Some(1023));
        assert_eq!(ChunkData::coord_to_index_checked(32, 0), None);
        assert_eq!(ChunkData::coord_to_index_checked(0, 32), None);
        assert_eq!(ChunkData::coord_to_index_checked(33, 33), None);
        
        assert_eq!(ChunkData::coord_to_index_unchecked(0, 0), 0);
        assert_eq!(ChunkData::coord_to_index_unchecked(31, 31), 1023);
    }
    
    #[test]
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    fn test_hash_coords_2d() {
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        let big_x = i64::MAX / 2;
        let big_y = i64::MIN / 2;
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0);
    }
}

// --- END: rust/ssxl_shared/src\chunk\chunk_data.rs ---
        36 LOC | rust/ssxl_shared/src\chunk\grid_bounds.rs
// --- START: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
use crate::Serialize;
use crate::Deserialize;
// -----------------------------------------------------------------------------
// Grid Bounds Module Overview
// -----------------------------------------------------------------------------
// This module defines the fundamental 2D coordinate and bounding box structures
// used throughout the SSXL engine. These are essential for representing world-space
// positions and rectangular regions (chunks, tiles, or arbitrary areas).
//
// Key Components:
// - Coord2D: A single point in 2D world space.
// - GridBounds: A rectangular bounding box defined by min and max coordinates.
// -----------------------------------------------------------------------------
//
// Coord2D
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a single 2D coordinate in world space.
//   - Uses i64 to support extremely large coordinate ranges (beyond i32 limits).
// Derives:
//   - Debug, Clone, Copy: for easy inspection and duplication.
//   - PartialEq, Eq, PartialOrd, Ord, Hash: for comparisons and use in collections.
//   - Serialize, Deserialize: for persistence and networking.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    pub x: i64, // X component of the coordinate
    pub y: i64, // Y component of the coordinate
}

// -----------------------------------------------------------------------------
// GridBounds
// -----------------------------------------------------------------------------
// Purpose:
//   - Represents a rectangular region in 2D world space.
//   - Defined by inclusive minimum (min) and exclusive maximum (max) coordinates.
// Convention:
//   - Half-open range: [min, max)
//     * min is inclusive
//     * max is exclusive
//   - This ensures correct size calculation and avoids off-by-one errors.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    pub min: Coord2D, // Inclusive minimum coordinate (bottom-left corner)
    pub max: Coord2D, // Exclusive maximum coordinate (one past top-right corner)
}

impl GridBounds {
    // -------------------------------------------------------------------------
    // Constructor: new
    // -------------------------------------------------------------------------
    // Creates a new GridBounds from explicit min and max coordinates.
    // Arguments:
    //   - min_x, min_y: inclusive minimum coordinates
    //   - max_x, max_y: exclusive maximum coordinates
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    // -------------------------------------------------------------------------
    // Method: size
    // -------------------------------------------------------------------------
    // Calculates the width and height of the bounds.
    // Formula:
    //   size.x = max.x - min.x
    //   size.y = max.y - min.y
    // Works correctly with half-open ranges, yielding the number of integer
    // coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    // -------------------------------------------------------------------------
    // Method: contains
    // -------------------------------------------------------------------------
    // Checks if a given coordinate lies within the bounds.
    // Follows half-open range convention:
    //   - min.x <= coord.x < max.x
    //   - min.y <= coord.y < max.y
    // Returns:
    //   - true if inside bounds
    //   - false otherwise
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

// -----------------------------------------------------------------------------
// Default Implementation
// -----------------------------------------------------------------------------
// Provides a default GridBounds instance.
//   - min = (0,0)
//   - max = (0,0)
// Represents a zero-sized bounds at the origin.
impl Default for GridBounds {
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}

// --- END: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
         2 LOC | rust/ssxl_shared/src\chunk\mod.rs
// --- START: rust/ssxl_shared/src\chunk\mod.rs ---
// -----------------------------------------------------------------------------
// Chunk Module Overview
// -----------------------------------------------------------------------------
// This file serves as the **module root** for all chunk-related functionality
// in the `ssxl_shared` crate. It organizes and exposes submodules that define
// the data structures and utilities for handling chunks in the SSXL engine.
//
// Why this matters:
//   - Rust modules are hierarchical. Declaring `pub mod ...` here tells the compiler
//     to look for corresponding files (or directories) and include them as part of
//     the `chunk` namespace.
//   - By centralizing these declarations, we ensure that all chunk-related logic
//     is grouped together and can be accessed via `ssxl_shared::chunk::...`.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Submodule: chunk_data
// -----------------------------------------------------------------------------
// Contains the **ChunkData** struct, which represents a single chunk of the world.
// Responsibilities:
//   - Stores chunk ID, bounds, tiles, dimension tag, and timestamp.
//   - Provides methods for tile access, insertion, and coordinate hashing.
//   - Acts as the atomic unit of procedural generation and caching.
// Usage:
//   - Accessed via `ssxl_shared::chunk::chunk_data::ChunkData`.
pub mod chunk_data;

// -----------------------------------------------------------------------------
// Submodule: grid_bounds
// -----------------------------------------------------------------------------
// Contains the **GridBounds** struct and supporting types (Coord2D).
// Responsibilities:
//   - Defines rectangular bounding boxes in world space.
//   - Provides utilities for size calculation and containment checks.
//   - Used by ChunkData to represent the spatial extent of a chunk.
// Usage:
//   - Accessed via `ssxl_shared::chunk::grid_bounds::GridBounds`.
pub mod grid_bounds;

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------
// Together, `chunk_data` and `grid_bounds` form the foundation of chunk management:
//   - `chunk_data` handles the contents and metadata of a chunk.
//   - `grid_bounds` defines the spatial boundaries of a chunk.
// This modular design keeps responsibilities clear and makes the engine easier
// to maintain, extend, and test.
// -----------------------------------------------------------------------------

// --- END: rust/ssxl_shared/src\chunk\mod.rs ---
        41 LOC | rust/ssxl_shared/src\config\config.rs
// --- START: rust/ssxl_shared/src\config\config.rs ---
// -----------------------------------------------------------------------------
// Global Configuration Module Overview
// -----------------------------------------------------------------------------
// This module defines the configuration structure and constants that govern
// the SSXL engine’s behavior. It ensures consistent values across crates
// (math, generate, cache, godot) and provides safe defaults when loading fails.
//
// Key Components:
// - SSXLConfig: Struct holding runtime configuration settings.
// - CHUNK_SIZE / TILE_ARRAY_SIZE: Constants defining chunk geometry.
// - DEFAULT_CONFIG_PATH: Default path for configuration file.
// - new_with_defaults: Provides safe fallback values.
// - load_from_path: Attempts to load configuration (placeholder implementation).
// - default_generator_id: Accessor for generator ID.
// - get_config_from_path: Public function to load configuration safely.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Imports
// -----------------------------------------------------------------------------
// tracing::{info, warn}
//   - Logging macros for runtime diagnostics (info-level success, warn-level failure).
// std::error::Error
//   - Trait object used for error handling in load_from_path.
// serde::{Deserialize, Serialize}
//   - Enables serialization/deserialization of SSXLConfig for persistence and loading.
use tracing::{info, warn};
use std::error::Error;
use serde::{Deserialize, Serialize};

// -----------------------------------------------------------------------------
// Struct: SSXLConfig
// -----------------------------------------------------------------------------
// Purpose:
//   - Holds runtime configuration settings for the SSXL engine.
// Fields:
//   - ca_default_ruleset: Default ruleset ID for cellular automata generation.
//   - default_generator_id: Identifier for the default generator used in world creation.
// Derives:
//   - Debug, Clone: For inspection and duplication.
//   - Serialize, Deserialize: For persistence and loading from config files.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSXLConfig {
    pub ca_default_ruleset: u8,
    pub default_generator_id: String,
}

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
// CHUNK_SIZE
//   - Canonical side length of a chunk in tiles (32).
// TILE_ARRAY_SIZE
//   - Total number of tiles in a chunk (32 * 32 = 1024).
// DEFAULT_CONFIG_PATH
//   - Default file path for configuration JSON.
pub const CHUNK_SIZE: u32 = 32;
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
const DEFAULT_CONFIG_PATH: &str = "res://ssxl_config.json";

// -----------------------------------------------------------------------------
// Implementation: SSXLConfig
// -----------------------------------------------------------------------------
impl SSXLConfig {
    // -------------------------------------------------------------------------
    // Method: new_with_defaults
    // -------------------------------------------------------------------------
    // Provides a safe, hardcoded default configuration.
    // Ensures engine can initialize even if config file is missing or invalid.
    pub fn new_with_defaults() -> Self {
        SSXLConfig {
            ca_default_ruleset: 1,
            default_generator_id: "default_noise_gen".to_string(),
        }
    }

    // -------------------------------------------------------------------------
    // Method: load_from_path
    // -------------------------------------------------------------------------
    // Attempts to load configuration from a file path.
    // Currently a placeholder: always returns defaults.
    // Returns:
    //   - Ok(Self) on success
    //   - Err(Box<dyn Error>) on failure
    pub fn load_from_path(_path: &str) -> Result<Self, Box<dyn Error>> {
        Ok(SSXLConfig::new_with_defaults())
    }
    
    // -------------------------------------------------------------------------
    // Method: default_generator_id
    // -------------------------------------------------------------------------
    // Accessor for the default generator ID.
    // Returns a clone of the string to avoid ownership issues.
    pub fn default_generator_id(&self) -> String {
        self.default_generator_id.clone()
    }
}

// -----------------------------------------------------------------------------
// Function: get_config_from_path
// -----------------------------------------------------------------------------
// Purpose:
//   - Public entry point for loading configuration.
//   - Attempts to load from provided path or falls back to DEFAULT_CONFIG_PATH.
// Behavior:
//   - On success: logs info and returns loaded config.
//   - On failure: logs warning and returns safe defaults.
// Ensures engine always initializes with valid configuration.
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            warn!(
                "Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.",
                path_to_load,
                e
            );
            SSXLConfig::new_with_defaults()
        }
    }
}

// --- END: rust/ssxl_shared/src\config\config.rs ---
         1 LOC | rust/ssxl_shared/src\config\mod.rs
// --- START: rust/ssxl_shared/src\config\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/config/mod.rs
// -----------------------------------------------------------------------------
// Purpose:
//   - This file acts as the *module root* for configuration logic in the
//     `ssxl_shared` crate.
//   - By declaring `pub mod config;`, it exposes the `config.rs` file as a
//     public submodule, making its types and functions available under
//     `ssxl_shared::config::...`.
//
// Why it matters:
//   - Keeps the crate organized: all configuration constants and structs live
//     in one place.
//   - Provides a clean namespace boundary, so other crates can import
//     `SSXLConfig` or constants without digging into file paths.
// -----------------------------------------------------------------------------
pub mod config;

// --- END: rust/ssxl_shared/src\config\mod.rs ---
        21 LOC | rust/ssxl_shared/src\error\errors.rs
// --- START: rust/ssxl_shared/src\error\errors.rs ---
use thiserror::Error;

// -----------------------------------------------------------------------------
// SSXLResult
// -----------------------------------------------------------------------------
// A project-wide Result type that standardizes error handling.
// All fallible functions in the SSXL engine should return this type.
pub type SSXLResult<T> = Result<T, SSXLError>;

// -----------------------------------------------------------------------------
// SSXLError
// -----------------------------------------------------------------------------
// Central error enumeration for the SSXL engine.
// Each variant represents a distinct failure category, ensuring consistent
// reporting across subsystems and FFI boundaries.
#[derive(Error, Debug)]
pub enum SSXLError {
    // I/O failures such as file system or network errors.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    // Serialization or deserialization problems (e.g., Bincode, Serde).
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    // Invalid or inconsistent data states (e.g., wrong tile array size).
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    // Failures in the procedural generation pipeline.
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    // Errors in the Godot bridge or FFI layer.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    // Critical, unexpected bug in core logic.
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    // Wrapper for errors from external crates not covered elsewhere.
    #[error("External Crate Error: {0}")]
    External(String),
}

// -----------------------------------------------------------------------------
// Error Conversions
// -----------------------------------------------------------------------------
// Provides convenient conversions from common external error types into SSXLError.
// Ensures external libraries integrate smoothly with the SSXL error system.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}

// --- END: rust/ssxl_shared/src\error\errors.rs ---
         1 LOC | rust/ssxl_shared/src\error\mod.rs
// --- START: rust/ssxl_shared/src\error\mod.rs ---
// -----------------------------------------------------------------------------
// Module Declaration: ssxl_shared/src/error/mod.rs
// -----------------------------------------------------------------------------
// This file is the entry point for the `error` namespace in the `ssxl_shared` crate.
// By declaring `pub mod errors;`, it exposes the `errors.rs` submodule, which
// contains the canonical `SSXLError` enum and `SSXLResult` type alias.
// Purpose:
//   - Centralizes error handling for the engine.
//   - Provides a clean namespace so other crates can import errors via
//     `ssxl_shared::error::SSXLError` or `ssxl_shared::error::SSXLResult`.
// -----------------------------------------------------------------------------
pub mod errors;

// --- END: rust/ssxl_shared/src\error\mod.rs ---
        22 LOC | rust/ssxl_shared/src\job\mod.rs
// --- START: rust/ssxl_shared/src\job\mod.rs ---
// ============================================================================
// ⚡ SSXL Job Module ⚡
// File: ssxl_shared/src/job/mod.rs
// ----------------------------------------------------------------------------
// This module is the **command center** of the SSXL engine.
// It defines the packets of intent (jobs) and the packets of outcome (results)
// that flow between the engine core and its generation pipeline.
// Think of it as the **messenger guild**: jobs go in, results come out.
// ============================================================================

use crate::ChunkData; // 🎯 Core chunk payload imported from lib.rs

// -----------------------------------------------------------------------------
// 🚀 Instruction Packet: SSXLJob
// -----------------------------------------------------------------------------
// Represents the set of commands the engine can receive.
// Each variant is a ritual order, telling the generator what to do next.
pub enum SSXLJob {
    // 🗺️ BuildMap: Spin up a new world grid with given dimensions and seed.
    BuildMap {
        width: u32,
        height: u32,
        seed: u64,
        generator_id: String, // 🔑 Which generator to invoke
    },

    // 🔧 SetGenerator: Swap out the active generator configuration mid-flight.
    SetGenerator {
        generator_id: String,
    },

    // 🛑 StopGeneration: Halt all jobs, both running and queued.
    StopGeneration,

    // ... Future expansion: more job types can be added here.
}

// -----------------------------------------------------------------------------
// 🎯 Result Packet: JobResult
// -----------------------------------------------------------------------------
// Represents the outcomes returned back to the engine tick loop.
// Each variant is a signal of success, completion, or failure.
pub enum JobResult {
    // 🌟 ChunkGenerated: A new chunk is ready for integration into world state.
    ChunkGenerated {
        x: i32,          // Explicit coordinates for clarity
        y: i32,
        data: ChunkData, // 📦 The freshly minted chunk payload
    },

    // ✅ MapBuildComplete: The BuildMap job has finished successfully.
    MapBuildComplete,

    // 💥 Error: Something went wrong during job execution.
    Error(String),
}

// --- END: rust/ssxl_shared/src\job\mod.rs ---
        53 LOC | rust/ssxl_shared/src\lib.rs
// --- START: rust/ssxl_shared/src\lib.rs ---
use serde::{Deserialize, Serialize};
use tracing;

pub mod chunk;
pub mod tile;
pub mod error;
pub mod config;
pub mod message;
pub mod math;
pub mod job;

pub use config::config::{get_config_from_path, SSXLConfig}; // ADDED: Re-exporting Config access
pub use ssxl_math::primitives::{ChunkId, TileCoord};

pub use chunk::chunk_data::{ChunkData, CHUNK_SIZE};
pub use tile::tile_data::TileData;
pub use chunk::grid_bounds::GridBounds;
pub use tile::tile_type::TileType;

pub use message::messages::{
    AnimationCommand,
    AnimationType,
    AnimationPayload,
    UpdateSender,
    AnimationConductorHandle,
    AnimationState,
    CommandResult,
    AnimationUpdate,
};

pub use error::errors::{SSXLError, SSXLResult};
pub use anyhow;

// ──────────────────────────────────────────────────────────────────────────────
// FFI Export Function for CLI (ssxl_start_runtime)
// ──────────────────────────────────────────────────────────────────────────────
/// Initializes the core engine runtime (primarily for the CLI) and returns a success status.
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    initialize_shared_data();
    tracing::info!("FFI Function `ssxl_start_runtime` called and shared initialization completed.");
    true 
}

// ──────────────────────────────────────────────────────────────────────────────
// Shared Data Structures
// ──────────────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

pub mod prelude {
    pub use super::chunk::chunk_data::{ChunkData, CHUNK_SIZE};
    pub use super::tile::tile_data::TileData;
    pub use super::chunk::grid_bounds::GridBounds;
    pub use super::tile::tile_type::TileType;
    
    pub use super::{ChunkId, TileCoord};
    
    pub use super::error::errors::{SSXLError, SSXLResult};
    
    // UPDATED: Added AnimationState to the prelude
    pub use super::message::messages::{AnimationCommand, AnimationType, AnimationState};
    pub use super::message::messages::AnimationUpdate;

    // ADDED: Adding SSXLConfig to the prelude for easy access
    pub use super::config::config::SSXLConfig;
}

use std::sync::atomic::AtomicUsize;

pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);
// --- END: rust/ssxl_shared/src\lib.rs ---
        20 LOC | rust/ssxl_shared/src\math\math_primitives.rs
// --- START: rust/ssxl_shared/src\math\math_primitives.rs ---
// ============================================================================
// 🧮 Math Primitives & Serde Helpers
// File: ssxl_shared/src/math_primitives.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Provides custom serialization/deserialization logic for mathematical and
//     standard library types that require deterministic formatting.
//   - Ensures cross-platform compatibility and stable persistence when caching
//     or transmitting data across the SSXL engine ecosystem.
//
// Why it matters:
//   - Default Serde behavior for certain types (like SystemTime) can vary
//     depending on platform or implementation.
//   - By enforcing a canonical format (milliseconds since UNIX epoch), we
//     guarantee consistency across all crates (math, generate, cache, godot).
// ============================================================================

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};

// -----------------------------------------------------------------------------
// ⏱️ Module: system_time_serde
// -----------------------------------------------------------------------------
// Custom Serde helpers for `std::time::SystemTime`.
// Converts SystemTime <-> u64 (milliseconds since epoch).
// This ensures:
//   - Deterministic representation (always the same format).
//   - Platform independence (no OS-specific quirks).
//   - Stable caching and networking (safe to persist and reload).
// -----------------------------------------------------------------------------
pub mod system_time_serde {
    use super::*;

    // -------------------------------------------------------------------------
    // Function: serialize
    // -------------------------------------------------------------------------
    // Converts a SystemTime into a u64 millisecond count since UNIX_EPOCH.
    // Steps:
    //   1. Compute duration since epoch.
    //   2. Convert duration to milliseconds.
    //   3. Serialize as u64.
    // Usage:
    //   - Called automatically by Serde when writing data structures containing
    //     SystemTime (e.g., saving ChunkData to disk or sending over network).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Duration since epoch; errors if time < UNIX_EPOCH.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert to milliseconds (u64).
        let ms = duration.as_millis() as u64;
        // Serialize the millisecond count.
        serializer.serialize_u64(ms)
    }

    // -------------------------------------------------------------------------
    // Function: deserialize
    // -------------------------------------------------------------------------
    // Converts a u64 millisecond count back into a SystemTime.
    // Steps:
    //   1. Deserialize u64 from input.
    //   2. Create Duration from milliseconds.
    //   3. Add Duration to UNIX_EPOCH to reconstruct SystemTime.
    // Usage:
    //   - Called automatically by Serde when reading data structures containing
    //     SystemTime (e.g., loading ChunkData from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Read the millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert back into SystemTime.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}

// --- END: rust/ssxl_shared/src\math\math_primitives.rs ---
         1 LOC | rust/ssxl_shared/src\math\mod.rs
// --- START: rust/ssxl_shared/src\math\mod.rs ---
// src/math/mod.rs
pub mod math_primitives;

// --- END: rust/ssxl_shared/src\math\mod.rs ---
        13 LOC | rust/ssxl_shared/src\message\generation_message.rs
// --- START: rust/ssxl_shared/src\message\generation_message.rs ---
// ============================================================================
// 📡 Generation Messaging
// File: ssxl_shared/src/message/generation_message.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Defines the communication protocol between the Conductor (main thread)
//     and worker threads in the SSXL engine.
//   - Provides structures for sending generation tasks into the pipeline and
//     receiving results or status updates back.
//   - Ensures messages are serializable for persistence, networking, or debugging.
// ============================================================================

use crate::chunk::chunk_data::ChunkData;   // Core chunk payload type
use ssxl_math::prelude::Vec2i;             // 2D integer vector for chunk coordinates
use std::sync::Arc;                        // Atomic reference-counted pointer for safe sharing
use serde::{Serialize, Deserialize};       // Serialization traits for message passing

// -----------------------------------------------------------------------------
// 🛠️ Work Request Structure: GenerationTask
// -----------------------------------------------------------------------------
// Represents a single unit of work to be performed by a worker thread.
// Inserted into the engine’s TaskQueue by the Conductor.
// Fields:
//   - chunk_coords: identifies which chunk in chunk-space should be generated.
//   - generator_id: specifies which generator algorithm to use (e.g. "cellular_automata").
// Derives:
//   - Debug, Clone: for inspection and duplication.
//   - Serialize, Deserialize: for persistence and cross-thread communication.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationTask {
    pub chunk_coords: Vec2i,     // Target chunk coordinates in grid space
    pub generator_id: String,    // Generator identifier string
}

// -----------------------------------------------------------------------------
// 📬 Communication Message Enumeration: GenerationMessage
// -----------------------------------------------------------------------------
// Represents messages sent back from worker threads to the Conductor.
// Each variant signals a different type of pipeline outcome.
// Variants:
//   - Generated: A chunk has been successfully produced.
//   - StatusUpdate: Informational message about progress or internal state.
//   - GenerationComplete: Signals that all tasks in a batch are finished.
// -----------------------------------------------------------------------------
#[derive(Debug, Serialize, Deserialize)]
pub enum GenerationMessage {
    // 🌟 Generated: A new chunk is ready.
    // Payload:
    //   - Vec2i: coordinates of the chunk.
    //   - Arc<ChunkData>: reference-counted chunk data for safe sharing.
    Generated(Vec2i, Arc<ChunkData>),

    // 📊 StatusUpdate: Provides progress or state information.
    // Example: "50% complete" or "Switching generator mode".
    StatusUpdate(String),

    // ✅ GenerationComplete: Marks the end of a batch of tasks.
    // Used by the Conductor to update global generation state.
    GenerationComplete,
}

// --- END: rust/ssxl_shared/src\message\generation_message.rs ---
        52 LOC | rust/ssxl_shared/src\message\messages.rs
// --- START: rust/ssxl_shared/src\message\messages.rs ---
// ============================================================================
// 🎭 Messaging System
// File: ssxl_shared/src/message/messages.rs
// ----------------------------------------------------------------------------
// Purpose:
//   - Defines the communication structures for animation and generation tasks.
//   - Provides enums, structs, and type aliases used to send commands and updates
//     between different subsystems (Conductor, workers, engine).
//   - Ensures all messages are serializable for persistence, networking, or debugging.
// ============================================================================

use tokio::sync::mpsc::UnboundedSender; // Async channel for sending updates/commands
use crate::{ChunkId, TileCoord};        // Core identifiers for chunks and tiles
use serde::{Deserialize, Serialize};    // Serialization traits for message passing

// -----------------------------------------------------------------------------
// 🎨 AnimationType
// -----------------------------------------------------------------------------
// Defines the types of animations that can be applied to tiles or chunks.
// Variants:
//   - TileFlip: flips a tile’s visual state.
//   - TweenMove: interpolates movement between positions.
//   - PulseFade(f32): fades with intensity parameter.
//   - CustomScripted(String): custom animation defined by script identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

// -----------------------------------------------------------------------------
// 🎨 AnimationPayload
// -----------------------------------------------------------------------------
// Represents the data payload for an animation update.
// Variants:
//   - FrameUpdate: updates to a specific frame index.
//   - TweenValue: key/value pair for tweening (e.g., opacity, position).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

// -----------------------------------------------------------------------------
// 🎨 AnimationUpdate
// -----------------------------------------------------------------------------
// A single animation update message.
// Fields:
//   - coord: tile coordinate being animated.
//   - payload: the animation data to apply.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

// -----------------------------------------------------------------------------
// 🎨 AnimationCommand
// -----------------------------------------------------------------------------
// Commands sent to the animation subsystem.
// Variants:
//   - AnimateChunkSet: apply animation to a set of chunks.
//   - StartTestAnimation: trigger a test animation sequence.
//   - SetTimeScale(f32): adjust animation speed.
//   - SetEnabled(bool): enable/disable animations globally.
//   - Shutdown: stop the animation subsystem.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationCommand {
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    StartTestAnimation,
    SetTimeScale(f32),
    SetEnabled(bool),
    Shutdown,
}

// Type alias for sending animation updates through an async channel.
pub type UpdateSender = UnboundedSender<AnimationUpdate>;

// -----------------------------------------------------------------------------
// ⚙️ GenerationCommand
// -----------------------------------------------------------------------------
// Commands for the generation subsystem.
// Variants:
//   - GenerateChunk: request generation of a specific chunk.
//   - SetGenerator: change active generator by ID.
//   - Shutdown: stop generation subsystem.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GenerationCommand {
    GenerateChunk { coords: TileCoord },
    SetGenerator { id: String },
    Shutdown,
}

// -----------------------------------------------------------------------------
// ⚙️ GenerationResponse
// -----------------------------------------------------------------------------
// Response structure for generation commands.
// Fields:
//   - success: indicates if the command succeeded.
//   - message: human-readable status or error message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationResponse {
    pub success: bool,
    pub message: String,
}

// Type alias for sending animation commands to the conductor.
pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

// Type alias for generic command results (Ok or error string).
pub type CommandResult = Result<(), String>;

// -----------------------------------------------------------------------------
// 🎛️ AnimationState
// -----------------------------------------------------------------------------
// Represents the current state of the animation subsystem.
// Fields:
//   - time_scale: multiplier for animation speed.
//   - is_enabled: global toggle for enabling/disabling animations.
// Provides setters for updating state.
#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
pub struct AnimationState {
    pub time_scale: f32,
    pub is_enabled: bool,
}

impl AnimationState {
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}

// -----------------------------------------------------------------------------
// 🔗 Re-export
// -----------------------------------------------------------------------------
// Re-exports GenerationMessage from generation_message.rs as ChunkMessage.
// This allows unified access to generation-related messages under this module.
pub use super::generation_message::GenerationMessage as ChunkMessage;

// --- END: rust/ssxl_shared/src\message\messages.rs ---
         9 LOC | rust/ssxl_shared/src\message\mod.rs
// --- START: rust/ssxl_shared/src\message\mod.rs ---
// FILE: ssxl_shared/src/message/mod.rs

pub mod generation_message;
pub mod messages;

// FIX: Publicly re-export all necessary message and state types from the messages submodule.
// This resolves the unresolved imports (E0432) in ssxl_godot/api_initializers.rs.
pub use messages::{
    // New re-exports to fix current error
    AnimationCommand,
    AnimationState,
    
    // Existing re-exports
    AnimationUpdate,
    GenerationCommand, 
    GenerationResponse,
};
// --- END: rust/ssxl_shared/src\message\mod.rs ---
         2 LOC | rust/ssxl_shared/src\tile\mod.rs
// --- START: rust/ssxl_shared/src\tile\mod.rs ---
// ssxl_shared/src/tile/mod.rs

pub mod tile_data;
pub mod tile_type;
// --- END: rust/ssxl_shared/src\tile\mod.rs ---
        51 LOC | rust/ssxl_shared/src\tile\tile_data.rs
// --- START: rust/ssxl_shared/src\tile\tile_data.rs ---
// ssxl_shared/src/tile/tile_data.rs

//! # Tile Data Structures (`ssxl_shared::tile::tile_data`) 
//!
//! This module defines the `TileData` structure, which holds the minimal necessary
//! information for a single tile in the procedural world. It also includes utility
//! structures and bitmask constants (`tile_flags`) for efficient property management.
//! The use of `Copy` and `u8` flags is key to maintaining the high-speed "Tempo"
//! of the multi-threaded engine.

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};

// Re-exports a core math primitive for use in related structures (e.g., AnimationUpdate).
use ssxl_math::prelude::Vec2i;


// --- Core Data Structure ---

/// Represents the data payload for a single tile in a chunk.
///
/// Marked `Copy` for high performance, as tiles are frequently cloned/copied
/// within generation and rendering loops.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The material or type of tile (e.g., grass, rock, empty).
    pub tile_type: TileType,
    
    /// The raw noise value (e.g., Perlin, Simplex) used to determine this tile's type.
    /// This is crucial for seamless neighbor checks and debugging the procedural generation.
    pub noise_value: f32,
    
    /// A compact bitfield storing up to 8 boolean properties about the tile.
    pub flags: u8,
}

impl Default for TileData {
    /// Returns the default state for a tile: `TileType::Void` with zero noise and no flags set.
    // FIX: Removed `const` keyword to resolve error E0379 and E0015.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}


// --- Godot FFI Message Structure ---

/// Data structure used specifically for communication between the Rust engine
/// and the Godot runtime regarding tile animations.
///
/// This message is typically used by a dedicated rendering or animation system.
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub struct AnimationUpdate {
    /// The layer or dimension the tile belongs to.
    pub layer: i32,
    /// The source ID of the tile map or animation source.
    pub source_id: i32,
    /// The world coordinates of the tile to update.
    pub tile_coords: Vec2i,
    /// The new coordinates within the texture atlas for the tile's animation frame.
    pub new_atlas_coords: Vec2i,
}


// --- Bitwise Flag Constants ---

/// Bitmasks used to set, check, or clear properties in the `TileData::flags` field.
/// This maximizes data density by storing 8 booleans in a single byte (`u8`).
pub mod tile_flags {
    /// Bit 0: Is the tile physically passable by entities? (e.g., air, water surface)
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001;
    /// Bit 1: Is the tile currently visible/rendered by the client?
    pub const IS_RENDERED:   u8 = 0b0000_0010;
    /// Bit 2: Has this tile been manually changed post-generation by a player/editor?
    pub const IS_MODIFIED:   u8 = 0b0000_0100;
    /// Bit 3: Does this tile contain a gatherable resource or item?
    pub const HAS_RESOURCE:    u8 = 0b0000_1000;
    // Bits 4-7 are reserved for future properties.
}


impl TileData {
    /// Creates a new `TileData` instance with specified type and noise value.
    // FIX: Removed `const` keyword.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0, // Flags are initialized to zero (all false)
        }
    }

    /// Checks if the tile is considered a "solid" block, typically used for collision.
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub const fn is_solid(&self) -> bool {
        // Relies on a method in TileType to define "solidity."
        !self.tile_type.is_empty()
    }
    
    /// Sets or clears a property using a predefined **flag mask** (e.g., `tile_flags::IS_TRAVERSABLE`).
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            // Set the bit(s) (|= is bitwise OR assignment).
            self.flags |= flag_mask;
        } else {
            // Clear the bit(s) (&! is bitwise AND with the inverted mask).
            self.flags &= !flag_mask;
        }
    }

    /// Checks the status of a property using a predefined **flag mask**.
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        // Returns true if any of the bits in the mask are set in self.flags.
        (self.flags & flag_mask) != 0
    }
}
// --- END: rust/ssxl_shared/src\tile\tile_data.rs ---
        60 LOC | rust/ssxl_shared/src\tile\tile_type.rs
// --- START: rust/ssxl_shared/src\tile\tile_type.rs ---
// ssxl_shared/src/tile/tile_type.rs

//! # Tile Type Enumeration (`ssxl_shared::tile::tile_type`)
//!
//! This module defines the canonical `TileType` enum, which identifies the material
//! or nature of a single tile. It is a fundamental data structure shared across
//! the entire SSXL-ext engine.
//!
//! **Critical Feature:** The use of `#[repr(u8)]` is a **memory optimization**
//! that guarantees the enum is stored as a single byte, drastically reducing the
//! memory footprint of the massive `ChunkData` tile arrays.

use serde::{Deserialize, Serialize};

/// Enumeration of all primary tile materials available in the procedural world.
///
/// Ensures strict memory layout as a single byte for efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    /// The default, empty state (e.g., air or background).
    Void = 0,
    /// A fluid, typically used for rivers, oceans, or lower areas.
    Water = 1,
    /// Base terrain, usually flat and traversable.
    Grass = 2,
    /// Elevated terrain, potentially difficult to traverse.
    Mountain = 3,
    /// An artificial boundary used to cap chunk edges or isolate generation regions.
    Boundary = 4,
    /// An engineered or placed structure (e.g., a ruin, road, or wall).
    Structure = 5,
    /// A solid, rocky, non-soil terrain type.
    Rock = 6,
    /// Reserved for generator-specific customization or future expansion.
    Custom1 = 7,
    /// Reserved for generator-specific customization or future expansion.
    Custom2 = 8,
    // Maximum defined variant value is 8.
}

// Constant to define the maximum valid u8 value for TileType.
pub const MAX_TILE_TYPE_VALUE: u8 = 8;


impl Default for TileType {
    /// The default state of a tile is always `TileType::Void` (empty).
    // FIX: Removed `const` keyword to resolve error E0379.
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Converts the `TileType` instance into its underlying `u8` representation.
    // OPTIMIZATION: Added inline hint and const fn for zero-cost conversion.
    #[inline(always)] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a raw `u8` value back into a `TileType`.
    ///
    /// Returns `None` if the input value does not correspond to a defined variant,
    /// ensuring safe deserialization.
    // OPTIMIZATION: Replaced verbose match with range check and unsafe transmute for zero-cost speed.
    #[inline(always)]
    pub fn from_u8(value: u8) -> Option<Self> {
        if value <= MAX_TILE_TYPE_VALUE {
            // SAFETY: We check that the value is within the contiguous range [0, 8]
            // of the #[repr(u8)] enum. This is a common pattern for fast enum conversion.
            Some(unsafe { std::mem::transmute(value) })
        } else {
            None
        }
    }
    
    /// Provides a simple, default unique ID for this tile type (equal to its u8 value).
    #[inline(always)]
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Provides default atlas coordinates (X, Y) for initial rendering/visual representation.
    ///
    /// This is a common lookup function used by the rendering component (`ssxl_godot`).
    #[inline(always)]
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // All default tiles are expected to be on the first row (Y=0) of the atlas.
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            // Void and unspecified types default to the origin (0, 0).
            _ => (0, 0), 
        }
    }
}


impl TileType {
    /// Checks if the tile type is one that a character can typically traverse (walk on).
    #[inline(always)]
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type is considered a fluid (e.g., for flow/buoyancy simulation).
    #[inline(always)]
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is empty (the default/void state).
    #[inline(always)]
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}
// --- END: rust/ssxl_shared/src\tile\tile_type.rs ---
        40 LOC | rust/ssxl_sync/src\animation_conductor.rs
// --- START: rust/ssxl_sync/src\animation_conductor.rs ---
// ssxl_sync/src/animation_conductor.rs (Type Resolution Fix)

use ssxl_shared::{
    AnimationConductorHandle,
    AnimationState,
    AnimationCommand, 
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tracing::info;

// FIX: Import the exact nested type required by the CoreAnimationWorker's signature 
// and alias it as `AnimationUpdate`. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: We rely on the core worker being defined as `conductor::AnimationConductor` within ssxl_animate.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct (for passing state between FFI stages)
// -----------------------------------------------------------------------------

/// Holds all the necessary internal channels and initial state required to spawn the
/// heavy, background Animation Conductor thread.
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,
    /// The receiver for Godot commands, which the worker thread will consume.
    pub command_receiver: UnboundedReceiver<AnimationCommand>,
    
    /// The sender for updates, which the worker thread will use.
    // This field now holds the correctly nested type due to the aliased import above.
    pub update_sender: UnboundedSender<AnimationUpdate>,
}

// -----------------------------------------------------------------------------
// 2. The Public Conductor Struct (The FFI-facing worker wrapper)
// -----------------------------------------------------------------------------

/// The SSXL Animation Conductor. This struct is responsible for executing the
/// animation logic in a background thread.
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup (Non-blocking)
    // -------------------------------------------------------------------------
    
    /// Creates all the necessary MPSC channels and the initial `AnimationState`.
    /// 
    /// # Returns
    /// A tuple containing:
    /// 1. `AnimationConductorInternalSetup`: The struct holding internal handles for spawning.
    /// 2. `AnimationConductorHandle`: The public command sender handle exposed to Godot's FFI layer.
    /// 3. `UnboundedReceiver<AnimationUpdate>`: The public update receiver handle exposed to Godot's Poller.
    pub fn setup_channels_and_state() -> (AnimationConductorInternalSetup, AnimationConductorHandle, UnboundedReceiver<AnimationUpdate>) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channels for commands from Godot to the worker.
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channels for updates from the worker to Godot (Poller).
        // This channel uses the correctly aliased type.
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        let initial_state = AnimationState::default();

        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        let public_command_handle: AnimationConductorHandle = command_tx;



        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------

    /// Consumes the setup handles and spawns the core animation worker thread.
    /// 
    /// # Arguments
    /// * `setup`: The internal channels and initial state from the setup stage.
    /// 
    /// # Returns
    /// A new `AnimationConductor` instance representing the running worker.
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // This call is now correct because `setup.update_sender` holds the 
        // type the `CoreAnimationWorker::new` function requires.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the opaque public handle struct
        AnimationConductor {} 
    }
}
// --- END: rust/ssxl_sync/src\animation_conductor.rs ---
        21 LOC | rust/ssxl_sync/src\lib.rs
// --- START: rust/ssxl_sync/src\lib.rs ---
//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//! 
//! This crate defines core thread-safe primitives, thread pool management, 
//! and high-level FFI channel handles for communication across the engine's asynchronous boundary.

use tokio::sync::mpsc;

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import all core contract types from ssxl_shared.
use ssxl_shared::{
    SSXLError,
    AnimationUpdate,
    AnimationCommand,
    //AnimationConductorHandle, // <-- import the alias directly
};
// FIX: Import and public re-export the core struct in one step to avoid E0252/E0365.
pub use ssxl_animate::AnimationConductor;

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

pub mod primitives;
pub mod pool;
pub mod animation_conductor;

// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

pub use primitives::{AtomicResource, create_unbounded_channel};

pub use pool::{
    WorkerPool,
    GenerationTask,
    ConductorResult,
    Task,
    TaskResult,
};

// --------------------------------------------------------------------------------
// --- Final FFI Wrappers and Type Aliases (CRATE ROOT API) ---
// --------------------------------------------------------------------------------

pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;
pub type UpdateSender   = mpsc::UnboundedSender<AnimationUpdate>;
pub type CommandResult  = Result<(), SSXLError>;

// ✅ No struct wrapper here — rely on the alias from ssxl_shared

// --- END: rust/ssxl_sync/src\lib.rs ---
        96 LOC | rust/ssxl_sync/src\pool.rs
// --- START: rust/ssxl_sync/src\pool.rs ---
//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::prelude::Vec2i;
// FIX: Import ChunkData directly from the root of ssxl_shared to resolve both E0433 errors.
use ssxl_shared::ChunkData; 

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    // FIX 1 (Line 47): Use the directly imported ChunkData.
    CompletedChunk(Arc<ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // FIX 2 (Line 130): Use the directly imported ChunkData.
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
// --- END: rust/ssxl_sync/src\pool.rs ---
        27 LOC | rust/ssxl_sync/src\primitives.rs
// --- START: rust/ssxl_sync/src\primitives.rs ---
// ssxl_sync/src/primitives.rs

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
// DELETE: tracing::info removed (placeholder worker function removed)

// --------------------------------------------------------------------------------
// --- Thread-Safe Resource Management (AtomicResource) ---
// --------------------------------------------------------------------------------

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline(always)] // O(1) Accessor: Force inlining
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline(always)] // O(1) Mutator: Force inlining
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

// --------------------------------------------------------------------------------
// --- Synchronization Primitives (Channels) ---
// --------------------------------------------------------------------------------

/// Creates an unbounded, multi-producer, single-consumer channel.
/// Generic over message type `M` (Zero Entropy).
pub fn create_unbounded_channel<M>() -> (Sender<M>, Receiver<M>) {
    unbounded()
}
// DELETE: start_sync_worker placeholder removed (non-primitive code).
// --- END: rust/ssxl_sync/src\primitives.rs ---
        50 LOC | rust/ssxl_tools/src\lib.rs
// --- START: rust/ssxl_tools/src\lib.rs ---
//! # SSXL Engine Tools (`ssxl_tools`)
//!
//! Provides utility functions for **configuration management**, **data validation**,
//! and other engine-wide tooling not specific to generation or synchronization.

// MINIMALIST IMPORTS: Removed regex, Lazy, Read, and ssxl_shared::SSXLData
use tracing::{info, warn};
use std::io;
use std::fs::File; // Kept for configuration file existence check

// --------------------------------------------------------------------------------
// --- Configuration Constants ---
// --------------------------------------------------------------------------------

/// The default file path to check for engine configuration.
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
/// The ID of the generator used when configuration loading fails or is not specified.
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
/// The default Cellular Automata ruleset ID to use.
const DEFAULT_CA_RULESET: u8 = 0;

// --------------------------------------------------------------------------------
// --- SSXL Configuration Management ---
// --------------------------------------------------------------------------------

#[derive(Debug, Clone)]
/// Configuration structure holding key engine settings, primarily for generation defaults.
pub struct SSXLConfig {
    /// The ID of the world generator to use when no specific one is requested.
    default_generator_id: String,
    /// The default ruleset ID for the Cellular Automata generator.
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Creates a new `SSXLConfig` instance populated with hardcoded default values.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to read and simulate loading engine configuration from a file path.
    ///
    /// The file content is not read (O(0) optimization) as it is currently simulated.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(_file) => {
                // O(0) Optimization: Config parsing is simulated, eliminating O(N) file read overhead.
                info!("SSXLConfig: Config file found. Simulating config override (No TOML parsing).");
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), // Simulated override
                    ca_default_ruleset: 1,                              // Simulated override
                })
            },
            // Propagate standard I/O error to the public getter for logging.
            Err(e) => Err(e),
        }
    }

    /// Returns the configured default generator ID string. (O(1) Accessor)
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Returns the configured default Cellular Automata ruleset ID. (O(1) Accessor)
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Attempts to load the configuration from the specified path.
///
/// If file loading fails, it logs a warning and returns hardcoded defaults (safe fallback).
/// **O(0) Entropy Fix**: Returns `SSXLConfig` directly, reflecting the guaranteed success (safe fallback).
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            // Safe fallback: Logs failure but ensures the engine initializes with defaults.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            SSXLConfig::new_with_defaults()
        }
    }
}

// --------------------------------------------------------------------------------
// --- DEPRECATED/REDUNDANT CODE REMOVED ---
// --------------------------------------------------------------------------------
// DELETED: Static CONFIG and get_config() (Deprecated).
// DELETED: ID_REGEX, validate_data_id, and initialize() (Redundant validation on u64).
// --- END: rust/ssxl_tools/src\lib.rs ---
       147 LOC | rust/ssxl_cli/src\actions\actions.rs
// --- START: rust/ssxl_cli/src\actions\actions.rs ---
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

pub fn run_communication_channel_test() {
    info!("TEST [2]: Starting Async Communication Channel Validation (Thread Jump Tempo Check)...");
    
    let (tx, rx) = mpsc::channel::<(String, String)>();

    let engine_test_thread = thread::spawn(move || {
        info!("WORKER: Starting 500ms sleep simulation (Simulating heavy map chunk 1 work)...");
        thread::sleep(Duration::from_millis(500));
        
        let message = "Async signal emission successful. Latency: 500ms".to_string();
        
        if tx.send(("TEST_COMPLETE".to_string(), message)).is_err() {
            error!("WORKER: Failed to send test signal. Receiver dropped (Godot side crashed?).");
        } else {
            info!("WORKER: Successfully sent TEST_COMPLETE signal back to main thread.");
        }
    });

    match rx.recv_timeout(Duration::from_secs(2)) {
        Ok((status, message)) => {
            if status == "TEST_COMPLETE" {
                info!("✅ SUCCESS: Communication Channel Validated. {}", message);
                info!("   Thread jump integrity confirmed.");
            } else {
                error!("❌ FAIL: Received incorrect status: {}", status);
            }
        },
        Err(mpsc::RecvTimeoutError::Timeout) => {
            error!("❌ FAIL: Timeout (2s). Communication channel failed to establish required tempo.");
        },
        Err(mpsc::RecvTimeoutError::Disconnected) => {
            error!("❌ FAIL: Worker thread disconnected unexpectedly (Systemic Entropy).");
        }
    }
    
    engine_test_thread.join().unwrap();
}

pub fn run_map_generation_test() {
    info!("TEST [4]: Starting Map Generation Flow Validation (Procedural Purity & Streaming)...");

    let (data_tx, data_rx) = mpsc::channel::<usize>();
    let (done_tx, done_rx) = mpsc::channel::<()>();    

    let total_chunks = 5;
    let engine_gen_thread = thread::spawn(move || {
        info!("WORKER: Starting map generation for {} chunks.", total_chunks);
        
        for i in 1..=total_chunks {
            thread::sleep(Duration::from_millis(50));
            
            if data_tx.send(i).is_err() {
                warn!("WORKER: Data channel dropped after chunk {}. Stopping.", i);
                return;
            }
            info!("WORKER: Emitted Chunk #{} (Data Payload Crypto Coded).", i);
        }
        
        if done_tx.send(()).is_err() {
             error!("WORKER: Failed to send generation_complete signal.");
        }
        info!("WORKER: Generation finished.");
    });

    let mut chunks_received = 0;
    
    loop {
        match data_rx.recv_timeout(Duration::from_millis(10)) {
            Ok(chunk_id) => {
                chunks_received += 1;
                info!("MAIN: Processed Chunk #{} (Data Channel) - Tempo maintained.", chunk_id);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                if done_rx.try_recv().is_ok() {
                    info!("MAIN: Detected Completion Signal (Generation Complete).");
                    break;
                }
                thread::sleep(Duration::from_millis(1));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                error!("❌ FAIL: Data channel disconnected prematurely (Systemic Entropy).");
                break;
            }
        }
        
        if done_rx.try_recv().is_ok() {
            info!("MAIN: Detected Completion Signal (Generation Complete).");
            break;
        }
    }
    
    engine_gen_thread.join().unwrap();
    
    if chunks_received == total_chunks {
        info!("✅ SUCCESS: Map Generation Flow Validated. Received {}/{} chunks.", chunks_received, total_chunks);
        info!("   All data channels validated and quantum alignment achieved.");
    } else {
        error!("❌ FAIL: Map Generation Failed. Expected {} chunks, received {}.", total_chunks, chunks_received);
    }
}

pub fn run_data_channel_test() {
    info!("TEST [3]: Starting Chunk/Tile Data Channel Integrity Check...");
    
    info!("TEST [3]: Data channel integrity is validated implicitly and explicitly.");
    info!("   Implicitly: By checking successful channel send/receive in Action 4.");
    info!("   Explicitly: The FFI data type validation logic should be integrated here.");
    
    run_map_generation_test();
}

pub fn run_animation_conductor_test() {
    info!("TEST [5]: Starting Animation Conductor Tempo Validation (High-Frequency Loop Check)...");

    let (tx, rx) = mpsc::channel::<u64>();
    let required_signals = 120;
    let target_duration = Duration::from_millis(2000);

    let conductor_thread = thread::spawn(move || {
        info!("WORKER: Animation Conductor spun up. Targeting high tempo signal emission.");
        let start_time = Instant::now();
        let mut count = 0;
        
        while start_time.elapsed() < target_duration {
            thread::sleep(Duration::from_nanos(8333));
            
            if tx.send(start_time.elapsed().as_micros() as u64).is_err() {
                warn!("WORKER: Conductor signal dropped (Receiver disconnected).");
                return;
            }
            count += 1;
        }
        info!("WORKER: Conductor stopped. Emitted {} signals.", count);
    });

    let mut signals_received = 0;
    let mut min_latency_us = u64::MAX;
    let mut max_latency_us = 0;
    let main_start_time = Instant::now();

    while main_start_time.elapsed() < target_duration + Duration::from_millis(500) {
        match rx.recv_timeout(Duration::from_millis(1)) {
            Ok(timestamp_us) => {
                signals_received += 1;
                let elapsed_us = main_start_time.elapsed().as_micros() as u64;
                let latency_us = elapsed_us.saturating_sub(timestamp_us);
                
                min_latency_us = min_latency_us.min(latency_us);
                max_latency_us = max_latency_us.max(latency_us);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                thread::sleep(Duration::from_nanos(100));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                info!("MAIN: Conductor thread finished/disconnected.");
                break;
            }
        }
    }

    conductor_thread.join().unwrap();
    
    let success = signals_received >= required_signals;
    
    if success {
        info!("✅ SUCCESS: Animation Conductor Tempo Validated.");
        info!("   Target Signals: {} | Received: {}", required_signals, signals_received);
        info!("   Latency (Main Thread Read Lag): Min {}µs, Max {}µs.", min_latency_us, max_latency_us);
    } else {
        error!("❌ FAIL: Animation Conductor FAILED to achieve required tempo.");
        error!("   Expected signals: {} | Received: {}. Check worker thread throttling.", required_signals, signals_received);
        error!("   Latency range suggests systemic entropy in signal marshalling.");
    }
}
// --- END: rust/ssxl_cli/src\actions\actions.rs ---
        66 LOC | rust/ssxl_cli/src\actions\benchmarking.rs
// --- START: rust/ssxl_cli/src\actions\benchmarking.rs ---
use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering}
};
use std::thread;
use std::time::Duration;
use ctrlc;

// FIX E0432: Conductor and ConductorStatus are found in the `conductor` module.
use ssxl_generate::conductor::{Conductor, ConductorStatus};


pub fn start_signal_inspector() {
    warn!("🔮 Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // FIX E0308: Conductor::new now returns 4 elements. We destructure the fourth 
    // element (_progress_receiver) to ignore it here, as the CLI inspects the 
    // ConductorState directly, not the message channel.
    let (conductor, state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        print!("\r");
        print!("🔮 LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        thread::sleep(Duration::from_millis(50));
    }

    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

#[allow(dead_code)]
pub fn run_benchmark() {
    warn!("⏱️ Benchmark execution not yet implemented. Placeholder called.");
}
// --- END: rust/ssxl_cli/src\actions\benchmarking.rs ---
       102 LOC | rust/ssxl_cli/src\actions\godot_harness.rs
// --- START: rust/ssxl_cli/src\actions\godot_harness.rs ---
// FILE: ssxl_cli/src/actions/godot_harness.rs

//! # CLI Actions: Godot Harness (`ssxl_cli::actions::godot_harness`)
//!
//! Utilities for managing and launching the Godot editor or the Godot game
//! client from the command line, including necessary setup steps like copying
//! the compiled Rust dynamic library (DLL/SO/DYLIB) into the Godot project's
//! GDExtension directory.

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Imports of constants and utility functions from the parent module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


/// Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the `target/release`
/// or `target/debug` folder to the Godot tester project's GDExtension directory.
///
/// This is a critical step to ensure Godot loads the latest engine code.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // --- 1. Construct Source Path ---
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    // Navigate to the target directory (e.g., `target/debug/`).
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    // Add the DLL file name (e.g., `SSXL_engine.dll`).
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // --- 2. Construct Destination Path ---
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    // Navigate to the Godot project's GDExtension folder.
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    // Add the DLL file name.
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // --- 3. Validation and Copy ---

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        // Treat missing source as a non-fatal warning to continue CLI usage.
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "✅ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            // This often fails if the target DLL is locked by a running Godot instance.
            Err(format!(
                "❌ FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}


/// Launches the Godot Editor in a non-blocking subprocess.
pub fn launch_godot_client() {
    info!("🚀 LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    // Execute the Godot process.
    match Command::new(GODOT_EXE_PATH)
        // Flag to launch the editor window instead of running the game directly.
        .arg("--editor")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously, allowing the CLI process to continue.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

/// Launches Godot in a non-blocking subprocess using the `--headless` flag.
/// 
/// This is used for automated testing where no GUI is needed.
pub fn launch_headless_godot() {
    info!("🚀 LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        // Flag to run Godot without a graphical interface.
        .arg("--headless")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\godot_harness.rs ---
        25 LOC | rust/ssxl_cli/src\actions\godot_tests.rs
// --- START: rust/ssxl_cli/src\actions\godot_tests.rs ---
use super::{
    run_godot_test, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

/// Runs the FFI Bridge/GDExtension validation test in Godot.
pub fn run_ffi_bridge_validation() {
    run_godot_test(
        "FFI Bridge and GDExtension Integration Validation",
        GODOT_TEST_SCENE,
        "FFI/GDExtension Bridge VALIDATION SUCCEEDED!",
    );
}

/// Runs the Headless Map Generation Integration Test (Full Pipeline Validation).
pub fn run_headless_generation_integration_test() {
    run_godot_test(
        "Headless Map Generation Integration Test",
        HEADLESS_GEN_TEST_SCENE,
        "Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.",
    );
}

/// Runs the Headless Animation Conductor Tempo Test (Signal Latency Check).
pub fn run_headless_animation_tempo_test() {
    run_godot_test(
        "Headless Animation Conductor Tempo Test",
        HEADLESS_ANIM_TEST_SCENE,
        "Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.",
    );
}
// --- END: rust/ssxl_cli/src\actions\godot_tests.rs ---
        46 LOC | rust/ssxl_cli/src\actions\mod.rs
// --- START: rust/ssxl_cli/src\actions\mod.rs ---
// FILE: ssxl_cli/src/actions/mod.rs

//! # CLI Actions Module (`ssxl_cli::actions`)
//!
//! This module acts as the public interface (façade) for all complex command-line
//! actions, such as launching Godot, running tests, or initiating benchmarks.
//! It aggregates constants, external dependencies, and exports from its child modules.

use std::env;
use std::path::PathBuf;

// --- Internal Modules ---

/// Tools for real-time monitoring of the Conductor and placeholder for benchmark logic.
mod benchmarking;
/// Utilities for launching and managing the external Godot engine tester project.
mod godot_harness;
/// The main menu and delegation stub for all test suites.
mod testing;
/// Contains self-contained architectural and data validation tests.
mod test_suites;
/// Contains tests requiring external processes like `cargo` and Godot FFI validation.
mod test_core_suites;

// --- Configuration Constants ---

/// The absolute path to the Godot executable file.
pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
/// The project-relative path fragment pointing to the GDExtension folder (e.g., `godot_tester_project/gde/`).
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXLtester2/";
/// The expected file name of the compiled Rust dynamic library (e.g., `ssxl_engine.dll`).
pub const DLL_NAME: &str = "ssxl_engine.dll";
/// The project-relative path fragment where the compiled DLL is found (e.g., `target/debug/`).
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
/// The scene path within the Godot project used for FFI bridge validation tests.
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; 

// --- NEW HEADLESS TEST SCENES ---
/// The scene path within the Godot project used for headless generation pipeline validation.
pub const HEADLESS_GEN_TEST_SCENE: &str = "res://tests/headless_gen_pipeline.tscn";
/// The scene path within the Godot project used for headless animation tempo validation.
pub const HEADLESS_ANIM_TEST_SCENE: &str = "res://tests/headless_anim_tempo.tscn";
// --- END NEW HEADLESS TEST SCENES ---

// --- Utility Functions ---

/// Calculates the absolute path to the Godot tester project root.
pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}


// --- Public Module Exports (Façade) ---

/// Re-export for starting the **real-time status feed**.
pub use benchmarking::start_signal_inspector;

// Exports from godot_harness (Includes the requested launch_headless_godot).
pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

// Exports from test_core_suites.
pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    // --- ADDING NEW HEADLESS TESTS ---
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
};

// Exports from test_suites.
pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};


/// Exports related to **testing and validation**.
#[allow(unused_imports)]
pub use testing::execute_testing_menu;
// --- END: rust/ssxl_cli/src\actions\mod.rs ---
        36 LOC | rust/ssxl_cli/src\actions\testing.rs
// --- START: rust/ssxl_cli/src\actions\testing.rs ---
// FILE: ssxl_cli/src/actions/testing.rs

//! # CLI Actions: Testing Utilities (`ssxl_cli::actions::testing`)
//!
//! Provides a menu for executing various test suites, delegating the complex
//! execution logic to the internal `test_suites` and external `test_core_suites` modules.

use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;      // Architectural tests
use crate::actions::test_core_suites; // External tests
use std::sync::LazyLock;              // NEW: Used for lazy, thread-safe static initialization

// --- Menu Setup Logic ---

// FIX 1 & 2: Use LazyLock to initialize the actions at runtime (solving E0015) 
// and store them in a Vec<CliAction>. The CliAction struct itself must have 
// been updated in cli_util_menu.rs to include Send + Sync bounds (solving E0277).
#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    // FIX 2: Added the "back" action which is used to exit the loop
    CliAction::new("back", "↩️ Return to Main Menu"), 
]);

/// Central entry point for all CLI testing actions.
#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    // FIX 3: Get a slice from the LazyLock Vec to satisfy CliMenu's 'a [CliAction] requirement.
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        // FIX 4: `*s == "id"` and no misplaced `Ok(())` returns are now correct.
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\testing.rs ---
       103 LOC | rust/ssxl_cli/src\actions\tests_core.rs
// --- START: rust/ssxl_cli/src\actions\tests_core.rs ---
use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, 
    // Keep constants here for completeness, or only required ones if splitting strictly
    // by dependencies. Keeping them here allows `run_godot_test` to access them.
    GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE, HEADLESS_GEN_TEST_SCENE,
};

/// Runs the full cargo test suite.
pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}

/// Helper function to read all output from a stream in a non-blocking way. (O(n) on stream size)
fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

/// Generic runner for Godot-based integration tests.
/// Extracts all boilerplate for spawning and output piping.
pub(crate) fn run_godot_test(
    test_title: &str,
    test_scene: &str,
    success_message: &str,
) -> bool {
    info!("🔥 STARTING: {}...", test_title);

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ {} failed: {}", test_title, e);
            return false;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(test_scene)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process for {}: {}", test_title, e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return false;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait for {}: {}", test_title, e);
            return false;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());
    
    // Output formatting and final result logging.
    println!("\n--- GODOT {} TEST OUTPUT START ---", test_title.to_uppercase());
    println!("{}", stdout_output);
    println!("--- GODOT {} TEST OUTPUT END ---\n", test_title.to_uppercase());

    if status.success() {
        info!("✅ {} SUCCEEDED! {}", test_title, success_message);
        true
    } else {
        error!(
            "❌ {} FAILED! Exit code: {:?}",
            test_title,
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
        false
    }
}
// --- END: rust/ssxl_cli/src\actions\tests_core.rs ---
       234 LOC | rust/ssxl_cli/src\actions\test_core_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_core_suites.rs ---
use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub fn run_ffi_bridge_validation() {
    info!("🔥 STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(
            "❌ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_generation_integration_test() {
    info!("🔥 STARTING: Headless Map Generation Integration Test (Full Pipeline Validation)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_GEN_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS GENERATION TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS GENERATION TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.");
    } else {
        error!(
            "❌ Headless Generation Integration Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_animation_tempo_test() {
    info!("🔥 STARTING: Headless Animation Conductor Tempo Test (Signal Latency Check)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_ANIM_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT START ---\n");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.");
    } else {
        error!(
            "❌ Headless Animation Tempo Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
// --- END: rust/ssxl_cli/src\actions\test_core_suites.rs ---
       107 LOC | rust/ssxl_cli/src\actions\test_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_suites.rs ---
// FILE: ssxl_cli\src\actions\test_suites.rs

//! # Internal Architectural and Data Validation Suites
//!
//! Contains self-contained Rust tests focused on validating internal data contracts,
//! concurrency models (channels), and core generation logic without external
//! process reliance.

use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

// --- Project Imports ---
use ssxl_generate::Generator;
// FIX E0432: `perlin_generator` likely renamed to `perlin`.
use ssxl_generate::perlin::PerlinGenerator;
use ssxl_math::prelude::Vec2i;
// FIX E0432: Correct path to Chunk data constant.
use ssxl_shared::chunk::chunk_data::CHUNK_SIZE;
// FIX E0432: Correct path to Tile data struct.
use ssxl_shared::tile::tile_data::AnimationUpdate;


// -----------------------------------------------------------------------------
// FOCUSED ARCHITECTURAL VALIDATION
// -----------------------------------------------------------------------------

/// Validates the non-blocking mpsc channels used between the Godot main thread
/// and the Rust worker threads (Generation and Animation Conductors).
pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    // 1. Create a channel pair: (CLI sends, Mock Conductor receives)
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    // 2. Spawn a thread to act as the Mock Conductor
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    // 3. CLI (main thread) floods the channel with messages
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1));
    }
    
    drop(cli_sender);

    // 4. Wait for the Mock Conductor thread to complete and get the result
    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("❌ Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    // 5. Report results
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("✅ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("❌ Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}


/// Alias for `run_communication_channel_test`. Validates data-channel functionality.
pub fn run_data_channel_test() {
    run_communication_channel_test();
}

/// Validates the core map generation logic by creating a chunk using the Perlin Generator.
pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords);
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("✅ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("❌ Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

/// Validates the data contract for the Animation Conductor by ensuring
/// the `AnimationUpdate` structure can be serialized and deserialized.
pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("❌ Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("❌ Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("✅ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("❌ Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}
// --- END: rust/ssxl_cli/src\actions\test_suites.rs ---
       129 LOC | rust/ssxl_cli/src\cli_util_bench.rs
// --- START: rust/ssxl_cli/src\cli_util_bench.rs ---
// ssxl_cli\src\cli_util_bench.rs

use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc,
    atomic::{AtomicU64, Ordering}
};
use std::io::{self, Write};
use std::time::Duration;

use ssxl_generate::benchmark_generation_workload;
use ssxl_generate::conductor::Conductor;
use ssxl_math::prelude::Vec2i;

pub fn test_generation_and_placement_cli() {
    warn!("🧪 Running CLI Test: Generation and Placement (Conductor Validation)...");

    let (mut conductor, _state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    let perlin_id = "perlin_basic_2d";
    if conductor.set_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            // FIX: Use the correct synchronous generation method: `get_chunk_data`
            let _chunk = conductor.get_chunk_data(&coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    let ca_id = "cellular_automata_basic";
    if conductor.set_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        // FIX: Use the correct synchronous generation method: `get_chunk_data`
        let _chunk = conductor.get_chunk_data(&coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    if chunks_generated > 0 {
        info!("✅ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).",
            chunks_generated,
            conductor.get_active_generator_id()
        );
    } else {
        error!("❌ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    conductor.graceful_teardown();
}


pub fn run_bitmask_conversion() {
    warn!("🧪 Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("✅ Conversion complete. Tiles placed: {}", tiles_placed);
}

pub fn run_max_grid_benchmark() {
    warn!("🧪 Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000;

    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone);
    });

    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            let throughput = if elapsed > 0.0 {
                (current as f64 / elapsed).round() as u64
            } else {
                0
            };

            print!("\r⏳ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s",
                percentage,
                current / 1_000_000,
                WORKLOAD_TILES / 1_000_000,
                throughput
            );
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    let start = Instant::now();
    
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        let _ = println!("\r❌ Benchmark failed: Generation thread panic. {: <100}", " ");
        return;
    }
    
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    println!("\r✅ Benchmark complete. Workload: {} tiles. Duration: {:.2}s",
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("⚡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("⚡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("🚀 CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("📈 Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("⚠️ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("❌ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}
// --- END: rust/ssxl_cli/src\cli_util_bench.rs ---
       137 LOC | rust/ssxl_cli/src\cli_util_inspect.rs
// --- START: rust/ssxl_cli/src\cli_util_inspect.rs ---
use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;


pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| 🌲 RUST WORKSPACE MODULE TREE (Scanning...)                            |");
	println!("=========================================================================");
	
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n🔍 Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "├── [CORE] "
                            } else {
                                "│   └── "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


pub fn print_godot_api_surface() {
	// --- STRATEGIC UPDATE: Include the new aggregated API file from the 'engine' module. ---
	let godot_api_files: [&str; 4] = [ 
        // 🎯 FIX: The new main file containing all #[func] methods.
        "ssxl_godot/src/engine/init.rs",
        // Retaining the two GDExtension helper classes (Oracle, Signals)
        "ssxl_godot/src/ffi/oracle.rs",      
        "ssxl_godot/src/ffi/signals.rs",
        // Retaining the FFI Core library
        "ssxl_engine_ffi/src/lib.rs", 
    ];

    println!("🧪 API scan triggered (targeting {} files in ssxl_godot/src/ and FFI core)...", godot_api_files.len());
    
	// --- MASTER REGEX FOR ALL CALLABLE METHODS (FIXED ESCAPING) ---
    let method_regex = Regex::new(
        r#"(?s)(?:\s*#\[func\].*?|#\[no_mangle\].*?pub\s+extern\s+"C"\s*)\s*(?:pub\s+fn|fn)\s+(\w+)\s*(\([^\{;]*)\s*(?:->\s*([^\{]*))?"#
    ).unwrap();

	// Signal regex remains robust for line-based #[signal] definitions
    let signal_signature_regex = Regex::new(
        r"^\s*fn\s+(\w+)\s*(\([^;]*)\s*;\s*$"
    ).unwrap();
    let signal_marker_regex = Regex::new(r"^\s*#\[signal\]\s*$").unwrap();
    
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();
    let mut api_signals: Vec<(String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        
        let mut signal_line_pending = false;

        match fs::read_to_string(path) {
            Ok(contents) => {
                info!("Successfully read {}", path.display());
                
				// --- METHOD SCAN (Single Pass over File Content) ---
                for cap in method_regex.captures_iter(&contents) {
                    let method_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                    let args = cap.get(2)
                        .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                        .unwrap_or_default();
                    let return_type = cap.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                    
                    // Simple cleanup for args
                    let clean_args = args.replace("self, ", "self,").trim().trim_start_matches("self").trim_start_matches(",").trim().to_string();

                    api_methods.push((method_name, clean_args, return_type, file_name.to_string()));
                }


				// --- SIGNAL SCAN (Line-by-Line, No Change Needed) ---
                for line in contents.lines() {
                    let trimmed_line = line.trim();

                    if signal_marker_regex.is_match(trimmed_line) {
                        signal_line_pending = true;
                        continue;
                    }
                    
                    if signal_line_pending {
                        if let Some(captures) = signal_signature_regex.captures(trimmed_line) {
                            let signal_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_signal").to_string();
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            api_signals.push((signal_name, args, file_name.to_string()));
                            signal_line_pending = false; 
                        } else if !trimmed_line.is_empty() {
                            signal_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- 🎮 SSXL Engine Developer MASTER API Surface ---");
    
    println!("\n✅ Callable Methods ({} total):", api_methods.len());
    if api_methods.is_empty() {
        warn!(" No callable methods found in targeted files (check FFI core!).");
    } else {
        for (name, args, return_type, source_file) in &api_methods {
            // Highlighting the low-level FFI entry points for clarity
            let marker = if source_file == "lib.rs" && api_methods.iter().any(|(n,_,_,s)| n == name && s == source_file) {
                "[FFI CORE]"
            } else {
                "[GDExt]"
            };
            println!(" > func {}({}) -> {} {} [{}]", name, args, return_type, marker, source_file);
        }
    }

    println!("\n⭐ Registered Signal Broadcasts ({} total):", api_signals.len());
    if api_signals.is_empty() {
        warn!(" No #[signal] broadcasts found in targeted files.");
    } else {
        for (name, args, source_file) in &api_signals {
            println!(" > signal {}({}) [{}]", name, args, source_file);
        }
    }
	println!("--------------------------------------------------");

    info!("API scan complete: {} methods and {} signals detected.", api_methods.len(), api_signals.len());
    thread::sleep(Duration::from_secs(2));
}
// --- END: rust/ssxl_cli/src\cli_util_inspect.rs ---
       106 LOC | rust/ssxl_cli/src\cli_util_loc.rs
// --- START: rust/ssxl_cli/src\cli_util_loc.rs ---
//! # CLI Utilities: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
//!
//! This module provides functions for scanning the SSXL-ext workspace, calculating
//! Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`) files, and
//! generating the LOC reports required by the Godot engine.

use walkdir::WalkDir;
use std::path::{PathBuf};
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// Constants for the fixed-name output file, which is read by Godot.
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
// Directory for full LOC reports, relative to the project root (../)
const LOC_REPORTS_DIR: &str = "../loc_reports";

/// Helper to count lines of code in file content, ignoring empty lines and comments (simplified).
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        // Simple check: ignore empty lines and lines starting with comment markers.
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Helper function to write the final Rust LOC total to a fixed-name file
/// for fast parsing by Godot at bootup.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level to the project root (ssxl-ext/)
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE); // Final Path: ../RUST_LOC_TOTAL.txt

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("🔥 SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("❌ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

/// Scans the Rust workspace, calculates lines of code (LOC), and generates
/// the full report and the final single-number LOC file.
///
/// Assumes CWD is inside the `ssxl-ext/rust/` directory.
pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // 1. Scan Rust Code
    // These paths are correct relative to the ssxl-ext/rust/ directory.
    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 2. Scan GDScript Code
    // Path traversal is correct: `ssxl-ext/rust/` -> `../ssxl_engine_tester`
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        // Note: path.display() will include the '..' but this is acceptable for internal reports.
                        let path_str = path.display().to_string();
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters (using '#' for GDScript comments)
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 3. Generate the full, dynamically-named report in the `../loc_reports/` directory
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    // Create the directory if it doesn't exist.
    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("❌ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    // Write the full report to the corrected dynamic path.
    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("✅ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("❌ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // 4. Write the single line count to the fixed-name file (RUST_LOC_TOTAL.txt)
    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}
// --- END: rust/ssxl_cli/src\cli_util_loc.rs ---
       158 LOC | rust/ssxl_cli/src\cli_util_menu.rs
// --- START: rust/ssxl_cli/src\cli_util_menu.rs ---
use crate::actions::{
    // --- Core Test & Validation Functions (Godot/Rust interaction) ---
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
    
    // --- NEW: Headless Integration Tests for Rendering Logic (Fixing Generate/Animate) ---
    run_headless_generation_integration_test, // Validates 'generate' FFI data pipeline.
    run_headless_animation_tempo_test,        // Validates 'animate' conductor tempo/latency.
    
    // --- Launch & Debug Functions ---
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
};
// Benchmark/Utility functions are correctly imported from their dedicated module:
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use tracing::warn;


/// Defines a single executable action within the Command Line Interface menu.
/// Each action is a closure wrapped in a Box for dynamic execution.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    /// Helper constructor (primarily for TODO/unimplemented actions).
    pub fn new(id: &'static str, label: &'static str) -> Self {
        CliAction {
            key: '?',
            label,
            id,
            action: Box::new(|| {}) // Default no-op action
        }
    }
}


/// Defines a structure for organizing and presenting a group of CLI actions.
pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    // Note: prompt_action implementation is omitted as it is environment-specific.
    pub fn prompt_action(&self) -> CliAction {
        unimplemented!()
    }
}


/// Constructs the complete list of available actions for the SSXL Engine Dev Console.
pub fn build_menu() -> Vec<CliAction> {
    vec![
        // =======================================================================
        // I. CORE RUST VALIDATION (Internal Checks)
        // =======================================================================
        CliAction { 
            key: '0', 
            label: "✅ Run: Full Cargo Test Suite", 
            id: "cargo_all", 
            action: Box::new(run_cargo_tests) 
        },
        CliAction {    
            key: '1',    
            label: "✅ Validate: FFI Bridge Data Transfer (Data Integrity)",    
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction {    
            key: '2',    
            label: "✅ Validate: Async Communication Channels (Godot <-> Rust)",    
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction {    
            key: '3',    
            label: "✅ Validate: Chunk/Tile Data Channels (Crypto Coded)",    
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction {    
            key: '4',    
            label: "✅ Validate: Map Generation Logic (Procedural Purity)",    
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction {    
            key: '5',    
            label: "✅ Validate: Animation Conductor Tempo (Frame Consistency)",    
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },

        // =======================================================================
        // II. HEADLESS INTEGRATION TESTS (Simulating Engine in Godot)
        // This targets the root of our 'generate' and 'animate' rendering errors.
        // =======================================================================
        CliAction { 
            key: '6', 
            label: "✅ Validate: Headless Generation Integration (Full Pipeline Simulation)", 
            id: "headless_gen_integration",
            action: Box::new(run_headless_generation_integration_test)
        },
        CliAction { 
            key: '7', 
            label: "✅ Validate: Headless Animation Tempo Integration (Signal Latency Check)", 
            id: "headless_anim_tempo",
            action: Box::new(run_headless_animation_tempo_test)
        },

        // =======================================================================
        // III. ENGINE LAUNCH & DEBUGGING TOOLS
        // =======================================================================
        CliAction {    
            key: 'L',    
            label: "🚀 Launch: Godot Client (Non-Headless)",    
            id: "launch_client",
            action: Box::new(launch_godot_client)    
        },
        CliAction {    
            key: 'H',    
            label: "🎮 Launch: Headless Godot (External)",    
            id: "launch_headless",
            action: Box::new(launch_headless_godot)    
        },
        CliAction {    
            key: 'S',    
            label: "🔮 Start: Signal Inspector / Live Feed (TODO)",    
            id: "start_inspector",
            action: Box::new(start_signal_inspector)    
        },

        // =======================================================================
        // IV. BENCHMARKS & UTILITIES
        // =======================================================================
        CliAction {    
            key: 'T',    
            label: "🧪 Test: Generation & Placement CLI",    
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli)    
        },
        CliAction {    
            key: 'B',    
            label: "🧪 Benchmark: Max Grid Placement",    
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)    
        },
        CliAction {    
            key: 'P',    
            label: "✅ Perform: Bitmask PNG Conversion",    
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)    
        },
        CliAction {    
            key: 'A',    
            label: "✅ Inspect: SSXL Developer API Surface (Callable + Signals)",    
            id: "api_surface",
            action: Box::new(print_godot_api_surface)    
        },
        CliAction {    
            key: 'I',    
            label: "✅ Inspect: Rust Module Tree",    
            id: "module_tree",
            action: Box::new(print_module_tree)    
        },
        CliAction {    
            key: 'R',    
            label: "⚠️ Run: Trailkeeper Scan (TODO)",    
            id: "trailkeeper_scan",
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented."))    
        },
        
        // =======================================================================
        // V. SYSTEM CONTROL
        // =======================================================================
        CliAction { key: 'E', label: "✅ Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}


/// Prints the structured menu to the console, ready for user selection.
pub fn print_menu(menu: &[CliAction]) {
    
    println!("\n🧭 SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}
// --- END: rust/ssxl_cli/src\cli_util_menu.rs ---
        92 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
//! # SSXL-ext CLI Developer Console (`ssxl_cli::main`)
//!
//! The main entry point for the interactive developer console. This utility manages
//! initialization, logging, the main menu loop, and delegates tasks to action modules
//! for testing, benchmarking, and external tool execution.

mod actions; // Core functions for tests, benchmarks, and Godot interaction.
mod cli_util_inspect; // Utilities for scanning the codebase and API surface.

// FIX: Change to `pub mod` so its types (CliAction, CliMenu) are accessible
// by other modules in the crate (like actions/testing.rs).
pub mod cli_util_menu; // Menu structure and display logic.

mod cli_util_bench; // Functions for running generation tests and benchmarks.
mod cli_util_loc; // Declares the new LOC utility module.

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
// FIX: Corrected FFI runtime import to use the ssxl_shared crate.
use ssxl_shared::ssxl_start_runtime; // External FFI function to bootstrap the engine core.
use crate::cli_util_loc::scan_and_report_loc; // Imports the LOC function.
use crate::actions::copy_dll_to_tester_project_at_boot; // Action to ensure the latest DLL is in the Godot project.


/// Prompts the user to press Enter before returning to the main menu.
fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    // Read a line from stdin and discard the result.
    let _ = io::stdin().read_line(&mut String::new());
}

/// Sets up the logging system and performs critical engine initialization steps.
fn init_logging_and_engine() {
    // 1. Initialize Tracing/Logging Subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout) // Direct log output to stdout.
                .with_filter(LevelFilter::INFO), // Set the minimum logging level to INFO.
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // 2. Initialize the Rust Core via FFI
    // Calls the external C-compatible function to boot the engine's core state and runtime.
    // FIX: Using the correct FFI function name and importing from `ssxl_shared`.
    if ssxl_start_runtime() {
        info!("Engine FFI core initialized.");
    } else {
        // We log the failure but allow the CLI to continue for non-engine tasks (like LOC scan).
        error!("Failed to initialize Engine FFI core.");
    }
    
    // 3. Copy DLL to Godot Project
    // Ensure the compiled GDExtension DLL is copied into the Godot tester project
    // before any Godot-related actions are run.
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        // This is a critical warning, as Godot interaction will fail without the DLL.
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // Perform initial setup: logging, FFI, and DLL copy.
    init_logging_and_engine();
    
    // --- FFI Linkage Fix for MSVC (LNK2019) ---
    // The linker is aggressively discarding the ssxl_godot library (which implements 
    // ssxl_set_cell and ssxl_notify_tilemap_update) because ssxl_cli doesn't 
    // appear to call it directly. This symbolic reference forces the linker to include it.
    extern "C" {
        // Declare the unresolved FFI functions provided by ssxl_godot
        fn ssxl_set_cell(x: i32, y: i32, tile_id: i32);
        fn ssxl_notify_tilemap_update();
    }

    // WARNING FIX: Removed unnecessary `unsafe` blocks. Pointer coercion is safe.
    // Create an unused symbolic reference to the function pointers.
    let _ = ssxl_set_cell as *const ();
    let _ = ssxl_notify_tilemap_update as *const ();
    // ---------------------------------------------
    
    // Run a Lines of Code (LOC) scan on the codebase at startup.
    scan_and_report_loc();
    
    // Print welcome ASCII art.
    println!(
        r#"
                (__)      
                (oo)
          /------\/
         / |    ||
        * ||----||
          ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // Build the menu structure.
    let menu = build_menu();
    // Set for input debouncing to prevent multiple actions from a single key press hold.
    let mut last_keys = HashSet::new();

    // --- Main Interactive Console Loop ---
    loop {
        // Display the menu options.
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        // Ensure the prompt character is immediately visible.
        io::stdout().flush().unwrap();

        // Inner loop handles key polling and processing.
        loop {
            // Poll for key events with a timeout to keep the loop responsive (500ms tempo).
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase(); // Normalize input to uppercase.

                        // Input Debounce Check: Only process if the key hasn't been seen recently.
                        if last_keys.insert(c) {
                            // Find the corresponding menu item.
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                // Execute the action associated with the menu item.
                                (item.action)();

                                // Check for the exit key ('E').
                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return; // Exit the main function, terminating the CLI.
                                }

                                // Wait for user acknowledgment before returning to the main menu screen.
                                wait_for_enter();
                                // Break the inner polling loop to redraw the menu.
                                break;
                            }
                        }
                    }
                }
            } else {
                // If the poll times out, clear the debounce set, allowing a new key press to be registered.
                last_keys.clear();
            }

            // Short pause for general loop control.
            thread::sleep(Duration::from_millis(10));
        }
    }
}
// --- END: rust/ssxl_cli/src\main.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("🌙 Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("🌀 SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("✨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("⚠️ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("❌ Failed to instantiate SSXL script.")
        else:
            push_error("❌ Invalid script resource at: %s" % script_path)
    else:
        push_error("❌ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("🧹 SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("🧺 SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("🌙 SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## 🧭 NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## ⚙️ CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## 🔗 LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("❌ CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("✅ Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## ⌨️ INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## 🖼️ CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## 📡 PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("⚠️ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("➡️ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("➡️ Switched to Camera 2 (Map View).")
	else:
		push_warning("⚠️ Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED → (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid — cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature — set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated →", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error →", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated → (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete →", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine → Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine → SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle → Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected →", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected →", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("❌ FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "❌ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("⚙️ FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "🕒 " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # ← THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # ← Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # ← Chunk data holder

# Old reference — we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX — only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready → CONNECTED (first time)")
		else:
			print("chunk_data_ready → already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\n🎶 Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("❌ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("❌ Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\n📜 Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd — FINAL VERSION (2025 SSXL FFI Sync) — RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle → Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle → Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine → SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing — no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED — EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready → tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready → _on_chunk_data_ready CONNECTED — RENDERING ENABLED")
		else:
			print("chunk_data_ready → already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd — Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("📢 SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("❌ FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("📢 SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("✅ SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("✅ GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("❌ GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("✅ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("❌ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
       4417 LOC | *.rs (Rust Total)
       961 LOC | *.gd (GDScript Total)
       5378 LOC | TOTALS
