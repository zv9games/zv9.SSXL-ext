SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1763385838
Root Directories: rust, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       107 LOC | rust/ssxl_cache/src\lib.rs
// --- START: rust/ssxl_cache/src\lib.rs ---
use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
use ssxl_shared::chunk_data::ChunkData;
use std::collections::HashMap;
use std::io;
use std::sync::{Arc, RwLock}; 
use tracing::{info, warn};
use glam::I64Vec3; 

type CacheMap = HashMap<ChunkKey, Arc<ChunkData>>;

const REGION_SIZE: i64 = 64;

type RegionKey = ChunkKey;
type RegionList = RwLock<Vec<ChunkKey>>;
type RegionMap = HashMap<RegionKey, Arc<RegionList>>;


#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<RegionMap>,
}

impl RegionIndex {
    fn new() -> Self {
        Self {
            storage: AtomicResource::new(RegionMap::new()),
        }
    }
    
    #[inline]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let rx = chunk_key.0.x / REGION_SIZE; 
        let ry = chunk_key.0.y / REGION_SIZE; 
        let rz = chunk_key.0.z / REGION_SIZE; 

        ChunkKey(I64Vec3 { x: rx, y: ry, z: rz })
    }

    pub fn get_chunks_in_region(&self, region_key: &RegionKey) -> Option<Arc<RegionList>> {
        let map = self.storage.read();
        map.get(region_key).map(Arc::clone)
    }

    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let mut map_lock = self.storage.write();

        let list_lock_arc = map_lock.entry(region_key)
            .or_insert_with(|| Arc::new(RwLock::new(Vec::new())))
            .clone();
        
        drop(map_lock); 

        {
            // CRITICAL FIX: The use of an explicit scope block forces the guard to drop.
            // Using `if let` here instead of `match` makes the expression end early.
            if let Ok(mut list) = list_lock_arc.write() {
                list.push(chunk_key);
            } else {
                warn!("Region list lock poisoned for {:?}: {}", region_key, "write error");
            };
        }
    }
    
    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        
        let list_lock_arc = {
            let map = self.storage.read();
            map.get(&region_key).map(Arc::clone)
        };

        if let Some(list_lock_arc) = list_lock_arc {
            
            match list_lock_arc.write() {
                Ok(mut list) => {
                    if let Some(pos) = list.iter().position(|k| *k == chunk_key) {
                        list.remove(pos);
                        
                        if list.is_empty() {
                            drop(list); 
                            let mut map_write = self.storage.write();
                            map_write.remove(&region_key);
                            info!("Removed empty region key from index: {:?}", region_key);
                        }
                        return true;
                    }
                },
                Err(e) => {
                    warn!("Region list lock poisoned during removal for {:?}: {}", region_key, e);
                }
            }
        }
        
        false
    }
}

#[derive(Debug, Clone)]
pub struct ChunkCache {
    storage: AtomicResource<CacheMap>,
    region_index: RegionIndex,
    max_capacity: usize,
}

impl ChunkCache {
    pub fn new(max_chunks: usize) -> Result<Self, io::Error> {
        info!("Initializing ChunkCache and RegionIndex with max_chunks: {}", max_chunks);
        
        Ok(ChunkCache { 
            storage: AtomicResource::new(CacheMap::new()), 
            region_index: RegionIndex::new(),
            max_capacity: max_chunks,
        })
    }

    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<Arc<ChunkData>>, io::Error> {
        let map = self.storage.read();
        Ok(map.get(key).map(Arc::clone))
    }

    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> Result<(), io::Error> {
        let mut map = self.storage.write();

        if map.len() >= self.max_capacity {
            warn!("ChunkCache capacity limit ({}) reached. LRU eviction is required to prevent OOM.", self.max_capacity);
        }
        
        if map.insert(*key, data).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
            
            self.region_index.insert_key(*key);
        } else {
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }
}
// --- END: rust/ssxl_cache/src\lib.rs ---
        65 LOC | rust/ssxl_engine_ffi/src\lib.rs
// --- START: rust/ssxl_engine_ffi/src\lib.rs ---
// ssxl_engine_ffi/src/lib.rs

//! Foreign Function Interface (FFI) Bridge for the SSXL Engine.
//!
//! This module exposes C-compatible functions to external host environments (like Godot's
//! GDExtension), allowing them to start, stop, and query the SSXL procedural generation
//! runtime, which is managed by the thread-safe `Conductor` singleton.

// REMOVED: use std::ffi::CString; // FIX: Unused import removed (no longer needed for ssxl_get_status pattern)
use std::os::raw::c_char; // FIX: c_void removed as it is not used in public FFI signatures.
use std::sync::OnceLock;
// FIX: Removed the redundant import 'use std::os::raw::c_char;' (and the non-breaking space).

use ssxl_generate::{Conductor, start_runtime_placeholder};
use ssxl_shared::initialize_shared_data;
use tracing::{info, error};

// --- 1. Thread-Safe Singleton for the Conductor ---

/// A thread-safe, one-time initialization container for the core Conductor runtime.
/// Using OnceLock ensures that the Conductor is initialized exactly once, protecting
/// against initialization race conditions across different FFI calls.
static CONDUCTOR: OnceLock<Conductor> = OnceLock::new();

// --- 2. FFI Functions for Runtime Management ---

/// Starts the SSXL Conductor runtime if it is not already running.
///
/// This function is idempotent: calling it multiple times will only initialize the
/// runtime once. It is the primary entry point for the external engine.
///
/// # Safety/FFI
/// Marked `extern "C"` and `#[no_mangle]` for C-ABI compatibility.
///
/// # Returns
/// `true` if the runtime is running (either started now or was already running),
/// `false` if initialization failed.
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    // Ensure core engine configuration data is initialized first.
    initialize_shared_data();

    if CONDUCTOR.get().is_some() {
        info!("FFI Bridge: Runtime already running.");
        return true;
    }

    // Attempt to initialize and set the Conductor singleton.
    match Conductor::new(None) {
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            if CONDUCTOR.set(conductor).is_err() {
                // Should only happen in a severe race condition during first initialization.
                error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                return false;
            }
            info!("FFI Bridge: Conductor Runtime started successfully.");
            true
        }
        Err(e) => {
            tracing::error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
            false
        }
    }
}

/// Signals the Conductor to begin a graceful shutdown sequence.
///
/// The FFI consumer should call this before unloading the DLL/shared library.
/// This prevents systemic entropy by allowing worker threads to finish.
#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    if let Some(conductor) = CONDUCTOR.get() {
        // The conductor's destructor will handle waiting for threads if necessary.
        conductor.signal_shutdown_graceful();
        info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
    }
}

/// Checks if the Conductor runtime has been successfully initialized.
///
/// # Returns
/// `true` if the Conductor is initialized and accessible, `false` otherwise.
#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    CONDUCTOR.get().is_some()
}

/// A convenience alias for the primary initialization function.
#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

// --- 3. FFI Functions for Diagnostics and Debugging ---

/// Triggers a structural test sequence within the Conductor's runtime manager.
/// This is typically used for integration testing or initial smoke checks.
#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    info!("FFI Bridge: Received command to trigger Conductor structural test.");
    start_runtime_placeholder();
    info!("FFI Bridge: Conductor test sequence complete.");
}

/// **[NEW SAFE FUNCTION]** Writes a formatted status string directly into a C-owned buffer.
///
/// This eliminates the memory leak risk by having the calling environment (Godot)
/// allocate and own the memory, removing the need for an explicit Rust deallocation FFI call.
///
/// # Safety/FFI Contract
/// 1. The caller must ensure `buffer` is a valid, non-null pointer.
/// 2. The caller must ensure `buffer_len` accurately reflects the allocated size.
///
/// # Arguments
/// * `buffer`: A pointer to the C-allocated buffer where the string will be written.
/// * `buffer_len`: The maximum size (in bytes) of the buffer.
/// * `id`: A simple identifier for the status query.
///
/// # Returns
/// The number of bytes written to the buffer (excluding the null terminator),
/// or a negative value (`-1`) on failure (e.g., null buffer).
#[no_mangle]
pub extern "C" fn ssxl_write_status(
    buffer: *mut c_char,
    buffer_len: usize,
    id: u32,
) -> isize {
    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        CONDUCTOR.get().is_some()
    );

    // Critical safety checks before touching the raw pointer
    if buffer.is_null() || buffer_len == 0 {
        return -1;
    }

    let bytes = status.as_bytes();
    // Calculate the maximum number of bytes we can copy, leaving 1 for the null terminator.
    let write_len = bytes.len().min(buffer_len.saturating_sub(1));

    unsafe {
        // 1. Copy the status bytes into the C-owned memory.
        std::ptr::copy_nonoverlapping(bytes.as_ptr(), buffer as *mut u8, write_len);
        // 2. CRITICAL: Null-terminate the string for C/GDScript compatibility.
        *buffer.add(write_len) = 0;
    }

    write_len as isize
}

// **[REMOVED]** ssxl_get_status (Used CString::into_raw(), requiring external free)
// **[REMOVED]** ssxl_free_string (The required cleanup function for ssxl_get_status)
// --- END: rust/ssxl_engine_ffi/src\lib.rs ---
        51 LOC | rust/ssxl_generate/src\batch_processor.rs
// --- START: rust/ssxl_generate/src\batch_processor.rs ---
// ssxl_generate/src/batch_processor.rs
//! Logic for executing large, synchronous batches of chunk generation requests.
//!
//! This module coordinates the parallel generation of a defined rectangular area of the
//! world map. It utilizes the Tokio runtime's `spawn_blocking` to safely move
//! the CPU-intensive work off the async executor, and the Rayon crate for CPU-bound,
//! fine-grained parallelism across available threads, ensuring high-speed completion
//! of generation tasks.

use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::info;
use std::collections::HashMap;
use std::sync::Arc; // CRITICAL FIX: Removed Mutex import.

use rayon::prelude::*;

use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache; // Assumed to be thread-safe (Send + Sync) via internal locking.

use crate::config_validator::GeneratorConfig;
use crate::task_queue::{handle_chunk_unit, GenerationMessage, CHUNK_SIZE};
use crate::conductor_state::ConductorState;
use crate::generator_manager::DynGenerator;

/// Spawns a new generation task that processes a full batch of chunks in parallel.
///
/// This function is non-blocking to the caller (usually the Conductor) and hands off
/// the CPU-intensive work to a separate thread pool via `spawn_blocking`.
///
/// # Arguments
/// * `runtime_handle`: The handle to the Tokio runtime's executor.
/// * `generators_clone`: Map of all registered generators for selection.
/// * `chunk_cache_clone`: **(FIXED)** The thread-safe cache, shared via Arc. It relies on its
///   internal locking to allow high-speed concurrent read/write operations from Rayon workers.
/// * `active_generator_id`: Identifier of the generator to use for this batch.
/// * `progress_sender_clone`: Channel sender for sending completion/progress messages back to Conductor.
/// * `internal_state_clone`: A copy of the Conductor's shared state (used for queue depth tracking).
/// * `config_clone`: The configuration defining the area and size of the generation request.
pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    // CRITICAL FIX: We changed the type from Arc<Mutex<ChunkCache>> to Arc<ChunkCache>.
    // This allows Rayon's parallel workers to use the cache's concurrent access 
    // mechanism (like RwLock or AtomicResource) instead of fighting over a single Mutex.
    chunk_cache_clone: Arc<ChunkCache>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: ConductorState,
    config_clone: GeneratorConfig,
) {
    info!("Conductor spawning BATCH generation task. Config: {}", config_clone);

    // Use `spawn_blocking` to move the synchronous, CPU-bound generation work off
    // of the async runtime's main thread pool, preventing executor starvation.
    runtime_handle.spawn_blocking(move || {
        // Increment the queue depth immediately to track the active task count.
        internal_state_clone.increment_queue_depth();

        // Calculate the grid size for the batch, rounding up to the nearest chunk boundary.
        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        
        // Ensure map dimensions are used as i64 for the calculation.
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        // Calculate the chunk counts using the correct ceiling division formula: (a + b - 1) / b
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        // Generate a vector of all ChunkKey coordinates (Vec2i) for the entire batch area.
        // The range (0..N) correctly includes coordinates 0 up to N-1.
        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        // Added check for 0x0 map request, although likely prevented by ConfigValidator.
        if all_chunk_coords.is_empty() {
             info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
        }


        // --- Core Parallel Processing ---
        all_chunk_coords
            // Convert the iterator to a parallel iterator using Rayon.
            .par_iter()
            // Process each chunk in parallel across all available CPU threads.
            .for_each(|&chunk_coords| {
                handle_chunk_unit(
                    chunk_coords,
                    &active_generator_id,
                    &generators_clone,
                    // The Arc reference is passed directly to the worker function.
                    &chunk_cache_clone, 
                    &progress_sender_clone,
                );
            });

        // Send a final message to the Conductor indicating the entire batch is complete.
        // `blocking_send` is used because this closure is running on a synchronous blocking thread.
        let _ = progress_sender_clone.blocking_send(GenerationMessage::GenerationComplete);

        // Decrement the queue depth, signaling to the Conductor that this task is done.
        internal_state_clone.decrement_queue_depth();

        info!("Batch generation task finished processing command: {}", config_clone);
    });
}
// --- END: rust/ssxl_generate/src\batch_processor.rs ---
        21 LOC | rust/ssxl_generate/src\benchmark_logic.rs
// --- START: rust/ssxl_generate/src\benchmark_logic.rs ---
// ssxl_generate/src/benchmark_logic.rs

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}
// --- END: rust/ssxl_generate/src\benchmark_logic.rs ---
         2 LOC | rust/ssxl_generate/src\ca\mod.rs
// --- START: rust/ssxl_generate/src\ca\mod.rs ---
// ssxl_generate/src/ca/mod.rs

//! Core module for the Cellular Automata (CA) generation algorithms.
//!
//! This logic is used by the `CellularAutomataGenerator` to simulate environment
//! growth (e.g., cave systems, walls, and borders) based on local neighborhood rules.
//! This module provides the tools necessary to enforce a state-based system
//! for structured, yet emergent, world design.

// --- Sub-Modules ---

/// Defines the specific CA rules (e.g., Survival and Birth rules like 4/5).
/// This module abstracts the core generation logic, allowing for easy experimentation
/// and swapping of different CA rule sets to achieve diverse world patterns.
pub mod rule_set;

/// Contains logic for checking a cell's immediate surroundings and calculating
/// the neighbor count based on the current state. This is the low-level
/// component that feeds the local state into the `rule_set`.
pub mod neighbor_check;
// --- END: rust/ssxl_generate/src\ca\mod.rs ---
        28 LOC | rust/ssxl_generate/src\ca\neighbor_check.rs
// --- START: rust/ssxl_generate/src\ca\neighbor_check.rs ---
// ssxl_generate/src/neighbor_check.rs

use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    tile_type::TileType,
};

/// Counts the number of "live" (TileType::Rock) neighbors in the 3x3 Moore neighborhood
/// surrounding a specific cell within a chunk.
///
/// This function handles boundary conditions, ensuring checks do not exceed the
/// chunk's borders (0 to CHUNK_SIZE - 1). It is crucial for the tempo and accuracy
/// of the Cellular Automata simulation.
///
/// **Safety Focus:** Explicitly checks signed coordinates (`i32`) against bounds before
/// casting to unsigned types (`u32`) for indexing, preventing potential wraparound bugs.
///
/// # Arguments
/// * `chunk_data`: The data structure containing the chunk's tiles.
/// * `cx`: The X coordinate of the center cell (0 to CHUNK_SIZE - 1).
/// * `cy`: The Y coordinate of the center cell (0 to CHUNK_SIZE - 1).
///
/// # Returns
/// The count of live neighbors (0-8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;
    // Cache the chunk size as i32 for direct comparison against signed coordinates.
    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    // Convert center coordinates to i32 for safe arithmetic with dx/dy.
    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    // Iterate through the 3x3 Moore neighborhood relative to the center cell (cx, cy).
    for dx in -1..=1 {
        for dy in -1..=1 {
            // 1. Exclude the center cell itself (self-exclusion).
            if dx == 0 && dy == 0 {
                continue;
            }

            // Calculate the neighbor's absolute coordinates using i32.
            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            // 2. CRITICAL BOUNDARY CHECK: Ensure the neighbor is within the chunk's bounds [0, CHUNK_SIZE_I32 - 1].
            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                
                // Now that bounds are guaranteed, safely cast back to u32 for indexing.
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;
                
                // Use a helper function for safer access if available, otherwise calculate index.
                // Assuming ChunkData provides a tiles array indexed [y * size + x].
                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                // 3. Check for the "live" state, defined as TileType::Rock.
                // NOTE: This assumes `chunk_data.tiles` is publicly accessible.
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}
// --- END: rust/ssxl_generate/src\ca\neighbor_check.rs ---
        28 LOC | rust/ssxl_generate/src\ca\rule_set.rs
// --- START: rust/ssxl_generate/src\ca\rule_set.rs ---
// ssxl_generate/src/ca/rule_set.rs
use ssxl_shared::tile_type::TileType;

// --- 1. Rule Set Identifiers ---

/// Identifier for the standard cave generation ruleset (B4-5/S1-7).
pub const RULE_BASIC_CAVE: u8 = 0;
/// Identifier for the maze-like generation ruleset (B3/S1-4).
pub const RULE_MAZE: u8 = 1;
/// Placeholder/future rule for generating a solid block.
pub const RULE_SOLID: u8 = 2;
/// Placeholder/future rule for generating a checkerboard pattern.
pub const RULE_CHECKERBOARD: u8 = 3;

// --- 2. Core Rule Application Function ---

/// Determines the next state of a tile based on the current state, live neighbor count, and a specific ruleset.
///
/// This implements the standard Birth/Survival (B/S) rules for cellular automata.
///
/// # Arguments
/// * `current_type`: The tile's state at the current CA iteration (Void or Rock).
/// * `live_neighbors`: The count of surrounding `TileType::Rock` tiles (0-8).
/// * `ruleset`: The identifier defining the B/S parameters to use.
///
/// # Returns
/// The tile's state for the next CA iteration.
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {

    // Define the specific Birth (B) and Survival (S) parameters based on the ruleset ID.
    // Bx-y: Tile will be born (become Rock) if live_neighbors is in range [x, y] and current state is Void.
    // Sx-y: Tile will survive (remain Rock) if live_neighbors is in range [x, y] and current state is Rock.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),               // B3/S1-4 (Favors thin, complex structures with few dead ends)
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7),     // B4-5/S1-7 (Favors large, open, robust cave systems)
    };

    match current_type {
        // --- Survival Check: If the tile is currently Rock (alive) ---
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                // Within survival range: Rock survives.
                TileType::Rock
            } else {
                // Outside survival range: Rock dies (becomes Void).
                TileType::Void
            }
        }
        // --- Birth Check: If the tile is currently Void (dead) ---
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                // Within birth range: Void becomes Rock (birth).
                TileType::Rock
            } else {
                // Outside birth range: Void remains Void.
                TileType::Void
            }
        }
        // Handle any other TileTypes outside the CA simulation (e.g., Water, Ore) by leaving them unchanged.
        _ => current_type,
    }
}
// --- END: rust/ssxl_generate/src\ca\rule_set.rs ---
       130 LOC | rust/ssxl_generate/src\cellular_automata_generator.rs
// --- START: rust/ssxl_generate/src\cellular_automata_generator.rs ---
// ssxl_generate/src/cellular_automata_generator.rs

//! Implements a procedural generator based on Cellular Automata (CA) rules.
//!
//! This generator is responsible for creating cave systems, mazes, and other
//! structured patterns by iterating on an initially random chunk state. It
//! delegates complex logic to the `ca::rule_set` and `ca::neighbor_check` modules.

use crate::Generator;
use ssxl_math::Vec2i;
use fastrand; // Lightweight, fast, and thread-safe PRNG
use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    grid_bounds::GridBounds,
    tile_data::TileData,
    tile_type::TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

// --- 1. Generator Constants ---

/// The fixed number of iterations for the CA simulation to stabilize the pattern.
const CA_ITERATIONS: u8 = 4;
/// The percentage of tiles randomly initialized as `TileType::Rock` (the "live" state).
const INITIAL_FILL_PERCENT: u8 = 45;

// --- 2. Generator Structure and Implementation ---

/// A generator that uses Cellular Automata rules to produce structured patterns.
#[allow(dead_code)] // Allowed since this struct is instantiated via the GeneratorManager
pub struct CellularAutomataGenerator {
    /// The specific B/S ruleset (e.g., RULE_BASIC_CAVE or RULE_MAZE) to apply.
    ruleset: u8,
}

impl CellularAutomataGenerator {
    /// Creates a new CA generator instance with the specified ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// --- 3. Internal Generation Helper Functions ---

/// Generates static, non-simulated patterns (Solid or Checkerboard).
/// (Static pattern generation is unchanged and remains efficient)
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;
    
    // Calculate world boundaries for the ChunkData metadata
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;
    
    // Create a unique 64-bit Chunk ID
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
    
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );
    
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };
    
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
    // Since chunk_data.tiles is a fixed-size array, we must fill a temporary Vec
    // and let ChunkData::insert_tiles handle the conversion/copy.
    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    // Checkerboard pattern: alternate based on coordinate parity
                    if (x + y) % 2 == 0 {
                        TileType::Rock
                    } else {
                        TileType::Void
                    }
                }
                _ => TileType::Void, // Should not be reached, but defaults to Void
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

/// **OPTIMIZED:** Runs the full Cellular Automata simulation using double-buffering.
///
/// This function allocates the `target_tiles` array only once by cloning the initial state.
/// **FIXED:** Corrected array handling using `[TileData; N]` for zero-cost `std::mem::swap` in the loop.
fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    // 1. The initial state is in `chunk_data.tiles` (Source buffer). 
    // Create the second buffer (Target) by cloning the array once.
    let mut target_tiles = chunk_data.tiles.clone();
    
    // `chunk_data.tiles` is the Source (Read), `target_tiles` is the Target (Write).

    for i in 0..CA_ITERATIONS {
        // Core loop: Read from `chunk_data.tiles` (Source), write to `target_tiles` (Target).
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                
                // Read current tile properties from the source array
                let current_tile = &chunk_data.tiles[index];
                
                // 1. Check Neighbors: reads from the current state within `&chunk_data`.
                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                // 2. Apply Rule Set
                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                // 3. Update the new tile state in the TARGET buffer.
                // We preserve the noise value from the previous step.
                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }
        
        // EFFICIENT SWAP: Exchange the contents of the two arrays. O(1) pointer swap.
        // `chunk_data.tiles` now holds the new state (Source for next iteration).
        // `target_tiles` now holds the stale state (Target for next iteration).
        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        
        info!("CA Generator: Iteration {} complete.", i + 1);
    }
    
    // The final result is in `chunk_data.tiles`.
    chunk_data
}

// --- 4. Trait Implementation (Generator API) ---

impl Generator for CellularAutomataGenerator {
    /// Returns a unique identifier string for this generator instance.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    /// The main logic to generate a single chunk of data.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns quickly without the iterative CA loop.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // --- Seeding for Determinism (Crypto Coded Memory) ---
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);
        
        // --- Initialization ---
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
        // Use a temporary Vec to build the initial randomized state
        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Initial randomization based on INITIAL_FILL_PERCENT
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            // Noise value is typically unused in base CA but kept for data integrity
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        // Insert the initial state, which copies the data into the internal fixed-size array.
        chunk_data.insert_tiles(tiles_vec); 

        // --- Simulation Iterations (Refactored to single, optimized call) ---
        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}
// --- END: rust/ssxl_generate/src\cellular_automata_generator.rs ---
       136 LOC | rust/ssxl_generate/src\conductor.rs
// --- START: rust/ssxl_generate/src\conductor.rs ---
// ssxl_generate/src/conductor.rs

//! The Conductor: Central command and control for the SSXL procedural generation runtime.
//!
//! The Conductor initializes all core components (runtime, cache, generators) and manages
//! the asynchronous request and progress channels, ensuring thread-safe, high-speed
//! world generation. This is the **Conductor Genesis** system.

use tokio::sync::mpsc::{self, Sender};
use tracing::{info, error};
// FIX: Removed Mutex from this import as it's no longer used for ChunkCache
use std::sync::Arc; 
use std::io;

use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache; // Assumed to implement Send + Sync via internal locks.
use ssxl_shared::chunk_data::ChunkData;
use ssxl_tools::get_config_from_path;

use crate::runtime_manager::RuntimeManager;
use crate::config_validator::{ConfigValidator, GeneratorConfig};
use crate::task_queue::{
    handle_chunk_unit, start_request_loop,
    GenerationTask as ChunkRequest, GenerationMessage,
};
pub use crate::conductor_state::{ConductorState, ConductorStatus};
use crate::generator_manager::GeneratorManager;
use crate::batch_processor::spawn_batch_generation_task;

// --- 1. Channel Constants ---

/// Bound for the progress channel (Conductor -> External World). Generous buffer for status updates.
const PROGRESS_CHANNEL_BOUND: usize = 1024;

// --- 2. Conductor Structure ---

/// The core runtime manager and orchestrator for the SSXL Engine.
pub struct Conductor {
    /// Manages the Tokio asynchronous runtime.
    runtime_manager: RuntimeManager,
    /// Manages all registered procedural generation algorithms.
    generator_manager: GeneratorManager,
    /// Thread-safe state tracking (Status, Active Generator ID).
    internal_state: ConductorState,
    /// Thread-safe, in-memory cache for generated chunk data (The **crypto coded memory**).
    // FIX: Updated type from Arc<Mutex<ChunkCache>> to Arc<ChunkCache> to match batch_processor.
    chunk_cache: Arc<ChunkCache>,
    /// Sender for progress updates (e.g., ChunkGenerated, GenerationComplete).
    progress_sender: Sender<GenerationMessage>,
    /// Sender for new chunk requests. Stored internally for potential control signals (e.g., clearing the queue).
    #[allow(dead_code)]
	_request_sender: mpsc::UnboundedSender<ChunkRequest>,
}

impl Conductor {
    /// Initializes the entire SSXL generation runtime.
    ///
    /// This function sets up the Tokio runtime, the cache, the generators, and starts
    /// the main request processing loop on a background task.
    ///
    /// # Returns
    /// A tuple containing: (The Conductor itself, ConductorState for external monitoring,
    /// progress receiver, and the unbounded request sender).
    pub fn new(config_path: Option<&str>) -> Result<(Self, ConductorState, mpsc::Receiver<GenerationMessage>, mpsc::UnboundedSender<ChunkRequest>), io::Error> {
        
        // Load initial configuration
        let config = get_config_from_path(config_path)?;

        // Initialize the asynchronous runtime manager
        let runtime_manager = RuntimeManager::new()?;
        let handle = runtime_manager.get_handle();

        // Initialize generator manager and prepare map for sharing
        let generator_manager = GeneratorManager::new().map_err(|e| {
            io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
        })?;
        let generators_for_loop = Arc::new(generator_manager.get_map_clone());

        // Initialize thread-safe chunk cache
        let cache_instance = ChunkCache::new(4096)?;
        
        // FIX: Removed the Mutex wrapper. ChunkCache is now directly wrapped in an Arc.
        let chunk_cache = Arc::new(cache_instance);
        let chunk_cache_for_loop = chunk_cache.clone();

        // Set up communication channels
        let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
        // Unbounded for flexibility. This sender is what the external API uses.
        let (request_sender_api, request_receiver) = mpsc::unbounded_channel();
        
        // Clone the sender to store inside the Conductor struct for internal control/signals.
        let request_sender_internal = request_sender_api.clone();

        // Initialize state tracker
        let initial_id = generator_manager.get_initial_id(config.get_default_generator_id());
        let state = ConductorState::new(initial_id.clone());
        state.set_status(ConductorStatus::Running);
        let state_for_loop = state.clone();

        info!("Conductor initialized. Active generator: {}", initial_id);

        // Start the request processing loop on the Tokio runtime
        start_request_loop(
            handle,
            request_receiver,
            progress_sender.clone(),
            generators_for_loop,
            chunk_cache_for_loop, // This cache is now Arc<ChunkCache>
            Arc::new(state_for_loop),
        );

        let conductor = Conductor {
            runtime_manager,
            generator_manager,
            internal_state: state.clone(),
            chunk_cache, // This is now Arc<ChunkCache>
            progress_sender: progress_sender.clone(),
            _request_sender: request_sender_internal, // Stored internally
        };

        // Return the conductor and the external interface components (state, receivers, senders)
        // The 'request_sender_api' is returned here for use by the external caller.
        Ok((conductor, state, progress_receiver, request_sender_api))
    }
    
    /// Returns the ID of the generator currently selected for use.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    /// Starts a large, CPU-intensive batch generation task using `spawn_batch_generation_task`.
    ///
    /// This is the **bulldozer** operation, leveraging Rayon to generate chunks in parallel
    /// on a separate blocking thread pool to maintain the async core's **tempo**.
    pub fn start_generation(&mut self, config: GeneratorConfig) -> Result<(), Box<dyn std::error::Error>> {
        ConfigValidator::validate_map_dimensions(&config)?;

        self.set_active_generator(&config.generator_name)?;
        
        self.internal_state.set_status(ConductorStatus::Generating);

        // Spawn the batch task onto the blocking pool via the RuntimeManager's handle.
        spawn_batch_generation_task(
            &self.runtime_manager.get_handle(),
            self.generator_manager.get_map_clone(),
            // FIX: self.chunk_cache.clone() now correctly returns Arc<ChunkCache>, matching the batch_processor.
            self.chunk_cache.clone(), 
            self.internal_state.get_active_generator_id(),
            self.progress_sender.clone(),
            self.internal_state.clone(),
            config,
        );

        Ok(())
    }

    /// FFI Command: Immediately stops all pending and active generation tasks.
    ///
    /// This method sets the Conductor state to `Stopping`. The request processing loop
    /// (`start_request_loop`) is responsible for observing this state and refusing
    /// to process further `ChunkRequest` tasks, allowing the queue to drain harmlessly.
    pub fn stop_generation(&self) -> Result<(), Box<dyn std::error::Error>> {
        self.internal_state.set_status(ConductorStatus::Stopping);
        info!("Conductor: Global STOP command received. Status set to Stopping.");
        
        // No need to explicitly drop the internal sender here, as relying on the status 
        // check in the worker loop is the most robust way to stop tasks already in the queue.
        Ok(())
    }

    /// Synchronously retrieves a single chunk's data, either from cache or by immediate generation.
    ///
    /// This uses a temporary channel to force a blocking wait for the result, making it
    /// suitable for external FFI calls that require an immediate return value.
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();

        // Create a temporary, tightly-bound MPSC channel for a one-shot request/response.
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        // Run the chunk generation logic. It checks the cache first.
        // NOTE: The signature of handle_chunk_unit must also support the Arc<ChunkCache> change,
        // which it should if it's following the same optimized pattern.
        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache, 
            &temp_sender, // Sender will send result back through this channel.
        );
        
        // Block the current thread and wait for the result from the temporary channel.
        match temp_receiver.blocking_recv() {
            Some(GenerationMessage::ChunkGenerated(_coords, chunk_data_arc)) => {
                // Attempt to unwrap the Arc if possible, otherwise clone the ChunkData.
                Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone())
            },
            _ => {
                // If the channel closes or sends an unexpected message, panic.
                error!("get_chunk_data failed to receive ChunkGenerated message for coords: {:?}", chunk_coords);
                panic!("get_chunk_data failed to receive ChunkGenerated message.");
            }
        }
    }

    /// Sets the generator to be used for all future requests, if the ID is valid.
    pub fn set_active_generator(&mut self, id: &str) -> Result<(), String> {
        if self.generator_manager.get_map_ref().contains_key(id) {
            info!("Active generator set to: {}", id);
            self.internal_state.set_active_generator_id(id);
            Ok(())
        } else {
            let err = format!("Generator ID '{}' not found. Available IDs: {:?}", id, self.generator_manager.get_map_ref().keys());
            error!("{}", err);
            Err(err)
        }
    }

    /// Runs the generation process for a single chunk immediately, without cache check or channels.
    /// Used mainly for internal structural tests or single-run debug generation.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let active_id = self.internal_state.get_active_generator_id();
        self.generator_manager.generate_single_chunk(chunk_coords, &active_id)
    }

    /// Signals the Conductor's internal state that the batch generation task is complete.
    /// Sets status back to Running (Idle) after a batch generation is done.
    pub fn signal_generation_complete(&self) {
        info!("SSXL Conductor received GenerationComplete. Setting status to Running (Idle).");
        self.internal_state.set_status(ConductorStatus::Running);
    }
    
    /// Signals the Conductor's internal state that shutdown is beginning.
    pub fn signal_shutdown_graceful(&self) {
        info!("SSXL Conductor signaled for shutdown. Setting status to ShuttingDown.");
        self.internal_state.set_status(ConductorStatus::ShuttingDown);
    }

    /// Performs a full, graceful teardown of the entire runtime.
    pub fn graceful_teardown(self) {
        self.signal_shutdown_graceful();
        // The RuntimeManager handles shutting down the Tokio threads gracefully.
        self.runtime_manager.shutdown_graceful();
        info!("SSXL Conductor full teardown complete.");
    }
}
// --- END: rust/ssxl_generate/src\conductor.rs ---
        64 LOC | rust/ssxl_generate/src\conductor_state.rs
// --- START: rust/ssxl_generate/src\conductor_state.rs ---
// ssxl_generate/src/conductor_state.rs

//! Defines the ConductorState, which is the thread-safe, shared state of the SSXL engine.
//!
//! This structure provides real-time status, queue depth, and active generator tracking
//! for all components, functioning as the **crypto-coded memory** for the Conductor.

use tracing::error;
// Added AtomicU64 to support u64 return type for tile count
use std::sync::{Arc, Mutex, atomic::{AtomicUsize, AtomicU64, Ordering}};

// --- 1. Conductor Status Enum ---

/// Enumerates the operational states of the SSXL Conductor runtime.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    /// The runtime is starting up and initializing core components.
    Initializing,
    /// The runtime is fully operational and waiting for requests.
    Running,
    /// Request processing and generation are temporarily halted.
    Paused,
    /// A large batch generation task is actively running (**Bulldozer** mode).
    Generating,
    /// **FIX**: A global stop signal has been issued, waiting for tasks to cease gracefully.
    Stopping,
    /// A graceful shutdown has been initiated.
    ShuttingDown,
    /// A critical, non-recoverable error has occurred.
    Error,
}

// --- 2. Conductor State Structure ---

/// Thread-safe structure holding the shared state for the Conductor and all worker threads.
#[derive(Clone)]
pub struct ConductorState {
    /// The current operational status. Protected by a Mutex as updates are infrequent.
    status: Arc<Mutex<ConductorStatus>>,
    /// The number of pending chunk generation requests. Uses AtomicUsize for efficient, lock-free updates.
    queue_depth: Arc<AtomicUsize>,
    /// The ID string of the currently selected generator. Protected by a Mutex.
    active_generator_id: Arc<Mutex<String>>,
    /// The total number of tiles successfully placed during the current generation run.
    tile_counter: Arc<AtomicU64>,
}
#[allow(dead_code)]
impl ConductorState {
    /// Creates a new state instance, initialized to `Initializing`.
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: Arc::new(Mutex::new(ConductorStatus::Initializing)),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: Arc::new(Mutex::new(initial_generator_id)),
            tile_counter: Arc::new(AtomicU64::new(0)), // Initialize the new counter
        }
    }

    /// Retrieves the current operational status of the Conductor.
    /// Logs an error and returns `ConductorStatus::Error` if the mutex is poisoned.
    pub fn get_status(&self) -> ConductorStatus {
        match self.status.lock() {
            Ok(guard) => *guard,
            Err(e) => {
                error!("Mutex poisoned when reading status: {}", e);
                ConductorStatus::Error
            }
        }
    }
    
    /// Returns true if the Conductor is in a state where it can actively process or accept tasks.
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        // Only Running and Generating allow task processing.
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    /// Retrieves the current depth (number of pending requests) of the task queue.
    /// Uses relaxed memory ordering for maximum **tempo**, as strict ordering isn't critical.
    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    /// Retrieves the total number of tiles successfully placed.
    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    /// Retrieves the ID of the currently selected generator.
    pub fn get_active_generator_id(&self) -> String {
        // Using unwrap() assumes the Mutex will not be poisoned under normal engine operation.
        self.active_generator_id.lock().unwrap().clone()
    }

    /// Atomically increases the queue depth count. Used when a new task is posted.
    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    /// Atomically decreases the queue depth count. Used after a task is completed.
    pub fn decrement_queue_depth(&self) {
        // Note: fetch_sub handles underflow if used incorrectly, but should typically remain >= 0.
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    /// Atomically increases the tile count by the specified amount.
    /// Used by worker threads after placing a batch of tiles.
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    /// Updates the operational status. Only visible within the `ssxl_generate` crate.
    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.lock().unwrap() = new_status;
    }

    /// Updates the active generator ID string. Only visible within the `ssxl_generate` crate.
    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.lock().unwrap() = id.to_string();
    }
}
// --- END: rust/ssxl_generate/src\conductor_state.rs ---
        50 LOC | rust/ssxl_generate/src\config_validator.rs
// --- START: rust/ssxl_generate/src\config_validator.rs ---
// ssxl_generate/config_validator.rs

//! Contains the structural definition for batch generation requests and the
//! logic for validating user-defined map dimensions against engine limits.
//!
//! This ensures stability and prevents excessive memory usage during large-scale
//! **Bulldozer** generation tasks.

use tracing::{error, info};
use std::fmt;

/// The canonical size of a chunk in tiles, used for dimension conversion.
/// (Local definition for validation, typically sourced from ssxl_shared).
const CHUNK_SIZE: i64 = 64;

/// The hard safety limit on the total number of chunks allowed to be generated
/// or held in active memory to prevent system overload.
const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

// --- 1. Configuration Data Structure ---

/// Configuration parameters defining a single batch world generation request.
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    /// Desired world width in tiles.
    pub width: usize,
    /// Desired world height in tiles.
    pub height: usize,
    /// The deterministic seed string for the generation process (**Crypto-coded memory**).
    pub seed: String,
    /// The ID of the generator to execute (e.g., 'cellular_automata_basic').
    pub generator_name: String,
}

impl fmt::Display for GeneratorConfig {
    /// Implements display for easy logging and error reporting.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ Width: {}, Height: {}, Seed: '{}', Generator: '{}' }}",
            self.width, self.height, self.seed, self.generator_name
        )
    }
}

// --- 2. Validation Logic ---

/// Utility struct containing static methods for validating generator configurations.
pub struct ConfigValidator;

impl ConfigValidator {
    /// Validates that the requested map dimensions (width, height) are sane and
    /// do not exceed the `MAX_ACTIVE_CHUNKS` limit.
    ///
    /// This step is crucial for maintaining system **balance** and ensuring project **completion**.
    ///
    /// # Arguments
    /// * `config`: The generation request parameters.
    ///
    /// # Returns
    /// `Ok(())` if validation passes, or `Err(String)` with an error message otherwise.
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE;

        // Calculate world size in chunks (uses integer division ceiling trick for partial chunks).
        let width_in_chunks = (config.width as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (config.height as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        // Validation Check 1: Must generate at least one chunk.
        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}. Dimensions are too small.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // Validation Check 2: Must not exceed the safety limit.
        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}. Adjust MAX_ACTIVE_CHUNKS or reduce map size.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}). Starting **Bulldozer** operation.",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}
// --- END: rust/ssxl_generate/src\config_validator.rs ---
         6 LOC | rust/ssxl_generate/src\generator.rs
// --- START: rust/ssxl_generate/src\generator.rs ---
// ssxl_generate/src/generator.rs
//! Defines the core Generator trait, the contract for all procedural generation algorithms.
//!
//! Any module (e.g., CellularAutomataGenerator, PerlinGenerator) intended to be managed
//! by the GeneratorManager and executed by the Conductor must implement this trait.

use ssxl_shared::chunk_data::ChunkData;

use ssxl_math::Vec2i;

/// The fundamental trait for all world generation algorithms in the SSXL Engine.
///
/// This contract ensures that all generators can be treated uniformly by the
/// Conductor runtime, maintaining the engine's modularity and high **tempo**.
#[allow(dead_code)] // The trait itself isn't used directly, but its implementors are.
pub trait Generator {
    /// Returns a unique, static string identifier for this specific generator instance.
    ///
    /// This ID is used by the Conductor to select the active generation strategy
    /// and should be unique across all registered generators.
    fn id(&self) -> &str;

    /// Executes the generation algorithm for a single chunk at the specified coordinates.
    ///
    /// The implementation must be **deterministic** and **self-contained**, relying only on
    /// the chunk coordinates and internal seed/ruleset to produce the `ChunkData`.
    ///
    /// # Arguments
    /// * `chunk_coords`: The global coordinate (X, Y) of the chunk to generate.
    ///
    /// # Returns
    /// The fully generated `ChunkData` structure.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}
// --- END: rust/ssxl_generate/src\generator.rs ---
        51 LOC | rust/ssxl_generate/src\generator_manager.rs
// --- START: rust/ssxl_generate/src\generator_manager.rs ---
// ssxl_generate/generator_manager.rs

//! The GeneratorManager acts as a registry for all available procedural generation algorithms.
//!
//! It initializes concrete generator types (Perlin, Cellular Automata) and stores them
//! as trait objects, enabling the Conductor to select and execute any generator by ID.

use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::Vec2i;
use ssxl_shared::chunk_data::ChunkData;

use crate::Generator;
use crate::perlin_generator::PerlinGenerator;
use crate::cellular_automata_generator::CellularAutomataGenerator;

use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
/// This allows the HashMap to store different generator types uniformly.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- 1. Manager Structure ---

/// Manages and provides access to all initialized generation algorithms.
pub struct GeneratorManager {
    /// The core registry: Maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    /// The ID of the default Perlin noise generator, used as a fallback.
    default_perlin_id: String,
}

impl GeneratorManager {
    /// Initializes all generator algorithms and registers them in the HashMap.
    ///
    /// This is the "Dimension Registry" initialization, setting up all available
    /// generation **experiments**.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // 1. Register Perlin Generator (The base noise layer)
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        // Wrap in Arc for thread-safe sharing with worker tasks.
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // 2. Register Cellular Automata Generators (The structured content layers)
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    /// Returns a reference to the internal generator map.
    /// Used by the Conductor for immediate, local lookups.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    /// Returns a clone of the internal generator map.
    /// Used when spawning new background tasks that need to own a map copy (e.g., the Request Loop).
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    /// Executes the generation process for a single chunk using the specified active generator ID.
    ///
    /// Used primarily by the Conductor for synchronous, single-chunk requests.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            // Panic is appropriate here as the generator ID should have been validated previously.
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        // Dereference the Arc<DynGenerator> and call the trait method.
        generator_arc.generate_chunk(chunk_coords)
    }

    /// Determines the initial active generator ID, prioritizing the config ID and falling back to default Perlin.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, self.default_perlin_id);
            self.default_perlin_id.clone()
        }
    }
}
// --- END: rust/ssxl_generate/src\generator_manager.rs ---
        38 LOC | rust/ssxl_generate/src\lib.rs
// --- START: rust/ssxl_generate/src\lib.rs ---
// ssxl_generate/src/lib.rs

//! The core library crate for the SSXL procedural generation engine.
//!
//! This crate orchestrates the asynchronous runtime, manages generator algorithms,
//! and provides the central Conductor API for world creation.

use ssxl_shared::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use tracing::{info, error};

// --- 1. Internal Module Definitions ---

/// Core command and control center for the generation engine.
pub mod conductor;
/// Logic for stress-testing and profiling generator algorithms.
pub mod benchmark_logic;
/// Perlin noise based generator implementation.
pub mod perlin_generator;
/// Cellular Automata based generator implementation.
pub mod cellular_automata_generator;
/// Module containing Cellular Automata specific rules and utilities.
pub mod ca; 
/// Manages the Tokio asynchronous runtime.
pub mod runtime_manager; 
/// Utilities for validating generation request configurations.
pub mod config_validator;
/// Manages the asynchronous chunk generation task queue.
pub mod task_queue;
/// Thread-safe state tracking for the Conductor.
pub mod conductor_state;
/// Registry for all available generation algorithms.
pub mod generator_manager;
/// Logic for processing large batch generation requests (**Bulldozer** operation).
pub mod batch_processor;
/// Module for synchronous types used for external communication (Senders/Receivers).
pub mod sync; 


// --- 2. Core Generator Trait Definition ---

/// The fundamental contract for all world generation algorithms.
/// (Duplicated here from `generator.rs` for convenience and to define the public contract).
pub trait Generator {
    /// Returns a unique, static string identifier for this generator.
    fn id(&self) -> &str;

    /// Executes the deterministic generation algorithm for a single chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


// --- 3. Public API Exports (Re-exports for external use) ---

// Concrete Generator implementations
pub use cellular_automata_generator::CellularAutomataGenerator;
pub use perlin_generator::PerlinGenerator;

// Conductor and Configuration Types
pub use conductor::Conductor;
pub use config_validator::GeneratorConfig; 

// Synchronization and Task Types (For FFI and API integration)
pub use sync::ConductorProgressReceiver;
pub use sync::ConductorRequestSender;
pub use task_queue::GenerationTask; 

// Benchmark Utility
pub use benchmark_logic::benchmark_generation_workload;


// --- 4. Initialization Placeholder (Example/Debug) ---

/// A placeholder function to test Conductor initialization and immediate graceful shutdown.
/// This simulates a quick external call to verify runtime setup and teardown.
pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Execute the cleanup logic
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}
// --- END: rust/ssxl_generate/src\lib.rs ---
        65 LOC | rust/ssxl_generate/src\perlin_generator.rs
// --- START: rust/ssxl_generate/src\perlin_generator.rs ---
// ssxl_generate/src/perlin_generator.rs

//! Implements the Generator trait using the Perlin noise function.
//!
//! This provides the engine's primary continuous, organic generation layer,
//! mapping noise values to different TileTypes based on a fixed threshold.

use crate::Generator;
use ssxl_shared::chunk_data::{ChunkData, CHUNK_SIZE};
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_math::Vec2i;
use ssxl_shared::tile_data::TileData;
use ssxl_shared::tile_type::TileType;

use noise::{NoiseFn, Perlin};
use tracing::info;

// --- 1. Generator Structure ---

/// A generator that uses the Perlin noise algorithm to create deterministic terrain.
pub struct PerlinGenerator {
    /// The noise object instance, which is thread-safe and deterministic based on its seed.
    perlin: Perlin,
    /// The scaling factor applied to world coordinates before generating noise.
    /// A smaller scale results in larger, smoother features.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator instance.
    ///
    /// # Arguments
    /// * `scale`: The frequency/scale of the noise (e.g., 64.0).
    pub fn new(scale: f64) -> Self {
        // NOTE: Default seed is currently hardcoded for deterministic, repeatable generation.
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// --- 2. Generator Trait Implementation ---

impl Generator for PerlinGenerator {
    /// Returns the unique identifier for this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates a single chunk based on the Perlin noise field.
    ///
    /// The logic is: 1) Convert chunk coordinates to world tile coordinates,
    /// 2) Sample the Perlin function, 3) Map the noise value to a `TileType`.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Calculate the world coordinate of the chunk's bottom-left corner.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Create a unique Chunk ID by packing the 2D coordinates into a 64-bit integer.
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Define the world bounds covered by this chunk.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Pre-allocate vector to hold all tile data for the chunk.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Iterate through all tiles within the chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // Sample the Perlin noise function. Coordinates are scaled down.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Perlin output is typically [-1.0, 1.0]. Normalize to [0.0, 1.0].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // Thresholding: Map the noise value to a concrete TileType (Water, Grass, Mountain).
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // Create the TileData, storing the raw noise value as metadata (useful for blending/details).
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }

        // Insert the generated tile array into the chunk data structure.
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}
// --- END: rust/ssxl_generate/src\perlin_generator.rs ---
        26 LOC | rust/ssxl_generate/src\runtime_manager.rs
// --- START: rust/ssxl_generate/src\runtime_manager.rs ---
// ssxl_generate/src/runtime_manager.rs

//! Manages the Tokio asynchronous runtime for the SSXL generation engine.
//!
//! The RuntimeManager is responsible for initializing the multi-threaded
//! runtime, providing handles to worker threads, and coordinating a graceful shutdown,
//! ensuring the highest possible **tempo** for asynchronous operations.

use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

/// Manages the lifecycle of the underlying Tokio asynchronous runtime.
pub struct RuntimeManager {
    /// The core Tokio multi-threaded runtime instance.
    runtime: Runtime,
}

impl RuntimeManager {
    /// Initializes a new multi-threaded Tokio runtime.
    ///
    /// The runtime is configured to use the same number of worker threads as the
    /// machine's logical CPU cores, maximizing parallelism for generation tasks.
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads (all logical cores).", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            // Set worker count to the number of logical cores.
            .worker_threads(num_cores)
            // Enable all features (timers, I/O) for general utility.
            .enable_all()
            .build()?;
            
        Ok(RuntimeManager { runtime })
    }

    /// Returns a clone of the runtime's handle.
    ///
    /// This handle is used by the **Conductor** to spawn new asynchronous tasks
    /// and to execute CPU-heavy tasks on the dedicated blocking thread pool.
    pub fn get_handle(&self) -> Handle {
        self.runtime.handle().clone()
    }

    /// Signals the Tokio runtime to begin a graceful shutdown in the background.
    ///
    /// This allows all remaining tasks to complete their current work before the
    /// threads are finally torn down.
    pub fn shutdown_graceful(self) {
        info!("Tokio Runtime signaling graceful shutdown.");
        // This method instructs the runtime to shut down without blocking the current thread.
        self.runtime.shutdown_background();
        info!("Tokio Runtime full teardown complete.");
    }
}
// --- END: rust/ssxl_generate/src\runtime_manager.rs ---
         5 LOC | rust/ssxl_generate/src\sync.rs
// --- START: rust/ssxl_generate/src\sync.rs ---
// ssxl_generate/src/sync.rs

//! Defines public type aliases for synchronization primitives used to communicate
//! with the Conductor from external systems (like FFI wrappers).
//!
//! This module simplifies the public API by wrapping complex Tokio channel types.

use tokio::sync::mpsc;
use crate::task_queue::GenerationMessage;
use crate::task_queue::GenerationTask;

// --- Public Synchronization Type Aliases ---

/// An unbounded sender for posting new chunk generation requests to the Conductor's task queue.
///
/// This is the primary input channel for the SSXL generation engine, allowing users to
/// queue up work (`GenerationTask`) without blocking.
pub type ConductorRequestSender = mpsc::UnboundedSender<GenerationTask>;

/// The receiver for all progress updates and completion messages from the Conductor.
///
/// This channel delivers structured updates (`GenerationMessage`) such as `ChunkGenerated`
/// and `GenerationComplete` back to the external caller.
pub type ConductorProgressReceiver = mpsc::Receiver<GenerationMessage>;
// --- END: rust/ssxl_generate/src\sync.rs ---
        91 LOC | rust/ssxl_generate/src\task_queue.rs
// --- START: rust/ssxl_generate/src\task_queue.rs ---
// ssxl_generate/src/task_queue.rs

//! Manages the asynchronous request loop for chunk generation and the core logic
//! for handling a single chunk request (cache check, generation, and storage).

use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tracing::{info, error, warn};
use std::collections::HashMap;
// FIX: Removed Mutex import. Arc is sufficient, as ChunkCache handles its own locking.
use std::sync::Arc; 

use glam::I64Vec3;
use ssxl_math::{Vec2i, prelude::ChunkKey};

use ssxl_cache::ChunkCache;
use crate::Generator;
use crate::conductor_state::ConductorState;

use ssxl_shared::chunk_data::ChunkData;
// Import the canonical size from ssxl_shared and cast it locally for coordinate math.
use ssxl_shared::config::CHUNK_SIZE as SHARED_CHUNK_SIZE;
pub use ssxl_shared::generation_message::{GenerationMessage, GenerationTask};


/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
type DynGenerator = Box<dyn Generator + Send + Sync>;

/// Canonical chunk size in i64 format for coordinate math.
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;


// --- 1. Single Chunk Processing Unit ---

/// The atomic unit of work for chunk generation.
///
/// This synchronous function performs the cache lookup, calls the generator if needed,
/// saves the result to the cache, and sends a completion message.
///
/// **Crucially, this must be run on a blocking thread pool (e.g., via `spawn_blocking`)
/// because generator functions are CPU-intensive and synchronous.**
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    // CRITICAL FIX: Changed from &Arc<Mutex<ChunkCache>> to &Arc<ChunkCache>.
    // We rely on ChunkCache's internal AtomicResource for thread-safe concurrent access.
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
) {
    let key_vec3 = I64Vec3::new(chunk_coords.x, chunk_coords.y, 0);
    let chunk_key = ChunkKey(key_vec3);
    let chunk_data: ChunkData;
    
    // We now interact directly with the ChunkCache which manages its internal lock (RwLock/AtomicResource).
    // This removes the redundant and bottlenecking Mutex::lock() call.

    // 1. Check Cache (Crypto-coded memory)
    match chunk_cache.load_chunk(&chunk_key) {
        Ok(Some(data)) => {
            info!("Chunk Unit: Retrieved chunk {:?} from cache (Gen: {}).", chunk_coords, generator_name);
            // 'data' is Arc<ChunkData>, 'chunk_data' is ChunkData.
            chunk_data = (*data).clone();
        },
        Ok(None) => {
            // 2. Generate if Cache Miss
            info!("Chunk Unit: Chunk {:?} not found in cache. Generating with {}.", chunk_coords, generator_name);
            let generator_arc = generators
                .get(generator_name)
                .expect("Generator ID must be registered in Conductor.");
            
            chunk_data = generator_arc.generate_chunk(chunk_coords);
            
            // 3. Save to Cache
            // ChunkCache::save_chunk expects Arc<ChunkData>.
            if let Err(e) = chunk_cache.save_chunk(&chunk_key, Arc::new(chunk_data.clone())) {
                error!("Chunk Unit: Failed to save chunk {:?} to cache: {:?}", chunk_coords, e);
            } else {
                info!("Chunk Unit: Saved chunk {:?} to cache.", chunk_coords);
            }
        },
        Err(e) => {
            // Cache system error (e.g., I/O or internal AtomicResource error), generate without caching.
            warn!("Chunk Unit: Cache access failed for {:?}: {:?}. Falling back to generation without caching.", chunk_coords, e);
            let generator_arc = generators
                .get(generator_name)
                .expect("Generator ID must be registered in Conductor.");
            chunk_data = generator_arc.generate_chunk(chunk_coords);
        }
    }
    
    // 4. Send Completion/Progress Message
    let chunk_data_arc = Arc::new(chunk_data);
    
    // Use blocking_send as this function is already running on a blocking thread.
    if let Err(e) = progress_sender.blocking_send(
        GenerationMessage::ChunkGenerated(chunk_coords, chunk_data_arc)
    ) {
        error!("Chunk Unit: Failed to send ChunkGenerated message for {:?}: {:?}", chunk_coords, e);
    }
}


// --- 2. Asynchronous Request Loop ---

/// Spawns the main request processing loop onto the Tokio runtime handle.
///
/// This loop listens for new generation tasks and offloads the synchronous work
/// to the dedicated `tokio::task::spawn_blocking` thread pool, maintaining the
/// asynchronous core's **tempo**.
pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    // FIX: Changed from Arc<Mutex<ChunkCache>> to Arc<ChunkCache> to align with Conductor/batch_processor.
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue active. Listening for requests.");
        
        // Loop while the sender side of the channel is open.
        while let Some(task) = request_rx.recv().await {
            // Check Conductor State (Pause/Shutdown)
            if !conductor_state.as_ref().is_active() { 
                warn!("Request received while Conductor is paused or shutting down. Dropping task: {:?}", task.chunk_coords);
                // Note: Task queue depth management (if any) is assumed to happen externally or based on the drop.
                continue;
            }

            // Prepare thread-safe clones for the blocking task
            let progress_tx_clone = progress_tx.clone();
            let generators_clone = generators.clone();
            let chunk_cache_clone = chunk_cache.clone();

            // Offload CPU-intensive work to the dedicated blocking thread pool.
            tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators_clone,
                    &chunk_cache_clone, // Now the correct Arc<ChunkCache> type
                    &progress_tx_clone,
                );
            });
        }
        
        // Loop exited (sender was dropped), signifying engine shutdown.
        info!("Generation Task Queue shutting down.");
        // FIX: Ensure the final message is sent asynchronously.
        if progress_tx.send(GenerationMessage::GenerationComplete).await.is_err() { 
            error!("Failed to send final GenerationComplete message.");
        }
    });
}
// --- END: rust/ssxl_generate/src\task_queue.rs ---
       118 LOC | rust/ssxl_godot/src\animation_api.rs
// --- START: rust/ssxl_godot/src\animation_api.rs ---
// ssxl_godot/src/animation_api.rs

//!
//! Provides the public API interface for Godot to interact with the
//! asynchronous **Animation Conductor**.
//!
//! This adapter is responsible for:
//! 1. Translating Godot calls into structured `AnimationCommand` messages.
//! 2. Synchronously retrieving generated `ChunkData` from the main **Conductor**.
//! 3. Sending chunk data and commands to the animation worker thread for visual updates.

use godot::classes::{Node, TileMap};
use godot::obj::Gd;

use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

use ssxl_generate::Conductor;
use ssxl_math::Vec2i;
use ssxl_sync::AnimationConductorHandle;
// The AnimationCommand definition has changed to use unit variants and SetTimeScale(f32).
use ssxl_shared::messages::AnimationCommand;

// -----------------------------------------------------------------------------
// 1. API Structure
// -----------------------------------------------------------------------------

/// The Godot API layer for controlling the background animation processing thread.
///
/// It holds non-owning, bounded references (`'a`) to the essential Conductor handles.
#[derive(Default)]
// FIX 1: Allow dead code, as this struct is constructed externally via FFI.
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    /// Handle used to send commands to the Animation Conductor (responsible for frame updates).
    animation_conductor: Option<&'a AnimationConductorHandle>,
    /// Thread-safe reference to the main Generation Conductor (used to retrieve completed chunk data).
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// FIX 2: Allow dead code for all associated items, as they are called externally via FFI.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    /// Constructs a new AnimationAPI, setting the internal references upon initialization.
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }


    // -------------------------------------------------------------------------
    // 2. High-Level Command Mapping
    // -------------------------------------------------------------------------

    /// Receives a string command from Godot and maps it to the appropriate `AnimationCommand` enum.
    /// This provides a flexible entry point for custom scripting.
    pub fn send_command_by_name(&self, command_name: String) {
        if let Some(handle) = self.animation_conductor {
            let command = match command_name.as_str() {
                // FIX: Map to the unit variant
                "StartTestAnimation" => {
                    info!("AnimationAPI: Mapping to StartTestAnimation command.");
                    AnimationCommand::StartTestAnimation
                },
                // FIX: Map stop/disable to SetTimeScale(0.0)
                "StopTestAnimation" => {
                    info!("AnimationAPI: Mapping stop test animation to SetTimeScale(0.0).");
                    AnimationCommand::SetTimeScale(0.0)
                },
                // FIX: Map enable/start to SetTimeScale(1.0)
                "ANIMATION_ENABLE" => {
                    info!("AnimationAPI: Mapping animation enable to SetTimeScale(1.0).");
                    AnimationCommand::SetTimeScale(1.0)
                },
                // FIX: Map disable/stop to SetTimeScale(0.0)
                "ANIMATION_DISABLE" => {
                    info!("AnimationAPI: Mapping animation disable to SetTimeScale(0.0).");
                    AnimationCommand::SetTimeScale(0.0)
                },
                _ => {
                    warn!("AnimationAPI: Received unrecognized command: {}", command_name);
                    return;
                }
            };

            if let Err(e) = handle.send(command) {
                error!("AnimationAPI: Failed to send command to worker: {}", e);
            }
        } else {
            warn!("AnimationAPI: Command '{}' received, but animation conductor is not initialized.", command_name);
        }
    }

    // -------------------------------------------------------------------------
    // 3. Specific Control Methods
    // -------------------------------------------------------------------------

    /// Starts a predefined test animation sequence.
    pub fn start_test_animation(&self, _tilemap_node: Option<&Gd<TileMap>>) {
        if let Some(handle) = self.animation_conductor {
            // FIX: Using the unit variant StartTestAnimation
            let command = AnimationCommand::StartTestAnimation;

            match handle.send(command) {
                Ok(_) => info!("AnimationAPI: Sent StartTestAnimation command."),
                Err(e) => error!("Failed to send StartTestAnimation command: {}", e),
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start test animation.");
        }
    }

    /// Stops the running test animation sequence.
    pub fn stop_test_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping 30x30 test animation by setting time scale to zero.");

            // FIX: Mapping stop to SetTimeScale(0.0)
            if let Err(e) = handle.send(AnimationCommand::SetTimeScale(0.0)) {
                error!("Failed to send SetTimeScale(0.0) (stop) command: {}", e);
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop test animation.");
        }
    }

    /// Configures the animation framerate and sends the global start command.
    pub fn start_loading_animation(
        &self,
        framerate: f32,
        _signals_node: Option<&Gd<Node>>,
    ) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Starting loading animation at {:.2} FPS by setting time scale.", framerate);

            // FIX: The framerate is used as the f32 argument for SetTimeScale
            let update_result = handle.send(AnimationCommand::SetTimeScale(framerate));
            
            // The Start command is removed, as SetTimeScale(non-zero) implies running.
            // If the framerate is 0, the animation will not start/run.

            if let Err(e) = update_result {
                error!("Failed to send SetTimeScale command: {}", e);
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start animation.");
        }
    }

    /// Stops the generic loading animation sequence.
    pub fn stop_loading_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping loading animation by setting time scale to zero.");

            // FIX: Mapping stop to SetTimeScale(0.0)
            if let Err(e) = handle.send(AnimationCommand::SetTimeScale(0.0)) {
                error!("Failed to send SetTimeScale(0.0) (stop) command: {}", e);
            }

        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop animation.");
        }
    }

    // -------------------------------------------------------------------------
    // 4. Data Transfer Method
    // -------------------------------------------------------------------------

    /// Retrieves pre-generated chunk data from the main Conductor and registers it
    /// with the animation system for display/interpolation.
    pub fn register_chunk_for_animation(&self, chunk_x: i32, chunk_y: i32) {
        if let Some(_handle) = self.animation_conductor {

            let coords = Vec2i::new(chunk_x as i64, chunk_y as i64);

            if let Some(conductor_arc) = self._conductor {
                // Lock the Conductor Mutex to call the synchronous data retrieval method.
                let result = conductor_arc.lock().map(|conductor| {
                    // Synchronously get the data (this will perform generation if not cached).
                    let _chunk_data = conductor.get_chunk_data(&coords);
                    
                    // FIX: The AnimationCommand enum no longer has a 'RegisterChunk' or 'LoadChunk'
                    // variant for sending raw data. The intended functionality is currently missing
                    // from the communication contract (ssxl_shared::messages::AnimationCommand).
                    warn!("AnimationAPI: Cannot register chunk ({}, {}). The command for data registration (e.g., RegisterChunk) is not available in the current AnimationCommand definition. Skipping command send.", chunk_x, chunk_y);
                    
                });

                if let Err(e) = result {
                    error!("Failed to lock Conductor mutex for chunk data retrieval: {}", e);
                }
            } else {
                warn!("Generation Conductor is not initialized. Cannot register chunk data.");
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot register chunk.");
        }
    }
}
// --- END: rust/ssxl_godot/src\animation_api.rs ---
       114 LOC | rust/ssxl_godot/src\api_initializers.rs
// --- START: rust/ssxl_godot/src\api_initializers.rs ---
//! # Godot Engine Initializers (`ssxl_godot::api_initializers`)
//!
//! Manages the initialization and graceful shutdown of the two core background
//! asynchronous systems: the **Generation Conductor** and the **Animation Conductor**.
//! This is the FFI layer's entry point for starting the Rust engine runtime.

use std::sync::{Arc, Mutex};
use tracing::{info, error};

// --- Standard Library Imports for Concurrency ---
use tokio::sync::mpsc;
use tokio::sync::mpsc::UnboundedReceiver;

// --- Imports from ssxl_generate ---
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
};
use ssxl_generate::conductor_state::ConductorState;

// --- Imports from ssxl_sync ---
use ssxl_sync::{
    AnimationConductor,
    AnimationConductorHandle as CoreAnimationConductorHandle, // Use alias for clarity
};

// --- Imports from ssxl_shared ---
use ssxl_shared::{
    messages::AnimationCommand,
    AnimationState,
    messages::AnimationUpdate as CoreAnimationUpdate,
};

// -----------------------------------------------------------------------------
// Type Aliases
// -----------------------------------------------------------------------------

/// Type alias for the `AnimationConductor` command sender handle.
// FIX: Removed generic argument <AnimationCommand> as the original type alias is already concrete.
pub type AnimationConductorHandle = CoreAnimationConductorHandle; 

/// Type alias for the `AnimationConductor` update receiver.
pub type AnimationUpdateReceiver = UnboundedReceiver<CoreAnimationUpdate>;


// -----------------------------------------------------------------------------
// EngineInitializer Struct and Implementation
// -----------------------------------------------------------------------------

/// Responsible for initializing and managing the lifecycle of the entire SSXL Engine runtime.
#[derive(Debug, Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    /// Creates a new, default instance of the initializer.
    pub fn new() -> Self {
        Self {}
    }

    // -------------------------------------------------------------------------
    // 1. Generation Conductor Initialization
    // -------------------------------------------------------------------------

    /// Initializes the main world generation system (`Conductor`).
    pub fn ensure_conductor(
        &self
    ) -> (
        // Thread-safe handle to the Conductor struct itself.
        Option<Arc<Mutex<Conductor>>>,
        // Receiver for generated chunk data and progress messages.
        Option<ConductorProgressReceiver>,
        // The thread-safe state tracker for the generation pipeline.
        Option<ConductorState>
    ) {
        info!("EngineInitializer: Attempting to initialize Conductor...");

        // Conductor::new starts the Tokio runtime and the main request loop.
        match Conductor::new(None) {
            Ok((conductor, state, gen_rx, _request_tx)) => {
                info!("Conductor initialized and background thread started successfully.");
                // We return the Conductor in a Mutex/Arc for thread-safe access from Godot.
                (Some(Arc::new(Mutex::new(conductor))), Some(gen_rx), Some(state))
            }
            Err(e) => {
                error!("Failed to initialize Conductor: {}", e);
                (None, None, None)
            }
        }
    }

    // -------------------------------------------------------------------------
    // 2. Animation Conductor Initialization
    // -------------------------------------------------------------------------

    /// Initializes the dedicated animation processing system (`AnimationConductor`).
    pub fn ensure_animation_conductor(
        &self
    ) -> (
        // Sender for control commands (e.g., Start, Stop, UpdateFramerate).
        Option<AnimationConductorHandle>,
        // Receiver for real-time animation updates.
        Option<AnimationUpdateReceiver>,
        // The thread-safe state tracker for the animation pipeline.
        Option<AnimationState>
    ) {
        info!("EngineInitializer: Attempting to initialize AnimationConductor...");

        // Create the communication channels.
        let (anim_tx, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        let (update_tx, update_rx) = mpsc::unbounded_channel::<CoreAnimationUpdate>();
        let anim_state = AnimationState::default();

        // Clone the AnimationState to pass to the background thread while retaining the original.
        let state_to_pass = anim_state.clone();

        // Start the background AnimationConductor thread.
        let _conductor = AnimationConductor::new(anim_rx, update_tx, state_to_pass);

        info!("AnimationConductor initialized and thread started successfully.");
        (
            // Return the sender handle for commands
            Some(anim_tx),
            // Return the receiver for tile updates, using the new alias
            Some(update_rx),
            // Return the original state tracker
            Some(anim_state)
        )
    }

    // -------------------------------------------------------------------------
    // 3. Core Setup Orchestration
    // -------------------------------------------------------------------------

    /// Orchestrates the setup for both the Generation and Animation cores.
    pub fn execute_core_setup(
        &self
    ) -> (
        // Conductor Handles
        Option<Arc<Mutex<Conductor>>>,
        Option<ConductorProgressReceiver>,
        Option<ConductorState>,
        // Animation Handles
        Option<AnimationConductorHandle>,
        Option<AnimationUpdateReceiver>,
        Option<AnimationState>,
    ) {
        let (c, grx, gs) = self.ensure_conductor();
        let (ah, arx, as_) = self.ensure_animation_conductor();

        (c, grx, gs, ah, arx, as_)
    }

    // -------------------------------------------------------------------------
    // 4. Graceful Shutdown
    // -------------------------------------------------------------------------

    /// Performs a **graceful shutdown** of both background conductors.
    pub fn shutdown(
        &self,
        mut anim_handle: Option<AnimationConductorHandle>,
        mut conductor_arc: Option<Arc<Mutex<Conductor>>>,
    ) {
        info!("EngineInitializer: Starting graceful shutdown process...");

        // 1. Shut down Generation Conductor (requires unique ownership)
        if let Some(arc) = conductor_arc.take() {
            // Attempt to unwrap the Arc to ensure we have the *only* reference.
            match Arc::try_unwrap(arc) {
                Ok(mutex) => {
                    info!("Shutting down Conductor...");
                    match mutex.into_inner() {
                        Ok(conductor) => {
                            conductor.graceful_teardown();
                            info!("Conductor shutdown complete.");
                        }
                        Err(e) => {
                            error!("Failed to unwrap Conductor Mutex (poisoned): {:?}", e);
                        }
                    }
                }
                Err(_) => {
                    error!("Could not unwrap Conductor Arc; other references may exist. Conductor may leak resources.");
                }
            }
        }

        // 2. Shut down Animation Conductor (by sending a command)
        if let Some(handle) = anim_handle.take() {
            // Send a Shutdown command to the animation thread's receiver.
            match handle.send(AnimationCommand::Shutdown) {
                Ok(_) => info!("AnimationConductor shutdown command sent successfully."),
                Err(e) => error!("Failed to send shutdown command to AnimationConductor: {}", e),
            }
        } else {
            info!("AnimationConductor handle was already consumed or not initialized.");
        }

        info!("EngineInitializer: All background runtimes terminated.");
    }
}
// --- END: rust/ssxl_godot/src\api_initializers.rs ---
        89 LOC | rust/ssxl_godot/src\async_poll.rs
// --- START: rust/ssxl_godot/src\async_poll.rs ---
//! # AsyncPoller
//!
//! This module implements the `AsyncPoller` struct, which acts as a crucial **thread-safe bridge**
//! between the SSXL-ext engine's **Rust worker threads** (Generation and Animation) and the
//! **Godot main thread**. It uses non-blocking channel polling (`try_recv`) to safely drain
//! messages without stalling the game engine loop.

// --- Godot GDExtension Imports ---
// NOTE: Removed unused godot imports (Node, Gd)
// --- Standard Library Imports ---
use std::sync::Arc;
// --- External Asynchronous Runtime Imports (Tokio) ---
use tokio::sync::mpsc::{
    Receiver as TokioReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError as TokioTryRecvError
};
// --- SSXL-ext Shared & Generation Crates Imports ---
use ssxl_generate::task_queue::GenerationMessage;
use ssxl_shared::chunk_data::ChunkData;
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_shared::messages::{ChunkMessage, AnimationUpdate};

// -----------------------------------------------------------------------------
// Constants and Type Aliases
// -----------------------------------------------------------------------------

/// **CRITICAL THROTTLE:** Max number of chunk messages to process in a single Godot frame.
/// This prevents the main thread from stalling when the Rust core finishes generating too quickly.
const MAX_GENERATION_MESSAGES_PER_POLL: usize = 64;

/// **REAL-TIME THROTTLE:** Max number of animation updates to process in a single Godot frame.
/// This ensures the main thread doesn't stutter under high animation load.
const MAX_ANIMATION_MESSAGES_PER_POLL: usize = 2048;

/// Type alias for the bounded channel receiver used by the **Generation** conductor.
pub type GenerationReceiver = TokioReceiver<GenerationMessage>;

/// Type alias for the unbounded channel receiver used by the **Animation** conductor.
pub type AnimationReceiver = TokioUnboundedReceiver<AnimationUpdate>;


// -----------------------------------------------------------------------------
// AsyncPoller Struct and Implementation
// -----------------------------------------------------------------------------

/// # AsyncPoller
///
/// Manages the receiver ends of the inter-thread message passing system.
/// It is responsible for draining these channels during the Godot frame loop.
#[derive(Default)]
pub struct AsyncPoller {
    /// Receiver for messages from the SSXL-ext **Generation** pipeline.
    generation_receiver: Option<GenerationReceiver>,
    /// Receiver for messages from the SSXL-ext **Animation** pipeline.
    animation_receiver: Option<AnimationReceiver>,
}

impl AsyncPoller {
    /// Creates a new, default instance of the `AsyncPoller`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the receiver for generated chunk data messages.
    pub fn set_generation_receiver(&mut self, receiver: Option<GenerationReceiver>) {
        self.generation_receiver = receiver;
    }

    /// Sets the receiver for real-time animation update messages.
    pub fn set_animation_receiver(&mut self, receiver: Option<AnimationReceiver>) {
        self.animation_receiver = receiver;
    }

    /// Clears both receivers, typically called during engine shutdown.
    pub fn clear_receivers(&mut self) {
        self.generation_receiver = None;
        self.animation_receiver = None;
    }

    // -------------------------------------------------------------------------
    // Polling Logic: Generation (THROTTLED)
    // -------------------------------------------------------------------------

    /// Polls the generation channel for available messages, **throttling** the
    /// maximum number of messages processed per Godot frame.
    pub fn poll_generation_messages(&mut self) -> Vec<ChunkMessage> {
        // Use `Option::take` to temporarily own the receiver.
        let mut receiver = match self.generation_receiver.take() {
            Some(r) => r,
            None => return Vec::new(),
        };

        // Pre-allocate vector capacity to the throttle limit.
        let mut messages = Vec::with_capacity(MAX_GENERATION_MESSAGES_PER_POLL);

        for _ in 0..MAX_GENERATION_MESSAGES_PER_POLL {
            match receiver.try_recv() {
                Ok(message) => {
                    let chunk_message = match message {
                        // Performance Optimization (Zero-Copy) using Arc::try_unwrap
                        GenerationMessage::ChunkGenerated(_coords, chunk_data_arc) => {
                            let chunk_data = Arc::try_unwrap(chunk_data_arc)
                                .unwrap_or_else(|arc| (*arc).clone());
                            ChunkMessage::Generated(chunk_data)
                        }
                        // Sentinel message for overall batch completion.
                        GenerationMessage::GenerationComplete => {
                            ChunkMessage::Generated(ChunkData::new(
                                0,
                                GridBounds::default(),
                                "complete".to_string(), // Sentinel string
                            ))
                        }
                    };
                    messages.push(chunk_message);
                }
                // Non-blocking exit: Channel is currently empty.
                Err(TokioTryRecvError::Empty) => break,
                // Critical Error: Generation channel disconnected.
                Err(TokioTryRecvError::Disconnected) => {
                    eprintln!("[SSXL-SYNC CRITICAL] Generation channel disconnected.");
                    // Do not restore the receiver; it's permanently dead.
                    return messages;
                }
            }
        }

        // Restore the receiver to the poller for the next Godot frame's poll.
        self.generation_receiver = Some(receiver);

        messages
    }

    // -------------------------------------------------------------------------
    // Polling Logic: Animation (THROTTLED)
    // -------------------------------------------------------------------------

    /// Polls the animation channel for available updates, **throttling** the
    /// maximum number of messages processed per Godot frame.
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // Use `Option::take` to temporarily own the receiver.
        let mut receiver = match self.animation_receiver.take() {
            Some(r) => r,
            None => return Vec::new(),
        };

        // Pre-allocate vector capacity to the throttle limit.
        let mut updates = Vec::with_capacity(MAX_ANIMATION_MESSAGES_PER_POLL);

        for _ in 0..MAX_ANIMATION_MESSAGES_PER_POLL {
            match receiver.try_recv() {
                Ok(update) => {
                    updates.push(update);
                }
                // Non-blocking exit: Channel is currently empty.
                Err(TokioTryRecvError::Empty) => break,
                // Critical Error: Animation channel disconnected.
                Err(TokioTryRecvError::Disconnected) => {
                    eprintln!("[SSXL-SYNC CRITICAL] Animation channel disconnected.");
                    // Do not restore the receiver; it's permanently dead.
                    return updates;
                }
            }
        }

        // Restore the receiver to the poller for the next frame's poll.
        self.animation_receiver = Some(receiver);

        updates
    }
}
// --- END: rust/ssxl_godot/src\async_poll.rs ---
        40 LOC | rust/ssxl_godot/src\build.rs
// --- START: rust/ssxl_godot/src\build.rs ---
// rust/SSXL_godot/src/build.rs

//! # Build Script for SSXL-ext GDExtension Deployment
//!
//! This script runs *before* the main compilation of the `ssxl_godot` crate.
//! Its purpose is to **automate the deployment** of the compiled GDExtension
//! dynamic library (`ssxl_engine.dll`) from the Cargo `target` directory
//! directly into the Godot test project (`ssxl_engine_tester`). This enables
//! fast iteration and "faster than light speed" development **tempo**.

use std::env;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    // 1. CARGO INSTRUCTION: Rerun on change
    // Tells Cargo to re-run this build script if the script itself is modified.
    println!("cargo:rerun-if-changed=build.rs");

    // 2. PATH SETUP: Determine the root of the current crate's manifest.
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR not set"));

    // 3. ARTIFACT NAME: The name of the resulting dynamic library (DLL on Windows).
    let dll_name = "ssxl_engine.dll";

    // 4. PROFILE: Determine the build profile (e.g., "debug" or "release").
    // This is crucial as the DLL location depends on the profile folder within 'target/'.
    let profile = env::var("PROFILE")
        .expect("PROFILE environment variable not set");

    // --- Path Calculation ---

    // 5. SOURCE PATH: Calculate the path to the newly compiled DLL.
    // The structure is generally: /workspace/rust/ssxl_godot -> /workspace/rust -> target/profile/ssxl_engine.dll
    let src_path = manifest_dir
        .parent().unwrap()      // Moves from `/rust/ssxl_godot` to `/rust`
        .join("target")
        .join(&profile)         // Inserts "debug" or "release"
        .join(dll_name);

    // 6. DESTINATION PATH: Calculate the path to the Godot test project folder.
    // The structure is: /workspace/rust/ssxl_godot -> /workspace/rust -> /workspace -> ssxl_engine_tester/ssxl_engine.dll
    let dst_path = manifest_dir
        .parent().unwrap()      // Moves from `/rust/ssxl_godot` to `/rust`
        .parent().unwrap()      // Moves from `/rust` to `/workspace` root
        .join("ssxl_engine_tester") // The Godot project folder
        .join(dll_name);

    // --- Deployment Execution (Windows-Specific) ---

    // 7. COMMAND: Execute a Windows shell command (`cmd /C copy`) to perform the deployment.
    // `/C` executes the command and then terminates.
    // `/Y` suppresses prompting to confirm overwriting the existing file.
    let status = Command::new("cmd")
        .args(&["/C", "copy", "/Y"])
        .arg(&src_path)
        .arg(&dst_path)
        .status();

    // 8. RESULT HANDLING: Report the outcome using Cargo warnings.
    match status {
        Ok(s) if s.success() => {
            // Success: The experiment's result is deployed and ready for testing!
            println!("cargo:warning= SUCCESS (CMD): Deployed {} to {}", dll_name, dst_path.display());
        }
        Ok(s) => {
            // Failure with status code: Common if files are locked (e.g., Godot is running).
            println!("cargo:warning= CRITICAL FAILURE (CMD): DLL deployment failed with exit code: {:?}", s.code());
            println!("cargo:warning=  Source Path: {}", src_path.display());
            println!("cargo:warning=  Dest Path: {}", dst_path.display());
            println!("cargo:warning=  Note: The shell command failed. Check file locks (is Godot editor running?) or path permissions.");
        }
        Err(e) => {
             // System error: Command could not even be executed.
            println!("cargo:warning= SYSTEM ERROR (CMD): Failed to execute copy command: {}", e);
        }
    }
}
// --- END: rust/ssxl_godot/src\build.rs ---
       114 LOC | rust/ssxl_godot/src\channel_handler.rs
// --- START: rust/ssxl_godot/src\channel_handler.rs ---
// rust/ssxl_godot/src/channel_handler.rs (Cleaned & Fixed)

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Gd;
use godot::builtin::GString;
use ssxl_generate::Conductor;
use ssxl_shared::messages::{AnimationUpdate, AnimationPayload};
use ssxl_shared::messages::ChunkMessage;
use crate::chunk_presenter::ChunkPresenter;
use std::sync::{Arc, Mutex};
use tracing::{info, error};

type PresenterHandle = Arc<Mutex<ChunkPresenter>>;

#[derive(Debug, Default, Clone)]
pub struct ChannelHandler {
    presenter: Option<PresenterHandle>,
    signals_node: Option<Gd<Node>>,
}

impl ChannelHandler {
    pub fn set_presenter_handle(&mut self, presenter: PresenterHandle) {
        self.presenter = Some(presenter);
    }

    pub fn set_signals_node(&mut self, signals_node: Option<Gd<Node>>) {
        self.signals_node = signals_node;
    }

    // --- FIX: Add missing signal emitter methods to resolve E0599 ---

    /// Emits the `build_map_start` signal on the connected signals node.
    pub fn emit_build_map_start(&self) {
        if let Some(mut node) = self.signals_node.clone() {
            node.emit_signal("build_map_start", &[]);
            info!("Signal Emitted: build_map_start");
        } else {
            error!("Cannot emit build_map_start: signals_node is missing.");
        }
    }

    /// Emits the `generation_error` signal with the provided message.
    pub fn emit_generation_error(&self, error_message: GString) {
        if let Some(mut node) = self.signals_node.clone() {
            node.emit_signal("generation_error", &[error_message.to_variant()]);
            error!("Signal Emitted: generation_error with message: {}", error_message);
        } else {
            error!("Cannot emit generation_error: signals_node is missing.");
        }
    }

    // -------------------------------------------------------------------------
    // Processing Logic: Generation (Deferred Rendering)
    // -------------------------------------------------------------------------

    pub fn process_generation_messages_deferred(
        &mut self,
        messages: Vec<ChunkMessage>,
        conductor: Option<Arc<Mutex<Conductor>>>,
    ) -> Option<GString> {
        if messages.is_empty() {
            return None;
        }

        let mut is_complete = false;

        if let Some(ref presenter_handle) = self.presenter {
            match presenter_handle.lock() {
                Ok(presenter_lock) => {
                    for msg in messages {
                        if let ChunkMessage::Generated(data) = &msg {
                            if data.dimension_tag == "complete" {
                                is_complete = true;
                                continue;
                            }
                        }

                        if let Some(deferred_call) = presenter_lock.create_deferred_present_call(msg) {
                            deferred_call.call_deferred(&[]);
                        } else {
                            error!("Failed to create deferred call for chunk message. Is TileMap set on Presenter?");
                        }
                    }
                },
                Err(e) => {
                    error!("Failed to acquire ChunkPresenter lock: {}", e);
                    return Some(GString::from("ERR_PRESENTER_MUTEX_POISONED"));
                }
            }
        } else {
            error!("Cannot process generation messages: ChunkPresenter handle is missing.");
        }

        if is_complete {
            if let Some(arc_mutex_conductor) = conductor {
                match arc_mutex_conductor.lock() {
                    Ok(conductor_lock) => {
                        conductor_lock.signal_generation_complete();
                        info!("GenerationComplete received. Conductor status set to Running (Idle).");
                    },
                    Err(e) => {
                        error!("Failed to acquire Conductor lock to set status: {}", e);
                        return Some(GString::from("ERR_CONDUCTOR_MUTEX_POISONED"));
                    }
                }
            } else {
                error!("GenerationComplete received, but Conductor reference is None.");
            }
        }

        None
    }

    // -------------------------------------------------------------------------
    // Processing Logic: Animation (Real-time Signal Emission)
    // -------------------------------------------------------------------------

    pub fn process_animation_messages(&mut self, updates: Vec<AnimationUpdate>) {
        if updates.is_empty() {
            return;
        }

        if let Some(mut node) = self.signals_node.clone() {
            for update in updates {
                
                let new_frame_id = match update.payload {
                    AnimationPayload::FrameUpdate { new_frame } => new_frame,
                    
                    AnimationPayload::TweenValue { .. } => {
                        error!("Received unhandled TweenValue payload. Expected FrameUpdate.");
                        0
                    },
                };
                
                node.emit_signal(
                    "tile_flip_updated",
                    &[
                        (update.coord.x as i32).to_variant(),
                        (new_frame_id as i32).to_variant(),
                    ],
                );
            }
        }
    }
}
// --- END: rust/ssxl_godot/src\channel_handler.rs ---
       143 LOC | rust/ssxl_godot/src\chunk_presenter.rs
// --- START: rust/ssxl_godot/src\chunk_presenter.rs ---
// ssxl_godot/src/chunk_presenter.rs (Final Cleaned and Optimized)
//! # ChunkPresenter
//!
//! This component is responsible for translating multi-threaded ChunkData messages into
//! a single, efficient Godot method call on the SSXLTileMap, executing the actual rendering
//! logic on the main thread via a deferred Callable.
// --- Godot GDExtension Imports (godot-rust)  ---
use godot::prelude::*;
use godot::classes::Node;
// Use our custom class for typed batch call
use crate::ssxl_tilemap::SSXLTileMap;
use godot::builtin::{Variant, Vector2i, Callable, Array, Dictionary};
use godot::obj::{Gd, Base};
use godot::meta::{
    GodotConvert, ToGodot, FromGodot, ByValue // CLEANUP: Removed unused ArgPassing, AsArg
};
use godot::meta::error::ConvertError;
// --- SSXL-ext Shared Crates Imports ---
use ssxl_shared::{ChunkData, CHUNK_SIZE};
use ssxl_shared::messages::ChunkMessage;
use ssxl_shared::tile_type::TileType;
use serde_json;
// --- Standard Library Imports ---
use std::io::Error as GodotError;
use tracing::{error, info};

// -----------------------------------------------------------------------------
// Godot Conversion Wrapper for ChunkMessage
// -----------------------------------------------------------------------------

/// Wrapper struct required to implement `GodotConvert` for `ChunkMessage`.
///
/// FIX & OPTIMIZATION: Uses fast binary serialization (`serde` bytes) into a
/// Godot `PackedByteArray` (via `Variant`) for safe, high-performance,
/// multi-threaded transfer across the FFI boundary.
struct ChunkMessageWrapper(ChunkMessage);

// Declares that the struct should be converted using `Variant` as the intermediate type.
impl GodotConvert for ChunkMessageWrapper {
    type Via = Variant;
}

// Implements conversion from the Rust struct into a PackedByteArray Variant.
impl ToGodot for ChunkMessageWrapper {
    // DEFINITIVE FIX (E0107): ByValue does not take a generic argument.
    // This allows the owned Variant to be transferred across the FFI boundary safely.
    type Pass = ByValue; 

    fn to_godot(&self) -> Variant { // The return type must match Self::Via (Variant)
        // OPTIMIZATION: Serialize ChunkMessage to a binary Vec<u8>.
        let bytes = match serde_json::to_vec(&self.0) {
            Ok(b) => b,
            Err(e) => {
                error!("Failed to serialize ChunkMessage to binary: {:?}", e);
                // Return the owned nil Variant directly.
                return godot::prelude::Variant::nil();
            }
        };

        // LIFETIME FIX (E0515): Wrap the binary data in a native Godot PackedByteArray
        // and return the owned Variant derived from it.
        let packed_array = godot::builtin::PackedByteArray::from(bytes.as_slice());
        
        packed_array.to_variant() // Returns the owned Variant, safely transferring ownership.
    }
}

// Implements conversion from a Godot Variant (containing PackedByteArray) back into the Rust struct.
impl FromGodot for ChunkMessageWrapper {
    fn try_from_godot(value: Self::Via) -> Result<Self, ConvertError> {
        // 1. Extract the PackedByteArray from the Variant.
        let packed_array = value.try_to::<godot::builtin::PackedByteArray>()
             .map_err(|e| ConvertError::new(format!("Variant conversion failed while extracting PackedByteArray: {}", e)))?;
        
        // 2. Convert the PackedByteArray to a Rust Vec<u8> slice.
        let bytes = packed_array.to_vec();
        
        // 3. Deserialize the binary data back into the ChunkMessage struct.
        let msg: ChunkMessage = serde_json::from_slice(&bytes)
             .map_err(|e| ConvertError::new(format!("Failed to deserialize ChunkMessage from binary: {}", e)))?;
             
        Ok(ChunkMessageWrapper(msg))
    }
}

// -----------------------------------------------------------------------------
// Core Constants for Godot TileMap Interaction
// -----------------------------------------------------------------------------
const SSXL_LAYER: i32 = 0; // Target layer ID on the Godot TileMap.
const ATLAS_SOURCE_ID: i32 = 0; // Source ID pointing to the tile atlas resource.
const DEFERRED_RENDER_METHOD_NAME: &str = "present_chunk_internal"; // Method name for deferred calls.

// -----------------------------------------------------------------------------
// ChunkPresenter Struct
// -----------------------------------------------------------------------------
#[derive(Debug, GodotClass)]
#[class(base=Node, init)]
/// A Godot Node used to receive and render chunk data onto a TileMap.
pub struct ChunkPresenter {
    #[base]
    base: Base<Node>, // The required base field for the Godot Node class.
    // Use the specific typed Godot class SSXLTileMap
    tilemap_node: Option<Gd<SSXLTileMap>>, // Optional reference to the target TileMap.
}

// -----------------------------------------------------------------------------
// Safe Constructor for Internal Rust Use
// -----------------------------------------------------------------------------

impl ChunkPresenter {
    /// Helper constructor for creating a new, inert instance outside of the Godot engine's flow.
    /// This is used by the orchestrator (`SSXLEngine`) to hold state before the `_ready` hook.
    #[allow(invalid_value)] // Suppresses warning about zero-initialization of Base<Node>
    pub fn new_internal() -> Self {
        // NOTE: This unsafe zero-initialization is currently required when a GodotClass-derived struct
        // is used as a plain Rust component outside of the engine's initialization flow.
        ChunkPresenter {
            base: unsafe { std::mem::zeroed() },
            tilemap_node: None,
        }
    }
}

// -----------------------------------------------------------------------------
// Exposed Godot API
// -----------------------------------------------------------------------------

#[godot_api]
impl ChunkPresenter {
    /// Godot `init` constructor.
    #[allow(dead_code)]
    pub fn init(base: Base<Node>) -> Self {
        ChunkPresenter {
            base,
            tilemap_node: None,
        }
    }

    /// Public method to set the TileMap reference.
    /// FIX: Update signature to accept the new typed class
    pub fn set_tilemap_node(&mut self, tilemap_node: Gd<SSXLTileMap>) {
        self.tilemap_node = Some(tilemap_node);
    }

    // -------------------------------------------------------------------------
    // Deferred Rendering API
    // -------------------------------------------------------------------------

    /// Creates a Godot `Callable` to safely queue the rendering work to run on the main thread.
    pub fn create_deferred_present_call(&self, msg: ChunkMessage) -> Option<Callable> {
        let presenter_node = self.base().clone();
        // Convert the ChunkMessage into a Variant argument using the custom wrapper.
        let msg_variant = ChunkMessageWrapper(msg).to_variant();
        
        // Create the Callable, binding the message variant as its argument.
        Some(Callable::from_object_method(
            &presenter_node,
            DEFERRED_RENDER_METHOD_NAME,
        ).bind(&[msg_variant]))
    }

    /// The internal method that executes the chunk rendering, called by the deferred `Callable`.
    #[func]
    pub fn present_chunk_internal(&mut self, msg_variant: Variant) {
        // Attempt to deserialize the ChunkMessage from the Variant.
        let msg_wrapper = match msg_variant.try_to::<ChunkMessageWrapper>() {
            Ok(m) => m,
            Err(e) => {
                error!("Failed to deserialize ChunkMessage from Variant in deferred call: {:?}", e);
                return;
            }
        };
        
        let msg = msg_wrapper.0; // Extract the ChunkMessage

        if let Some(ref mut tile_map) = self.tilemap_node {
            // Only process a generated chunk message.
            if let ChunkMessage::Generated(chunk_data) = msg {
                // Call the revised batch function.
                if let Err(e) = ChunkPresenter::grunt_apply_chunk_data(tile_map, chunk_data) {
                    error!("Error applying chunk data in deferred call: {:?}", e);
                }
            }
        } else {
            error!("Cannot present chunk: SSXLTileMap reference is missing.");
        }
    }

    // -------------------------------------------------------------------------
    // Core Rendering Logic (Internal) - REVISED FOR SINGLE-CALL C++ BATCH
    // -------------------------------------------------------------------------

    /// Logic to iterate over all tiles in a chunk, collect data into a single batch Dictionary,
    /// and dispatch it in a single FFI call for a custom C++ TileMap function to process.
    fn grunt_apply_chunk_data(tile_map: &mut Gd<SSXLTileMap>, chunk_data: ChunkData) -> Result<(), GodotError> {
        let chunk_size_i32 = CHUNK_SIZE as i32;
        
        // Calculate the starting grid coordinate (top-left) for this chunk.
        let chunk_pos_grid = Vector2i::new(
            (chunk_data.bounds.min.x / CHUNK_SIZE as i64) as i32 * chunk_size_i32,
            (chunk_data.bounds.min.y / CHUNK_SIZE as i64) as i32 * chunk_size_i32,
        );

        // --- FFI BATCH OPTIMIZATION: Collect data into Godot typed arrays ---
        let mut pos_array = Array::<Vector2i>::new();
        let mut atlas_array = Array::<Vector2i>::new();
        let mut source_id_array = Array::<i32>::new();
        let mut alt_tile_array = Array::<i32>::new();

        // Iterate through all tiles within the chunk.
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                let tile_type = chunk_data.tiles[index].tile_type;

                // Calculate the final cell position for this tile.
                let cell_pos = chunk_pos_grid + Vector2i::new(x as i32, y as i32);

                // Push the position regardless of content, as the C++ side handles clearing/setting.
                pos_array.push(cell_pos);

                if TileType::is_empty(tile_type) {
                    // To CLEAR a cell, set source_id to -1.
                    source_id_array.push(-1);
                    atlas_array.push(Vector2i::new(-1, -1));
                    alt_tile_array.push(0); // Default alternative tile ID
                } else {
                    // Place a tile.
                    let (_tile_id_render, (atlas_x, atlas_y)) =
                        (TileType::get_default_tile_id(tile_type), TileType::get_default_atlas_coords(tile_type));

                    let atlas_coords = Vector2i::new(atlas_x as i32, atlas_y as i32);

                    source_id_array.push(ATLAS_SOURCE_ID);
                    atlas_array.push(atlas_coords);
                    alt_tile_array.push(0); // Default alternative tile ID
                }
            }
        }

        // Single Batch FFI Call
        if pos_array.is_empty() {
            return Ok(());
        }

        // 1. Bundle all arrays and the layer ID into a single Dictionary.
        let mut batch_data = Dictionary::new();
        batch_data.set("layer", SSXL_LAYER.to_variant());
        batch_data.set("positions", pos_array.to_variant());
        batch_data.set("atlas_coords", atlas_array.to_variant());
        batch_data.set("source_ids", source_id_array.to_variant());
        batch_data.set("alt_tiles", alt_tile_array.to_variant());

        info!(
            "ChunkPresenter: Dispatching single-call batch update of {} tiles to SSXLTileMap (Layer {}).",
            pos_array.len(),
            SSXL_LAYER
        );

        // 2. Call the C++-backed function on the SSXLTileMap using a typed method call.
        tile_map.bind_mut().batch_set_tiles_v4(batch_data);

        Ok(())
    }
}
// --- END: rust/ssxl_godot/src\chunk_presenter.rs ---
         2 LOC | rust/ssxl_godot/src\engine_api_extension.rs
// --- START: rust/ssxl_godot/src\engine_api_extension.rs ---
// Create the file: ssxl_godot\src\engine_api_extension.rs

// This module is defined as a trait for API delegation.
// Add the necessary code here. For now, an empty file or a minimal trait definition will suffice.
#[allow(dead_code)]
pub trait EngineApiExtension {
    // Add trait methods here
}
// --- END: rust/ssxl_godot/src\engine_api_extension.rs ---
        57 LOC | rust/ssxl_godot/src\engine_core_logic.rs
// --- START: rust/ssxl_godot/src\engine_core_logic.rs ---
use godot::prelude::*;
use godot::classes::{Node, TileMap};
use godot::obj::Gd;
use godot::builtin::GString;
use std::sync::{Arc, Mutex};
use ssxl_generate::Conductor;
use ssxl_generate::conductor_state::ConductorState;
use ssxl_sync::{AnimationConductorHandle, AnimationState, Receiver};
use crate::api_initializers::EngineInitializer;
use crate::generation_api::GenerationAPI;
use crate::animation_api::AnimationAPI;
use crate::ssxl_engine::SSXLEngine; // Import the host struct

// -----------------------------------------------------------------------------
// 1. Core Setup Logic (Moves complexity out of SSXLEngine::initialize_core)
// -----------------------------------------------------------------------------

/// Assumption: We are adding this method to the existing EngineInitializer impl.
/// This method encapsulates all thread spawning and handle creation, which used
/// to take up ~15 lines in SSXLEngine::initialize_core.
impl EngineInitializer {
    /// Executes the full multi-threaded core setup, returning all necessary handles.
    pub fn execute_core_setup(
    ) -> (
        Option<Arc<Mutex<Conductor>>>, Option<Receiver>, Option<ConductorState>, 
        Option<AnimationConductorHandle>, Option<Receiver>, Option<AnimationState>
    ) {
        // The complex logic (info! logs, thread spawning, result unwrapping)
        // for ensure_conductor() and ensure_animation_conductor() lives here now.
        let (conductor_arc, gen_rx, gen_state) = EngineInitializer::ensure_conductor();
        let (anim_handle, anim_rx, anim_state) = EngineInitializer::ensure_animation_conductor();
        
        (conductor_arc, gen_rx, gen_state, anim_handle, anim_rx, anim_state)
    }
}


// -----------------------------------------------------------------------------
// 2. Trait Definition (The boilerplate reducer)
// -----------------------------------------------------------------------------

/// Trait implemented on SSXLEngine to provide access to API delegation methods
/// without cluttering the main SSXLEngine impl block.
pub trait EngineApiExtension {
    // This trait is empty but used to implement the methods below.
}

// -----------------------------------------------------------------------------
// 3. Trait Implementation (The bulk of the logic moved from ssxl_engine.rs)
// -----------------------------------------------------------------------------

/// Implements all public Godot API methods that are simple delegates.
/// This drastically reduces the LOC count in ssxl_engine.rs.
#[godot_api]
impl EngineApiExtension for SSXLEngine {
    
    // --- Generation API Delegation (REMOVED FROM ssxl_engine.rs) ---

    #[func]
    fn build_map(&mut self, width: i32, height: i32, seed: GString, generator_name: GString) {
        GenerationAPI::new(self.conductor.as_ref()).build_map(width, height, seed, generator_name, self.signals_node.as_ref());
    }

    #[func]
    fn set_generator(&mut self, id: GString) -> bool {
        GenerationAPI::new(self.conductor.as_ref()).set_generator(id)
    }

    #[func]
    fn get_active_generator_id(&self) -> GString {
        GenerationAPI::new(self.conductor.as_ref()).get_active_generator_id()
    }

    // --- Animation API Delegation (REMOVED FROM ssxl_engine.rs) ---

    #[func]
    fn start_loading_animation(&mut self, framerate: f32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).start_loading_animation(framerate, self.signals_node.as_ref());
    }

    #[func]
    fn register_chunk_for_animation(&mut self, chunk_x: i32, chunk_y: i32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).register_chunk_for_animation(chunk_x, chunk_y);
    }

    #[func]
    fn stop_loading_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).stop_loading_animation(self.signals_node.as_ref());
    }

    #[func]
    fn send_animation_command(&mut self, command_name: GString) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .send_command_by_name(command_name.to_string());
    }

    #[func]
    fn start_test_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .start_test_animation(self.tilemap_node.as_ref());
    }

    #[func]
    fn stop_test_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .stop_test_animation(self.signals_node.as_ref());
    }
}
// --- END: rust/ssxl_godot/src\engine_core_logic.rs ---
        17 LOC | rust/ssxl_godot/src\gde_api_defs.rs
// --- START: rust/ssxl_godot/src\gde_api_defs.rs ---
// ssxl_godot/src/gde_api_defs.rs

//! # Godot Extension API Definitions (GDExtension Interface)
//!
//! This module defines the essential Rust-side bindings that connect the `SSXLEngine`
//! struct to the Godot engine's runtime environment. It implements the necessary
//! traits to register the class and hook into the standard Node lifecycle methods.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;

// --- Local Crate Imports ---
// Import the core SSXL engine implementation.
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// GDExtension Initialization Macro
// -----------------------------------------------------------------------------

/// The mandatory **GDExtension entry point**.
///
/// This function is called by Godot when the dynamic library is loaded.
/// The `#[gdextension]` attribute marks it as the entry function.
/// It is declared `unsafe` because it interacts with the C/C++ FFI of Godot.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // 1. **Class Registration:** Registers the core `SSXLEngine` struct with Godot.
    // This makes the Rust struct available in the Godot scripting environment (GDScript/C#).
    builder.add_class::<SSXLEngine>();
}


// -----------------------------------------------------------------------------
// Godot Node Lifecycle Implementation
// -----------------------------------------------------------------------------

/// Implements the `ExtensionLibrary` trait for `SSXLEngine`.
/// This trait binds the Rust struct to a Godot class (in this case, `Node`)
/// and maps Godot's virtual methods (like `_init`, `_process`) to the Rust implementation.
impl ExtensionLibrary for SSXLEngine {
    /// **Godot's Constructor (`_init`)**:
    /// This runs when an instance of `SSXLEngine` is created in Godot.
    /// It delegates initialization to the custom `SSXLEngine::init` method.
    fn _init(base: Base<Node>) -> Self {
        // `base` is the underlying Godot Node that this struct wraps.
        SSXLEngine::init(base)
    }

    /// **Godot's Frame Update (`_process(delta)`)**:
    /// This is called every frame, **adapting** the engine's logic to the game's **tempo**.
    /// The `delta` is the time elapsed since the last frame.
    fn _process(&mut self, delta: f64) {
        // Call the internal game loop tick function, passing the delta time.
        // The delta is cast to `u64` (milliseconds or similar unit) as used internally
        // by the SSXL-ext game loop logic (which may need adjustment depending on the unit).
        self.tick(delta as u64);
    }

    /// **Godot's Initialization Hook (`_ready`)**:
    /// This runs once when the node and all its children have entered the scene tree.
    /// This is the ideal place to start the multi-threaded SSXL engine.
    fn _ready(&mut self) {
        self.on_ready();
    }
}
// --- END: rust/ssxl_godot/src\gde_api_defs.rs ---
        87 LOC | rust/ssxl_godot/src\generation_api.rs
// --- START: rust/ssxl_godot/src\generation_api.rs ---
// ssxl_godot/src/generation_api.rs (CLEANED)

//! # GenerationAPI
//!
//! This module provides the high-level, exposed interface for the Godot runtime
//! (e.g., GDScript or C#) to control the **SSXL-ext Generation Conductor**.
//! It handles the necessary **synchronization (Arc/Mutex)** to safely pass commands
//! from the single-threaded Godot main loop to the background Conductor thread.

// --- Godot GDExtension Imports ---
use godot::classes::Node;
use godot::obj::Gd;
use godot::builtin::GString;

// --- Standard Library Imports (Synchronization & Logging) ---
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn}; // Tracing/logging for debugging and tracking the tempo

// --- SSXL-ext Internal Crates Imports ---
use ssxl_generate::Conductor;
use ssxl_generate::GeneratorConfig;


// -----------------------------------------------------------------------------
// GenerationAPI Struct
// -----------------------------------------------------------------------------

/// # GenerationAPI
///
/// A wrapper that holds a reference to the **thread-safe Conductor**.
/// It is responsible for accepting Godot inputs, validating them, and forwarding
/// the commands to the core generation logic.
/// The lifetime parameter `'a` ensures the API wrapper doesn't outlive the engine context.
#[derive(Default)]
// FIX 1: Allows the struct to be constructed and used externally via FFI without warning.
#[allow(dead_code)] 
pub struct GenerationAPI<'a> {
    /// A potentially temporary, borrowed reference to the globally shared,
    /// mutex-protected `Conductor` instance.
    conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// FIX 2: Allows all methods, which are used externally, to exist without warning.
#[allow(dead_code)] 
impl<'a> GenerationAPI<'a> {
    /// Constructs a new `GenerationAPI`, injecting the `Conductor` reference.
    pub fn new(conductor: Option<&'a Arc<Mutex<Conductor>>>) -> Self {
        GenerationAPI { conductor }
    }

    // -------------------------------------------------------------------------
    // Core Method: Map Generation Dispatch
    // -------------------------------------------------------------------------

    /// Initiates a new map generation task on the worker threads.
    /// This is the primary method called from the Godot environment.
    ///
    /// # Arguments
    /// * `width`, `height`: Dimensions of the map (in tiles or chunks).
    /// * `seed`: The generation seed string, converted from Godot's `GString`.
    /// * `generator_name`: The ID of the generator (e.g., "CellularAutomata").
    pub fn build_map(
        &self,
        width: i32,
        height: i32,
        seed: GString,
        generator_name: GString,
        _signals_node: Option<&Gd<Node>>, // Retained for future signal use, currently unused
    ) {
        // FIX: Abort early if the dimensions are invalid (e.g., 0 or negative).
        if width <= 0 || height <= 0 {
            error!("GenerationAPI: Map dimensions must be positive (received {}x{}). Aborting command.", width, height);
            return;
        }

        // 1. Check for the Conductor and acquire the Mutex lock.
        if let Some(arc) = self.conductor {
            // Use `map` to perform the action only if the lock succeeds.
            let result = arc.lock().map(|mut conductor| {
                info!("GenerationAPI: Attempting to build map with width={} height={}...", width, height);

                // 2. Build the thread-safe configuration object.
                let config = GeneratorConfig {
                    width: width as usize,
                    height: height as usize,
                    seed: seed.to_string(),
                    generator_name: generator_name.to_string(),
                };

                // 3. Dispatch the command to the Conductor.
                // The Conductor handles placing this task on the worker queue.
                conductor.start_generation(config)
            });

            // 4. Handle results and synchronization errors.
            match result {
                Ok(Ok(())) => info!("Generation command successfully dispatched to Conductor."),
                Ok(Err(e)) => error!("Failed to start map generation: {}", e), // Conductor reported logic error
                Err(e) => error!("Failed to lock Conductor mutex: {}", e),         // Mutex poisoned/lock error
            }

        } else {
            warn!("GenerationAPI: Conductor is not initialized. Cannot build map.");
        }
    }

    // -------------------------------------------------------------------------
    // Utility Method: Active Generator Management
    // -------------------------------------------------------------------------

    /// Sets the active generator to be used for future generation requests.
    ///
    /// # Returns
    /// `true` if the generator was successfully set, `false` otherwise.
    pub fn set_generator(&self, id: GString) -> bool {
        let generator_id: String = id.to_string();

        if let Some(arc) = self.conductor {
            // Use `map_or_else` to handle both the Mutex lock error (`Err`) and the
            // internal Conductor's result (`Ok(Result)`).
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for set_generator: {}", e);
                    false
                },
                |mut conductor| {
                    match conductor.set_active_generator(&generator_id) {
                        Ok(()) => {
                            info!("GenerationAPI: Active generator set to '{}'.", generator_id);
                            true
                        }
                        Err(e) => {
                            error!("GenerationAPI: Failed to set generator '{}': {}", generator_id, e);
                            false
                        }
                    }
                },
            );
        }
        warn!("GenerationAPI: Conductor is not initialized. Cannot set generator.");
        false
    }

    // -------------------------------------------------------------------------
    // Utility Method: Active Generator Query
    // -------------------------------------------------------------------------

    /// Retrieves the ID of the currently active generator.
    ///
    /// # Returns
    /// The generator ID as a Godot `GString`, or an error string if the lock fails.
    pub fn get_active_generator_id(&self) -> GString {
        if let Some(arc) = self.conductor {
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for get_active_generator_id: {}", e);
                    GString::from("Error: Mutex Lock Failed")
                },
                |conductor| {
                    let id_string = conductor.get_active_generator_id();
                    // Convert the internal Rust String back to Godot's GString type.
                    GString::from(&id_string)
                },
            );
        }
        GString::from("Error: Conductor Not Initialized")
    }
}
// --- END: rust/ssxl_godot/src\generation_api.rs ---
        19 LOC | rust/ssxl_godot/src\lib.rs
// --- START: rust/ssxl_godot/src\lib.rs ---
//! # SSXL-ext GDExtension Core Library
//!
//! This file is the **root manifest** for the `ssxl_godot` crate. It defines the module
//! structure, imports necessary Godot framework components, and sets up the required
//! boilerplate for the Rust code to be loaded as a GDExtension dynamic library.

// -----------------------------------------------------------------------------
// Public Modules (Exposed to the GDExtension Interface)
// -----------------------------------------------------------------------------

/// The core class that wraps the GDExtension Node and orchestrates the SSXL engine.
pub mod ssxl_engine;
/// Defines custom signals for communication between the Rust core and Godot scripts.
pub mod ssxl_signals;
/// A potential future module for querying engine state or procedural data (the "Oracle").
pub mod ssxl_oracle;
pub mod ssxl_tilemap;
// -----------------------------------------------------------------------------
// Private Modules (Internal Implementation Details)
// -----------------------------------------------------------------------------

/// Handles non-blocking, asynchronous polling of message channels from worker threads.
mod async_poll;
/// Delegates the final rendering of generated chunk data onto the Godot TileMap.
mod chunk_presenter;
/// Processes messages drained by the `AsyncPoller` and delegates to the `ChunkPresenter`.
mod channel_handler;
/// Contains utility structs and functions for initial configuration of the APIs.
mod api_initializers;
/// The exposed API for starting and configuring map generation from Godot.
mod generation_api;
/// The exposed API for controlling real-time tile animation and simulation.
mod animation_api;

// --- Modules Required by ssxl_engine.rs ---
/// Contains static methods for reporting the internal state (used by SSXLEngine).
mod status_reporter;
/// Defines a trait for API delegation in SSXLEngine.
mod engine_api_extension;

// -----------------------------------------------------------------------------
// GDExtension Boilerplate
// -----------------------------------------------------------------------------

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};


/// Placeholder struct required by the `godot-rust` library to implement
/// the `ExtensionLibrary` trait, which defines the dynamic library's behavior.
struct SSXLExtension;

/// Implements the required trait for the GDExtension to be loaded.
/// This acts as the **primary entry point** for the Godot runtime.
///
/// NOTE: The `gde_api_defs.rs` file handles the class registration (like `SSXLEngine`),
/// while this block handles the low-level library initialization hooks.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    /// Called by Godot when a new initialization level is reached.
    /// This hook is used for potential setup that needs to occur before/after
    /// the game engine, editor, or scene is initialized.
    fn on_level_init(_level: InitLevel) {
        // Currently, no actions are required at this low-level init stage,
        // as setup is handled in `SSXLEngine::_init` and `_ready`.
    }

    // `on_level_deinit` is implicitly handled or omitted if no cleanup is needed.
}
// --- END: rust/ssxl_godot/src\lib.rs ---
       212 LOC | rust/ssxl_godot/src\ssxl_engine.rs
// --- START: rust/ssxl_godot/src\ssxl_engine.rs ---
use godot::prelude::*;
use godot::classes::{Node, TileMap};
use godot::obj::Base;
use godot::builtin::GString;
use std::sync::{Arc, Mutex};
use std::convert::TryInto;
use ssxl_generate::{Conductor, GeneratorConfig};
use ssxl_generate::conductor_state::ConductorState;
use ssxl_shared::AnimationState;
use ssxl_shared::AnimationCommand;
use crate::async_poll::AsyncPoller;
use crate::chunk_presenter::ChunkPresenter;
use crate::channel_handler::ChannelHandler;
use crate::api_initializers::{
    EngineInitializer,
    AnimationConductorHandle,
};
use crate::status_reporter::StatusReporter;
use crate::ssxl_tilemap::SSXLTileMap;
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLEngine {
    conductor: Option<Arc<Mutex<Conductor>>>,
    animation_conductor: Option<AnimationConductorHandle>,
    conductor_state: Option<ConductorState>,
    animation_state: Option<AnimationState>,
    signals_node: Option<Gd<Node>>,
    tilemap_node: Option<Gd<TileMap>>,
    initializer: EngineInitializer,
    poller: AsyncPoller,
    presenter: Option<Arc<Mutex<ChunkPresenter>>>,
    handler: ChannelHandler,
    #[base]
    base: Base<Node>,
}
impl SSXLEngine {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            conductor: None,
            animation_conductor: None,
            conductor_state: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,
            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            presenter: Some(Arc::new(Mutex::new(ChunkPresenter::new_internal()))),
            handler: ChannelHandler::default(),
            base,
        }
    }
    fn initialize_core(&mut self) -> bool {
        if self.conductor.is_some() {
            return true;
        }
        godot_print!("SSXLEngine: Initializing Rust core runtime...");
        let (c, grx, gs, ah, arx, as_) = self.initializer.execute_core_setup();
        if c.is_none() || ah.is_none() {
            godot_print!("CRITICAL ERROR: Failed to spawn Rust conductors.");
            return false;
        }
        self.conductor = c;
        self.conductor_state = gs;
        self.animation_conductor = ah;
        self.animation_state = as_;
        self.poller.set_generation_receiver(grx);
        self.poller.set_animation_receiver(arx);
        if let Some(presenter_handle) = &self.presenter {
             self.handler.set_presenter_handle(presenter_handle.clone());
        }
        self.handler.set_signals_node(self.signals_node.clone());
        godot_print!("SSXLEngine: Core runtime initialized successfully.");
        true
    }
    fn poll_generation(&mut self) {
        let gen_messages = self.poller.poll_generation_messages();
        if let Some(status_update) = self.handler.process_generation_messages_deferred(
            gen_messages,
            self.conductor.as_ref().map(|arc| arc.clone()),
        ) {
            self.base_mut().emit_signal("status_updated", &[status_update.to_variant()]);
        }
    }
}
#[godot_api]
impl SSXLEngine {
    #[func]
    pub fn _ready(&mut self) {
        self.initialize_core();
    }
    #[func]
    pub fn build_map(&mut self, width: u32, height: u32, seed_str: GString, generator_name: GString) {
        if let Some(conductor_arc) = self.conductor.as_ref() {
            match conductor_arc.lock() {
                Ok(mut conductor) => {
                    self.handler.emit_build_map_start();
                    let seed = seed_str.to_string().parse::<u64>().unwrap_or_else(|_| {
                        godot_print!("Warning: Invalid seed input: {}. Using 0.", seed_str);
                        0
                    });
                    let config = GeneratorConfig {
                        width: width.try_into().unwrap(),
                        height: height.try_into().unwrap(),
                        seed: seed.to_string(),
                        generator_name: generator_name.to_string(),
                    };
                    let result = conductor.start_generation(config);
                    match result {
                        Ok(_) => godot_print!("SSXLEngine: Map build task SENT to Conductor ({}x{}).", width, height),
                        Err(e) => {
                            godot_print!("Error starting generation task: {:?}", e);
                            // FIX E0277: Convert temporary String to &str before calling GString::from()
                            let error_msg = format!("Failed to start: {:?}", e);
                            self.handler.emit_generation_error(GString::from(error_msg.as_str()));
                        },
                    }
                },
                Err(e) => godot_print!("Error locking Conductor for build_map: {:?}", e),
            }
        } else {
            godot_print!("Error: Conductor not initialized. Cannot start generation.");
        }
    }
    #[func]
    pub fn stop_generation(&mut self) {
        if let Some(conductor_arc) = self.conductor.as_ref() {
            match conductor_arc.lock() {
                Ok(conductor) => {
                    let result = conductor.stop_generation();
                    match result {
                        Ok(_) => godot_print!("SSXLEngine: Generation STOP command SENT to Conductor."),
                        Err(e) => godot_print!("Error sending stop command: {:?}", e),
                    }
                },
                Err(e) => godot_print!("Error locking Conductor for stop_generation: {:?}", e),
            }
        } else {
            godot_print!("Warning: Conductor not initialized. Cannot send stop command.");
        }
    }
    #[func]
    pub fn set_generator(&mut self, tile_type_name: GString) {
        if let Some(conductor_arc) = self.conductor.as_ref() {
            match conductor_arc.lock() {
                Ok(_conductor) => {
                    godot_print!("SSXLEngine: Placeholder: Attempted to set generator '{}'. Conductor API is missing.", tile_type_name);
                },
                Err(e) => godot_print!("Error locking Conductor for set_generator: {:?}", e),
            }
        }
    }
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        StatusReporter::get_current_tile_count_value(self.conductor_state.as_ref())
    }
    #[func]
    pub fn get_status(&self) -> GString {
        StatusReporter::get_status_report(
            self.conductor_state.as_ref(),
            self.animation_state.as_ref(),
        )
    }
    #[signal]
    fn status_updated(status_message: godot::prelude::GString);
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);
    #[func]
    pub fn tick(&mut self, _current_tick: u64) {
        if self.conductor.is_none() {
            return;
        }
        self.poll_generation();
        if self.signals_node.is_some() {
            let anim_messages = self.poller.poll_animations();
            self.handler.process_animation_messages(anim_messages);
        }
    }
    #[func]
    pub fn stop_animation(&mut self) {
        if let Some(ref conductor_sender) = self.animation_conductor {
            let command = AnimationCommand::SetEnabled(false);
            match conductor_sender.send(command) {
                Ok(_) => godot_print!("SSXLEngine: Animation STOP command SENT to Conductor."),
                Err(e) => godot_print!("Error sending animation stop command: {}", e),
            }
        } else {
            godot_print!("Warning: Animation Conductor is not initialized. Cannot send stop command.");
        }
    }
    #[func]
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        if let Some(ref conductor_sender) = self.animation_conductor {
            let command = AnimationCommand::SetEnabled(enabled);
            match conductor_sender.send(command) {
                Ok(_) => godot_print!("SSXLEngine: Animation conductor command SENT: {}", enabled),
                Err(e) => godot_print!("Error sending animation command: {}", e),
            }
        } else {
            godot_print!("Warning: Animation Conductor is not initialized.");
        }
    }
    #[func]
    pub fn set_signals_node(&mut self, signals_node: Gd<Node>) {
        self.signals_node = Some(signals_node.clone());
        self.handler.set_signals_node(Some(signals_node));
    }
    #[func]
    pub fn set_tilemap(&mut self, tilemap_node: Gd<TileMap>) {
        self.tilemap_node = Some(tilemap_node.clone());
        if let Ok(ssxl_tilemap_node) = tilemap_node.try_cast::<SSXLTileMap>() {
            if let Some(presenter_arc) = &self.presenter {
                if let Ok(mut presenter) = presenter_arc.lock() {
                    presenter.set_tilemap_node(ssxl_tilemap_node);
                    godot_print!("SSXLEngine: SSXLTileMap successfully set on ChunkPresenter.");
                } else {
                    godot_print!("Warning: Failed to acquire lock on ChunkPresenter during set_tilemap.");
                }
            } else {
                godot_print!("Warning: ChunkPresenter not initialized in SSXLEngine.");
            }
        } else {
            godot_print!("Warning: set_tilemap called with a TileMap node that is not an SSXLTileMap instance. Presenter will not be configured.");
        }
    }
    #[func]
    pub fn shutdown_engine(&mut self) {
        self.initializer.shutdown(self.animation_conductor.take(), self.conductor.take());
        self.poller.clear_receivers();
        godot_print!("SSXLEngine: Engine shutdown complete.");
    }
}
// --- END: rust/ssxl_godot/src\ssxl_engine.rs ---
        60 LOC | rust/ssxl_godot/src\ssxl_oracle.rs
// --- START: rust/ssxl_godot/src\ssxl_oracle.rs ---
// ssxl_godot/src/SSXL_oracle.rs

//! # SSXLOracle
//!
//! This module defines the `SSXLOracle` Godot class, an optional, **decoupled manager**
//! responsible for driving the main `SSXLEngine` update loop. It provides an explicit
//! clock (`tick` method) for precise control, which is essential for deterministic
//! simulation or fixed-timestep game loops. It serves as a query endpoint for engine state.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};

// --- Local Crate Imports ---
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// SSXLOracle Struct Definition
// -----------------------------------------------------------------------------

/// # SSXLOracle
///
/// A Godot class that acts as the external driver and observer of the SSXL system.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    /// The base field required for the Godot GDExtension class implementation.
    #[base]
    base: Base<Node>,

    /// A reference to the core `SSXLEngine` instance it controls.
    /// This connection allows the Oracle to explicitly call the engine's `tick` function.
    engine: Option<Gd<SSXLEngine>>,

    /// Internal counter for the number of times the engine has been updated.
    tick_count: u64,
}

impl SSXLOracle {
    /// Custom constructor logic called when the Godot node is created.
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}


// -----------------------------------------------------------------------------
// Exposed Godot API (Methods callable from GDScript/C#)
// -----------------------------------------------------------------------------

#[godot_api]
impl SSXLOracle {

    /// **Godot `_ready` Hook:** Initializes the Oracle upon entering the scene tree.
    #[func]
    fn _ready(&mut self) {
        godot_print!(" SSXLOracle (v8.2) is online. I await the ignition.");
        self.base_mut().set_process(true);
    }

    /// Establishes the link between the Oracle and the `SSXLEngine` instance.
    /// This is mandatory before calling `tick`.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
        godot_print!(" Oracle: Engine link established.");
    }

    /// Drives the core game loop for the `SSXLEngine`, sending the current
    /// tick count as the time delta/update indicator. This dictates the system's **tempo**.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // CLEANUP: Use direct method call for type-safety and performance.
                engine.bind_mut().tick(self.tick_count);

                godot_print!(" Oracle: Tick {}  Engine", self.tick_count);
                self.tick_count += 1;
            }
            None => {
                godot_warn!(" Oracle: No engine linked. Tick aborted.");
            }
        }
    }

    ///  **FIX FOR ANIMATION:** Retrieves the total number of tiles placed by the engine.
    /// This is called by the GDScript animation timer to poll generation progress.
    #[func]
    pub fn get_total_tiles_placed(&self) -> i64 {
        match self.engine.as_ref() {
            Some(engine) => {
                // CRITICAL: Call the SSXLEngine FFI method to safely read the atomic/shared progress state.
                // NOTE: SSXLEngine MUST implement `get_current_tile_count` to fetch this data.
                engine.bind().get_current_tile_count() as i64
            }
            None => {
                0
            }
        }
    }
    
    /// Simple diagnostics function for checking if the Oracle is reachable.
    #[func]
    pub fn ping(&self) {
        godot_print!(" Oracle: Ping received. I am awake.");
    }

    /// Resets the internal tick counter.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
        godot_print!(" Oracle: Tick counter reset.");
    }

    /// Retrieves the current tick count.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}
// --- END: rust/ssxl_godot/src\ssxl_oracle.rs ---
        18 LOC | rust/ssxl_godot/src\ssxl_signals.rs
// --- START: rust/ssxl_godot/src\ssxl_signals.rs ---
// ssxl_godot/src/ssxl_signals.rs

//! # SSXLSignals (Communications Hub)
//!
//! Defines a simple, stateless Godot class (`SSXLSignals`) used exclusively
//! to house and expose engine signals to Godot's scripting environment (GDScript/C#).

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Base;

// -----------------------------------------------------------------------------
// SSXLSignals Struct Definition
// -----------------------------------------------------------------------------

/// SSXLSignals: A simple, stateless Node class for defining and emitting custom engine signals.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLSignals {
    /// Base field required for the GDExtension class implementation.
    #[base]
    base: Base<Node>,
}

// -----------------------------------------------------------------------------
// Godot API (Signal Definitions)
// -----------------------------------------------------------------------------

#[godot_api]
impl SSXLSignals {
    /// Constructor logic.
    pub fn init(base: Base<Node>) -> Self {
        SSXLSignals { base }
    }

    // --- Generation Lifecycle Signals ---

    /// Emitted when the engine receives a `build_map` command and starts processing.
    #[signal]
    fn build_map_start();

    /// Emitted when a single **chunk** has finished generation on a worker thread.
    /// Args: x (i32), y (i32)
    #[signal]
    fn chunk_generated(x: i32, y: i32);

    /// Emitted when the entire map generation task has finished.
    #[signal]
    fn build_map_complete();

    /// Emitted when a critical, non-recoverable error occurs during generation.
    /// Args: error_message (GString)
    #[signal]
    fn generation_error(error_message: godot::prelude::GString);

    // --- Animation & Utility Signals ---

    /// CRITICAL: Emitted when a single tile's state flips (e.g., collapsed).
    /// Used to queue animation frames without blocking the engine's generation speed.
    /// Args: tile_id (i32), flip_frame (i32)
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    /// Emitted for high-level animation or loading updates.
    /// Args: percent_done (f32), new_atlas_coords (Vector2i)
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: godot::builtin::Vector2i);

    /// **FIXED:** Emitted periodically to update the Godot client on the engine's internal status (e.g., worker queue size).
    /// Args: status_message (GString)
    #[signal]
    fn engine_status_updated(status_message: godot::prelude::GString);
}
// --- END: rust/ssxl_godot/src\ssxl_signals.rs ---
        51 LOC | rust/ssxl_godot/src\ssxl_tilemap.rs
// --- START: rust/ssxl_godot/src\ssxl_tilemap.rs ---
use godot::prelude::*;
use godot::classes::{TileMap, ITileMap};
use godot::builtin::{Vector2i, PackedInt32Array, Dictionary, Array};
use godot::meta::error::ConvertError;
use godot::obj::Base;
use tracing::error;

#[derive(GodotClass)]
#[class(base=TileMap)]
pub struct SSXLTileMap {
    base: Base<TileMap>,
}

#[godot_api]
impl ITileMap for SSXLTileMap {
    fn init(base: Base<TileMap>) -> Self {
        SSXLTileMap { base }
    }
}

#[godot_api]
impl SSXLTileMap {
    #[func]
    pub fn batch_set_tiles_v4(&mut self, batch_data: Dictionary) {
        let layer: i32 = batch_data.get("layer")
            .unwrap_or_default()
            .try_to()
            .unwrap_or(0);

        let Ok(positions) = batch_data.get("positions")
            .map(|v| v.try_to::<Array<Vector2i>>())
            .unwrap_or(Err(ConvertError::default()))
        else { error!("Batch Data Error: Missing or invalid 'positions' array."); return; };

        let Ok(source_ids) = batch_data.get("source_ids")
            .map(|v| v.try_to::<PackedInt32Array>())
            .unwrap_or(Err(ConvertError::default()))
        else { error!("Batch Data Error: Missing or invalid 'source_ids' array."); return; };

        let Ok(atlas_coords) = batch_data.get("atlas_coords")
            .map(|v| v.try_to::<Array<Vector2i>>())
            .unwrap_or(Err(ConvertError::default()))
        else { error!("Batch Data Error: Missing or invalid 'atlas_coords' array."); return; };

        let Ok(alt_tiles) = batch_data.get("alt_tiles")
            .map(|v| v.try_to::<PackedInt32Array>())
            .unwrap_or(Err(ConvertError::default()))
        else { error!("Batch Data Error: Missing or invalid 'alt_tiles' array."); return; };

        let tile_count = positions.len();
        if tile_count == 0 {
            return;
        }

        let mut base_tilemap = self.base_mut();
        
        let args = [
            layer.to_variant(),
            positions.to_variant(),
            source_ids.to_variant(),
            atlas_coords.to_variant(),
            alt_tiles.to_variant(),
        ];
        
        let _ = base_tilemap.call("set_cells_coord_array", &args);
    }
}
// --- END: rust/ssxl_godot/src\ssxl_tilemap.rs ---
        36 LOC | rust/ssxl_godot/src\status_reporter.rs
// --- START: rust/ssxl_godot/src\status_reporter.rs ---
use godot::prelude::GString;
// Assuming these internal state structures are publically accessible or have accessor traits.
use ssxl_generate::conductor_state::ConductorState;
use ssxl_shared::AnimationState;

/// # StatusReporter
/// 
/// A stateless utility struct responsible for querying the various core states
/// (Generation, Animation) and compiling human-readable status reports
/// for the Godot scripting layer.
pub struct StatusReporter;

impl StatusReporter {
    /// Constructs a new, human-readable status string combining the state of
    /// the Generation and Animation cores.
    /// 
    /// This removes complex string formatting logic from SSXLEngine.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    /// * `anim_state` - Read-only reference to the Animation process state.
    /// 
    /// # Returns
    /// A Godot `GString` containing the formatted status message.
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        let gen_status = gen_state
            // This line is assumed correct for ConductorState
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let anim_status = anim_state
            .map(|state| {
                // FIX: AnimationState does not have a get_status() method.
                // We derive the status from the publicly available `time_scale` field.
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    // Handle negative or otherwise unexpected scales
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        GString::from(status.as_str())
    }

    /// Retrieves the total number of tiles placed by the engine during generation.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            // Fails gracefully to 0 if the core is not yet initialized.
            .unwrap_or(0)
    }
}
// --- END: rust/ssxl_godot/src\status_reporter.rs ---
        58 LOC | rust/ssxl_math/src\coordinate_system.rs
// --- START: rust/ssxl_math/src\coordinate_system.rs ---
// ssxl_math/src/coordinate_system.rs

//! # Coordinate System
//!
//! Defines the core coordinate types for the SSXL-ext engine, using 64-bit integers (`I64Vec3`)
//! to support extremely large, virtually infinite world dimensions.
//!
//! This module implements the crucial logic for converting a global `WorldPos` into its
//! localized `(ChunkKey, TileOffset)` components, ensuring mathematical correctness
//! even for large **negative coordinates** through the use of Euclidean division.

use serde::{Serialize, Deserialize};
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;


// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------

/// Represents a specific point in the vast 3D world space.
/// The underlying `I64Vec3` ensures the system can handle coordinates well beyond i32 limits.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

/// The unique identifier for a 3D chunk.
/// This acts as the *base coordinate* for a 32x32x32 (or `CHUNK_SIZE`) cubic volume of the world.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

/// The local position of a tile *within* its parent chunk.
/// Coordinates are always non-negative and range from `[0, CHUNK_SIZE - 1]`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);


// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------

impl WorldPos {
    /// Converts a global `WorldPos` into its discrete `ChunkKey` and local `TileOffset` components.
    ///
    /// This conversion is robust against **negative world coordinates** by using
    /// `rem_euclid`, which guarantees the `TileOffset` is always positive (or zero).
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {

        let chunk_size = CHUNK_SIZE_I64;

        // 1. Calculate the Tile Offset (Local Position)
        // `rem_euclid` ensures the remainder is always non-negative, correctly wrapping
        // negative world coordinates (e.g., -1 rem_euclid 32 = 31).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // 2. Calculate the Chunk Key (Chunk Index)
        // The chunk index is calculated by subtracting the tile offset (remainder)
        // and then performing simple integer division. This is the correct Euclidean
        // division for finding the quotient (chunk index).
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------

impl ChunkKey {
    /// Reconstructs the original `WorldPos` from the `ChunkKey` and `TileOffset`.
    ///
    /// This is the inverse operation, verifying the idempotence of the coordinate system.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        // Formula: World = (Chunk Index * Chunk Size) + Tile Offset
        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    // NOTE: CHUNK_SIZE_I64 is assumed to be 32 for these tests.

    #[test]
    /// Tests conversion for a very large positive coordinate, confirming I64 robustness.
    fn test_world_to_chunk_positive() {
        let huge_coord = 5_000_000_000i64; // Well over i32::MAX
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64; // 156,250,000
        let expected_offset = huge_coord % CHUNK_SIZE_I64; // 0

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // 64 / 32 = 2 (chunk key), 64 rem_euclid 32 = 0 (offset)
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    /// CRUCIAL test for negative coordinates, verifying the Euclidean division logic.
    fn test_world_to_chunk_negative_crucial() {
        // Test case 1: (-1, -1, -1)
        // Expected: Chunk index should be -1. Offset should be 31 (32 - 1).
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test case 2: (-33, -64, -100)
        // X: -33 rem 32 = 31, (-33 - 31)/32 = -2.
        // Y: -64 rem 32 = 0, (-64 - 0)/32 = -2.
        // Z: -100 rem 32 = 28, (-100 - 28)/32 = -4.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    /// Tests that converting a WorldPos to (ChunkKey, TileOffset) and back results in the original WorldPos.
    fn test_round_trip() {
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();

        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}
// --- END: rust/ssxl_math/src\coordinate_system.rs ---
        14 LOC | rust/ssxl_math/src\generation_utils.rs
// --- START: rust/ssxl_math/src\generation_utils.rs ---
// ssxl_math/src/generation_utils.rs

//! # Generation Utilities
//!
//! Provides common mathematical and random-sampling utilities used throughout the
//! procedural generation pipeline (e.g., `ssxl_generate` crate).
//!
//! Functions here are designed for rapid, stateless generation logic, such as
//! calculating percentage chance rolls and generating unique identifiers for data structures.

use crate::primitives::SSXLData;
use rand::Rng;

// -----------------------------------------------------------------------------
// Randomness and Chance Utilities
// -----------------------------------------------------------------------------

/// Rolls a chance check against a given percentage.
///
/// This function is vital for injecting controlled **randomness** and **balance**
/// into the generation process (e.g., probability of a resource spawning, or a
/// cellular automata rule firing).
///
/// # Arguments
/// * `target_percent` - The probability of success, expressed as a whole percentage (0-100).
///
/// # Returns
/// * `0`: Success (The random number was less than `target_percent`).
/// * `1`: Failure (The random number was greater than or equal to `target_percent`).
///
/// # Example
/// A 25% chance of spawning:
/// ```ignore
/// if generate_percent_roll(25) == 0 {
///     // spawn item
/// }
/// ```
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the inclusive range [0, 99], which is a 0-100 scale.
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Success occurs if the random value falls within the target range.
    if rand_val < target_percent {
        0 // Success / Hit
    } else {
        1 // Failure / Miss
    }
}

// -----------------------------------------------------------------------------
// Data Processing Utilities
// -----------------------------------------------------------------------------

/// Processes an object implementing the `SSXLData` trait to derive a simple aggregate identifier.
///
/// This is a basic utility that combines the object's unique ID with its data payload size.
/// It is often used for creating quick, unique signatures or simple hashing/checksums
/// for data chunks across worker threads.
///
/// # Arguments
/// * `data` - A reference to any structure that implements the `SSXLData` trait.
///
/// # Returns
/// * `u64` - The sum of the data's ID and the length of its associated value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine the inherent ID (u64) with the value length (u64 after casting).
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}
// --- END: rust/ssxl_math/src\generation_utils.rs ---
        42 LOC | rust/ssxl_math/src\hashing.rs
// --- START: rust/ssxl_math/src\hashing.rs ---

// ssxl_math/src/hashing.rs

/// # Hashing Utilities for SSXL-ext
///
/// This module provides **deterministic, collision-resistant** hashing functions
/// essential for identifying and retrieving procedural data.
///
/// Hashing is crucial for:
/// 1.  Generating unique, stable IDs for **world chunks** based on their coordinates.
/// 2.  Creating cache keys for **generated content** to ensure persistence and integrity.
use crate::primitives::SSXLResult;
use glam::I64Vec3;
use sha2::{Digest, Sha256};

/// Generates a **deterministic SHA-256 hash** for a given 3D chunk coordinate.
///
/// This hash is used as a unique identifier (a key) for world chunks, ensuring that
/// the same coordinate always yields the identical hash string, which is crucial
/// for cache lookups and procedural generation stability.
///
/// # Arguments
///
/// * `coords` - The 3D world coordinate of the chunk, using 64-bit integers (`I64Vec3`)
///              to support extremely large, dimension-agnostic worlds.
///
/// # Returns
///
/// A `SSXLResult<String>` containing the 64-character hexadecimal SHA-256 hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // 1. Serialize the coordinates into a canonical string format (e.g., "100:5:25").
    // This fixed format ensures deterministic input for the hash function.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash bytes into a lowercase 64-character hexadecimal string.
    Ok(format!("{:x}", result))
}

/// Generates a **deterministic SHA-256 hash** for a generic 64-bit data key.
///
/// This is typically used to create unique cache keys for generated content or
/// assets, prefixed with `"content_"` for easy identification in the cache system
/// (`ssxl_cache`).
///
/// # Arguments
///
/// * `data_key` - A generic `u64` identifier for the content (e.g., a seed,
///                a configuration ID, or a tile type index).
///
/// # Returns
///
/// A `SSXLResult<String>` containing the hash prefixed with `"content_"`.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // 1. Convert the u64 key into a string.
    let key_string = data_key.to_string();

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // 3. Format the result with the required "content_" prefix.
    Ok(format!("content_{:x}", result))
}


/// Unit tests to ensure the hashing functions are **deterministic** and produce
/// the expected **format** and **uniqueness** required for stable world generation.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// Tests that the same coordinates always produce the identical hash (determinism).
    fn test_chunk_coords_determinism() {
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    /// Tests the expected hash length (64 chars) and confirms that a small coordinate change
    /// results in a completely different hash (uniqueness/avalanche effect).
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    /// Tests determinism, the 'content_' prefix, and the total expected length (72 chars).
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // 'content_' (8 chars) + SHA-256 hex (64 chars) = 72
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}
// --- END: rust/ssxl_math/src\hashing.rs ---
        19 LOC | rust/ssxl_math/src\lib.rs
// --- START: rust/ssxl_math/src\lib.rs ---
// ssxl_math/src/lib.rs

//! # SSXL Math Crate (`ssxl_math`)
//!
//! This crate contains the core mathematical utilities, data structures, and coordinate
//! system logic required by the SSXL-ext procedural generation engine.
//!
//! Key functionalities include:
//! - **Coordinate System:** Defining world and chunk positions (`ChunkKey`, `WorldPos`).
//! - **Hashing:** Deterministic generation of unique chunk and content identifiers.
//! - **Primitives:** Shared types and result wrappers (`SSXLResult`, `Vec2i`).

// --- Module Declarations ---

/// Defines the global and local coordinate system structures (`ChunkKey`, `WorldPos`).
pub mod coordinate_system;

/// Houses various utility functions for procedural generation algorithms.
pub mod generation_utils;

/// Provides deterministic hashing functions (e.g., `hash_chunk_coords`).
pub mod hashing;

/// Core mathematical primitives, custom types, and error handling results.
pub mod primitives;

// --- Public Re-exports (The Main Crate API) ---

// Re-export key coordinate types for direct use by other SSXL-ext crates.
pub use coordinate_system::{ChunkKey, TileOffset, WorldPos};

// Re-export core functions and utilities.
pub use crate::generation_utils::process_data;

// Re-export essential primitives and type aliases.
pub use crate::primitives::Vec2i;
pub use crate::primitives::SSXLData;
pub use crate::primitives::SSXLResult;
pub use crate::primitives::TileCoord; //  FIXED: Changed 'crate primitives' to 'crate::primitives'

// --- Prelude for Internal Engine Use ---

/// A convenience module that re-exports all essential types and traits
/// from the `ssxl_math` crate.
///
/// Crates in the SSXL-ext project are encouraged to use `use ssxl_math::prelude::*`
/// to easily import the most commonly needed math components. This adheres to the
/// common Rust practice for making libraries ergonomic.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
}

// --- Initialization Function ---

/// Initializes the SSXL Math system.
///
/// Currently, this only logs an informational message. It acts as a potential
/// future hook for any necessary global math configuration or setup checks.
pub fn initialize_math_system() {
    tracing::info!("SSXL Math system initialized and ready.");
}
// --- END: rust/ssxl_math/src\lib.rs ---
        19 LOC | rust/ssxl_math/src\primitives.rs
// --- START: rust/ssxl_math/src\primitives.rs ---
//! # Primitives Module (`ssxl_math::primitives`)
//!
//! Defines the essential, low-level data types, type aliases, traits, and global
//! constants used throughout the SSXL-ext procedural generation engine.

use serde::{Deserialize, Serialize};

// --- Data Structures ---

/// A 2D vector for integer coordinates, typically used for tile offsets or local
/// coordinate mapping within a chunk.
///
/// Uses `i64` to maintain compatibility with the large coordinate space of `I64Vec3`
/// from the `glam` crate, preventing silent overflow issues.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    /// The X component of the 2D vector.
    pub x: i64,
    /// The Y component of the 2D vector.
    pub y: i64,
}

impl Vec2i {
    /// Creates a new `Vec2i` instance.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// --- Type Aliases ---

/// The standard 2D coordinate type for referencing a tile in the world
/// or within a chunk. Aliased to `Vec2i`.
pub type TileCoord = Vec2i; 

/// The standard 2D coordinate type for referencing a spatial chunk in the world grid.
/// Aliased to `Vec2i` for memory layout consistency with `TileCoord`.
pub type ChunkId = Vec2i; 

/// A specialized `Result` type for the SSXL-ext project.
///
/// The error type is fixed as `String`, providing a simple, high-level way to
/// convey error messages across the engine's various crates.
pub type SSXLResult<T> = Result<T, String>;

// --- Traits for Engine Data Management ---

/// A trait defining the requirements for any data structure that will be managed
/// or processed by the SSXL engine (e.g., in the task queue or cache).
///
/// The bounds `Send + Sync` are mandatory, ensuring all implementors can be
/// safely sent between worker threads and shared across thread boundaries.
pub trait SSXLData: Send + Sync {
    /// Retrieves a unique 64-bit ID for the data. Used primarily for cache keys
    /// and tracking within the `task_queue`.
    fn get_id(&self) -> u64;

    /// Returns the length or size of the data's core value in bytes or elements.
    /// Used for diagnostics, memory management, or processing limits.
    fn get_value_len(&self) -> usize;
}

// --- Global Constants ---

/// The canonical side length of a procedural chunk in the world.
///
/// This value is cast to `i64` to match the coordinate system of the engine,
/// ensuring consistent type usage for chunk-related calculations.
pub const CHUNK_SIZE_I64: i64 = 32;

/// A small constant used for floating-point comparisons to account for
/// precision errors (e.g., in perlin noise interpolation or physics-related math).
pub const F32_EPSILON: f32 = 1.0e-6;
// --- END: rust/ssxl_math/src\primitives.rs ---
       117 LOC | rust/ssxl_shared/src\chunk_data.rs
// --- START: rust/ssxl_shared/src\chunk_data.rs ---
// ssxl_shared\src\chunk_data.rs

//! # Chunk Data Structures (`ssxl_shared::chunk_data`)
//!
//! This module defines the `ChunkData` structure, which represents a single,
//! fixed-size block of the procedural world. It includes coordinates, bounds,
//! the array of tiles, and metadata about its generation. This is the atomic
//! unit of data shared between generation workers and the cache/Godot runtime,
//! forming the basis of the engine's "crypto coded memory."

use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto; 

use crate::grid_bounds::GridBounds;
use crate::tile_data::TileData;
// Imports the custom Serde helper for deterministic SystemTime serialization.
use crate::math_primitives;

// Re-exports a core math primitive for chunk coordinates.
// FIX: Removed the erroneous `I64Vec3` import to resolve E0432.
use ssxl_math::Vec2i; 
// REMOVED: use ssxl_math::hashing::hash_chunk_coords; // FIX: Cleaned up unused import.

// Used to enable serialization/deserialization of arrays larger than 32 elements
// by the serde framework (necessary for the 1024-tile array).
use serde_big_array::BigArray;

// --- Constants ---

/// The canonical side length of a chunk (e.g., 32x32 tiles), defined as a public constant.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles in a single chunk (32 * 32 = 1024).
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;


// --- Coordinate Structure ---

/// Defines the **chunk-space** coordinates (e.g., Chunk [1, 5] on the world grid).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}


// --- Core Data Structure ---

/// The central data structure for a world chunk. This is the primary payload
/// for procedural generation tasks and caching.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    /// A unique, deterministic identifier for this chunk.
    pub id: u64,
    /// The world-space bounding box of the chunk, using the half-open range convention.
    pub bounds: GridBounds,
    /// The fixed-size array containing all tiles within the chunk.
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    /// A string tag identifying the dimension or layer this chunk belongs to.
    pub dimension_tag: String,
    /// Timestamp indicating when the chunk was generated (serialized deterministically).
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}


impl ChunkData {
    /// Re-export of the canonical chunk size as an associated constant for use in methods.
    pub const SIZE: u32 = CHUNK_SIZE;

    /// Creates a new `ChunkData` instance using explicit, pre-calculated parameters.
    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        // Initialize the tile array with default (empty) TileData.
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    /// Creates a new `ChunkData` instance by calculating its bounds and generating
    /// an initial ID based solely on its chunk coordinates.
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        // 1. Calculate the world-space minimum coordinates (inclusive).
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        // 2. Calculate the world-space maximum coordinates (exclusive, half-open range).
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        // 3. Generate a robust, collision-resistant ID.
        // FIX: Now uses the robust Zigzag-encoded 2D hash.
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    /// Internal helper to map signed i64 to u64 for safe spatial indexing (e.g., Z-order curves).
    /// This prevents massive u64 values for small negative i64 inputs.
    /// Formula: (n << 1) ^ (n >> 63)
    #[inline(always)]
    fn zigzag_encode(n: i64) -> u64 {
        // We use the standard Zigzag formula to map all i64 values to unique u64 values,
        // prioritizing small absolute values to the lowest u64 space.
        ((n << 1) ^ (n >> 63)) as u64
    }

    /// Internal 2D coordinate hashing function, replacing the problematic FFI call.
    /// Uses a **Zigzag-encoded** packing into a u64, which is fast, deterministic,
    /// and ensures no collisions across the world origin.
    fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);

        // Pack the two 32-bit halves. This is standard 2D packing for chunk keys.
        ux | (uy << 32)
    }

    /// Internal helper to convert local tile coordinates (x, y) within the chunk
    /// into a flat array index.
    ///
    /// This is marked `#[inline(always)]` for **performance optimization**
    /// as it's called repeatedly during generation loops.
    ///
    /// Returns `None` if the coordinates are out of the [0, CHUNK_SIZE - 1] range.
    #[inline(always)]
    fn coord_to_index(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            // Index = Y * Width + X (standard row-major order)
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    /// Safely retrieves an immutable reference to a tile at the given local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    /// Inserts a fully generated vector of tiles into the chunk's internal array.
    ///
    /// # Panics
    /// Panics if the input vector's length does not exactly match the expected
    /// `TILE_ARRAY_SIZE`, which is a critical **data integrity** check.
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        // FIX: Use TryInto to consume the Vec, which is more idiomatic and clear for ownership transfer.
        match tiles_vec.try_into() {
            Ok(arr) => self.tiles = arr,
            Err(vec) => {
                // Critical error: A generator produced an incomplete or oversized chunk.
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    /// Safely retrieves a mutable reference to a tile at the given local coordinates.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }
}

// --- Unit Tests ---

#[cfg(test)]
mod tests {
    use super::*;

    // NOTE: For tests to compile, TileData::default() must be Copy, which it implicitly is.
    // The coordinate-to-index tests are sound and require no changes.
    
    #[test]
    /// Tests the critical coordinate-to-index logic for boundaries and center.
    fn test_coord_to_index() {
        // Top-left corner
        assert_eq!(ChunkData::coord_to_index(0, 0), Some(0));

        // Center (16, 16) -> 16 * 32 + 16 = 528
        assert_eq!(ChunkData::coord_to_index(16, 16), Some(528));

        // Bottom-right corner (31, 31) -> 31 * 32 + 31 = 1023 (TILE_ARRAY_SIZE - 1)
        assert_eq!(ChunkData::coord_to_index(31, 31), Some(1023));

        // Out of bounds checks (32 is the exclusive size limit)
        assert_eq!(ChunkData::coord_to_index(32, 0), None);
        assert_eq!(ChunkData::coord_to_index(0, 32), None);
        assert_eq!(ChunkData::coord_to_index(33, 33), None);
    }
    
    #[test]
    /// Tests the Zigzag encoding for correct mapping of signed to unsigned space.
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    /// Tests the new 2D hashing function for uniqueness across the origin.
    fn test_hash_coords_2d() {
        // Standard coordinates
        // (1, 0) -> (Zigzag(1)=2 | Zigzag(0)=0 << 32) = 2
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        // (0, 1) -> (Zigzag(0)=0 | Zigzag(1)=2 << 32) = 8589934592 (2 * 2^32)
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        
        // Critical Negative Coordinate Check (was broken before)
        // (-1, 0) -> (Zigzag(-1)=1 | Zigzag(0)=0 << 32) = 1
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        
        // Collision check across the origin must pass
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        // Large coordinates (to ensure all 64 bits are used)
        let big_x = i64::MAX / 2; // Large positive
        let big_y = i64::MIN / 2; // Large negative
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0); 
    }
}
// --- END: rust/ssxl_shared/src\chunk_data.rs ---
         2 LOC | rust/ssxl_shared/src\config.rs
// --- START: rust/ssxl_shared/src\config.rs ---
// ssxl_shared/src/config.rs

//! # Global Configuration Constants (`ssxl_shared::config`)
//!
//! This module defines fundamental, immutable constants that govern the structure
//! and scale of the SSXL procedural world. These values must be consistent
//! across all SSXL-ext crates (math, generate, cache, godot) to ensure data
//! integrity and system entropy is controlled.

// --- World Geometry Constants ---

/// The canonical side length of a procedural chunk in tiles.
///
/// **Value:** 32 (meaning chunks are 32x32 tiles).
///
/// This constant defines the resolution and granularity of the generated world
/// and is critical for both memory allocation and generation performance.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles contained within a single `ChunkData` structure.
///
/// **Calculation:** CHUNK_SIZE * CHUNK_SIZE (32 * 32 = 1024).
///
/// This value is used to define the fixed-size array in `ChunkData` and for
/// ensuring generators return the correct payload size.
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
// --- END: rust/ssxl_shared/src\config.rs ---
        21 LOC | rust/ssxl_shared/src\errors.rs
// --- START: rust/ssxl_shared/src\errors.rs ---
// ssxl_shared/src/errors.rs

//! # SSXL Error Definitions (`ssxl_shared::errors`)
//!
//! This module defines the global, canonical error type for the entire SSXL-ext
//! procedural generation engine. Centralizing error handling ensures that failures
//! across different crates (math, generate, cache, godot) can be consistently
//! reported, managed, and debugged, particularly across FFI boundaries.

use thiserror::Error;

/// A specialized `Result` type for the SSXL-ext project.
///
/// All function calls that can fail within the SSXL ecosystem should return this
/// type, wrapping the concrete `SSXLError` enum.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// The comprehensive enumeration of all possible errors within the SSXL-ext engine.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Wrapper for standard I/O errors (e.g., file system access, network issues).
    /// This variant automatically handles conversion from `std::io::Error`.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors encountered during data serialization (e.g., using Bincode or Serde).
    /// Indicates problems with converting data to or from a byte stream.
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors related to unexpected or invalid data states, such as a generator
    /// returning a tile array of the wrong size or an invalid chunk key.
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the procedural generation pipeline (e.g., a generator
    /// failing to find a valid output after too many iterations).
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors occurring in the Godot GDExtension bridge or FFI layer.
    /// Crucial for debugging communication issues between Rust and the Godot runtime.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// A critical, unexpected error indicating a bug in the core logic that
    /// should never occur under normal execution (a **"BUG!"**).
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Generic wrapper for errors originating from third-party libraries or crates
    /// that are not covered by other specific variants.
    #[error("External Crate Error: {0}")]
    External(String),
}


// --- Error Conversion Implementations ---

/// Implements conversion from the `bincode::Error` type into the SSXL `Serialization` error.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Implements conversion from the generic `anyhow::Error` type into the SSXL `External` error.
/// This provides a convenient way to integrate external library errors into the SSXL system.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        // Use the debug message of the anyhow error to retain the source chain.
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}
// --- END: rust/ssxl_shared/src\errors.rs ---
        11 LOC | rust/ssxl_shared/src\generation_message.rs
// --- START: rust/ssxl_shared/src\generation_message.rs ---
// ssxl_shared/src/generation_message.rs

//! # Generation Messaging (`ssxl_shared::generation_message`)
//!
//! This module defines the structures and enumerations used for communication
//! between the main **Conductor** thread and the asynchronous **Worker Threads**
//! (managed by the `RuntimeManager` in the `ssxl_generate` crate).
//!
//! These structures manage the flow of work requests (`GenerationTask`) and
//! completed results (`GenerationMessage`).

use crate::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use std::sync::Arc;


// --- Work Request Structure ---

/// Defines a single unit of work (a task) to be processed by a worker thread.
///
/// This structure is put into the engine's `TaskQueue` by the `Conductor`.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    /// The chunk-space coordinates of the chunk that needs to be generated.
    pub chunk_coords: Vec2i,
    /// The unique identifier of the generator to be used for this task (e.g., "cellular_automata").
    pub generator_id: String,
}


// --- Communication Message Enumeration ---

/// An enumeration of messages sent from the worker threads back to the
/// main thread or the Conductor to signal task completion or pipeline status.
#[derive(Debug)]
pub enum GenerationMessage {
    /// Signals that a chunk has been successfully generated.
    ///
    /// Uses `Arc<ChunkData>` (Atomic Reference Counted) to allow multiple parts
    /// of the engine (e.g., the cache and the Godot presenter) to hold a reference
    /// to the generated data simultaneously without deep copying, which is critical
    /// for high-performance data sharing.
    ChunkGenerated(Vec2i, Arc<ChunkData>),

    /// Signals that all current tasks related to a specific generation batch
    /// or request have been finalized. Used by the `Conductor` to update
    /// the generation state.
    GenerationComplete,
}
// --- END: rust/ssxl_shared/src\generation_message.rs ---
        35 LOC | rust/ssxl_shared/src\grid_bounds.rs
// --- START: rust/ssxl_shared/src\grid_bounds.rs ---
// ssxl_shared/src/grid_bounds.rs

//! # Grid Bounds Structures (`ssxl_shared::grid_bounds`)
//!
//! This module defines the core structures for representing 2D world-space points
//! and rectangular bounding boxes (bounds) used throughout the SSXL-ext engine.

use serde::{Deserialize, Serialize};

// --- Coordinate Structure ---

/// Represents a single 2D world-space coordinate point.
///
/// Uses `i64` to support the massive scale of the SSXL world coordinates.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    /// The X component of the coordinate.
    pub x: i64,
    /// The Y component of the coordinate.
    pub y: i64,
}

// --- Bounding Box Structure ---

/// Defines a rectangular region in the world by its minimum and maximum coordinate points.
///
/// **Convention:** `GridBounds` uses a **half-open range** (`[min, max)`), meaning
/// the minimum coordinates are **inclusive** and the maximum coordinates are **exclusive**.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum coordinate (e.g., the bottom-left point of the region).
    pub min: Coord2D,
    /// The exclusive maximum coordinate (one unit past the top-right point of the region).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new `GridBounds` instance from four explicit coordinate components.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size (width and height) of the bounds.
    ///
    /// For a half-open range, the size is simply `max - min`, which correctly
    /// yields the number of unique integer coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within the bounds.
    ///
    /// Follows the half-open range convention: `[min.x, max.x)` and `[min.y, max.y)`.
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Returns a default, zero-sized bounds at the origin (0, 0) to (0, 0).
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}
// --- END: rust/ssxl_shared/src\grid_bounds.rs ---
        41 LOC | rust/ssxl_shared/src\lib.rs
// --- START: rust/ssxl_shared/src\lib.rs ---
//! # SSXL Shared Data Crate (`ssxl_shared`)
//!
//! This crate contains fundamental data structures, configuration constants, and
//! messaging definitions utilized across all modules of the SSXL-ext procedural
//! generation engine. Its purpose is to ensure data integrity and consistency
//! between the high-speed worker threads and the main Godot runtime.

use serde::{Deserialize, Serialize};
use tracing;

// --- Module Declarations ---

pub mod chunk_data;
pub mod tile_data;
pub mod grid_bounds;
pub mod tile_type;
pub mod errors;
pub mod messages;
pub mod config;
pub mod generation_message;
pub mod math_primitives;

// --- Public Re-exports (The Main Crate API) ---

// 1. Primitive Spatial IDs (Re-exported from ssxl_math)
pub use ssxl_math::primitives::{ChunkId, TileCoord}; 

// 2. Core Data Structures & Constants
pub use chunk_data::{ChunkData, CHUNK_SIZE}; 
pub use tile_data::{AnimationUpdate, TileData}; // Canonical source for AnimationUpdate
pub use grid_bounds::GridBounds;
pub use tile_type::TileType;

// 3. Cycle-Breaking Communication Types (From the messages module)
pub use messages::{
    AnimationCommand,
    AnimationType,
    AnimationPayload,
    UpdateSender,
    AnimationConductorHandle,
    AnimationState,
    CommandResult,
};

// 4. Error Handling
pub use errors::{SSXLError, SSXLResult};
pub use anyhow;

// --- Generic Data Structure ---

/// A generic struct used to represent serializable, time-stamped data payloads.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

// --- Initialization Function ---

/// Initializes the shared data module.
pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

// --- Prelude for Ergonomics ---

/// A convenience module that re-exports all essential types for ergonomic use.
/// Other SSXL-ext crates are encouraged to use `use ssxl_shared::prelude::*`.
pub mod prelude {
    // Re-export core structs
    pub use super::{ChunkData, TileData, GridBounds, TileType};
    // Re-export Primitives
    pub use super::{ChunkId, TileCoord};
    // Re-export Errors
    pub use super::{SSXLError, SSXLResult};
    // Re-export Communication Types (essential for high-level module interaction)
    pub use super::{AnimationCommand, AnimationUpdate, AnimationType};
}
// --- END: rust/ssxl_shared/src\lib.rs ---
        20 LOC | rust/ssxl_shared/src\math_primitives.rs
// --- START: rust/ssxl_shared/src\math_primitives.rs ---
// ssxl_shared/src/math_primitives.rs

//! # Math Primitives & Serde Helpers (`ssxl_shared::math_primitives`)
//!
//! This module contains custom logic, primarily Serde serialization/deserialization
//! functions, for mathematical or standard library types that require specific,
//! deterministic formatting (e.g., `SystemTime`) for cross-platform compatibility
//! and persistent caching.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};


/// Serde serialization/deserialization helper for `std::time::SystemTime`.
///
/// This custom serializer converts `SystemTime` to and from a `u64` representing
/// the time in milliseconds since the Unix epoch (1970-01-01). This guarantees
/// a **deterministic, platform-independent** representation for caching and networking.
pub mod system_time_serde {
    use super::*;

    /// Serializes a `SystemTime` into a `u64` representing milliseconds since epoch.
    /// This is used by Serde when writing data (e.g., saving a `ChunkData` to cache).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Calculate the duration from the UNIX_EPOCH to the current time.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert the duration to milliseconds (u64) to ensure a stable format.
        let ms = duration.as_millis() as u64;
        // Serialize the u64 millisecond count.
        serializer.serialize_u64(ms)
    }

    /// Deserializes a `u64` (milliseconds since epoch) back into a `SystemTime`.
    /// This is used by Serde when reading data (e.g., loading a `ChunkData` from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize the u64 millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert the millisecond count into a Duration, then add it to UNIX_EPOCH.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}
// --- END: rust/ssxl_shared/src\math_primitives.rs ---
        48 LOC | rust/ssxl_shared/src\messages.rs
// --- START: rust/ssxl_shared/src\messages.rs ---
//! # Core Communication Contracts (`ssxl_shared::messages`)
//!
//! This module defines the essential messaging structures used for asynchronous
//! communication between the Godot FFI layer, the Conductor, and the Rayon worker pool.
//! These public types centralize the data contract to break the cyclic dependency
//! between `ssxl_animate` and `ssxl_sync`.

use serde::{Deserialize, Serialize};
use tokio::sync::mpsc::UnboundedSender;

// Primitives and ChunkData are available via the crate root's public exports.
use crate::chunk_data::ChunkData;
use crate::{ChunkId, TileCoord};

// --- Core Animation Communication (Cycle-Breaking Types) ---

/// Defines the various types of animation behaviors that workers can execute.
#[derive(Debug, Clone)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

/// Defines the change to a tile (e.g., new frame ID, new tween value).
#[derive(Debug, Clone)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

/// A structure representing a single update to be applied by the Godot main thread.
#[derive(Debug, Clone)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

/// The command sent from the Godot FFI layer (via ssxl_sync) to the async workers.
#[derive(Debug, Clone)]
pub enum AnimationCommand {
    /// Command 1: Delegate heavy animation work to the Rayon thread pool.
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    
    /// Command 2: System command to kick off a dedicated test or demo animation.
    StartTestAnimation,
    
    /// Command 3: State command to adjust the overall simulation speed.
    SetTimeScale(f32),

    /// State command to enable or disable the animation conductor thread.
    SetEnabled(bool),
    
    /// Command 4: System command to trigger a graceful shutdown of the Conductor.
    Shutdown,
}

/// The sender handle for the main update channel (Tokio/MPSC).
/// Used by Rayon workers to send results back to the main thread poller.
pub type UpdateSender = UnboundedSender<AnimationUpdate>;


// --- FFI / Conductor Control Types (Completing the Contract) ---

/// The handle returned to the FFI layer to send AnimationCommands to the Conductor.
/// This type lives here to break the package dependency cycle (ssxl_sync -> ssxl_animate).
pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

/// A simple Result type for command processing success/failure.
pub type CommandResult = Result<(), String>;

/// The current runtime state of the Animation Conductor (e.g., Running, Paused).
#[derive(Debug, Clone, Copy, Default)]
pub struct AnimationState {
    pub time_scale: f32, // The state field required by the SetTimeScale command
    // FIX: Added to track the enabled/disabled state, resolving E0599.
    pub is_enabled: bool,
}

impl AnimationState {
    /// Implements the required method for the Conductor to update local state.
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    /// FIX: Implements the required setter for the `AnimationCommand::SetEnabled` command.
    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}


// --- Generic Data Messages (Existing Content) ---

/// A generic, serializable message wrapper for communicating the status of a
/// single chunk data request.
///
/// **FIX:** Removed the `GodotConvert` derive, as it belongs to the Godot-facing
/// code that consumes this shared struct.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChunkMessage {
    /// The request was successful, and the complete `ChunkData` is attached.
    Generated(ChunkData),

    /// The request was processed, but the data does not exist (e.g., a cache miss).
    NoData,

    /// An operational error occurred during the request (e.g., I/O failure).
    /// The attached `String` contains the human-readable error description.
    Error(String),
}
// --- END: rust/ssxl_shared/src\messages.rs ---
        68 LOC | rust/ssxl_shared/src\tile_data.rs
// --- START: rust/ssxl_shared/src\tile_data.rs ---
// ssxl_shared/src/tile_data.rs

//! # Tile Data Structures (`ssxl_shared::tile_data`)
//!
//! This module defines the `TileData` structure, which holds the minimal necessary
//! information for a single tile in the procedural world. It also includes utility
//! structures and bitmask constants (`tile_flags`) for efficient property management.
//! The use of `Copy` and `u8` flags is key to maintaining the high-speed "Tempo"
//! of the multi-threaded engine.

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};

// Re-exports a core math primitive for use in related structures (e.g., AnimationUpdate).
use ssxl_math::Vec2i;


// --- Core Data Structure ---

/// Represents the data payload for a single tile in a chunk.
///
/// Marked `Copy` for high performance, as tiles are frequently cloned/copied
/// within generation and rendering loops.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The material or type of tile (e.g., grass, rock, empty).
    pub tile_type: TileType,
    
    /// The raw noise value (e.g., Perlin, Simplex) used to determine this tile's type.
    /// This is crucial for seamless neighbor checks and debugging the procedural generation.
    pub noise_value: f32,
    
    /// A compact bitfield storing up to 8 boolean properties about the tile.
    pub flags: u8,
}

impl Default for TileData {
    /// Returns the default state for a tile: `TileType::Void` with zero noise and no flags set.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}


// --- Godot FFI Message Structure ---

/// Data structure used specifically for communication between the Rust engine
/// and the Godot runtime regarding tile animations.
///
/// This message is typically used by a dedicated rendering or animation system.
#[derive(Debug, Clone, Serialize, Deserialize)] // FIX: Added Serialize and Deserialize
pub struct AnimationUpdate {
    /// The layer or dimension the tile belongs to.
    pub layer: i32,
    /// The source ID of the tile map or animation source.
    pub source_id: i32,
    /// The world coordinates of the tile to update.
    pub tile_coords: Vec2i,
    /// The new coordinates within the texture atlas for the tile's animation frame.
    pub new_atlas_coords: Vec2i,
}


// --- Bitwise Flag Constants ---

/// Bitmasks used to set, check, or clear properties in the `TileData::flags` field.
/// This maximizes data density by storing 8 booleans in a single byte (`u8`).
pub mod tile_flags {
    /// Bit 0: Is the tile physically passable by entities? (e.g., air, water surface)
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001;
    /// Bit 1: Is the tile currently visible/rendered by the client?
    pub const IS_RENDERED:    u8 = 0b0000_0010;
    /// Bit 2: Has this tile been manually changed post-generation by a player/editor?
    pub const IS_MODIFIED:    u8 = 0b0000_0100;
    /// Bit 3: Does this tile contain a gatherable resource or item?
    pub const HAS_RESOURCE:    u8 = 0b0000_1000;
    // Bits 4-7 are reserved for future properties.
}


impl TileData {
    /// Creates a new `TileData` instance with specified type and noise value.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0, // Flags are initialized to zero (all false)
        }
    }

    /// Checks if the tile is considered a "solid" block, typically used for collision.
    pub const fn is_solid(&self) -> bool {
        // Relies on a method in TileType to define "solidity."
        !self.tile_type.is_empty()
    }

    /// Sets a flag based on its **bit index** (0-7).
    pub fn set_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise OR assignment: sets the bit at the given index to 1.
            self.flags |= 1 << flag_index;
        }
    }

    /// Clears (sets to 0) a flag based on its **bit index** (0-7).
    pub fn clear_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise AND assignment with the inverted mask: sets the bit to 0.
            self.flags &= !(1 << flag_index);
        }
    }

    /// Checks the status of a flag based on its **bit index** (0-7).
    pub fn check_flag_by_index(&self, flag_index: u8) -> bool {
        if flag_index < 8 {
            // Bitwise AND with the mask: returns true if the bit is set.
            (self.flags & (1 << flag_index)) != 0
        } else {
            false
        }
    }
    
    /// Sets or clears a property using a predefined **flag mask** (e.g., `tile_flags::IS_TRAVERSABLE`).
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            // Set the bit(s) (|= is bitwise OR assignment).
            self.flags |= flag_mask;
        } else {
            // Clear the bit(s) (&! is bitwise AND with the inverted mask).
            self.flags &= !flag_mask;
        }
    }

    /// Checks the status of a property using a predefined **flag mask**.
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        // Returns true if any of the bits in the mask are set in self.flags.
        (self.flags & flag_mask) != 0
    }
}
// --- END: rust/ssxl_shared/src\tile_data.rs ---
        66 LOC | rust/ssxl_shared/src\tile_type.rs
// --- START: rust/ssxl_shared/src\tile_type.rs ---
// ssxl_shared/src/tile_type.rs

//! # Tile Type Enumeration (`ssxl_shared::tile_type`)
//!
//! This module defines the canonical `TileType` enum, which identifies the material
//! or nature of a single tile. It is a fundamental data structure shared across
//! the entire SSXL-ext engine.
//!
//! **Critical Feature:** The use of `#[repr(u8)]` is a **memory optimization**
//! that guarantees the enum is stored as a single byte, drastically reducing the
//! memory footprint of the massive `ChunkData` tile arrays.

use serde::{Deserialize, Serialize};

/// Enumeration of all primary tile materials available in the procedural world.
///
/// Ensures strict memory layout as a single byte for efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    /// The default, empty state (e.g., air or background).
    Void = 0,
    /// A fluid, typically used for rivers, oceans, or lower areas.
    Water = 1,
    /// Base terrain, usually flat and traversable.
    Grass = 2,
    /// Elevated terrain, potentially difficult to traverse.
    Mountain = 3,
    /// An artificial boundary used to cap chunk edges or isolate generation regions.
    Boundary = 4,
    /// An engineered or placed structure (e.g., a ruin, road, or wall).
    Structure = 5,
    /// A solid, rocky, non-soil terrain type.
    Rock = 6,
    /// Reserved for generator-specific customization or future expansion.
    Custom1 = 7,
    /// Reserved for generator-specific customization or future expansion.
    Custom2 = 8,
}


impl Default for TileType {
    /// The default state of a tile is always `TileType::Void` (empty).
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Converts the `TileType` instance into its underlying `u8` representation.
    #[inline] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a raw `u8` value back into a `TileType`.
    ///
    /// Returns `None` if the input value does not correspond to a defined variant,
    /// ensuring safe deserialization.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TileType::Void),
            1 => Some(TileType::Water),
            2 => Some(TileType::Grass),
            3 => Some(TileType::Mountain),
            4 => Some(TileType::Boundary),
            5 => Some(TileType::Structure),
            6 => Some(TileType::Rock),
            7 => Some(TileType::Custom1),
            8 => Some(TileType::Custom2),
            _ => None,
        }
    }
    
    /// Provides a simple, default unique ID for this tile type (equal to its u8 value).
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Provides default atlas coordinates (X, Y) for initial rendering/visual representation.
    ///
    /// This is a common lookup function used by the rendering component (`ssxl_godot`).
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // All default tiles are expected to be on the first row (Y=0) of the atlas.
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            // Void and unspecified types default to the origin (0, 0).
            _ => (0, 0), 
        }
    }
}


impl TileType {
    /// Checks if the tile type is one that a character can typically traverse (walk on).
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type is considered a fluid (e.g., for flow/buoyancy simulation).
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is empty (the default/void state).
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}
// --- END: rust/ssxl_shared/src\tile_type.rs ---
        50 LOC | rust/ssxl_sync/src\animation_conductor.rs
// --- START: rust/ssxl_sync/src\animation_conductor.rs ---
use godot::prelude::*;
// FIX: Removed unused imports: Array and Variant
// use godot::builtin::{Array, Variant}; 
use ssxl_shared::{
    // FIX: Removed unused import: AnimationUpdate
    AnimationConductorHandle,
    AnimationState, 
};

// CRITICAL FIX: Explicitly import the correct message type for use in the receiver's type.
use ssxl_shared::messages::AnimationUpdate as MessageAnimationUpdate; 

use ssxl_animate::{
    // Keep logic components imported from ssxl_animate.
    initialize_animation_conductor, 
    AnimationConductor, 
};
// Use `tokio::sync::mpsc` for channel creation and type aliases
use tokio::sync::mpsc::{self, UnboundedReceiver}; 

// FIX: Change the type alias to use the correct MESSAGE struct.
pub type AnimationUpdateReceiver = UnboundedReceiver<MessageAnimationUpdate>;

/// The FFI Conductor: This struct is exposed to Godot as a Singleton or Node.
/// Its sole purpose is to bridge Godot's main thread with the Rust async workers.
#[derive(GodotClass)]
#[class(tool, init, base=Node)] // Base Node for easy Godot integration
pub struct FfiAnimationConductor {
    // 1. The FFI Handle: Used by Godot to send commands.
    // FIX: Allows dead code. This field is accessed via FFI functions (e.g., queue_job).
    #[allow(dead_code)] 
    command_tx: Option<AnimationConductorHandle>,
    // 2. The FFI Poller: Used by Godot's main thread to receive updates from workers.
    update_rx: Option<AnimationUpdateReceiver>,
    // 3. The Arc<Mutex<Conductor>>: The core async component.
    _core_conductor: Option<std::sync::Arc<std::sync::Mutex<AnimationConductor>>>,
    // Godot-safe handle to the TileMap resource for applying updates.
    tilemap_node: Option<Gd<Node2D>>,
}

#[godot_api]
impl FfiAnimationConductor {
    // FFI Lifecycle: Called once when the Node enters the tree.
    // FIX: Allows dead code. This method is called by the Godot Engine lifecycle.
    #[allow(dead_code)]
    fn ready(&mut self) {
        // NOTE: The `update_rx` created here is `UnboundedReceiver<ssxl_shared::messages::AnimationUpdate>`
        let (update_tx, update_rx) = mpsc::unbounded_channel();
        let initial_state = AnimationState::default(); 

        let (tx_handle, core_conductor) = initialize_animation_conductor(
            update_tx, 
            initial_state, 
        );

        // Assign the handles and receiver to the struct fields.
        self.command_tx = Some(tx_handle);
        self.update_rx = Some(update_rx); 
        self._core_conductor = Some(core_conductor);

        godot_print!("SSXL Animation System FFI initialized.");
    }

    // ... (omitted `queue_job` logic)
    
    /// FFI Method: Called every frame (e.g., via _process(delta)) by GDScript.
    #[func]
    pub fn poll_updates(&mut self) -> i32 {
        let mut updates_processed = 0;
        let mut updates_to_process: Vec<MessageAnimationUpdate> = Vec::new();
        
        if let Some(rx) = self.update_rx.as_mut() {
            // CRITICAL LOGIC: Non-blocking receive loop.
            while let Ok(update) = rx.try_recv() {
                updates_to_process.push(update);
            }
        }
        
        // Now self is not mutably borrowed by rx, so we can mutably borrow it here.
        for update in &updates_to_process {
            self.apply_update_to_tilemap(update);
            updates_processed += 1;
        }

        updates_processed
    }

    // Internal function for Godot interaction details (TileMap logic lives here).
    fn apply_update_to_tilemap(&mut self, _update: &MessageAnimationUpdate) {
        if let Some(_tilemap) = &mut self.tilemap_node {
            // TODO: Restore original 246-LOC logic for applying the change.
            // This is where the Chunking logic will be applied next!
        }
    }
}
// --- END: rust/ssxl_sync/src\animation_conductor.rs ---
        26 LOC | rust/ssxl_sync/src\lib.rs
// --- START: rust/ssxl_sync/src\lib.rs ---
// ssxl_sync/src/lib.rs

//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//!
//! This crate provides the core primitives and manager structs necessary for
//! thread synchronization, communication, and high-performance worker management
//! within the SSXL-ext engine. This includes:
//! 1. **Data Safety:** Atomic wrappers for thread-safe shared resources.
//! 2. **Worker Management:** Thread pools and specialized, dedicated worker threads (Conductors).
//! 3. **Communication:** Channel definitions for command and result passing.

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import tokio for the channel types used in the aliases below.
use tokio::sync::mpsc; 
// CRITICAL: Import all core contract types from ssxl_shared.
use ssxl_shared::{
    SSXLError, 
    AnimationUpdate,
    AnimationCommand, 
    // FIX: Removed unused import AnimationState
};
// FIX: Import and public re-export the core struct in one step to avoid E0252/E0365.
pub use ssxl_animate::AnimationConductor; 

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

/// Defines core thread-safe types, enums, and channel aliases used for concurrency and communication.
pub mod primitives;

/// Manages the generic, fixed-size thread pool used for synchronous, CPU-intensive tasks.
pub mod pool_manager;

/// Manages the dedicated worker thread and state for calculating visual animation frames.
pub mod animation_conductor;


// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

// --- 1. Generic Primitives and Utility Functions (from primitives) ---

/// Re-exports of generic thread-safe resource wrappers, synchronous channels, and worker placeholders.
pub use primitives::{
    AtomicResource, 
    create_sync_channel, 
    start_sync_worker
};

// --- 2. Animation Conductor Types ---

// FIX: Removed the unused `pub use animation_conductor::{...};` block.
// The primary conductor struct is handled by the `pub use ssxl_animate::AnimationConductor` above.


// --- 3. Thread Pool Manager Types (from pool_manager) ---

/// Re-exports of all public types related to the generic CPU worker thread pool.
pub use pool_manager::{
    WorkerPool, 
    GenerationTask, 
    ConductorResult, 
    Task, 
    TaskResult
};

// --------------------------------------------------------------------------------
// --- Final Type Aliases (CRATE ROOT API) ---
// --------------------------------------------------------------------------------

// The UnboundedSender type is used to send commands to the Conductor's thread.
pub type AnimationConductorHandle = mpsc::UnboundedSender<AnimationCommand>;

// The Receiver half of the command channel for the AnimationConductor.
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;

// The UnboundedSender type is used to send updates (e.g., animation frames) back to the main thread.
pub type UpdateSender = mpsc::UnboundedSender<AnimationUpdate>; 

// The standard result wrapper, using SSXLError.
pub type CommandResult = Result<(), SSXLError>;
// --- END: rust/ssxl_sync/src\lib.rs ---
        95 LOC | rust/ssxl_sync/src\pool_manager.rs
// --- START: rust/ssxl_sync/src\pool_manager.rs ---
// ssxl_sync/src/pool_manager.rs

//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::Vec2i;

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    CompletedChunk(Arc<ssxl_shared::chunk_data::ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // ssxl_shared::chunk_data is assumed to be available to this crate.
                        Arc::new(ssxl_shared::chunk_data::ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
// --- END: rust/ssxl_sync/src\pool_manager.rs ---
        26 LOC | rust/ssxl_sync/src\primitives.rs
// --- START: rust/ssxl_sync/src\primitives.rs ---
// ssxl_sync/src/primitives.rs

//! # Synchronization Primitives (`ssxl_sync::primitives`)
//!
//! This module defines the core thread-safe data structures and communication channels.

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
use tracing::info; // Required for the start_sync_worker function

// --- 1. Thread-Safe Resource Wrapper ---

/// A generic, thread-safe wrapper for data shared between multiple threads.
/// It uses `parking_lot::RwLock` for fast, efficient concurrent read access.
#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    /// The actual data protected by an Arc (shared ownership) and RwLock (read/write access control).
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    /// Creates a new `AtomicResource` containing the provided data.
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    /// Acquires a read lock on the data. Allows multiple concurrent readers.
    #[inline]
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    /// Acquires an exclusive write lock on the data. Blocks all other readers/writers.
    #[inline]
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}


// --- 2. Generic Synchronous Channel (Crossbeam) ---

/// Creates an unbounded, multi-producer, single-consumer channel for synchronous (blocking) communication.
/// This is used primarily for simple signalling or utility messaging.
pub fn create_sync_channel() -> (Sender<String>, Receiver<String>) {
    unbounded()
}

/// A placeholder function demonstrating where a synchronous worker thread might be started.
pub fn start_sync_worker() {
    info!("SSXL Synchronization Worker placeholder started.");
}
// --- END: rust/ssxl_sync/src\primitives.rs ---
        70 LOC | rust/ssxl_tools/src\lib.rs
// --- START: rust/ssxl_tools/src\lib.rs ---
// ssxl_tools/src/lib.rs

//! # SSXL Engine Tools (`ssxl_tools`)
//!
//! Provides utility functions for **configuration management**, **data validation**,
//! and other engine-wide tooling not specific to generation or synchronization.

use once_cell::sync::Lazy;
use regex::Regex;
use tracing::{info, warn};
use std::io::{self, Read};
use std::fs::File;

use ssxl_shared::SSXLData;

// --------------------------------------------------------------------------------
// --- Configuration Constants ---
// --------------------------------------------------------------------------------

/// The default file path to check for engine configuration.
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
/// The ID of the generator used when configuration loading fails or is not specified.
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
/// The default Cellular Automata ruleset ID to use.
const DEFAULT_CA_RULESET: u8 = 0;

// --------------------------------------------------------------------------------
// --- SSXL Configuration Management ---
// --------------------------------------------------------------------------------

/// Configuration structure holding key engine settings, primarily for generation defaults.
pub struct SSXLConfig {
    /// The ID of the world generator to use when no specific one is requested.
    default_generator_id: String,
    /// The default ruleset ID for the Cellular Automata generator.
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Creates a new `SSXLConfig` instance populated with hardcoded default values.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to read and simulate loading engine configuration from a file path.
    ///
    /// The actual configuration parsing logic is currently simulated:
    /// it reads the file and then unconditionally returns hardcoded override values.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                // Read the entire file content into a string.
                file.read_to_string(&mut contents)?;

                info!("SSXLConfig: File read successfully. Simulating config override.");
                // Placeholder: In a real implementation, 'contents' would be parsed (e.g., via TOML).
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), // Simulated override
                    ca_default_ruleset: 1,                               // Simulated override
                })
            },
            // If file opening fails, propagate the standard I/O error.
            Err(e) => Err(e),
        }
    }

    /// Returns the configured default generator ID string.
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Returns the configured default Cellular Automata ruleset ID.
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Attempts to load the configuration from the specified path.
///
/// If `path` is `None`, it defaults to `DEFAULT_CONFIG_PATH`.
/// If the file loading fails for any reason, it logs a warning and **returns
/// a new `SSXLConfig` instance populated with hardcoded defaults** (safe fallback).
pub fn get_config_from_path(path: Option<&str>) -> Result<SSXLConfig, io::Error> {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            Ok(config)
        },
        Err(e) => {
            // Log the failure but ensure the engine has a runnable configuration.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            // Return the defaults wrapped in an Ok() to ensure initialization succeeds.
            Ok(SSXLConfig::new_with_defaults())
        }
    }
}

// --------------------------------------------------------------------------------
// --- Static Configuration (DEPRECATED) ---
// --------------------------------------------------------------------------------

/// Lazy-initialized static instance of the default configuration.
///
/// Used by the deprecated `get_config()` function.
static CONFIG: Lazy<SSXLConfig> = Lazy::new(SSXLConfig::new_with_defaults);

/// Retrieves the global static configuration instance.
///
/// **WARNING:** This function is **DEPRECATED**. It does not allow for specifying
/// a configuration path and relies on a hardcoded static default.
/// Use [`get_config_from_path`] instead.
pub fn get_config() -> &'static SSXLConfig {
    warn!("DEPRECATED: Called `get_config()`. Use `get_config_from_path()` for correct FFI CWD handling and dynamic loading.");
    &CONFIG
}

// --------------------------------------------------------------------------------
// --- Utility Functions ---
// --------------------------------------------------------------------------------

/// Lazy-initialized regular expression for validating SSXL data IDs (must be composed only of digits).
static ID_REGEX: Lazy<Regex> = Lazy::new(|| {
    // Pattern matches one or more digits from start to end of the string.
    Regex::new(r"^\d+$").expect("Failed to compile ID validation regex")
});

/// Validates that an `SSXLData` ID is composed solely of digits.
pub fn validate_data_id(data: &SSXLData) -> bool {
    // Checks if the string representation of the data ID matches the digit-only regex.
    ID_REGEX.is_match(&data.id.to_string())
}

/// Initializes engine tool utilities.
///
/// This function triggers the lazy initialization of necessary static resources,
/// such as the ID validation regex, ensuring they are ready before first use.
pub fn initialize() {
    // Force initialization of the static regex.
    let _ = &*ID_REGEX;
    info!("SSXL Tools: Configuration and data validation utilities initialized.");
}
// --- END: rust/ssxl_tools/src\lib.rs ---
        67 LOC | rust/ssxl_cli/src\actions\benchmarking.rs
// --- START: rust/ssxl_cli/src\actions\benchmarking.rs ---
// ssxl_cli/src/actions/benchmarking.rs

//! # CLI Actions: Monitoring and Benchmarking (`ssxl_cli::actions::benchmarking`)
//!
//! Provides command-line interface tools for interacting with the SSXL engine's
//! asynchronous systems. This includes real-time status inspection of the
//! `Conductor` and facilities for running performance benchmarks.

use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering} // Atomic types for thread-safe signaling
};
use std::thread;
use std::time::Duration;
use ctrlc; // Crate for handling Ctrl-C signals

// FINAL FIX: Importing types directly from the external crates as suggested by the compiler.
// This bypasses any ambiguity or compilation order issues with `crate::actions::` re-exports.
use ssxl_generate::conductor::Conductor;
use ssxl_generate::conductor_state::ConductorStatus;


/// Initializes the main world generation Conductor and begins a live, real-time
/// feed of its status to the command line.
///
/// This function blocks the current thread until the process is terminated via
/// Ctrl-C or the Conductor signals a fatal state (Error/ShuttingDown).
pub fn start_signal_inspector() {
    warn!(" Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // Attempt to initialize the Conductor, which starts the Tokio runtime and worker threads.
    let (conductor, state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!(" Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    // --- Graceful Shutdown Setup ---

    // 1. Wrap the Conductor in a structure that allows for shared, mutable ownership
    // and consumption from the signal handler thread.
    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    // 2. Use a thread-safe atomic boolean to control the main inspection loop.
    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    // 3. Set the Ctrl-C handler to trigger graceful shutdown.
    if let Err(e) = ctrlc::set_handler(move || {
        // Stop the main inspection loop.
        r_for_handler.store(false, Ordering::SeqCst);

        // Attempt to take the Conductor out of the Mutex/Option and call its teardown method.
        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    // --- Live Feed Loop ---

    let mut frame_count: u64 = 0;
    // Arbitrary maximum tile generation rate used for display.
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        // Fetch current state variables from the thread-safe state tracker.
        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        // Print the status line, using '\r' (carriage return) to overwrite the line
        // without scrolling the console.
        print!("\r");
        print!(" LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        // Flush stdout to ensure the output is immediately written to the terminal.
        let _ = io::stdout().flush();

        // Check for internal shutdown signals from the Conductor itself (e.g., internal error).
        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            // Signal the loop to stop and try to manually trigger cleanup one last time.
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        // Pause for a brief duration (50ms refresh rate).
        thread::sleep(Duration::from_millis(50));
    }

    // Overwrite the last printed line with spaces to clear it cleanly.
    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}


/// Placeholder function for running engine performance benchmarks.
#[allow(dead_code)] // Suppressing the warning as this is a public API for the CLI.
pub fn run_benchmark() {
    warn!(" Benchmark execution not yet implemented. Placeholder called.");
}
// --- END: rust/ssxl_cli/src\actions\benchmarking.rs ---
       102 LOC | rust/ssxl_cli/src\actions\godot_harness.rs
// --- START: rust/ssxl_cli/src\actions\godot_harness.rs ---
// FILE: ssxl_cli/src/actions/godot_harness.rs

//! # CLI Actions: Godot Harness (`ssxl_cli::actions::godot_harness`)
//!
//! Utilities for managing and launching the Godot editor or the Godot game
//! client from the command line, including necessary setup steps like copying
//! the compiled Rust dynamic library (DLL/SO/DYLIB) into the Godot project's
//! GDExtension directory.

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Imports of constants and utility functions from the parent module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


/// Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the `target/release`
/// or `target/debug` folder to the Godot tester project's GDExtension directory.
///
/// This is a critical step to ensure Godot loads the latest engine code.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // --- 1. Construct Source Path ---
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    // Navigate to the target directory (e.g., `target/debug/`).
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    // Add the DLL file name (e.g., `SSXL_engine.dll`).
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // --- 2. Construct Destination Path ---
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    // Navigate to the Godot project's GDExtension folder.
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    // Add the DLL file name.
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // --- 3. Validation and Copy ---

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        // Treat missing source as a non-fatal warning to continue CLI usage.
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                " DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            // This often fails if the target DLL is locked by a running Godot instance.
            Err(format!(
                " FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}


/// Launches the Godot Editor in a non-blocking subprocess.
pub fn launch_godot_client() {
    info!(" LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!(" Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    // Execute the Godot process.
    match Command::new(GODOT_EXE_PATH)
        // Flag to launch the editor window instead of running the game directly.
        .arg("--editor")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously, allowing the CLI process to continue.
        .spawn()
    {
        Ok(_) => {
            info!(" Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!(" Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

/// Launches Godot in a non-blocking subprocess using the `--headless` flag.
/// 
/// This is used for automated testing where no GUI is needed.
pub fn launch_headless_godot() {
    info!(" LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!(" Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        // Flag to run Godot without a graphical interface.
        .arg("--headless")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously.
        .spawn()
    {
        Ok(_) => {
            info!(" Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!(" Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\godot_harness.rs ---
        42 LOC | rust/ssxl_cli/src\actions\mod.rs
// --- START: rust/ssxl_cli/src\actions\mod.rs ---
// FILE: ssxl_cli/src/actions/mod.rs

//! # CLI Actions Module (`ssxl_cli::actions`)
//!
//! This module acts as the public interface (faade) for all complex command-line
//! actions, such as launching Godot, running tests, or initiating benchmarks.
//! It aggregates constants, external dependencies, and exports from its child modules.

use std::env;
use std::path::PathBuf;

// --- Internal Modules ---

/// Tools for real-time monitoring of the Conductor and placeholder for benchmark logic.
mod benchmarking;
/// Utilities for launching and managing the external Godot engine tester project.
mod godot_harness;
/// The main menu and delegation stub for all test suites.
mod testing;
/// Contains self-contained architectural and data validation tests.
mod test_suites;
/// Contains tests requiring external processes like `cargo` and Godot FFI validation.
mod test_core_suites;

// --- Public Re-exports from Sibling Crates ---

// --- Configuration Constants ---

/// The absolute path to the Godot executable file.
pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
/// The project-relative path fragment pointing to the GDExtension folder (e.g., `godot_tester_project/gde/`).
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXL_engine_tester/";
/// The expected file name of the compiled Rust dynamic library (e.g., `ssxl_engine.dll`).
pub const DLL_NAME: &str = "ssxl_engine.dll";
/// The project-relative path fragment where the compiled DLL is found (e.g., `target/debug/`).
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
/// The scene path within the Godot project used for FFI bridge validation tests.
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; // <--- ADDED THIS LINE

// --- Utility Functions ---

/// Calculates the absolute path to the Godot tester project root.
///
/// The calculation starts from the current working directory, navigates to the 
/// GDExtension path, and then steps back one level to find the project root.
pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    // Start from the current working directory (usually the crate root)
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;

    // Append the relative project fragment path (e.g., 'godot_tester_project/gde/')
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    // Remove the last component (the `gde/` part) to get the project root
    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}


// --- Public Module Exports (Faade) ---

/// Re-export for starting the **real-time status feed**.
pub use benchmarking::start_signal_inspector;

//  FIX: Add the missing pub use statements for all functions required by cli_util_menu.rs.
// Exports from godot_harness (Includes the requested launch_headless_godot).
pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

// Exports from test_core_suites.
pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
};

// Exports from test_suites.
pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};


/// Exports related to **testing and validation**.
#[allow(unused_imports)]
pub use testing::execute_testing_menu;
// --- END: rust/ssxl_cli/src\actions\mod.rs ---
        36 LOC | rust/ssxl_cli/src\actions\testing.rs
// --- START: rust/ssxl_cli/src\actions\testing.rs ---
// FILE: ssxl_cli/src/actions/testing.rs

//! # CLI Actions: Testing Utilities (`ssxl_cli::actions::testing`)
//!
//! Provides a menu for executing various test suites, delegating the complex
//! execution logic to the internal `test_suites` and external `test_core_suites` modules.

use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;      // Architectural tests
use crate::actions::test_core_suites; // External tests
use std::sync::LazyLock;              // NEW: Used for lazy, thread-safe static initialization

// --- Menu Setup Logic ---

// FIX 1 & 2: Use LazyLock to initialize the actions at runtime (solving E0015) 
// and store them in a Vec<CliAction>. The CliAction struct itself must have 
// been updated in cli_util_menu.rs to include Send + Sync bounds (solving E0277).
#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    // FIX 2: Added the "back" action which is used to exit the loop
    CliAction::new("back", " Return to Main Menu"), 
]);

/// Central entry point for all CLI testing actions.
#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    // FIX 3: Get a slice from the LazyLock Vec to satisfy CliMenu's 'a [CliAction] requirement.
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        // FIX 4: `*s == "id"` and no misplaced `Ok(())` returns are now correct.
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\testing.rs ---
        74 LOC | rust/ssxl_cli/src\actions\test_core_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_core_suites.rs ---
// FILE: ssxl_cli\src\actions\test_core_suites.rs

//! # Core Integration and External Test Suites
//!
//! Houses tests that rely on external tools like `cargo test` or involve heavy
//! I/O and process management (e.g., headless Godot execution and FFI bridge validation).

use std::process::{Command, Stdio};
use tracing::{info, error, warn};
use std::thread;
use std::io;

// Import utilities from the actions module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    GODOT_TEST_SCENE,
};


// -----------------------------------------------------------------------------
// EXTERNAL TESTING SUITES 
// -----------------------------------------------------------------------------

/// Executes the full, default `cargo test` suite for the entire workspace.
pub fn run_cargo_tests() {
    println!(" Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!(" All Rust unit and integration tests passed.");
    } else {
        error!(" Some Rust tests failed. See output above.");
    }
}


/// Runs the core integration test against a headless Godot instance to validate
/// the FFI bridge and GDExtension module loading/calls.
pub fn run_ffi_bridge_validation() {
    info!(" STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!(" Validation failed: {}", e);
            return;
        }
    };
    
    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--headless")
        .arg("--path").arg(&project_path_abs)
        .arg("--scene").arg(GODOT_TEST_SCENE)
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!(" Failed to spawn Godot process: {}", e);
            warn!("Please ensure the Godot executable is in the correct path: {}", GODOT_EXE_PATH);
            return;
        }
    };

    // --- Capture and Read Output Concurrently ---
    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || {
        io::read_to_string(stdout).unwrap_or_else(|_| "Failed to read stdout.".to_string())
    });

    let stderr_handle = thread::spawn(move || {
        io::read_to_string(stderr).unwrap_or_else(|_| "Failed to read stderr.".to_string())
    });

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!(" Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    // --- Report Results ---
    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!(" FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(" FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}", status.code());
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
// --- END: rust/ssxl_cli/src\actions\test_core_suites.rs ---
       107 LOC | rust/ssxl_cli/src\actions\test_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_suites.rs ---
// FILE: ssxl_cli\src\actions\test_suites.rs

//! # Internal Architectural and Data Validation Suites
//!
//! Contains self-contained Rust tests focused on validating internal data contracts,
//! concurrency models (channels), and core generation logic without external
//! process reliance.

use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

// --- Project Imports ---
use ssxl_generate::Generator;
use ssxl_generate::perlin_generator::PerlinGenerator;
use ssxl_math::Vec2i;
use ssxl_shared::chunk_data::CHUNK_SIZE;
use ssxl_shared::tile_data::AnimationUpdate;


// -----------------------------------------------------------------------------
// FOCUSED ARCHITECTURAL VALIDATION
// -----------------------------------------------------------------------------

/// Validates the non-blocking mpsc channels used between the Godot main thread
/// and the Rust worker threads (Generation and Animation Conductors).
pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    // 1. Create a channel pair: (CLI sends, Mock Conductor receives)
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    // 2. Spawn a thread to act as the Mock Conductor
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    // 3. CLI (main thread) floods the channel with messages
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1)); 
    }
    
    drop(cli_sender);

    // 4. Wait for the Mock Conductor thread to complete and get the result
    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!(" Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    // 5. Report results
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!(" Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!(" Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}


/// Alias for `run_communication_channel_test`. Validates data-channel functionality.
pub fn run_data_channel_test() {
    run_communication_channel_test();
}

/// Validates the core map generation logic by creating a chunk using the Perlin Generator.
pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords); 
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!(" Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!(" Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

/// Validates the data contract for the Animation Conductor by ensuring
/// the `AnimationUpdate` structure can be serialized and deserialized.
pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!(" Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!(" Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!(" Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!(" Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}
// --- END: rust/ssxl_cli/src\actions\test_suites.rs ---
       129 LOC | rust/ssxl_cli/src\cli_util_bench.rs
// --- START: rust/ssxl_cli/src\cli_util_bench.rs ---
// ssxl_cli/src/cli_util_bench.rs

//! # CLI Utilities: Benchmarking and Validation (`ssxl_cli::cli_util_bench`)
//!
//! Provides CLI-specific functions for testing core engine features and running
//! performance benchmarks, primarily focusing on world generation logic.

use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc, 
    atomic::{AtomicU64, Ordering} // AtomicU64 for thread-safe tile counting
};
use std::io::{self, Write};
use std::time::Duration;

// Imports of core engine components.
use ssxl_generate::benchmark_generation_workload; // External function that runs the actual benchmark work
use ssxl_generate::conductor::Conductor; // The main asynchronous world manager
use ssxl_math::Vec2i; // Coordinate type

// --- Test Utilities ---

/// Runs a high-level test to validate that the `Conductor` can initialize,
/// switch active generators, and successfully generate single chunks on demand.
pub fn test_generation_and_placement_cli() {
    warn!(" Running CLI Test: Generation and Placement (Conductor Validation)...");

    // Initialize the Conductor. We only need the Conductor handle for this test.
    let (mut conductor, _state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!(" Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    // Test Case 1: Perlin Noise Generator
    //  FIX: Changed "perlin_mvg" to the correct, registered ID "perlin_basic_2d"
    let perlin_id = "perlin_basic_2d";
    if conductor.set_active_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            // Synchronously request a chunk generation.
            let _chunk = conductor.generate_single_chunk(coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    // Test Case 2: Cellular Automata Generator
    let ca_id = "cellular_automata_basic";
    if conductor.set_active_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.generate_single_chunk(coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    // Final result reporting.
    if chunks_generated > 0 {
        info!(" CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).", 
            chunks_generated, 
            // NOTE: This will report the last successful generator ID.
            conductor.get_active_generator_id() 
        );
    } else {
        error!(" CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    // Clean up the Conductor's worker threads and runtime.
    conductor.graceful_teardown();
}


/// Placeholder for a utility function that converts an image file into engine bitmask data.
pub fn run_bitmask_conversion() {
    warn!(" Starting bitmask conversion from world.png (Placeholder)...");

    // Simulated result.
    let tiles_placed = 5000;
    
    info!(" Conversion complete. Tiles placed: {}", tiles_placed);
}

// --- Benchmark ---

/// Executes the Max Grid Generation Benchmark, which stresses the asynchronous
/// generation pipeline with a large, simulated workload.
pub fn run_max_grid_benchmark() {
    warn!(" Starting Max Grid Benchmark (Real Workload)...");
    
    // Define the total number of tiles the benchmark should process.
    const WORKLOAD_TILES: u64 = 100_000_000;

    // An Atomic counter shared between the workload thread and the reporting thread.
    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    // --- Workload Thread (Generates Tiles) ---
    let workload_handle = thread::spawn(move || {
        // This function blocks and increments `workload_counter_clone`.
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone); 
    });

    // --- Ticker Thread (Reports Progress) ---
    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            // Calculate progress percentage and clamp to 100%.
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            // Calculate instantaneous throughput (tiles per second).
            let throughput = if elapsed > 0.0 { 
                (current as f64 / elapsed).round() as u64 
            } else { 
                0 
            };

            // Display progress using carriage return (`\r`) to update the same line.
            print!("\r Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s", 
                percentage, 
                current / 1_000_000, // Display current in Millions
                WORKLOAD_TILES / 1_000_000, // Display total in Millions
                throughput
            );
            let _ = io::stdout().flush(); // Ensure output is immediately displayed.

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    // --- Execution & Final Reporting ---

    let start = Instant::now();
    
    // Wait for the generation workload to complete. Handle panics gracefully.
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        // Overwrite the ticker line with a failure message.
        let _ = println!("\r Benchmark failed: Generation thread panic. {: <100}", " "); 
        return; 
    }
    
    // Wait for the ticker thread to finish (it breaks its loop after the workload completes).
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    // Final summary print.
    println!("\r Benchmark complete. Workload: {} tiles. Duration: {:.2}s", 
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!(" Max Throughput: ~{} tiles/sec", throughput_sec);
        println!(" Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        // Define performance targets for status reporting.
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        // Grade the performance result.
        if throughput_sec >= ITERATION5_TARGET {
            info!(" CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!(" Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!(" Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!(" Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}
// --- END: rust/ssxl_cli/src\cli_util_bench.rs ---
       110 LOC | rust/ssxl_cli/src\cli_util_inspect.rs
// --- START: rust/ssxl_cli/src\cli_util_inspect.rs ---
//! # CLI Utilities: Inspection and Codebase Analysis (`ssxl_cli::cli_util_inspect`)
//!
//! This module provides utility functions for inspecting the structure of the SSXL-ext
//! Rust workspace and scanning the exposed Godot API surface. These tools are used
//! for development, debugging, and verification of the engine's public interface.

use walkdir::WalkDir; // Crate for iterating over directory trees
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex; // Crate for regular expressions
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;


/// Scans the SSXL-ext workspace and prints a structured, visual tree of all `.rs` files.
///
/// This provides a quick overview of the codebase structure, highlighting core files (`lib.rs`, `main.rs`).
pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("|  RUST WORKSPACE MODULE TREE (Scanning...)                           |");
	println!("=========================================================================");
	
	// List of all crate source directories in the workspace.
	// NOTE: These are relative paths assuming execution from ssxl-ext/rust/ or a subdirectory.
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
            // Walk the directory starting at a depth of 1 (excluding the root `src` folder).
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        // Check if the path is a file and ends with the .rs extension.
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            // Differentiate between core files and nested module files for visualization.
                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                " [CORE] "
                            } else {
                                "    "
                            };
                            
                            // Print the path relative to the crate's `src/` directory.
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                // Fallback if strip_prefix fails (shouldn't happen here).
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


/// Scans specific `ssxl_godot` files to extract and print function signatures
/// marked with the `#[func]` attribute, exposing the engine's public API surface.
pub fn print_godot_api_surface() {
    // Files where the Godot API methods are typically defined.
	let godot_api_files: [&str; 3] = [
        "ssxl_godot/src/ssxl_engine.rs",
        "ssxl_godot/src/ssxl_oracle.rs", // Assumed file for oracle/query functions
        "ssxl_godot/src/ssxl_signals.rs",
    ];

    println!(" API scan triggered (targeting {} files in ssxl_godot/src/)...", godot_api_files.len());
    
    // Regex to capture function signature: `pub fn method_name(args) -> return_type {`
    let fn_signature_regex = Regex::new(
        r"^\s*pub\s+fn\s+(\w+)\s*(\([^\{]*)\s*(?:->\s*([^\{]*))?\s*\{"
    ).unwrap();

    // Regex to find the Godot `#[func]` marker line.
    let func_marker_regex = Regex::new(r"^\s*#\[func\]\s*$").unwrap();

    // Vector to store (method_name, args, return_type, source_file) tuples.
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let godot_lib_path: &Path = Path::new(file_path_str);
        // Extract the filename for reporting.
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        let mut func_line_pending = false;

        match fs::read_to_string(godot_lib_path) {
            Ok(contents) => {
                info!("Successfully read {}", godot_lib_path.display());
                
                for line in contents.lines() {
                    // Step 1: Detect the #[func] marker.
                    if func_marker_regex.is_match(line) {
                        func_line_pending = true;
                        continue;
                    }

                    // Step 2: If the marker was found, check the next non-empty line for the function signature.
                    if func_line_pending {
                        if let Some(captures) = fn_signature_regex.captures(line) {
                            
                            // Capture Group 1: Method name
                            let method_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                            
                            // Capture Group 2: Arguments (including parentheses)
                            let args = captures.get(2)
                                // Clean up the argument string: remove surrounding parentheses and trim whitespace.
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            // Capture Group 3: Return type (optional). Defaults to `()` if not present.
                            let return_type = captures.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                            
                            // Store the captured method details.
                            api_methods.push((method_name, args, return_type, file_name.to_string()));
                            
                            func_line_pending = false; // Reset state after successful capture.
                        } else if !line.trim().is_empty() {
                            // If we hit a non-#[func], non-function line, reset the pending flag.
                            func_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n---  SSXL Engine Godot API Surface ---");
    if api_methods.is_empty() {
        warn!("No #[func] methods found in the targeted ssxl_godot API files. Is the Godot binding active?");
    } else {
        println!("Registered {} callable methods:", api_methods.len());
        // Print all detected API methods in a standardized format.
        for (name, args, return_type, source_file) in &api_methods {
            println!("   func {}({}) -> {} [{}]", name, args, return_type, source_file);
        }
    }
	println!("-------------------------------------------\n");

    info!("API scan complete: {} methods detected.", api_methods.len());
    // Pause briefly for dramatic effect and to ensure logging is flushed.
    thread::sleep(Duration::from_secs(2));
}

// --- END: rust/ssxl_cli/src\cli_util_inspect.rs ---
       106 LOC | rust/ssxl_cli/src\cli_util_loc.rs
// --- START: rust/ssxl_cli/src\cli_util_loc.rs ---
//! # CLI Utilities: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
//!
//! This module provides functions for scanning the SSXL-ext workspace, calculating
//! Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`) files, and
//! generating the LOC reports required by the Godot engine.

use walkdir::WalkDir;
use std::path::{PathBuf};
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// Constants for the fixed-name output file, which is read by Godot.
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
// Directory for full LOC reports, relative to the project root (../)
const LOC_REPORTS_DIR: &str = "../loc_reports";

/// Helper to count lines of code in file content, ignoring empty lines and comments (simplified).
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        // Simple check: ignore empty lines and lines starting with comment markers.
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Helper function to write the final Rust LOC total to a fixed-name file
/// for fast parsing by Godot at bootup.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level to the project root (ssxl-ext/)
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE); // Final Path: ../RUST_LOC_TOTAL.txt

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!(" SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!(" CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

/// Scans the Rust workspace, calculates lines of code (LOC), and generates
/// the full report and the final single-number LOC file.
///
/// Assumes CWD is inside the `ssxl-ext/rust/` directory.
pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // 1. Scan Rust Code
    // These paths are correct relative to the ssxl-ext/rust/ directory.
    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 2. Scan GDScript Code
    // Path traversal is correct: `ssxl-ext/rust/` -> `../ssxl_engine_tester`
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        // Note: path.display() will include the '..' but this is acceptable for internal reports.
                        let path_str = path.display().to_string();
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters (using '#' for GDScript comments)
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 3. Generate the full, dynamically-named report in the `../loc_reports/` directory
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    // Create the directory if it doesn't exist.
    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!(" Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    // Write the full report to the corrected dynamic path.
    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!(" Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!(" Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // 4. Write the single line count to the fixed-name file (RUST_LOC_TOTAL.txt)
    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}
// --- END: rust/ssxl_cli/src\cli_util_loc.rs ---
       139 LOC | rust/ssxl_cli/src\cli_util_menu.rs
// --- START: rust/ssxl_cli/src\cli_util_menu.rs ---
// ssxl_cli/src/cli_util_menu.rs

//! # CLI Utilities: Dev Console Menu (`ssxl_cli::cli_util_menu`)
//!
//! Defines the interactive main menu structure and logic for the SSXL-ext
//! developer console. It maps user-input keys to specific actions (tests,
//! benchmarks, inspection, or external tool launches).

// Imports of action functions from sibling modules within `ssxl_cli`.
use crate::actions::{
    run_cargo_tests,
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
    run_ffi_bridge_validation,
    // NEW FOCUSED TESTS
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use tracing::warn;


// --- FIX: Add missing required types and adjust visibility ---

/// FIX: Renamed from `MenuItem` to `CliAction` to resolve E0432 in testing.rs.
/// Represents a single selectable entry in the CLI menu.
pub struct CliAction {
    /// The character key the user presses to execute this item's action.
    pub key: char,
    /// The descriptive label displayed in the console menu.
    pub label: &'static str,
    /// FIX: Changing to `pub` so `testing.rs` can use pattern matching on the field.
    pub id: &'static str, // Added required `id` field based on usage in testing.rs
    /// A Boxed trait object holding the function to be executed when the item is selected.
    // FIX: Added `Send + Sync` bounds to make the type thread-safe for use in `static` or `LazyLock`.
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    // FIX: Removed `const` keyword to allow use of `Box::new` and the closure, resolving E0015.
    pub fn new(id: &'static str, label: &'static str) -> Self {
        // Note: This implementation is for `testing.rs` which uses the actions in an array.
        // It requires an action field, but here we can only define `id` and `label`.
        // The `testing.rs` file does not need the action in its array definition, 
        // so we can use a dummy action for array creation.
        // This is a common pattern when action structs are reused for different menu layers.
        CliAction { 
            key: '?', // Key is not used in the testing action list
            label, 
            id, 
            // The dummy closure must also be Send + Sync. Since it captures nothing, it is by default.
            action: Box::new(|| {}) 
        }
    }
}


/// FIX: Added `CliMenu` struct to resolve E0432 in testing.rs.
/// Represents a collection of actions for a sub-menu.
pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    // FIX: Removed `const` keyword for consistency, though this function could be const if `actions` were static.
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    // Placeholder implementation for `prompt_action`
    pub fn prompt_action(&self) -> CliAction {
        // Since this is a utility file, this placeholder satisfies the compiler.
        unimplemented!() 
    }
}

// --- Menu Construction Logic ---

/// Constructs the complete list of menu items for the developer console.
///
/// Each item is a `CliAction` struct mapping a key to a specific action function.
// FIX: Update the return type to use the new CliAction name.
pub fn build_menu() -> Vec<CliAction> {
    vec![
        // --- Core Testing & Validation (Keys 0-5) ---
        // NOTE: The `id` field is redundant for this main menu but required by the struct definition.
        CliAction { key: '0', label: " Run: Full Cargo Test Suite", id: "cargo_all", action: Box::new(run_cargo_tests) },
        CliAction { 
            key: '1', 
            label: " Validate: FFI Bridge Data Transfer (Data Integrity)", 
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction { 
            key: '2', 
            label: " Validate: Async Communication Channels (Godot <-> Rust)", 
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction { 
            key: '3', 
            label: " Validate: Chunk/Tile Data Channels (Crypto Coded)", 
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction { 
            key: '4', 
            label: " Validate: Map Generation Logic (Procedural Purity)", 
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction { 
            key: '5', 
            label: " Validate: Animation Conductor Tempo (Frame Consistency)", 
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },

        // --- External Harness & Inspection (Keys L, H, S) ---
        CliAction { 
            key: 'L', 
            label: " Launch: Godot Client (Non-Headless)", 
            id: "launch_client",
            action: Box::new(launch_godot_client) 
        },
        CliAction { 
            key: 'H', 
            label: " Launch: Headless Godot (External)", 
            id: "launch_headless",
            action: Box::new(launch_headless_godot) 
        },
        CliAction { 
            key: 'S', 
            label: " Start: Signal Inspector / Live Feed (TODO)", 
            id: "start_inspector",
            action: Box::new(start_signal_inspector) 
        },

        // --- Benchmarks & Utilities (Keys T, B, P, A, I, R) ---
        CliAction { 
            key: 'T', 
            label: " Test: Generation & Placement CLI", 
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli) 
        },
        CliAction { 
            key: 'B', 
            label: " Benchmark: Max Grid Placement", 
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark) 
        },
        CliAction { 
            key: 'P', 
            label: " Perform: Bitmask PNG Conversion", 
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion) 
        },
        CliAction { 
            key: 'A', 
            label: " Inspect: Godot-Callable API Surface", 
            id: "api_surface",
            action: Box::new(print_godot_api_surface) 
        },
        CliAction { 
            key: 'I', 
            label: " Inspect: Rust Module Tree", 
            id: "module_tree",
            action: Box::new(print_module_tree) 
        },
        CliAction { 
            key: 'R', 
            label: " Run: Trailkeeper Scan (TODO)", 
            id: "trailkeeper_scan",
            // Inline action for a simple placeholder warning.
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented.")) 
        },
        
        // --- Exit ---
        CliAction { key: 'E', label: " Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}


/// Prints the formatted menu to the console, showing the key and label for each item.
// FIX: Update the parameter type to use the new CliAction name.
pub fn print_menu(menu: &[CliAction]) {
    
    println!("\n SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}
// --- END: rust/ssxl_cli/src\cli_util_menu.rs ---
        86 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
//! # SSXL-ext CLI Developer Console (`ssxl_cli::main`)
//!
//! The main entry point for the interactive developer console. This utility manages
//! initialization, logging, the main menu loop, and delegates tasks to action modules
//! for testing, benchmarking, and external tool execution.

mod actions;               // Core functions for tests, benchmarks, and Godot interaction.
mod cli_util_inspect;      // Utilities for scanning the codebase and API surface.

// FIX: Change to `pub mod` so its types (CliAction, CliMenu) are accessible
// by other modules in the crate (like actions/testing.rs).
pub mod cli_util_menu;     // Menu structure and display logic.

mod cli_util_bench;        // Functions for running generation tests and benchmarks.
mod cli_util_loc;          // <--- CHANGE 1: Declare the new LOC utility module.

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // External FFI function to bootstrap the engine core.
use crate::cli_util_loc::scan_and_report_loc; // <--- CHANGE 2: Update the import path and function name.
use crate::actions::copy_dll_to_tester_project_at_boot; // Action to ensure the latest DLL is in the Godot project.


/// Prompts the user to press Enter before returning to the main menu.
fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    // Read a line from stdin and discard the result.
    let _ = io::stdin().read_line(&mut String::new());
}

/// Sets up the logging system and performs critical engine initialization steps.
fn init_logging_and_engine() {
    // 1. Initialize Tracing/Logging Subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout) // Direct log output to stdout.
                .with_filter(LevelFilter::INFO), // Set the minimum logging level to INFO.
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // 2. Initialize the Rust Core via FFI
    // Calls the external C-compatible function to boot the engine's core state and runtime.
    if ssxl_initialize_engine() {
        info!("Engine FFI core initialized.");
    } else {
        // We log the failure but allow the CLI to continue for non-engine tasks (like LOC scan).
        error!("Failed to initialize Engine FFI core.");
    }
    
    // 3. Copy DLL to Godot Project
    // Ensure the compiled GDExtension DLL is copied into the Godot tester project
    // before any Godot-related actions are run.
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        // This is a critical warning, as Godot interaction will fail without the DLL.
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // Perform initial setup: logging, FFI, and DLL copy.
    init_logging_and_engine();
    
    // Run a Lines of Code (LOC) scan on the codebase at startup.
    // Note: The scan function no longer takes an argument.
    scan_and_report_loc(); // <--- CHANGE 3: Update function call and remove unnecessary argument.
    
    // Print welcome ASCII art.
    println!(
        r#"
                 (__)                      
                 (oo)
           /------\/
          / |    ||
         * ||----||
            ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // Build the menu structure.
    let menu = build_menu();
    // Set for input debouncing to prevent multiple actions from a single key press hold.
    let mut last_keys = HashSet::new();

    // --- Main Interactive Console Loop ---
    loop {
        // Display the menu options.
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        // Ensure the prompt character is immediately visible.
        io::stdout().flush().unwrap();

        // Inner loop handles key polling and processing.
        loop {
            // Poll for key events with a timeout to keep the loop responsive (500ms tempo).
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase(); // Normalize input to uppercase.

                        // Input Debounce Check: Only process if the key hasn't been seen recently.
                        if last_keys.insert(c) {
                            // Find the corresponding menu item.
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                // Execute the action associated with the menu item.
                                (item.action)();

                                // Check for the exit key ('E').
                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return; // Exit the main function, terminating the CLI.
                                }

                                // Wait for user acknowledgment before returning to the main menu screen.
                                wait_for_enter();
                                // Break the inner polling loop to redraw the menu.
                                break;
                            }
                        }
                    }
                }
            } else {
                // If the poll times out, clear the debounce set, allowing a new key press to be registered.
                last_keys.clear();
            }

            // Short pause for general loop control.
            thread::sleep(Duration::from_millis(10));
        }
    }
}
// --- END: rust/ssxl_cli/src\main.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print(" Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print(" Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print(" No idle method found. Skipping ticker.")

func start_idle():
    print(" Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print(" Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print(" Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print(" SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print(" SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print(" SSXL instance missing 'enter_idle' method.")
            else:
                push_error(" Failed to instantiate SSXL script.")
        else:
            push_error(" Invalid script resource at: %s" % script_path)
    else:
        push_error(" SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print(" SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print(" SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print(" SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print(" Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print(" No idle method found. Skipping ticker.")

func start_idle():
    print(" Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print(" SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print(" SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
extends Node

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robust access)
# ----------------------------------------------------------------------

@onready var camera1: Camera2D = $camera1
@onready var camera2: Camera2D = $camera2

# ----------------------------------------------------------------------
## CONSTANTS & STATE
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1 
const MIN_ZOOM: float = 0.05 
const MAX_ZOOM: float = 10.0 

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Ensure camera nodes exist before attempting to use them
	if camera1 == null or camera2 == null:
		push_error(" Critical: Camera nodes (camera1 or camera2) not found as children.")
		return
		
	# Start by making camera1 current
	camera1.make_current()

# ----------------------------------------------------------------------
## INPUT HANDLING (Toggle, Zoom, & Pan)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	# --- 1. Camera Toggle Logic (Space/Tab) ---
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.is_action("ui_accept") or event.is_action("ui_focus_next"):
			get_viewport().set_input_as_handled()
			_toggle_camera()
			return

	# Only proceed with Mouse/Map controls if camera2 is the current active camera
	if camera2 and camera2.is_current():
		
		# --- 2. Combined Mouse Input Handling (Zoom & Pan State) ---
		if event is InputEventMouseButton:
			
			var current_zoom: Vector2 = camera2.zoom
			var new_zoom: Vector2 = current_zoom
			
			# --- A. ZOOM LOGIC (Scroll Wheel) ---
			# We only check for the press event to prevent double-processing.
			if event.is_pressed():
				if event.button_index == MOUSE_BUTTON_WHEEL_UP:
					# Zoom IN
					new_zoom -= Vector2(ZOOM_SPEED, ZOOM_SPEED)
				elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
					# Zoom OUT
					new_zoom += Vector2(ZOOM_SPEED, ZOOM_SPEED)
			
			if new_zoom != current_zoom:
				# Apply and clamp zoom
				new_zoom = new_zoom.clamp(Vector2(MIN_ZOOM, MIN_ZOOM), Vector2(MAX_ZOOM, MAX_ZOOM))
				camera2.zoom = new_zoom
				get_viewport().set_input_as_handled()
				return 
			
			# --- B. PANNING STATE LOGIC (Middle Click) ---
			if event.button_index == MOUSE_BUTTON_MIDDLE:
				is_panning = event.is_pressed()
				
				if is_panning:
					last_mouse_position = event.position
				
				get_viewport().set_input_as_handled()
				return 

		# --- 3. Camera Pan Logic (Mouse Motion) ---
		elif event is InputEventMouseMotion and is_panning:
			
			var delta: Vector2 = event.position - last_mouse_position
			
			# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
			camera2.position -= delta / camera2.zoom
			
			last_mouse_position = event.position
			get_viewport().set_input_as_handled()
			return

# ----------------------------------------------------------------------
## PUBLIC API (No functional change, uses @onready variables)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	if camera1 == null or camera2 == null:
		print(" Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print(" Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print(" Switched to Camera 2 (Map View).")
	else:
		print(" Invalid camera index passed.")

func _toggle_camera() -> void:
	if camera1 == null or camera2 == null:
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Use public API for consistency
	elif camera2.is_current():
		switch_to_camera(1) # Use public API for consistency
	else:
		# Fallback: if neither is current, default to camera1
		switch_to_camera(1)

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        79 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic extends RefCounted

##  Properties
var controller: Control
# Queue to hold incoming tile updates (flips) from the engine
var tile_flip_queue: Array = []
# Maximum number of tile updates to process per animation tick
const MAX_FLIPS_PER_TICK: int = 1000


func _init(p_controller: Control) -> void:
	# Store a reference to the main controller node
	controller = p_controller


## ANIMATION STATE CONTROL

func on_animate_checkbox_toggled(button_pressed: bool) -> void:
	"""
    Updates the controller's local animation state and sends the new mode 
    to the Rust engine via FFI to update its status.
	"""
	controller.is_animated = button_pressed
	print(" Animation Toggled: %s" % controller.is_animated)
	
	# FFI: Call the direct Rust function to set the enabled state.
	# This resolves the 'Nonexistent function 'send_animation_command'' error.
	if is_instance_valid(controller.ssxl_engine):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	# Automatically switch the polling mechanism based on the animation mode
	setup_animation_worker(button_pressed)


func setup_animation_worker(should_animate: bool) -> void:
	"""
    Starts the correct timer (throttled animation or fast engine poll)
    based on the user's animation choice.
	"""
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			# Slower tick for visual updates
			controller.animation_timer.start()
		if is_instance_valid(controller.engine_timer):
			# Stop the fast poll
			controller.engine_timer.stop()
	else:
		if is_instance_valid(controller.engine_timer):
			# Fast tick for engine polling
			controller.engine_timer.start()
		if is_instance_valid(controller.animation_timer):
			# Stop the animation loop
			controller.animation_timer.stop()


##  TIMER HANDLERS (Polling & Animation Loop)

func _on_engine_timer_timeout() -> void:
	"""
    Called by the fast (e.g., 0.01s) engine_timer when NOT animating.
    Its primary job is to poll the Rust engine for updates.
	"""
	if not controller.is_generating or not is_instance_valid(controller.ssxl_engine):
		return
	
	controller.engine_tick_count += 1
	# Manually poll the engine status
	controller.ssxl_engine.get_status()


func _on_animation_timer_timeout() -> void:
	"""
    Called by the throttled animation_timer when ANIMATING.
    Processes a batch of tile flips and updates the screen once.
	"""
	if not controller.is_generating:
		return
	
	# 1. Determine how many flips to process
	var flips_to_process: int = mini(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	if flips_to_process > 0:
		# Process the first batch of flips directly from the queue
		for i in range(flips_to_process):
			var flip_data: Array = tile_flip_queue[i]
			var tile_id: int = flip_data[0]
			var flip_frame: int = flip_data[1]
			
			process_tile_flip(tile_id, flip_frame)
			
		# Remove the processed elements from the queue using pop_front()
		for i in range(flips_to_process):
			tile_flip_queue.pop_front()


	# 2. Update Map and Poll Engine Status
	if is_instance_valid(controller.expansive_tilemap):
		# Force the TileMap to refresh with the batch of new tiles
		controller.expansive_tilemap.force_update()
	
	# Poll Engine Status (Less frequently in animation mode)
	if is_instance_valid(controller.ssxl_engine):
		controller.ssxl_engine.get_status()


##  TILE FLIP PROCESSING

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	"""Converts linear tile ID to grid coords and applies the visual flip/frame."""
	if not is_instance_valid(controller.expansive_tilemap) or not is_instance_valid(controller.grid_width):
		return

	# Use the current grid width value (which is likely a SpinBox or similar)
	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	# Convert linear tile_id back to grid coordinates (x, y)
	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	# Apply the tile flip/alternative tile index
	controller.expansive_tilemap.set_cell_alt(0, coords, flip_frame)


func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
    Signal handler connected to SSXLSignals.
    Queues the incoming tile flip data for processing on the next animation tick.
	"""
	# Only queue updates if the system is running and animation is enabled
	if not controller.is_animated or not controller.is_generating:
		return

	# Store the data in the queue immediately
	tile_flip_queue.append([tile_id, flip_frame])

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
       123 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
#  TOGGLE (UI ENTRY POINT)
# ------------------------------------------------------------------------------
func toggle_generation() -> void:
	"""
	Toggles map generation between start and stop based on the current state.
	This is the function connected directly to the 'Generate' button.
	"""
	if controller.is_generating:
		stop_generation()
	else:
		start_generation()

# ------------------------------------------------------------------------------
#  STOP GENERATION LOGIC
# ------------------------------------------------------------------------------
func stop_generation() -> void:
	print(" ControlPanel: Stop button pressed. Halting generation.")
	
	# Attempt to send a stop command to the FFI/Rust engine
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("send_stop_command"): # Refactored method name for clarity
		controller.ssxl_engine.send_stop_command()
		print(" ControlPanel: Sent explicit stop command to SSXL Engine.")
		
	# Reset state and update UI
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " Generation halted by user."
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	
	# Switch back to the Control Panel camera
	controller.utility.switch_to_camera_view(1) # Delegated to utility script
	print(" Switched to Camera 1 (Control Panel View).")


# ------------------------------------------------------------------------------
#  START GENERATION LOGIC
# ------------------------------------------------------------------------------
func start_generation() -> void:
	# Critical node checks
	if not controller.utility.check_critical_nodes():
		return # Error message handled in utility

	# Input gathering: Grid size
	var width: int = int(controller.grid_width.value) if is_instance_valid(controller.grid_width) else 0
	var height: int = int(controller.grid_height.value) if is_instance_valid(controller.grid_height) else 0
	
	# Input validation
	if width <= 0 or height <= 0:
		if is_instance_valid(controller.status_label):
			controller.status_label.text = " Invalid grid size."
		return

	# Retrieve inputs using safer, single-purpose functions
	var generator_name: String = get_selector_item_text(controller.placement_mode_selector, "perlin_basic_2d", "Generator list empty. Using default: %s")
	var tile_type_name: String = get_selector_item_text(controller.tile_type_selector, "tile_type_grass")
	var seed: int = get_and_set_seed()
		
	# State Setup
	if controller.ssxl_engine.has_method("set_generator"):
		controller.ssxl_engine.set_generator(tile_type_name)
		print(" ControlPanel: set_generator called with tile_type %s" % tile_type_name)

	controller.utility.clear_generation_state()
	controller.is_generating = true
	controller.is_animated = controller.animate_checkbox.button_pressed
	
	controller.animation_logic.setup_animation_worker(controller.is_animated)

	controller.generation_start_time_ms = Time.get_ticks_msec()
	
	# Progress Bar Setup
	var total_chunks_x: float = ceil(float(width) / controller.CHUNK_SIZE_X)
	var total_chunks_y: float = ceil(float(height) / controller.CHUNK_SIZE_Y)
	
	if is_instance_valid(controller.progress_bar):
		var total_tiles: float = total_chunks_x * total_chunks_y * controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
		controller.progress_bar.max_value = total_tiles
		controller.progress_bar.value = 0.0
		controller.progress_bar.visible = true
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " Generating map with mode: %s..." % [generator_name]
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		controller.generate_button.text = "STOP"
	
	prepopulate_map(width, height)
	controller.get_tree().process_frame

	# Camera switch to map view
	controller.utility.switch_to_camera_view(2)
	print(" Switched to Camera 2 (Map View).")

	# FFI CALL 2: Queues the task in the Rust engine
	controller.ssxl_engine.build_map(width, height, str(seed), generator_name)
	print(" ControlPanel: build_map called with seed %d and generator %s (Task Queued)" % [seed, generator_name])

	# Start the appropriate timer based on animation state
	if controller.is_animated and is_instance_valid(controller.animation_timer):
		controller.animation_timer.start()
	elif is_instance_valid(controller.engine_timer):
		controller.engine_timer.start()

# ------------------------------------------------------------------------------
#  UTILITY FUNCTIONS
# ------------------------------------------------------------------------------

func get_selector_item_text(selector: OptionButton, default_value: String, warning_message: String = "") -> String:
	"""Safely retrieves the selected item text from an OptionButton, or returns a default."""
	if not is_instance_valid(selector) or selector.get_item_count() == 0:
		if not warning_message.is_empty() and is_instance_valid(controller.status_label):
			controller.status_label.text = warning_message % default_value
		return default_value
		
	var selected_idx: int = max(0, selector.selected)
	if selected_idx < selector.get_item_count():
		return selector.get_item_text(selected_idx)
		
	return default_value # Should not happen if item_count > 0, but safe fallback

func get_and_set_seed() -> int:
	"""Retrieves the seed from input or generates a new random one, updating the UI."""
	if is_instance_valid(controller.seed_input) and controller.seed_input.text.is_valid_int():
		return int(controller.seed_input.text)
	
	var new_seed: int = randi() % 1_000_000
	if is_instance_valid(controller.seed_input):
		controller.seed_input.text = str(new_seed)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " Invalid seed. Using random seed: %d" % new_seed
	
	return new_seed

func prepopulate_map(width: int, height: int) -> void:
	"""Pre-fills the entire map with a base tile to reserve space and show bounds."""
	if not is_instance_valid(controller.expansive_tilemap):
		push_error("Cannot prepopulate: TileMap invalid.")
		return

	controller.expansive_tilemap.clear_layer(0)
	for x in range(width):
		for y in range(height):
			controller.expansive_tilemap.set_cell(0, Vector2i(x, y), controller.BASE_SOURCE_ID, controller.BASE_ATLAS_COORDS, controller.BASE_ALT_ID)
	
	# Note: force_update() is called after build_map_complete for final drawing.
	print(" ControlPanel: Map prepopulated with base tile (%d x %d)." % [width, height])


# ------------------------------------------------------------------------------
#  COMPLETION HANDLER
# ------------------------------------------------------------------------------
func _on_build_map_complete_received() -> void:
	# This function is connected directly to the ssxl_signals build_map_complete signal
	on_build_map_complete()
	
func on_build_map_complete() -> void:
	print(" Finalizing map generation.")
	
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	var elapsed_placement_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var elapsed_placement_time_sec: float = float(elapsed_placement_time_ms) / 1000.0
	
	var final_tile_count: int = controller.total_tiles_placed
	
	# Update labels
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % final_tile_count
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = " Tile Placement Time: %.2fs" % elapsed_placement_time_sec
		
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = " Final Runtime: %.2fs | Ticks: %d" % [elapsed_placement_time_sec, controller.engine_tick_count]

	# Final camera positioning and zoom (Delegate this logic to Utility)
	controller.utility.set_map_zoom_and_position()
	
	if is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	
	controller.get_tree().process_frame

	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " Generation Complete. Map built. (%d tiles)" % final_tile_count
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        46 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
class_name control_panel_signal_handler extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

##  ENGINE STATUS/ERROR SIGNALS
# 
func _on_engine_status_updated(status_message: String) -> void:
	"""Updates the status label with a general message from the engine."""
	if is_instance_valid(controller.status_label):
		# Only update the status if it's a critical or final state, 
		# allowing chunk_generated to handle progress status.
		if status_message.begins_with("ERROR:") or status_message.begins_with("IDLE:"):
			controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	"""Handles a critical error signal from the generation process."""
	print(" ERROR: Generation failed: %s" % error_message)
	
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"


##  GENERATION PROGRESS SIGNALS
func _on_build_map_start() -> void:
	"""Fired when the FFI build_map call is successfully received by the Rust engine."""
	print(" Signal: build_map_start received.")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = " Engine task started..."

func _on_chunk_generated(chunk_x: int, chunk_y: int) -> void:
	"""Updates progress bar and tile count when a chunk is processed by the engine."""
	var tiles_in_chunk: int = controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
	
	# Update Progress Bar and Tile Count
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value += float(tiles_in_chunk)
	
	controller.total_tiles_placed += tiles_in_chunk
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % controller.total_tiles_placed
	
	# Request the utility module to schedule a visual TileMap redraw (throttled)
	# This is the key to fixing the map refresh rate.
	controller.utility.request_redraw()

	# Update the status label with percentage progress
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if is_instance_valid(controller.status_label):
		# Only update status if the percentage value has changed significantly (e.g., 5%)
		if percent != controller.last_percent and (percent % 5 == 0 or percent == 100):
			controller.status_label.text = " Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent


##  ANIMATION/TILE FLIP SIGNAL
# 
func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
	Handles an individual tile flip update signal, delegating the data to the
	Animation Logic module for queueing and processing.
	"""
	if not is_instance_valid(controller.animation_logic):
		return
	
	# FIX: Delegate the flip data to the animation logic module for queueing.
	controller.animation_logic._on_tile_flip_updated(tile_id, flip_frame)

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        76 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller


# ------------------------------------------------------------------------------
##  CORE LIFECYCLE
# ------------------------------------------------------------------------------
func setup_all() -> void:
	"""Combines all setup functions for the main controller's _ready()."""
	setup_timers()
	setup_engine_links()
	setup_ui()
	connect_signals()
	print(" ControlPanel UI Setup complete.")


# ------------------------------------------------------------------------------
##  TIMER CONFIGURATION
# ------------------------------------------------------------------------------
func setup_timers() -> void:
	"""Sets up timer properties and connects timeouts to the appropriate handler."""
	
	# Engine Timer (Fast poll for non-animated generation)
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.01
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	# Animation Timer (Throttled tick for animated generation)
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	# Clock Timer
	if is_instance_valid(controller.clock_timer):
		# Connect to the Utility module for clock updates
		controller.clock_timer.timeout.connect(controller.utility.on_clock_timer_timeout)
		
	# Redraw Throttle Timer (Map Gen batch redraw)
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1


# ------------------------------------------------------------------------------
##  EXTERNAL NODE LINKING
# ------------------------------------------------------------------------------
func setup_engine_links() -> void:
	"""Passes necessary Godot node references to the SSXL engine components."""
	if is_instance_valid(controller.ssxl_engine):
		if is_instance_valid(controller.ssxl_signals) and controller.ssxl_engine.has_method("set_signals_node"):
			controller.ssxl_engine.set_signals_node(controller.ssxl_signals)
		if is_instance_valid(controller.expansive_tilemap) and controller.ssxl_engine.has_method("set_tilemap"):
			controller.ssxl_engine.set_tilemap(controller.expansive_tilemap)
	else:
		push_error(" SSXLEngine node not found.")

# ------------------------------------------------------------------------------
##  UI INITIALIZATION (Populate OptionButtons)
# ------------------------------------------------------------------------------
func setup_ui() -> void:
	"""Sets initial values and properties for core UI elements and populates selectors."""
	
	# 1. Grid Size SpinBoxes
	if is_instance_valid(controller.grid_width) and is_instance_valid(controller.grid_height):
		# Set sensible bounds and default values based on CHUNK_SIZE
		controller.grid_width.max_value = 1_000_000_000.0
		controller.grid_width.step = float(controller.CHUNK_SIZE_X)
		controller.grid_width.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		controller.grid_height.max_value = 1_000_000_000.0
		controller.grid_height.step = float(controller.CHUNK_SIZE_Y)
		controller.grid_height.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	# 2. Tile Type Selector
	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.clear()
		controller.tile_type_selector.add_item("tile_type_grass")
		controller.tile_type_selector.add_item("tile_type_water")
		controller.tile_type_selector.add_item("tile_type_mountain")
		controller.tile_type_selector.select(0)
	
	# 3. Placement Mode Selector
	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.clear()
		controller.placement_mode_selector.add_item("perlin_basic_2d")
		controller.placement_mode_selector.add_item("cellular_automata_checkerboard")
		controller.placement_mode_selector.add_item("drunkards_walk")
		controller.placement_mode_selector.add_item("maze_recursive_division")
		controller.placement_mode_selector.select(0)
		
	# 4. Status and Progress Bar
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."


# ------------------------------------------------------------------------------
##  SIGNAL CONNECTIONS
# ------------------------------------------------------------------------------
func connect_signals() -> void:
	"""Connects all UI and external engine signals to the appropriate handler functions."""
	
	# --- UI Connections (Delegated to helper scripts) ---
	if is_instance_valid(controller.generate_button):
		controller.generate_button.pressed.connect(controller.gen_logic.toggle_generation)
	
	if is_instance_valid(controller.animate_ui_button):
		controller.animate_ui_button.pressed.connect(controller.utility.toggle_camera_view)
		
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.pressed.connect(controller.utility.on_toggle_terminal_button_pressed)
		
	if is_instance_valid(controller.animate_checkbox):
		controller.animate_checkbox.toggled.connect(controller.animation_logic.on_animate_checkbox_toggled)
	
	# --- External Engine Connections (SSXLSignals Hub) ---

	if is_instance_valid(controller.ssxl_signals):
		# Signals related to map start/chunk/error go to the dedicated Signal Handler
		controller.ssxl_signals.build_map_start.connect(controller.signal_handler._on_build_map_start)
		controller.ssxl_signals.chunk_generated.connect(controller.signal_handler._on_chunk_generated)
		controller.ssxl_signals.generation_error.connect(controller.signal_handler._on_generation_error)
		
		# Completion signal connects directly to the Generation Logic to finalize the process
		controller.ssxl_signals.build_map_complete.connect(controller.gen_logic._on_build_map_complete_received)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       113 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
#  CRITICAL NODE CHECKING
# ------------------------------------------------------------------------------
func check_critical_nodes() -> bool:
	"""Checks if all core FFI and rendering nodes are present and valid."""
	var valid: bool = true
	var missing_nodes: Array[String] = []

	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false

	if not valid:
		var error_msg: String = " CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid

# ------------------------------------------------------------------------------
#  INPUT HANDLING
# ------------------------------------------------------------------------------
func handle_input_event(event: InputEvent) -> void:
	"""Handles global input events delegated from _input()."""
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.keycode == KEY_SPACE:
			# Check if any input field is focused (prevent spacebar from activating buttons)
			var is_input_focused: bool = (is_instance_valid(controller.seed_input) and controller.seed_input.has_focus()) or \
										 (is_instance_valid(controller.grid_width) and controller.grid_width.has_focus()) or \
										 (is_instance_valid(controller.grid_height) and controller.grid_height.has_focus())
			
			if not is_input_focused:
				# Spacebar toggles the camera view between UI and Map
				toggle_camera_view()
				controller.get_viewport().set_input_as_handled()
				

# ------------------------------------------------------------------------------
#  REDRAW THROTTLING
# ------------------------------------------------------------------------------
func request_redraw() -> void:
	"""
	Starts the redraw throttle timer if not already running.
	Limits TileMap updates to the timer's wait_time (e.g., 10 FPS).
	"""
	if not controller.redraw_pending and is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.start()
		controller.redraw_pending = true

func _on_redraw_throttle_timeout() -> void:
	"""Forces a TileMap update when the throttle timer times out."""
	if controller.is_generating and is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	controller.redraw_pending = false


# ------------------------------------------------------------------------------
#  CAMERA / UI TOGGLES (Delegated Logic)
# ------------------------------------------------------------------------------

func toggle_camera_view() -> void:
	"""The handler connected to the 'Animate/Toggle View' button and SPACEBAR."""
	# Toggle the current ID: 1 becomes 2, 2 becomes 1
	var new_camera_id: int = 2 if controller.current_camera_id == 1 else 1
	switch_to_camera_view(new_camera_id)

func switch_to_camera_view(target_id: int) -> void:
	"""
	Sets the camera to the target_id (1=UI, 2=Map View) and updates the controller state.
	This is called by both toggle_camera_view and gen_logic.
	"""
	if not is_instance_valid(controller.cameras) or not controller.cameras.has_method("switch_to_camera"):
		return
		
	controller.current_camera_id = target_id
	controller.cameras.switch_to_camera(controller.current_camera_id)
	print("Camera switched to: %d" % controller.current_camera_id)

func set_map_zoom_and_position() -> void:
	"""Positions the map camera (camera2) to center the generated map and calculates appropriate zoom."""
	if not is_instance_valid(controller.camera2) or not is_instance_valid(controller.grid_width) or not is_instance_valid(controller.grid_height):
		return
		
	var map_width_tiles: int = int(controller.grid_width.value)
	var map_height_tiles: int = int(controller.grid_height.value)
	
	var full_map_width: float = float(map_width_tiles) * controller.tile_size.x
	var full_map_height: float = float(map_height_tiles) * controller.tile_size.y

	# Center the camera on the map
	controller.camera2.global_position = Vector2(full_map_width / 2.0, full_map_height / 2.0)
	
	# Calculate zoom
	var viewport_size: Vector2 = controller.get_viewport_rect().size
	var zoom_factor: float = min(viewport_size.x / full_map_width, viewport_size.y / full_map_height) * 0.9
	
	controller.camera2.zoom = Vector2(clampf(zoom_factor, 0.05, 1.0), clampf(zoom_factor, 0.05, 1.0))
	controller.initial_zoom_set = true
	print("Camera 2 positioned and zoomed after generation.")


func on_toggle_terminal_button_pressed() -> void:
	"""Toggles the visibility and size of the control panel."""
	controller.panel_collapsed = !controller.panel_collapsed
	
	var target_y: float = 32.0 if controller.panel_collapsed else 300.0
	var button_text: String = "EXPAND " if controller.panel_collapsed else "COLLAPSE "
	
	# Apply changes
	controller.custom_minimum_size.y = target_y
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.text = button_text
	
	# Hide/Show all main controls when collapsed
	for child in controller.get_children():
		if child != controller.toggle_terminal_button and child is Control:
			child.visible = not controller.panel_collapsed


# ------------------------------------------------------------------------------
#  STATE MANAGEMENT & MISC UTILITIES
# ------------------------------------------------------------------------------

func on_clock_timer_timeout() -> void:
	"""Updates the clock label."""
	if is_instance_valid(controller.clock_label):
		controller.clock_label.text = " " + Time.get_datetime_string_from_system()

func reset_temporary_state() -> void:
	"""Resets generation-specific state flags and stops timers."""
	controller.is_generating = false
	controller.redraw_pending = false
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
		
	controller.engine_tick_count = 0
	
func clear_generation_state() -> void:
	"""Resets all generation-related counters and labels to zero/default."""
	reset_temporary_state() # Calls the basic reset
	
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = " Tile Placement Time: N/A"

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
# control_panel.gd
extends Control

# ------------------------------------------------------------------------------
# --- CHUNK & RENDER CONSTANTS  ---
# ------------------------------------------------------------------------------
# These constants define the dimensions used by the Rust generation logic.
const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# ------------------------------------------------------------------------------
#  UI Node & External References (DATA HUB)
# ------------------------------------------------------------------------------
# All @onready references use explicit type hints for performance and clarity.
# UI Elements
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var animate_checkbox: CheckBox = $animatecheckbox
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton

# Timers
@onready var engine_timer: Timer = $enginetimer             # Fast poll when NOT animating
@onready var animation_timer: Timer = $AnimationTimer       # Animation loop when animating
@onready var redraw_throttle_timer: Timer = $redrawthrottle # Map Gen batch redraw

# Timer Labels
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene Tree Nodes (Critical Engine References)
@onready var main: Node2D = get_parent() as Node2D
# Use NodePath strings directly in @onready where possible for robust reference initialization
@onready var ssxl_engine: Node = main.get_node("SSXLEngine")
@onready var ssxl_oracle: Node = main.get_node("SSXLOracle")
@onready var ssxl_signals: Node = main.get_node("SSXLSignals") # <-- CRITICAL FIX: Named correctly!
@onready var expansive_tilemap: TileMap = main.get_node("expansive_tilemap") as TileMap
@onready var clock_label: Label = main.get_node("tilemap/clocklabel") as Label
@onready var clock_timer: Timer = main.get_node("tilemap/clocktimer") as Timer
@onready var tilemap_node: Node2D = main.get_node("tilemap") as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var camera1: Camera2D = main.get_node("cameras/camera1") as Camera2D
@onready var camera2: Camera2D = main.get_node("cameras/camera2") as Camera2D

#  State Variables (Shared data)
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var is_animated: bool = false
var animation_tilemap_handle: TileMap = null # Initialize to null with explicit type

#  Composed Helper Scripts (Typed instantiation)
# Note: Type hints use the script resource's type for better safety
var ui_setup: control_panel_ui_setup
var gen_logic: control_panel_gen_logic
var signal_handler: control_panel_signal_handler
var animation_logic: control_panel_animation_logic
var utility: control_panel_utility


# ------------------------------------------------------------------------------
#  CORE LIFECYCLE (COORDINATION)
# ------------------------------------------------------------------------------

func _ready() -> void:
	# Use preload() for optimal, faster resource loading and type safety
	const SCRIPT_PATH = "res://root_scripts/"
	
	# 1. Instantiate Helper Scripts
	# Using preload().new() is generally faster than load().new()
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self) as control_panel_ui_setup
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self) as control_panel_gen_logic
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self) as control_panel_signal_handler
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self) as control_panel_animation_logic
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self) as control_panel_utility

	# 2. Critical Node Validation (Ensure engine and map are present)
	if not is_instance_valid(expansive_tilemap):
		push_error(" FATAL: Initialization Error: TileMap missing.")
		if is_instance_valid(status_label):
			status_label.text = " FATAL: TileMap missing."
		return

	# Validate Engine references (Crucial for GDExtension FFI)
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals):
		push_error(" FATAL: SSXLEngine or SSXLSignals GDExtension nodes missing.")
		return

	# --- 3. Delegate Initialization Tasks ---
	ui_setup.setup_all()
	
	# Final ready steps
	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	var tileset: TileSet = expansive_tilemap.get_tileset()
	if tileset:
		tile_size = tileset.get_tile_size()

	# Initialize animation state
	if is_instance_valid(animate_checkbox):
		animation_logic.on_animate_checkbox_toggled(animate_checkbox.button_pressed)

	# --- 4. Connect Engine Signals to Handlers ---
	
	# High-Frequency Signals (Animation)
	# This signal is only connected here and in ui_setup.gd (for animation checkbox)
	# The animation logic relies on the GDExtension's ability to emit high-frequency data.
	ssxl_signals.tile_flip_updated.connect(animation_logic._on_tile_flip_updated) 
	
	# Status signal: check existence before connecting (Good practice preserved)
	if ssxl_signals.has_signal("engine_status_updated"):
		ssxl_signals.engine_status_updated.connect(signal_handler._on_engine_status_updated)
	else:
		push_error(" FATAL: Engine status signal not found. Check Rust GDExtension.")


	# --- 5. Connect Timers to Logic (Separating concerns) ---
	
	# Map Generation Redraw Throttling (Map Gen Draw)
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)

	# Animation/Polling Timers (Animation Draw & Status Polling)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)
	engine_timer.timeout.connect(animation_logic._on_engine_timer_timeout)
	
	# Ensure one polling mechanism is active
	animation_logic.setup_animation_worker(is_animated)


func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)


func _process(_delta: float) -> void:
	# Process polling is handled by timers. This remains empty, prioritizing
	# asynchronous Rust conduction over synchronous _process() polling.
	pass

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        26 LOC | ../ssxl_engine_tester\root_scripts\engine_monitor.gd
# --- START: ../ssxl_engine_tester\root_scripts\engine_monitor.gd ---
extends Node

# Use the more specific Node type hint for GDExtension nodes
var engine_ref: Node = null
var status: String = "Unknown"

# Links this monitor to the SSXLEngine node and establishes signal communication.
func set_engine(engine: Node) -> void:
	# 1. Disconnect safely if a previous engine was linked
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Check if the signal is ALREADY connected before trying to disconnect
		if engine_ref.status_updated.is_connected(Callable(self, "_on_status_updated")):
			engine_ref.status_updated.disconnect(Callable(self, "_on_status_updated"))

	# 2. Set the new engine reference
	engine_ref = engine
	print(" EngineMonitor: Engine linked.")

	# 3. Connect the signal (now guaranteed to connect only once)
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Use the modern signal syntax for cleaner code
		engine_ref.status_updated.connect(_on_status_updated)
		print(" EngineMonitor: Connected to 'status_updated' signal.")
	else:
		push_warning(" EngineMonitor: Engine missing 'status_updated' signal.")


# Polls the engine for its current status (used by the engine_timer).
func update_status() -> void:
	if not is_instance_valid(engine_ref):
		push_error(" EngineMonitor: Engine not linked.")
		return

	# Check for the existence of the method (essential for FFI/GDExtension calls)
	if not engine_ref.has_method("get_status"):
		push_error(" EngineMonitor: Engine missing 'get_status' method.")
		return

	# Use call() for safety when interacting with GDExtension
	status = engine_ref.call("get_status") as String
	print(" EngineMonitor: Polled status  %s" % status)


# Handler for the status_updated signal (Asynchronous update from Rust).
func _on_status_updated(status_msg: String) -> void:
	status = status_msg
	print(" EngineMonitor: Received status  %s" % status)

# --- END: ../ssxl_engine_tester\root_scripts\engine_monitor.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

var initialized_nodes: Array = []

func initialize():
	print("\n Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	var root_node := get_tree().get_root()
	if root_node == null:
		push_error(" Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	var tester := root_node.get_node("ssxltester")
	if tester == null:
		push_error(" Init: AetherionTester node not found. No one to receive the scroll.")
		return

	print("\n Init: Scroll prepared. Delivering to SSXLTester...")
	tester.call("report_initialized", initialized_nodes)

func _recursive_initialize(node: Node) -> void:
	#print(" Init: Blessing node  %s" % node.name)
	initialized_nodes.append(node)

	for child in node.get_children():
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        38 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
extends Node2D

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robustness)
# ----------------------------------------------------------------------

# System Nodes (Children of this Main node, must match GDExtension names)
@onready var ssxl_oracle: Node = $SSXLOracle
@onready var ssxl_engine: Node = $SSXLEngine
@onready var ssxl_signals: Node = $SSXLSignals

# Global Utility Nodes (Explicitly typed for performance)
@onready var clock_timer: Timer = $/root/ssxltester/main/tilemap/clocktimer
@onready var engine_monitor: Node = $/root/ssxltester/main/EngineMonitor

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Check for critical timer node before connecting
	if is_instance_valid(clock_timer):
		# Start the primary orchestration loop
		clock_timer.timeout.connect(_on_clock_tick)
		clock_timer.start()
	else:
		push_error(" Clock timer not found. Main orchestration failed to start.")
	
	# We call this here to ensure all engine links are established immediately
	# after the clock timer is configured.
	enter_idle_state()


# Initializes the links between the Godot-side controllers and the Rust GDExtension engine.
func enter_idle_state() -> void:
	print("\n Main: Entering idle state. Systems standing by...")

	# Validate all core systems before proceeding
	if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine) and is_instance_valid(engine_monitor):
		
		# --- 1. Oracle Link (Tells the Oracle which Engine to command) ---
		print(" Linking Oracle to Engine...")
		ssxl_oracle.set_engine(ssxl_engine) 
		print(" Oracle: Engine link established.")

		# --- 2. Monitor Link (Tells the Monitor which Engine to observe) ---
		print(" Linking EngineMonitor to Engine...")
#		engine_monitor.set_engine(ssxl_engine)
		print(" EngineMonitor: Engine linked.")

		# --- 3. Signals Link (Tells the Engine which Godot Node to use for signal emission) ---
		if is_instance_valid(ssxl_signals):
			#  FIX APPLIED: Changed AetherionSignals to SSXLSignals
			print(" Connecting Engine to SSXLSignals...")
			ssxl_engine.set_signals_node(ssxl_signals) 
			
			# The Monitor-Signal connection is trusted to happen within set_engine()
			print(" EngineMonitor connected to status signal.")
		else:
			push_warning(" SSXLSignals node not found. Signal emission connection skipped.")

		# --- 4. First Pulse ---
		# The Oracle's initial tick primes the Rust system's state machine.
		print(" Oracle linked. Delivering first pulse...")
		ssxl_oracle.tick() 

		print(" Engine confirmed idle.")
	else:
		# Use push_error to make this visible in the debugger
		push_error(" Failed to link Core Systems (Oracle/Engine/Monitor). Invocation aborted.")


# ----------------------------------------------------------------------
## RUNTIME (Clock Tick)
# ----------------------------------------------------------------------

# Drives the core update loop for the engine and monitor systems.
func _on_clock_tick() -> void:
	print(" Clock tick.")

	if is_instance_valid(ssxl_oracle):
		# Tick the Oracle, which in turn commands the Rust engine
		ssxl_oracle.tick() 

	if is_instance_valid(engine_monitor):
		# Polls the engine for its current status (should be throttled or non-blocking)
#		engine_monitor.update_status()
		pass

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        20 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node
var main_node: Node2D
var initialized_nodes: Array = []

func _ready():
	#get_tree().get_root().print_tree()

	print(" SSXLTester: Summoning subsystems...")

	init_node = get_node("init")
	main_node = get_node("main")

	if init_node == null:
		push_error(" SSXLTester: Init node not found.")
		return

	if main_node == null:
		push_error(" SSXLTester: Main node not found.")
		return

	print(" SSXLTester: Launching initialization sequence...")
	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes
	print(" SSXLTester: Initialization complete. All nodes accounted for.")
	print(" SSXLTester: Delegating control to Main...")
#	main_node.call("enter_idle_state")

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        10 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

signal tree_ready(map)

func scan_tree():
	var map = {}
	_recursive_scan(get_tree().root, map)
	emit_signal("tree_ready", map)

func _recursive_scan(node: Node, map: Dictionary):
	map[node.name.to_lower()] = node.get_path()
	for child in node.get_children():
		_recursive_scan(child, map)

# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print(" FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print(" FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
       3987 LOC | *.rs (Rust Total)
       842 LOC | *.gd (GDScript Total)
       4829 LOC | TOTALS
