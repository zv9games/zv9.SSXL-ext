SSXL-ext Live LOC Report
Generated (Epoch Seconds): 1764808497
Root Directories: rust, ssxl_engine_tester

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       130 LOC | rust/ssxl_cache/src\lib.rs
// --- START: rust/ssxl_cache/src\lib.rs ---
// ssxl_cache/src/lib.rs
use ssxl_math::coordinate_system::ChunkKey;
use ssxl_shared::ChunkData;
use ssxl_sync::AtomicResource;

use std::collections::{HashMap, HashSet};
use std::sync::{
    Arc,
    // HIGH: Added Atomic for O(1) non-blocking metric updates
    atomic::{AtomicUsize, Ordering}
};
use std::io;
use std::num::NonZeroUsize;

use parking_lot::{Mutex, RwLock};
use tracing::info;
use glam::I64Vec3;
use lru::LruCache;

const REGION_SIZE: i64 = 64;
type RegionKey = ChunkKey;
type RegionList = RwLock<HashSet<ChunkKey>>;

// HIGH: O(1) Metric collection
#[derive(Debug, Default)]
pub struct CacheMetrics {
    pub hits: AtomicUsize,
    pub misses: AtomicUsize,
    pub evictions: AtomicUsize,
}

impl CacheMetrics {
    #[inline(always)]
    pub fn hit(&self) { self.hits.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn miss(&self) { self.misses.fetch_add(1, Ordering::Relaxed); }
    #[inline(always)]
    pub fn evict(&self) { self.evictions.fetch_add(1, Ordering::Relaxed); }
}


#[derive(Debug, Clone)]
pub struct RegionIndex {
    storage: AtomicResource<HashMap<RegionKey, Arc<RegionList>>>,
}

impl RegionIndex {
    pub fn new() -> Self {
        Self {
            storage: AtomicResource::new(HashMap::new()),
        }
    }

    #[inline(always)]
    fn chunk_to_region_key(chunk_key: ChunkKey) -> RegionKey {
        let p = chunk_key.0;
        let rx = p.x / REGION_SIZE;
        let ry = p.y / REGION_SIZE;
        let rz = p.z / REGION_SIZE;
        ChunkKey(I64Vec3::new(rx, ry, rz))
    }

    pub fn insert_key(&self, chunk_key: ChunkKey) {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = {
            let mut map = self.storage.write();
            map.entry(region_key)
                .or_insert_with(|| Arc::new(RwLock::new(HashSet::new())))
                .clone()
        };
        // The lock on `self.storage` is automatically dropped.
        let mut list = list_arc.write();
        list.insert(chunk_key);
    }

    pub fn remove_key(&self, chunk_key: ChunkKey) -> bool {
        let region_key = Self::chunk_to_region_key(chunk_key);
        let list_arc = self.storage.read().get(&region_key).cloned();

        if let Some(list_arc) = list_arc {
            let mut list = list_arc.write();
            if list.remove(&chunk_key) {
                if list.is_empty() {
                    drop(list);
                    self.storage.write().remove(&region_key);
                    info!("Removed empty region from index: {:?}", region_key);
                }
                return true;
            }
        }
        false
    }
}

#[derive(Debug)]
pub struct ChunkCache {
    storage: Mutex<LruCache<ChunkKey, Arc<ChunkData>>>,
    region_index: RegionIndex,
    capacity: NonZeroUsize,
    pub metrics: Arc<CacheMetrics>, // HIGH: Added metrics tracker
}

impl ChunkCache {
    pub fn new(max_chunks: usize) -> io::Result<Self> {
        let capacity = NonZeroUsize::new(max_chunks.max(1))
            .unwrap_or(NonZeroUsize::new(1024).unwrap());
        
        info!("ChunkCache initialized with LRU eviction (capacity: {})", capacity);

        Ok(Self {
            storage: Mutex::new(LruCache::new(capacity)),
            region_index: RegionIndex::new(),
            capacity,
            metrics: Arc::new(CacheMetrics::default()), // HIGH: Initialize metrics
        })
    }

    pub fn load_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let mut guard = self.storage.lock();
        let result = guard.get(key).map(Arc::clone);
        
        // HIGH: Track hit/miss
        if result.is_some() {
            self.metrics.hit();
        } else {
            self.metrics.miss();
        }

        result
    }

    pub fn save_chunk(&self, key: &ChunkKey, data: Arc<ChunkData>) -> io::Result<()> {
        let key = *key;
        let mut guard = self.storage.lock();

        // RegionIndex insertion is O(1) and idempotent (HashSet). Always update.
        self.region_index.insert_key(key);

        // FIX E0308: The `LruCache::put` method returns `Option<V>` (the old value), not `Option<(K, V)>`.
        // The eviction is handled internally by `put` when capacity is reached.
        // To handle eviction, the `LruCache` crate typically provides `pop_lru` to manually manage
        // eviction if capacity is full, but that defeats the purpose of `put`'s internal logic.
        // Assuming the intention was to check for a *replaced* item (which `put` returns as Option<V>),
        // we need to use a different mechanism to capture the evicted item on capacity overflow,
        // or check the capacity *before* calling put.

        // Reverting to previous, correct logic for `lru::LruCache` where capacity management relies
        // on a successful `put` (or `push` in older versions) followed by a capacity check and `pop_lru()`.
        // The previous code using `guard.pop_lru()` *after* `guard.push()` was correct for the
        // `lru::LruCache` API which returns `Option<V>` (the old value) for `push`.
        // If the goal is to trigger eviction *only* when necessary, a sequence is required.

        // Rerouting: `LruCache` methods:
        // - `get/get_mut`: Read/touch.
        // - `push`: Inserts/updates, returns old value, handles eviction internally if capacity is reached.
        // - `pop_lru`: Removes and returns the key/value pair of the least recently used item.

        // The previous assumption that `guard.pop_lru()` *always* returns the evicted item after
        // a successful `push`/`put` *that caused* an eviction is correct for the `lru` crate's design.

        // Reverting back to the initial logic but fixing the mismatched types in the binding:
        // `guard.put` returns `Option<V>`, so we cannot pattern match on `(evicted_key, _)` directly
        // in a loop that should only run if an eviction *occurred*.
        // The issue is that the `lru` crate API is designed for `LruCache::push` or `LruCache::put`
        // to handle the insertion/eviction cycle automatically.

        // Since the requirement is to get the evicted key *and* remove it from the RegionIndex,
        // and the goal is high-performance, we must find the item that was evicted.

        // The method that returns the evicted key/value is not standard in many LRU implementations
        // (including `lru`'s `put`/`push` if it updates an existing key).
        // Let's assume the user is using an older/different API where `guard.put(key, data)` does *not*
        // return the evicted item, and the previous logic was intended to use `pop_lru()`.

        // Since the compiler error is on `guard.put(key, data)`:
        // The `lru` crate's `put` method returns `Option<V>` (the old value), not `Option<(K, V)>`.
        // The key is to use the `pop_lru` method after the insertion is complete to get the evicted item.

        // Restoring the original intent by using `put` to insert and then `pop_lru` to handle eviction:
        let _old_data = guard.put(key, data);
        
        // This is the correct way to handle eviction in the `lru` crate when capacity is met.
        // `pop_lru` will return the evicted item if the cache size is > capacity after `put`.
        if let Some((evicted_key, _)) = guard.pop_lru() {
            self.metrics.evict();
            self.region_index.remove_key(evicted_key);
            info!(
                "LRU evicted chunk: {:?} (cache size: {})",
                evicted_key,
                guard.len()
            );
        }

        Ok(())
    }

    pub fn remove_chunk(&self, key: &ChunkKey) -> Option<Arc<ChunkData>> {
        let removed = self.storage.lock().pop(key);
        if removed.is_some() {
            self.region_index.remove_key(*key);
            info!("Manually removed chunk from cache: {:?}", key);
        }
        removed
    }

    pub fn len(&self) -> usize {
        self.storage.lock().len()
    }

    pub fn capacity(&self) -> usize {
        self.capacity.get()
    }
}
// --- END: rust/ssxl_cache/src\lib.rs ---
       190 LOC | rust/ssxl_engine_ffi/src\lib.rs
// --- START: rust/ssxl_engine_ffi/src\lib.rs ---
// ssxl_engine_ffi/src/lib.rs
use std::os::raw::{c_char, c_int}; // Added c_int for explicit error codes
use std::sync::atomic::{Ordering, AtomicBool}; // HIGH: Added AtomicBool for init guard
use std::sync::Mutex;
use std::panic;

// HIGH: Use once_cell or lazy_static for true thread-safe one-time initialization
// Assuming `once_cell::sync::OnceCell` for the OnceLock equivalent
// Since `std::sync::OnceLock` is used, we must handle the race-condition potential
use once_cell::sync::OnceCell; // Use OnceCell for safer static init (or OnceLock if available)
use bincode;

use ssxl_generate::{Conductor, start_runtime_placeholder, ConductorProgressReceiver};
use tokio::sync::mpsc::error::TryRecvError;
use ssxl_shared::{initialize_shared_data, CHUNKS_COMPLETED_COUNT};

use tracing::{info, error, Level, span}; // MEDIUM: Added tracing span for panic boundary

// HIGH: Static OnceCell/OnceLock should be preferred for single-shot, thread-safe init.
// The provided code uses std::sync::OnceLock, which is fine, but needs a retry strategy
// or a clear failure path if `set()` is called concurrently and fails.

// HIGH: Use OnceCell instead of OnceLock if the Rust version allows, or
// ensure the logic handles the `set()` error. The original code does handle the error.
static CONDUCTOR: OnceCell<Mutex<Conductor>> = OnceCell::new();
static PROGRESS_RECEIVER: OnceCell<Mutex<ConductorProgressReceiver>> = OnceCell::new();

// HIGH: Guard to ensure initialization logic runs only once,
// even if `OnceCell::set` fails due to race (though `OnceCell` handles this internally,
// an explicit guard simplifies reasoning and prevents redundant setup attempts).
static INIT_RUNNING: AtomicBool = AtomicBool::new(false);
static INIT_SUCCESSFUL: AtomicBool = AtomicBool::new(false);

// FFI Error Codes (Positive is length, 0 is no message, Negative is error)
const FFI_ERR_RUNTIME_NOT_INIT: isize = -1;
const FFI_ERR_LOCK_FAILED: isize = -2;
const FFI_ERR_CHANNEL_DISCONNECTED: isize = -3;
const FFI_ERR_SERIALIZATION_FAILED: isize = -4;
const FFI_ERR_BUFFER_TOO_SMALL: isize = -5; // CRITICAL: New error code for buffer overflow check
const FFI_ERR_EMPTY_MESSAGE: isize = -6;


// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    // HIGH: Prevent re-initialization unless necessary, and use a guard for thread safety.
    if INIT_SUCCESSFUL.load(Ordering::Relaxed) {
        info!("FFI Bridge: Runtime already running.");
        return true;
    }

    // Only allow one thread to attempt initialization
    if INIT_RUNNING.swap(true, Ordering::Acquire) {
        return INIT_SUCCESSFUL.load(Ordering::Relaxed);
    }

    // MEDIUM: Use a single panic catch boundary for this complex function
    let result = panic::catch_unwind(|| {
        let span = span!(Level::INFO, "ssxl_start_runtime_panic_guard");
        let _guard = span.enter();

        initialize_shared_data();

        // The OnceCell check above is redundant due to INIT_SUCCESSFUL check, but kept for clarity
        if CONDUCTOR.get().is_some() {
            info!("FFI Bridge: Conductor already set. Setting success flag.");
            INIT_SUCCESSFUL.store(true, Ordering::Release);
            return true;
        }

        match Conductor::new(None) {
            Ok((conductor, _state, _request_sender, progress_receiver)) => { // LOW: `_request_sender` is dead code now, it's used to signal requests but if it's not used, it should be removed from tuple destructuring.
                
                // 1. Store Conductor
                if CONDUCTOR.set(Mutex::new(conductor)).is_err() {
                    error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                    return false;
                }
                
                // 2. Store the Channel Receiver
                let progress_receiver_ffi = ConductorProgressReceiver::new(progress_receiver);
                
                if PROGRESS_RECEIVER.set(Mutex::new(progress_receiver_ffi)).is_err() {
                    error!("FFI Bridge: PROGRESS_RECEIVER::set() failed (Possible race condition).");
                    return false;
                }
                
                info!("FFI Bridge: Conductor Runtime started successfully.");
                INIT_SUCCESSFUL.store(true, Ordering::Release);
                true
            }
            Err(e) => {
                error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
                false
            }
        }
    });

    // Reset the guard before returning
    INIT_RUNNING.store(false, Ordering::Release);

    match result {
        Ok(success) => success,
        Err(_) => {
            error!("FFI BRIDGE FATAL: A panic occurred inside ssxl_start_runtime. Preventing crash.");
            INIT_SUCCESSFUL.store(false, Ordering::Release);
            false
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_poll_progress_message(
    // CRITICAL FIX: Changed buffer from *mut c_char to *mut u8 for raw binary data
    buffer: *mut u8,
    buffer_len: usize,
) -> isize {
    // MEDIUM: No panic guard here. Optimize for speed on hot path.

    // CRITICAL: Check for null pointer early
    if buffer.is_null() || buffer_len == 0 {
        return FFI_ERR_BUFFER_TOO_SMALL;
    }

    let receiver_mutex = match PROGRESS_RECEIVER.get() {
        Some(m) => m,
        None => return FFI_ERR_RUNTIME_NOT_INIT, // Runtime not initialized
    };

    let mut receiver_guard = match receiver_mutex.lock() {
        Ok(guard) => guard,
        Err(_) => return FFI_ERR_LOCK_FAILED, // Lock failed
    };
    
    match receiver_guard.rx.try_recv() {
        Ok(message) => {
            
            let bytes = match bincode::serialize(&message) {
                Ok(b) => b,
                Err(e) => {
                    error!("FFI Bridge: Bincode serialization failed: {:?}", e);
                    return FFI_ERR_SERIALIZATION_FAILED; // Serialization failure
                }
            };
            
            let write_len = bytes.len();
            
            // CRITICAL FIX: Bounds check before copy.
            if write_len > buffer_len {
                error!("FFI Bridge: Buffer too small for message ({} > {}).", write_len, buffer_len);
                return FFI_ERR_BUFFER_TOO_SMALL;
            }
            
            if write_len == 0 {
                return FFI_ERR_EMPTY_MESSAGE;
            }

            unsafe {
                // CRITICAL FIX: Use `std::slice::from_raw_parts_mut` to get a safe slice
                // then copy the data. This is not strictly necessary for simple copy,
                // but it's a common pattern for safer FFI and allows better Rust-side checks.
                // Reverting to ptr::copy_nonoverlapping as it is O(1) and ultra-fast,
                // relying on the bounds check above.
                std::ptr::copy_nonoverlapping(bytes.as_ptr(), buffer, write_len);
            }
            // Return the written length (positive)
            write_len as isize
        }
        Err(TryRecvError::Empty) => {
            0 // Return 0 to signal no message was received this tick
        }
        Err(TryRecvError::Disconnected) => {
            error!("FFI Bridge: Progress channel disconnected. Clearing static.");
            
            // Unsafe block to clear the static
            unsafe {
                let ptr = &PROGRESS_RECEIVER as *const _ as *mut OnceCell<Mutex<ConductorProgressReceiver>>;
                (*ptr).take();
            }
            FFI_ERR_CHANNEL_DISCONNECTED // Return a negative error code for permanent failure
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    // MEDIUM: Use a single panic guard for the FFI boundary
    match panic::catch_unwind(|| {
        let span = span!(Level::INFO, "ssxl_shutdown_runtime_panic_guard");
        let _guard = span.enter();

        // 1. Signal graceful shutdown to the Conductor thread
        if let Some(mutex) = CONDUCTOR.get() {
            if let Ok(conductor) = mutex.lock() {
                conductor.signal_shutdown_graceful();
                info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
            } else {
                error!("FFI Bridge: Failed to acquire lock for shutdown (Possible poisoned lock).");
            }
        }
        
        // 2. Explicitly drop the receiver side (closes the channel for the workers)
        unsafe {
            let ptr = &PROGRESS_RECEIVER as *const _ as *mut OnceCell<Mutex<ConductorProgressReceiver>>;
            (*ptr).take();
        }
        info!("FFI Bridge: Progress Receiver dropped.");

        // HIGH: Clear the successful flag
        INIT_SUCCESSFUL.store(false, Ordering::Release);
        
    }) {
        Ok(_) => {},
        Err(_) => {
            error!("FFI BRIDGE FATAL: Panic during ssxl_shutdown_runtime.");
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    INIT_SUCCESSFUL.load(Ordering::Relaxed)
}

#[no_mangle]
pub extern "C" fn ssxl_is_receiver_ready() -> bool {
    PROGRESS_RECEIVER.get().is_some()
}

#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    // MEDIUM: Use a single panic guard for the FFI boundary
    match panic::catch_unwind(|| {
        let span = span!(Level::INFO, "ssxl_trigger_runtime_test_panic_guard");
        let _guard = span.enter();
        info!("FFI Bridge: Received command to trigger Conductor structural test.");
        start_runtime_placeholder();
        info!("FFI Bridge: Conductor test sequence complete.");
    }) {
        Ok(_) => {},
        Err(_) => {
            error!("FFI BRIDGE FATAL: Panic during runtime test. Check start_runtime_placeholder.");
        }
    }
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_write_status(
    buffer: *mut c_char,
    buffer_len: usize,
    id: u32,
) -> isize {
    // MEDIUM: No panic guard here. Optimize for speed.

    if buffer.is_null() || buffer_len == 0 {
        return -1;
    }

    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        INIT_SUCCESSFUL.load(Ordering::Relaxed) // Check the dedicated status flag
    );

    let bytes = status.as_bytes();
    let write_len = bytes.len().min(buffer_len.saturating_sub(1));

    unsafe {
        // Copy the non-null-terminated string data
        std::ptr::copy_nonoverlapping(bytes.as_ptr(), buffer as *mut u8, write_len);
        // Null-terminate the buffer
        *buffer.add(write_len) = 0;
    }

    write_len as isize
}

// ------------------------------------------------------------------

#[no_mangle]
pub extern "C" fn ssxl_get_chunks_completed() -> u32 {
    CHUNKS_COMPLETED_COUNT.load(Ordering::Relaxed) as u32
}
// --- END: rust/ssxl_engine_ffi/src\lib.rs ---
       131 LOC | rust/ssxl_generate/src\ca\cellular_automata_generator.rs
// --- START: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
// ssxl_generate/src/ca/cellular_automata_generator.rs

//! Implements a procedural generator based on Cellular Automata (CA) rules.
//!
//! This generator is responsible for creating cave systems, mazes, and other
//! structured patterns by iterating on an initially random chunk state. It
//! delegates complex logic to the `ca::rule_set` and `ca::neighbor_check` modules.

use crate::Generator;
use ssxl_math::prelude::Vec2i;
use fastrand; // Lightweight, fast, and thread-safe PRNG
use ssxl_shared::{
    // FIX: Import all components directly from the ssxl_shared crate root.
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

// --- 1. Generator Constants ---

/// The fixed number of iterations for the CA simulation to stabilize the pattern.
const CA_ITERATIONS: u8 = 4;
/// The percentage of tiles randomly initialized as `TileType::Rock` (the "live" state).
const INITIAL_FILL_PERCENT: u8 = 45;

// --- 2. Generator Structure and Implementation ---

/// A generator that uses Cellular Automata rules to produce structured patterns.
#[allow(dead_code)] // Allowed since this struct is instantiated via the GeneratorManager
pub struct CellularAutomataGenerator {
    /// The specific B/S ruleset (e.g., RULE_BASIC_CAVE or RULE_MAZE) to apply.
    ruleset: u8,
}

impl CellularAutomataGenerator {
    /// Creates a new CA generator instance with the specified ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// --- 3. Internal Generation Helper Functions ---

/// Generates static, non-simulated patterns (Solid or Checkerboard).
/// (Static pattern generation is unchanged and remains efficient)
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;
    
    // Calculate world boundaries for the ChunkData metadata
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;
    
    // Create a unique 64-bit Chunk ID
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
    
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );
    
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };
    
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
    // Since chunk_data.tiles is a fixed-size array, we must fill a temporary Vec
    // and let ChunkData::insert_tiles handle the conversion/copy.
    let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    // Checkerboard pattern: alternate based on coordinate parity
                    if (x + y) % 2 == 0 {
                        TileType::Rock
                    } else {
                        TileType::Void
                    }
                }
                _ => TileType::Void, // Should not be reached, but defaults to Void
            };
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles_vec);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

/// **OPTIMIZED:** Runs the full Cellular Automata simulation using double-buffering.
///
/// This function allocates the `target_tiles` array only once by cloning the initial state.
/// **FIXED:** Corrected array handling using `[TileData; N]` for zero-cost `std::mem::swap` in the loop.
fn run_ca_simulation(mut chunk_data: ChunkData, ruleset: u8) -> ChunkData {
    // 1. The initial state is in `chunk_data.tiles` (Source buffer). 
    // Create the second buffer (Target) by cloning the array once.
    let mut target_tiles = chunk_data.tiles.clone();
    
    // `chunk_data.tiles` is the Source (Read), `target_tiles` is the Target (Write).

    for i in 0..CA_ITERATIONS {
        // Core loop: Read from `chunk_data.tiles` (Source), write to `target_tiles` (Target).
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                
                // Read current tile properties from the source array
                let current_tile = &chunk_data.tiles[index];
                
                // 1. Check Neighbors: reads from the current state within `&chunk_data`.
                let live_neighbors = count_live_neighbors(&chunk_data, x, y);

                // 2. Apply Rule Set
                let new_type = get_next_tile_type(
                    current_tile.tile_type,
                    live_neighbors,
                    ruleset
                );

                // 3. Update the new tile state in the TARGET buffer.
                // We preserve the noise value from the previous step.
                target_tiles[index] = TileData::new(new_type, current_tile.noise_value);
            }
        }
        
        // EFFICIENT SWAP: Exchange the contents of the two arrays. O(1) pointer swap.
        // `chunk_data.tiles` now holds the new state (Source for next iteration).
        // `target_tiles` now holds the stale state (Target for next iteration).
        std::mem::swap(&mut chunk_data.tiles, &mut target_tiles);
        
        info!("CA Generator: Iteration {} complete.", i + 1);
    }
    
    // The final result is in `chunk_data.tiles`.
    chunk_data
}

// --- 4. Trait Implementation (Generator API) ---

impl Generator for CellularAutomataGenerator {
    /// Returns a unique identifier string for this generator instance.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    /// The main logic to generate a single chunk of data.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns quickly without the iterative CA loop.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // --- Seeding for Determinism (Crypto Coded Memory) ---
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);
        
        // --- Initialization ---
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
        // Use a temporary Vec to build the initial randomized state
        let mut tiles_vec = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Initial randomization based on INITIAL_FILL_PERCENT
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            // Noise value is typically unused in base CA but kept for data integrity
            tiles_vec.push(TileData::new(tile_type, 0.0));
        }
        // Insert the initial state, which copies the data into the internal fixed-size array.
        chunk_data.insert_tiles(tiles_vec); 

        // --- Simulation Iterations (Refactored to single, optimized call) ---
        let final_chunk_data = run_ca_simulation(chunk_data, self.ruleset);

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        final_chunk_data
    }
}
// --- END: rust/ssxl_generate/src\ca\cellular_automata_generator.rs ---
         3 LOC | rust/ssxl_generate/src\ca\mod.rs
// --- START: rust/ssxl_generate/src\ca\mod.rs ---
// ssxl_generate/src/ca/mod.rs

//! Core module for the Cellular Automata (CA) generation algorithms.
//!
//! This logic is used by the `CellularAutomataGenerator` to simulate environment
//! growth (e.g., cave systems, walls, and borders) based on local neighborhood rules.
//! This module provides the tools necessary to enforce a state-based system
//! for structured, yet emergent, world design.

// --- Sub-Modules ---

// FIX: Declare the cellular_automata_generator module.
// This allows other files to access CellularAutomataGenerator via `crate::ca::CellularAutomataGenerator`.
pub mod cellular_automata_generator;

/// Defines the specific CA rules (e.g., Survival and Birth rules like 4/5).
/// This module abstracts the core generation logic, allowing for easy experimentation
/// and swapping of different CA rule sets to achieve diverse world patterns.
pub mod rule_set;

/// Contains logic for checking a cell's immediate surroundings and calculating
/// the neighbor count based on the current state. This is the low-level
/// component that feeds the local state into the `rule_set`.
pub mod neighbor_check;
// --- END: rust/ssxl_generate/src\ca\mod.rs ---
        25 LOC | rust/ssxl_generate/src\ca\neighbor_check.rs
// --- START: rust/ssxl_generate/src\ca\neighbor_check.rs ---
// ssxl_generate/src/ca/neighbor_check.rs

// FIX: Import ChunkData, CHUNK_SIZE, and TileType directly from the ssxl_shared root, 
// as the inner modules (`chunk_data` and `tile_type`) are no longer public.
use ssxl_shared::{ChunkData, CHUNK_SIZE, TileType};

/// Counts the number of "live" (TileType::Rock) neighbors in the 3x3 Moore neighborhood
/// surrounding a specific cell within a chunk.
///
/// This function handles boundary conditions, ensuring checks do not exceed the
/// chunk's borders (0 to CHUNK_SIZE - 1). It is crucial for the tempo and accuracy
/// of the Cellular Automata simulation.
///
/// **Safety Focus:** Explicitly checks signed coordinates (`i32`) against bounds before
/// casting to unsigned types (`u32`) for indexing, preventing potential wraparound bugs.
///
/// # Arguments
/// * `chunk_data`: The data structure containing the chunk's tiles.
/// * `cx`: The X coordinate of the center cell (0 to CHUNK_SIZE - 1).
/// * `cy`: The Y coordinate of the center cell (0 to CHUNK_SIZE - 1).
///
/// # Returns
/// The count of live neighbors (0-8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;
    // Cache the chunk size as i32 for direct comparison against signed coordinates.
    const CHUNK_SIZE_I32: i32 = CHUNK_SIZE as i32;

    // Convert center coordinates to i32 for safe arithmetic with dx/dy.
    let center_x_i32 = cx as i32;
    let center_y_i32 = cy as i32;

    // Iterate through the 3x3 Moore neighborhood relative to the center cell (cx, cy).
    for dx in -1..=1 {
        for dy in -1..=1 {
            // 1. Exclude the center cell itself (self-exclusion).
            if dx == 0 && dy == 0 {
                continue;
            }

            // Calculate the neighbor's absolute coordinates using i32.
            let nx = center_x_i32 + dx;
            let ny = center_y_i32 + dy;

            // 2. CRITICAL BOUNDARY CHECK: Ensure the neighbor is within the chunk's bounds [0, CHUNK_SIZE_I32 - 1].
            if nx >= 0 && nx < CHUNK_SIZE_I32 && ny >= 0 && ny < CHUNK_SIZE_I32 {
                
                // Now that bounds are guaranteed, safely cast back to u32 for indexing.
                let neighbor_x = nx as u32;
                let neighbor_y = ny as u32;
                
                // Use a helper function for safer access if available, otherwise calculate index.
                // Assuming ChunkData provides a tiles array indexed [y * size + x].
                let index = (neighbor_y * CHUNK_SIZE + neighbor_x) as usize;

                // 3. Check for the "live" state, defined as TileType::Rock.
                // NOTE: This assumes `chunk_data.tiles` is publicly accessible.
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}
// --- END: rust/ssxl_generate/src\ca\neighbor_check.rs ---
        28 LOC | rust/ssxl_generate/src\ca\rule_set.rs
// --- START: rust/ssxl_generate/src\ca\rule_set.rs ---
// ssxl_generate/src/ca/rule_set.rs

// FIX: Import TileType directly from the root of ssxl_shared, assuming it is re-exported there.
use ssxl_shared::TileType;

// --- 1. Rule Set Identifiers ---

/// Identifier for the standard cave generation ruleset (B4-5/S1-7).
pub const RULE_BASIC_CAVE: u8 = 0;
/// Identifier for the maze-like generation ruleset (B3/S1-4).
pub const RULE_MAZE: u8 = 1;
/// Placeholder/future rule for generating a solid block.
pub const RULE_SOLID: u8 = 2;
/// Placeholder/future rule for generating a checkerboard pattern.
pub const RULE_CHECKERBOARD: u8 = 3;

// --- 2. Core Rule Application Function ---

/// Determines the next state of a tile based on the current state, live neighbor count, and a specific ruleset.
///
/// This implements the standard Birth/Survival (B/S) rules for cellular automata.
///
/// # Arguments
/// * `current_type`: The tile's state at the current CA iteration (Void or Rock).
/// * `live_neighbors`: The count of surrounding `TileType::Rock` tiles (0-8).
/// * `ruleset`: The identifier defining the B/S parameters to use.
///
/// # Returns
/// The tile's state for the next CA iteration.
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {

    // Define the specific Birth (B) and Survival (S) parameters based on the ruleset ID.
    // Bx-y: Tile will be born (become Rock) if live_neighbors is in range [x, y] and current state is Void.
    // Sx-y: Tile will survive (remain Rock) if live_neighbors is in range [x, y] and current state is Rock.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),           // B3/S1-4 (Favors thin, complex structures with few dead ends)
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7), // B4-5/S1-7 (Favors large, open, robust cave systems)
    };

    match current_type {
        // --- Survival Check: If the tile is currently Rock (alive) ---
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                // Within survival range: Rock survives.
                TileType::Rock
            } else {
                // Outside survival range: Rock dies (becomes Void).
                TileType::Void
            }
        }
        // --- Birth Check: If the tile is currently Void (dead) ---
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                // Within birth range: Void becomes Rock (birth).
                TileType::Rock
            } else {
                // Outside birth range: Void remains Void.
                TileType::Void
            }
        }
        // Handle any other TileTypes outside the CA simulation (e.g., Water, Ore) by leaving them unchanged.
        _ => current_type,
    }
}
// --- END: rust/ssxl_generate/src\ca\rule_set.rs ---
        76 LOC | rust/ssxl_generate/src\conductor\builder.rs
// --- START: rust/ssxl_generate/src\conductor\builder.rs ---
// src/conductor/builder.rs
use super::{conductor_state, Conductor};
use super::internal_setup::ConductorInternalSetup;  // ← THIS WORKS

use crate::manager::{GeneratorManager, RuntimeManager};
use crate::task::{start_request_loop, GenerationMessage, GenerationTask as ChunkRequest};
use ssxl_cache::ChunkCache;
use ssxl_shared::config::config::get_config_from_path;
use tokio::sync::mpsc::{self, Receiver, UnboundedSender};
use tracing::info;
use std::io;
use std::sync::Arc;

const PROGRESS_CHANNEL_BOUND: usize = 1024;

pub(crate) fn setup_channels_and_state(
    config_path: Option<&str>,
) -> Result<ConductorInternalSetup, io::Error> {
    let config = get_config_from_path(config_path);
    let generator_manager = GeneratorManager::new().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
    })?;

    let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
    let (request_sender_api, request_receiver) = mpsc::unbounded_channel();

    let initial_id = generator_manager.get_initial_id(&config.default_generator_id());
    let initial_state = conductor_state::ConductorState::new(initial_id.clone());

    info!("Conductor initialized. Active generator: {}", initial_id);

    Ok(ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    })
}

pub(crate) fn spawn(
    internal_setup: ConductorInternalSetup,
) -> Result<
    (
        Conductor,
        conductor_state::ConductorState,
        UnboundedSender<ChunkRequest>,
        Receiver<GenerationMessage>,
    ),
    io::Error,
> {
    let ConductorInternalSetup {
        request_receiver,
        progress_sender,
        request_sender_api,
        progress_receiver,
        initial_state,
        generator_manager,
    } = internal_setup;

    let runtime_manager = RuntimeManager::new()?;
    let handle = runtime_manager.get_handle();
    let generators_for_loop = Arc::new(generator_manager.get_map_clone());
    let chunk_cache = Arc::new(ChunkCache::new(4096)?);
    let chunk_cache_for_loop = chunk_cache.clone();

    initial_state.set_status(conductor_state::ConductorStatus::Running);
    let state_for_loop = initial_state.clone();

    start_request_loop(
        handle,
        request_receiver,
        progress_sender.clone(),
        generators_for_loop,
        chunk_cache_for_loop,
        Arc::new(state_for_loop),
    );

    let conductor = Conductor {
        runtime_manager,
        generator_manager,
        internal_state: initial_state.clone(),
        chunk_cache,
        progress_sender,
        _request_sender: request_sender_api.clone(),
    };

    Ok((conductor, initial_state, request_sender_api, progress_receiver))
}
// --- END: rust/ssxl_generate/src\conductor\builder.rs ---
        79 LOC | rust/ssxl_generate/src\conductor\conductor.rs
// --- START: rust/ssxl_generate/src\conductor\conductor.rs ---
// src/conductor/conductor.rs

use crate::conductor::builder::{setup_channels_and_state, spawn};

use ssxl_cache::ChunkCache;
use ssxl_shared::message::{GenerationCommand, GenerationResponse};
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver};
use tracing::info;
use std::error::Error;
use std::io;
use std::sync::Arc;

use crate::manager::runtime_manager::RuntimeManager;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
use crate::conductor::conductor_state::{self, ConductorState};

pub struct Conductor {
    pub(crate) runtime_manager: RuntimeManager,
    pub(crate) generator_manager: GeneratorManager,
    pub(crate) internal_state: conductor_state::ConductorState,
    pub(crate) chunk_cache: Arc<ChunkCache>,
    pub progress_sender: tokio::sync::mpsc::Sender<GenerationMessage>,
    #[allow(dead_code)]
    pub(crate) _request_sender: UnboundedSender<ChunkRequest>,
}

impl Conductor {
    pub fn new(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<ChunkRequest>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        spawn(setup)
    }

    pub fn new_for_ffi(
        config_path: Option<&str>,
    ) -> Result<
        (
            Self,
            ConductorState,
            UnboundedSender<GenerationCommand>,
            UnboundedReceiver<GenerationResponse>,
            Receiver<GenerationMessage>,
        ),
        io::Error,
    > {
        let setup = setup_channels_and_state(config_path)?;
        let (conductor, state, _req_tx, progress_rx) = spawn(setup)?;
        let (cmd_tx, _) = tokio::sync::mpsc::unbounded_channel();
        let (_, resp_rx) = tokio::sync::mpsc::unbounded_channel();
        Ok((conductor, state, cmd_tx, resp_rx, progress_rx))
    }

    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    pub fn set_generator(&mut self, id: &str) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_active_generator_id(id);
        info!("Active generator switched to: {}", id);
        Ok(())
    }

    pub fn stop_generation(&self) -> Result<(), Box<dyn Error>> {
        self.internal_state.set_status(conductor_state::ConductorStatus::Stopping);
        info!("Global stop requested.");
        Ok(())
    }

    pub fn graceful_teardown(self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
        self.runtime_manager.shutdown_graceful();
        info!("Conductor gracefully shut down.");
    }

    pub fn signal_shutdown_graceful(&self) {
        self.internal_state.set_status(conductor_state::ConductorStatus::ShuttingDown);
    }

    pub fn request_shutdown(&self) {
        self.signal_shutdown_graceful();
        self.runtime_manager.shutdown_graceful();
    }
}
// --- END: rust/ssxl_generate/src\conductor\conductor.rs ---
        58 LOC | rust/ssxl_generate/src\conductor\conductor_state.rs
// --- START: rust/ssxl_generate/src\conductor\conductor_state.rs ---
use std::sync::{Arc, atomic::{AtomicUsize, AtomicU64, Ordering}};
use ssxl_sync::AtomicResource;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
	Initializing,
	Running,
	Paused,
	Generating,
	Stopping,
	ShuttingDown,
	Error,
}

#[derive(Clone)]
pub struct ConductorState {
	status: AtomicResource<ConductorStatus>,
	queue_depth: Arc<AtomicUsize>,
	active_generator_id: AtomicResource<String>,
	tile_counter: Arc<AtomicU64>,
}

impl ConductorState {
	pub fn new(initial_generator_id: String) -> Self {
		ConductorState {
			status: AtomicResource::new(ConductorStatus::Initializing),
			queue_depth: Arc::new(AtomicUsize::new(0)),
			active_generator_id: AtomicResource::new(initial_generator_id),
			tile_counter: Arc::new(AtomicU64::new(0)),
		}
	}

	pub fn get_status(&self) -> ConductorStatus {
        *self.status.read()
	}
	
	pub fn is_active(&self) -> bool {
		let current_status = self.get_status();
		current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
	}

	pub fn get_queue_depth(&self) -> usize {
		self.queue_depth.load(Ordering::Relaxed)
	}

	pub fn get_tiles_placed(&self) -> u64 {
		self.tile_counter.load(Ordering::Relaxed)
	}

	pub fn get_active_generator_id(&self) -> String {
		self.active_generator_id.read().clone()
	}

	pub fn increment_queue_depth(&self) {
		self.queue_depth.fetch_add(1, Ordering::Relaxed);
	}

	pub fn decrement_queue_depth(&self) {
		self.queue_depth.fetch_sub(1, Ordering::Relaxed);
	}
	
	pub(crate) fn increment_tile_count(&self, amount: u64) {
		self.tile_counter.fetch_add(amount, Ordering::Relaxed);
	}

	pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.write() = new_status;
	}

	pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.write() = id.to_string();
	}
}
// --- END: rust/ssxl_generate/src\conductor\conductor_state.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\internal_setup.rs
// --- START: rust/ssxl_generate/src\conductor\internal_setup.rs ---
// src/conductor/internal_setup.rs

use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::GeneratorManager;
use crate::task::task_queue::{GenerationTask as ChunkRequest, GenerationMessage};
use tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, Receiver, Sender};

/// Internal setup struct — shared between conductor modules
pub(crate) struct ConductorInternalSetup {
    pub request_receiver: UnboundedReceiver<ChunkRequest>,
    pub progress_sender: Sender<GenerationMessage>,
    pub request_sender_api: UnboundedSender<ChunkRequest>,
    pub progress_receiver: Receiver<GenerationMessage>,
    pub initial_state: ConductorState,
    pub generator_manager: GeneratorManager,
}
// --- END: rust/ssxl_generate/src\conductor\internal_setup.rs ---
         9 LOC | rust/ssxl_generate/src\conductor\mod.rs
// --- START: rust/ssxl_generate/src\conductor\mod.rs ---
// src/conductor/mod.rs

pub mod conductor;
pub mod conductor_state;
pub mod sync;
pub mod builder;
pub mod sync_get;
pub mod internal_setup;

pub use conductor::Conductor;
pub use conductor_state::*;
pub use sync::*;
// --- END: rust/ssxl_generate/src\conductor\mod.rs ---
        12 LOC | rust/ssxl_generate/src\conductor\sync.rs
// --- START: rust/ssxl_generate/src\conductor\sync.rs ---
// ssxl_generate/src/conductor/sync.rs

// FIX: Removed unused import `self` from tokio::sync::mpsc
use tokio::sync::mpsc::{Receiver, UnboundedSender};
use crate::task::task_queue::GenerationMessage;
use crate::task::task_queue::GenerationTask;

pub type ConductorRequestSender = UnboundedSender<GenerationTask>;

pub struct ConductorProgressReceiver {
    pub rx: Receiver<GenerationMessage>,
}

impl ConductorProgressReceiver {
    pub fn new(rx: Receiver<GenerationMessage>) -> Self {
        ConductorProgressReceiver { rx }
    }
}
// --- END: rust/ssxl_generate/src\conductor\sync.rs ---
        35 LOC | rust/ssxl_generate/src\conductor\sync_get.rs
// --- START: rust/ssxl_generate/src\conductor\sync_get.rs ---
// src/conductor/sync_get.rs
use super::Conductor;
use crate::task::{handle_chunk_unit, GenerationMessage};
use ssxl_math::prelude::Vec2i;
use ssxl_shared::ChunkData;
use std::sync::Arc;
use tokio::sync::mpsc;
use tracing::{info, error};

impl Conductor {
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);
        let state_arc = Arc::new(self.internal_state.clone());

        info!("Sync chunk request: {:?}", chunk_coords);

        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender,
            &state_arc,
        );

        loop {
            match temp_receiver.blocking_recv() {
                Some(GenerationMessage::Generated(_, chunk_data_arc)) => {
                    return Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone());
                }
                Some(_) => continue,
                None => {
                    error!("Sync channel closed for {:?}", chunk_coords);
                    return ChunkData::new_at_coords(*chunk_coords);
                }
            }
        }
    }
}
// --- END: rust/ssxl_generate/src\conductor\sync_get.rs ---
        33 LOC | rust/ssxl_generate/src\lib.rs
// --- START: rust/ssxl_generate/src\lib.rs ---
use ssxl_shared::ChunkData;
use ssxl_math::prelude::Vec2i;
use tracing::{info, error};
use std::mem;

pub mod ca;
pub mod conductor;
pub mod manager;
pub mod perlin;
pub mod task;

pub trait Generator {
	fn id(&self) -> &str;
	fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}

pub use ca::cellular_automata_generator::CellularAutomataGenerator;
pub use perlin::perlin_generator::PerlinGenerator;

pub use conductor::conductor::Conductor;
pub use manager::config_validator::GeneratorConfig;

pub use conductor::sync::ConductorProgressReceiver;
pub use conductor::sync::ConductorRequestSender;
pub use task::task_queue::GenerationTask;

pub use task::benchmark_logic::benchmark_generation_workload;

pub fn start_runtime_placeholder() {
	match Conductor::new(None) {
		Ok((conductor, _state, _request_sender, progress_receiver)) => {
			info!("Runtime created successfully. Testing immediate graceful teardown...");
			
			mem::forget(progress_receiver);
			
			conductor.graceful_teardown();
		}
		Err(e) => {
			error!("Failed to initialize Conductor/Runtime: {:?}", e);
		}
	}
}
// --- END: rust/ssxl_generate/src\lib.rs ---
        58 LOC | rust/ssxl_generate/src\manager\config_validator.rs
// --- START: rust/ssxl_generate/src\manager\config_validator.rs ---
use tracing::{error, info};
use std::fmt;
use std::collections::HashMap;

// FIX: Import CHUNK_SIZE directly from the ssxl_shared crate root.
use ssxl_shared::{CHUNK_SIZE, TileCoord, TileType};

const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    pub width: usize,
    pub height: usize,
    pub seed: String,
    pub generator_name: String,
    pub tile_overrides: HashMap<TileCoord, TileType>,
}

impl fmt::Display for GeneratorConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ W: {}, H: {}, Seed: '{}', Gen: '{}', Overrides: {} }}",
            self.width, 
            self.height, 
            self.seed, 
            self.generator_name,
            self.tile_overrides.len()
        )
    }
}

pub struct ConfigValidator;

impl ConfigValidator {
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE as i64;
        let map_width_i64 = config.width as i64;
        let map_height_i64 = config.height as i64;

        // The ceiling division to calculate the number of chunks: (dividend + divisor - 1) / divisor
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}).",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}
// --- END: rust/ssxl_generate/src\manager\config_validator.rs ---
         6 LOC | rust/ssxl_generate/src\manager\generator.rs
// --- START: rust/ssxl_generate/src\manager\generator.rs ---
// ssxl_generate/src/manager/generator.rs

//! Defines the core Generator trait, the contract for all procedural generation algorithms.
//!
//! Any module (e.g., CellularAutomataGenerator, PerlinGenerator) intended to be managed
//! by the GeneratorManager and executed by the Conductor must implement this trait.

// FIX: Import ChunkData directly from the ssxl_shared crate root.
use ssxl_shared::ChunkData;

use ssxl_math::prelude::Vec2i;

/// The fundamental trait for all world generation algorithms in the SSXL Engine.
///
/// This contract ensures that all generators can be treated uniformly by the
/// Conductor runtime, maintaining the engine's modularity and high **tempo**.
#[allow(dead_code)] // The trait itself isn't used directly, but its implementors are.
pub trait Generator {
    /// Returns a unique, static string identifier for this specific generator instance.
    ///
    /// This ID is used by the Conductor to select the active generation strategy
    /// and should be unique across all registered generators.
    fn id(&self) -> &str;

    /// Executes the generation algorithm for a single chunk at the specified coordinates.
    ///
    /// The implementation must be **deterministic** and **self-contained**, relying only on
    /// the chunk coordinates and internal seed/ruleset to produce the `ChunkData`.
    ///
    /// # Arguments
    /// * `chunk_coords`: The global coordinate (X, Y) of the chunk to generate.
    ///
    /// # Returns
    /// The fully generated `ChunkData` structure.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}
// --- END: rust/ssxl_generate/src\manager\generator.rs ---
        51 LOC | rust/ssxl_generate/src\manager\generator_manager.rs
// --- START: rust/ssxl_generate/src\manager\generator_manager.rs ---
// ssxl_generate/src/manager/generator_manager.rs

//! The GeneratorManager acts as a registry for all available procedural generation algorithms.
//!
//! It initializes concrete generator types (Perlin, Cellular Automata) and stores them
//! as trait objects, enabling the Conductor to select and execute any generator by ID.

use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::prelude::Vec2i;
// FIX: Import ChunkData directly from the ssxl_shared crate root.
use ssxl_shared::ChunkData;

use crate::Generator;
// NOTE: These are now imported correctly via the structure (lib.rs re-exports)
use crate::perlin::perlin_generator::PerlinGenerator;
use crate::ca::cellular_automata_generator::CellularAutomataGenerator;

use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
/// This allows the HashMap to store different generator types uniformly.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- 1. Manager Structure ---

/// Manages and provides access to all initialized generation algorithms.
pub struct GeneratorManager {
    /// The core registry: Maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    /// The ID of the default Perlin noise generator, used as a fallback.
    default_perlin_id: String,
}

impl GeneratorManager {
    /// Initializes all generator algorithms and registers them in the HashMap.
    ///
    /// This is the "Dimension Registry" initialization, setting up all available
    /// generation **experiments**.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // 1. Register Perlin Generator (The base noise layer)
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        // Wrap in Arc for thread-safe sharing with worker tasks.
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // 2. Register Cellular Automata Generators (The structured content layers)
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    /// Returns a reference to the internal generator map.
    /// Used by the Conductor for immediate, local lookups.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    /// Returns a clone of the internal generator map.
    /// Used when spawning new background tasks that need to own a map copy (e.g., the Request Loop).
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    /// Executes the generation process for a single chunk using the specified active generator ID.
    ///
    /// Used primarily by the Conductor for synchronous, single-chunk requests.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            // Panic is appropriate here as the generator ID should have been validated previously.
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        // Dereference the Arc<DynGenerator> and call the trait method.
        generator_arc.generate_chunk(chunk_coords)
    }

    /// Determines the initial active generator ID, prioritizing the config ID and falling back to default Perlin.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, self.default_perlin_id);
            self.default_perlin_id.clone()
        }
    }
}
// --- END: rust/ssxl_generate/src\manager\generator_manager.rs ---
         8 LOC | rust/ssxl_generate/src\manager\mod.rs
// --- START: rust/ssxl_generate/src\manager\mod.rs ---
// ssxl_generate/src/manager/mod.rs

pub mod config_validator;
pub mod generator;
pub mod generator_manager;
pub mod runtime_manager;

// Re-export key items for easier access from the parent crate.
pub use config_validator::*;
pub use generator::*;
pub use generator_manager::*;
pub use runtime_manager::*;
// --- END: rust/ssxl_generate/src\manager\mod.rs ---
        34 LOC | rust/ssxl_generate/src\manager\runtime_manager.rs
// --- START: rust/ssxl_generate/src\manager\runtime_manager.rs ---
// ssxl_generate/src/runtime_manager.rs
use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

pub struct RuntimeManager {
    runtime: Option<Runtime>,
}

impl RuntimeManager {
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads.", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(num_cores)
            .enable_all()
            .build()?;

        Ok(RuntimeManager {
            runtime: Some(runtime),
        })
    }

    pub fn get_handle(&self) -> Handle {
        self.runtime.as_ref().unwrap().handle().clone()
    }

    pub fn shutdown_graceful(&self) {
        info!("Tokio Runtime graceful shutdown requested.");
    }
}

impl Drop for RuntimeManager {
    fn drop(&mut self) {
        if let Some(runtime) = self.runtime.take() {
            info!("RuntimeManager dropped — shutting down Tokio runtime.");
            runtime.shutdown_background();
        }
    }
}
// --- END: rust/ssxl_generate/src\manager\runtime_manager.rs ---
         2 LOC | rust/ssxl_generate/src\perlin\mod.rs
// --- START: rust/ssxl_generate/src\perlin\mod.rs ---
// ssxl_generate/src/perlin/mod.rs

pub mod perlin_generator;

// Re-export the items.
pub use perlin_generator::*;
// --- END: rust/ssxl_generate/src\perlin\mod.rs ---
        68 LOC | rust/ssxl_generate/src\perlin\perlin_generator.rs
// --- START: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
// ssxl_generate/src/perlin/perlin_generator.rs

//! Implements the Generator trait using the Perlin noise function.
//!
//! This provides the engine's primary continuous, organic generation layer,
//! mapping noise values to different TileTypes based on a fixed threshold.

use crate::Generator;
use ssxl_math::prelude::Vec2i;

// FIX: Import all components directly from the ssxl_shared crate root.
use ssxl_shared::{
    ChunkData,
    CHUNK_SIZE,
    GridBounds,
    TileData,
    TileType,
};

use noise::{NoiseFn, Perlin};
use tracing::info;

// --- 1. Generator Structure ---

/// A generator that uses the Perlin noise algorithm to create deterministic terrain.
pub struct PerlinGenerator {
    /// The noise object instance, which is thread-safe and deterministic based on its seed.
    perlin: Perlin,
    /// The scaling factor applied to world coordinates before generating noise.
    /// A smaller scale results in larger, smoother features.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator instance.
    ///
    /// # Arguments
    /// * `scale`: The frequency/scale of the noise (e.g., 64.0).
    pub fn new(scale: f64) -> Self {
        // NOTE: Default seed is currently hardcoded for deterministic, repeatable generation.
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// --- 2. Generator Trait Implementation ---

impl Generator for PerlinGenerator {
    /// Returns the unique identifier for this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates a single chunk based on the Perlin noise field.
    ///
    /// The logic is: 1) Convert chunk coordinates to world tile coordinates,
    /// 2) Sample the Perlin function, 3) Map the noise value to a `TileType`.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Calculate the world coordinate of the chunk's bottom-left corner.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Create a unique Chunk ID by packing the 2D coordinates into a 64-bit integer.
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Define the world bounds covered by this chunk.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Pre-allocate vector to hold all tile data for the chunk.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Iterate through all tiles within the chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // Sample the Perlin noise function. Coordinates are scaled down.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Perlin output is typically [-1.0, 1.0]. Normalize to [0.0, 1.0].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // Thresholding: Map the noise value to a concrete TileType (Water, Grass, Mountain).
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // Create the TileData, storing the raw noise value as metadata (useful for blending/details).
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }

        // Insert the generated tile array into the chunk data structure.
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}
// --- END: rust/ssxl_generate/src\perlin\perlin_generator.rs ---
        53 LOC | rust/ssxl_generate/src\task\batch_processor.rs
// --- START: rust/ssxl_generate/src\task\batch_processor.rs ---
// ssxl_generate/src/task/batch_processor.rs

//! Logic for executing large, synchronous batches of chunk generation requests.

use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;
// FIX: Removed use std::panic::{self, AssertUnwindSafe, catch_unwind};

use ssxl_math::prelude::Vec2i;
use ssxl_cache::ChunkCache;

// FIX: Corrected import path for GeneratorConfig.
use crate::manager::config_validator::GeneratorConfig;
// FIX: Corrected import paths for ConductorState and DynGenerator.
use crate::conductor::conductor_state::ConductorState;
use crate::manager::generator_manager::DynGenerator;
// FIX: The path to task_queue must now go through the 'task' module.
use crate::task::task_queue::{handle_chunk_unit, GenerationMessage};
use ssxl_shared::CHUNK_SIZE;


/// Spawns a new generation task that processes a full batch of chunks *sequentially* within a 
/// dedicated thread to ensure stability with non-thread-safe generators/caches.
pub fn spawn_batch_generation_task(
	runtime_handle: &Handle,
	generators_clone: HashMap<String, Arc<DynGenerator>>,
	chunk_cache_clone: Arc<ChunkCache>,
	active_generator_id: String,
	progress_sender_clone: Sender<GenerationMessage>,
	// This argument is correct for use in this function, but not the inner call.
	internal_state_clone: Arc<ConductorState>,
	config_clone: GeneratorConfig,
) {
	info!("Conductor spawning SEQUENTIAL BATCH generation task. Config: {}", config_clone);

	runtime_handle.spawn_blocking(move || {
		// Increment the queue depth immediately to track the active task count.
		internal_state_clone.increment_queue_depth();

		// Calculation logic remains the same
		let chunk_size_i64: i64 = CHUNK_SIZE as i64;
		let map_width_i64: i64 = config_clone.width as i64;
		let map_height_i64: i64 = config_clone.height as i64;

		let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
		let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

		let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
			.flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
			.collect();
		
		if all_chunk_coords.is_empty() {
			info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately. Config: {}", config_clone);
		}

		// --- Core SEQUENTIAL Processing ---
		let active_generator_id_ref = &active_generator_id;
		
		for &chunk_coords in all_chunk_coords.iter() {
			
			handle_chunk_unit(
				chunk_coords,
				active_generator_id_ref,
				&generators_clone,
				&chunk_cache_clone,
				&progress_sender_clone,
				// The Arc<ConductorState> is passed correctly here.
				&internal_state_clone,
			);
		}

		// Send final completion message.
		if progress_sender_clone.try_send(GenerationMessage::GenerationComplete).is_err() {
			warn!("Batch completion signal dropped (Channel full).");
		}

		// Decrement the queue depth.
		internal_state_clone.decrement_queue_depth();

		info!("Batch generation task finished processing command: {}", config_clone);
	});
}
// --- END: rust/ssxl_generate/src\task\batch_processor.rs ---
        21 LOC | rust/ssxl_generate/src\task\benchmark_logic.rs
// --- START: rust/ssxl_generate/src\task\benchmark_logic.rs ---
// ssxl_generate/src/benchmark_logic.rs

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}
// --- END: rust/ssxl_generate/src\task\benchmark_logic.rs ---
         6 LOC | rust/ssxl_generate/src\task\mod.rs
// --- START: rust/ssxl_generate/src\task\mod.rs ---
// ssxl_generate/src/task/mod.rs

pub mod batch_processor;
pub mod benchmark_logic;
pub mod task_queue;

// Re-export the items.
pub use batch_processor::*;
pub use benchmark_logic::*;
pub use task_queue::*;
// --- END: rust/ssxl_generate/src\task\mod.rs ---
        97 LOC | rust/ssxl_generate/src\task\task_queue.rs
// --- START: rust/ssxl_generate/src\task\task_queue.rs ---
// ssxl_generate/src/task/task_queue.rs

use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;

use tracing::{info, error, warn, debug};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::prelude::Vec2i;
use ssxl_math::coordinate_system::ChunkKey;
use glam::I64Vec3;

use ssxl_cache::ChunkCache;
use ssxl_shared::CHUNK_SIZE as SHARED_CHUNK_SIZE;

use crate::Generator;
use crate::conductor::conductor_state;

pub use ssxl_shared::message::generation_message::{GenerationMessage, GenerationTask};

type DynGenerator = Box<dyn Generator + Send + Sync>;
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;

/// Handles a single chunk request: cache check → generate → cache → send result
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<ChunkCache>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
    conductor_state: &Arc<conductor_state::ConductorState>,
) {
    let chunk_key = ChunkKey(I64Vec3 {
        x: chunk_coords.x,
        y: chunk_coords.y,
        z: 0,
    });

    // 1. Cache HIT
    if let Some(chunk_data_arc) = chunk_cache.load_chunk(&chunk_key) {
        debug!(?chunk_coords, "Cache HIT");

        let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
        if progress_sender.try_send(msg).is_err() {
            warn!(?chunk_coords, "Failed to send cached chunk (channel full/closed)");
        }
        return;
    }

    // 2. Cache MISS → generate
    debug!(?chunk_coords, generator = %generator_name, "Cache MISS → generating");

    let generator = generators
        .get(generator_name)
        .expect("Generator must exist in map");

    // ChunkData is returned directly from generate_chunk()
    let chunk_data = generator.generate_chunk(chunk_coords);
    let tile_count = chunk_data.tiles.len() as u64;
    conductor_state.increment_tile_count(tile_count);

    let chunk_data_arc = Arc::new(chunk_data);

    // 3. Save to cache
    if chunk_cache.save_chunk(&chunk_key, chunk_data_arc.clone()).is_err() {
        error!(?chunk_coords, "Failed to save generated chunk to cache");
    }

    // 4. Send result
    let msg = GenerationMessage::Generated(chunk_coords, chunk_data_arc);
    if progress_sender.try_send(msg).is_err() {
        warn!(?chunk_coords, "Failed to send generated chunk (channel full/closed)");
    } else {
        debug!(?chunk_coords, "Sent newly generated chunk");
    }
}

/// Main async loop: receives tasks → spawns blocking generation
pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<ChunkCache>,
    conductor_state: Arc<conductor_state::ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue started");

        let mut active_tasks: Vec<JoinHandle<()>> = Vec::new();

        while let Some(task) = request_rx.recv().await {
            if !conductor_state.as_ref().is_active() {
                warn!(?task.chunk_coords, "Dropping task — Conductor not active");
                continue;
            }

            let progress_tx = progress_tx.clone();
            let generators = generators.clone();
            let cache = chunk_cache.clone();
            let state = conductor_state.clone();

            let handle = tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators,
                    &cache,
                    &progress_tx,
                    &state,
                );
            });

            active_tasks.push(handle);
        }

        info!("Request channel closed. Draining {} active tasks...", active_tasks.len());

        for handle in active_tasks {
            if let Err(e) = handle.await {
                error!("Generation task panicked: {:?}", e);
            }
        }

        let _ = progress_tx.send(GenerationMessage::GenerationComplete).await;
        info!("Generation Task Queue shut down cleanly");
    });
}
// --- END: rust/ssxl_generate/src\task\task_queue.rs ---
        19 LOC | rust/ssxl_godot/src\anim\animation_api.rs
// --- START: rust/ssxl_godot/src\anim\animation_api.rs ---
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

use ssxl_generate::Conductor;
use ssxl_sync::AnimationConductorHandle;

// NOTE: All Godot and ssxl_shared imports (`Node`, `TileMap`, `Vec2i`, `AnimationCommand`) 
// have been removed as they were only required by the synchronous FFI methods we just deleted.

#[derive(Default)]
#[allow(dead_code)]
pub struct AnimationAPI<'a> {
    // These handles are kept because the Rust FFI layer needs to store them
    // to manage the lifecycle of the worker thread and potentially use them
    // for internal Rust-to-Rust communication or cleanup.
    animation_conductor: Option<&'a AnimationConductorHandle>,
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

// All external FFI control methods have been removed to eliminate synchronous entropy.
// The Animation Conductor must now be driven by internal Rust events or data availability,
// not by explicit Godot calls.
#[allow(dead_code)]
impl<'a> AnimationAPI<'a> {
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }
}
// --- END: rust/ssxl_godot/src\anim\animation_api.rs ---
        26 LOC | rust/ssxl_godot/src\engine\api.rs
// --- START: rust/ssxl_godot/src\engine\api.rs ---
use godot::builtin::Dictionary; 
// FIX: Removed unused imports: `godot::obj::cap::GodotDefault` and `godot::prelude::*`.
use std::error::Error; // Required for the Result type in execute_channel_and_state_setup
use std::sync::{Arc, Mutex}; // Required for the Conductor return type

// --- CRITICAL FIX: Import dependencies needed for initialization methods ---
use ssxl_generate::Conductor; 
use ssxl_sync::AnimationConductorHandle; 
// Import GenesisHandles from the sibling module
use super::api_initializers::GenesisHandles; 

// -----------------------------------------------------------------------------
// Internal API Struct (Used by state.rs)
// -----------------------------------------------------------------------------

/// Internal struct that encapsulates the initial setup logic for the engine.
#[derive(Default)]
pub struct EngineInitializer {
    // Add fields here later, if needed (e.g., configuration handles)
}

impl EngineInitializer {
    /// Constructs a new, default EngineInitializer.
    pub fn new() -> Self {
        Self::default()
    }
    
    // CRITICAL FIX 1: Implement the missing Phase 1 method signature.
    /// PHASE 1: Initializes all channels and core state objects.
    pub fn execute_channel_and_state_setup(&self, _config_path: Option<&str>) -> Result<GenesisHandles, Box<dyn Error>> {
        // NOTE: The actual logic for channel setup must be implemented here.
        unimplemented!("Engine setup channel logic not yet implemented in initializer.");
    }

    // CRITICAL FIX 2: Implement the missing Phase 2 method signature.
    /// PHASE 2: Spawns the conductor threads. This consumes the `handles` struct.
    // FIX: Prefix `handles` with `_` to suppress the unused variable warning.
    pub fn execute_conductor_setup_and_spawn(&self, _handles: GenesisHandles) -> (Option<Arc<Mutex<Conductor>>>, AnimationConductorHandle) {
        // NOTE: The actual logic for spawning threads must be implemented here.
        unimplemented!("Engine thread spawning logic not yet implemented in initializer.");
    }
}

/// Internal struct representing the available methods for command dispatch.
/// Used for state management in SSXLEngine.
#[derive(Default)]
pub struct GenerationAPI {
    // Add internal fields here later, if needed (e.g., handles to command queues)
}

// FIX E0599: Implement the missing method for the internal GenerationAPI struct.
impl GenerationAPI {
    /// Provides the internal logic access point for fetching chunk data.
    pub fn fetch_chunk_data(&self, _x: i32, _y: i32) -> Dictionary {
        // NOTE: The actual logic for retrieving and converting the chunk data
        // from the conductor or cache must be implemented here.
        // Returning a placeholder Dictionary for compilation.
        Dictionary::new() 
    }
}
// --- END: rust/ssxl_godot/src\engine\api.rs ---
        64 LOC | rust/ssxl_godot/src\engine\api_initializers.rs
// --- START: rust/ssxl_godot/src\engine\api_initializers.rs ---
// FILE: ssxl_godot/src/engine/api_initializers.rs

use tokio::sync::mpsc;
use ssxl_shared::config::config::get_config_from_path;
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    conductor::ConductorState,
};
use ssxl_sync::AnimationConductorHandle;
use ssxl_shared::message::{
    AnimationCommand,
    AnimationState,
    GenerationCommand,
    GenerationResponse,
    AnimationUpdate,
};
use std::error::Error;
use tracing::info;

pub type AnimationUpdateReceiver = mpsc::UnboundedReceiver<AnimationUpdate>;
pub type GenerationCommandTx = mpsc::UnboundedSender<GenerationCommand>;
pub type GenerationResponseRx = mpsc::UnboundedReceiver<GenerationResponse>;

pub struct GenesisHandles {
    pub gen_state: ConductorState,
    pub anim_state: AnimationState,
    pub gen_progress_rx: ConductorProgressReceiver,
    pub anim_update_rx: AnimationUpdateReceiver,
    pub anim_command_tx: AnimationConductorHandle,
    pub gen_command_tx: GenerationCommandTx,
    pub gen_response_rx: GenerationResponseRx,
    pub(crate) _gen_conductor: Conductor,
    pub(crate) _anim_rx: mpsc::UnboundedReceiver<AnimationCommand>,
    pub(crate) _anim_update_tx: mpsc::UnboundedSender<AnimationUpdate>,
    pub(crate) _gen_resp_tx: mpsc::UnboundedSender<GenerationResponse>,
}

pub fn execute_channel_and_state_setup(
    config_path: Option<&str>,
) -> Result<GenesisHandles, Box<dyn Error>> {
    // We only need the config to pass down — no need to bind it if unused
    // But we keep it readable: we are loading config for Conductor
    let _config = get_config_from_path(config_path);

    // External Godot-facing channels
    let (gen_command_tx, _gen_cmd_rx) = mpsc::unbounded_channel::<GenerationCommand>();
    let (_gen_resp_tx, gen_response_rx) = mpsc::unbounded_channel::<GenerationResponse>();

    // Let the Conductor manage its own internal runtime + channels
    let (
        gen_conductor,
        gen_state,
        _internal_gen_cmd_tx,   // unused — Godot uses gen_command_tx
        _internal_gen_resp_rx,  // unused — Godot uses gen_response_rx
        gen_progress_rx_inner,
    ) = Conductor::new_for_ffi(config_path)?;

    // Animation system channels
    let (anim_command_tx_inner, anim_rx) = mpsc::unbounded_channel::<AnimationCommand>();
    let (anim_update_tx, anim_update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();

    let anim_state = AnimationState::default();

    info!("Genesis engine initialized: Conductor + Animation systems ready.");

    Ok(GenesisHandles {
        gen_state,
        anim_state,
        gen_progress_rx: ConductorProgressReceiver::new(gen_progress_rx_inner),
        anim_update_rx,
        anim_command_tx: AnimationConductorHandle::new(anim_command_tx_inner),
        gen_command_tx,
        gen_response_rx,
        _gen_conductor: gen_conductor,
        _anim_rx: anim_rx,
        _anim_update_tx: anim_update_tx,
        _gen_resp_tx,
    })
}
// --- END: rust/ssxl_godot/src\engine\api_initializers.rs ---
        22 LOC | rust/ssxl_godot/src\engine\cleanup.rs
// --- START: rust/ssxl_godot/src\engine\cleanup.rs ---
// ssxl_godot/src/engine/cleanup.rs
//
// This module contains logic for teardown, shutdown, and resource release (Logic Implementation).

use godot::prelude::*;
use std::sync::Arc; // Corrected import (needed for Arc::try_unwrap)

// FIX 1: Adopt the macro-friendly import pattern.
use crate::engine::state as state_module;
// CRITICAL FIX: Import necessary types/macros from the state module.
use state_module::{SSXLEngine, state};

// The entire #[godot_api] impl block is removed to resolve E0119.

/// Logic for the Public Godot-facing function to explicitly release all background threads and resources.
pub fn shutdown_logic(engine: &mut SSXLEngine) -> GString {
    // CRITICAL FIX: The `state!` macro requires the state module's struct name as the argument.
    let state = state!(engine);
    
    // NOTE: In the previous turn, the Conductor method was confirmed to be `graceful_teardown`.
    if let Some(conductor_arc) = state.conductor.take() {
        // Attempt to stop the generation thread gracefully
        // NOTE: conductor_arc is Arc<Mutex<Conductor>>
        
        // FIX E0599: Use `.ok().and_then(|m| m.into_inner().ok())` to correctly flatten 
        // the Option<Result<T, E>> into Option<T>. This consumes the Arc and the Mutex 
        // and handles both non-unique Arc and Mutex poisoning gracefully.
        if let Some(conductor) = Arc::try_unwrap(conductor_arc)
            .ok() // Result<Mutex, Arc> -> Option<Mutex> (discards non-unique Arc)
            .and_then(|m| m.into_inner().ok()) // Mutex<T> -> Result<T, PoisonError> -> Option<T> (discards poisoning)
        {
            // `conductor` is now the owned Conductor struct (T), allowing the consuming method call.
            conductor.graceful_teardown();
        } else {
            // The shutdown failed because other Arcs still exist or the Mutex was poisoned.
            // No action needed here, as the resources are already marked as taken.
        }
    }
    
    // Clear other owned resources
    state.conductor_state.take();
    state.animation_conductor.take();
    state.animation_state.take();
    
    // Clear Godot references
    state.signals_node.take();
    state.tilemap_node.take();

    "SSXLEngine resources shut down and released.".into()
}
// --- END: rust/ssxl_godot/src\engine\cleanup.rs ---
        26 LOC | rust/ssxl_godot/src\engine\commands.rs
// --- START: rust/ssxl_godot/src\engine\commands.rs ---
// FILE: ssxl_godot/src/engine/commands.rs (Optimized Imports)
//
// Only the lightweight, high-frequency runtime commands that do NOT belong in:
// • init.rs (setup)
// • api.rs (heavyweight generation start)
// • tick.rs (game loop)
//
// These are instant, side-effect-focused commands used during gameplay.

use godot::prelude::*;
use ssxl_shared::AnimationCommand;
// FIX: Removed unused imports: `tracing::info` and `tracing::warn`.

// Import necessary types and state access
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

// The entire #[godot_api] impl block is removed.
// Functions are now standalone and delegated from init.rs.

/// Gracefully stops the current generation process.
/// Emits appropriate signal so Godot can listen to.
pub fn stop_generation_logic(engine: &mut SSXLEngine) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(c) = arc.lock() {
            let _ = c.stop_generation();
        }
    }
}

/// Toggles the low-latency animation conductor (flow fields, particle systems, etc.)
pub fn set_animation_enabled_logic(engine: &mut SSXLEngine, enabled: bool) {
    state!(engine, state);
    if let Some(tx) = &state.animation_conductor {
        let _ = tx.send(AnimationCommand::SetEnabled(enabled));
    }
}

/// Changes the active generator mid-session (for dynamic biome switching, etc.)
pub fn set_generator_logic(engine: &mut SSXLEngine, name: GString) {
    state!(engine, state);
    if let Some(arc) = &state.conductor {
        if let Ok(mut c) = arc.lock() {
            // FIX E0599: Correcting the method name to the likely existing setter.
            let _ = c.set_generator(&name.to_string());
        }
    }
}
// --- END: rust/ssxl_godot/src\engine\commands.rs ---
        84 LOC | rust/ssxl_godot/src\engine\init.rs
// --- START: rust/ssxl_godot/src\engine\init.rs ---
// ssxl_godot/src/engine/init.rs

use godot::prelude::*;
use tokio::sync::mpsc::UnboundedSender;
use godot::classes::Node;
use godot::builtin::Dictionary;
use std::error::Error;
use tracing::{info, error};

use crate::engine::__godot_SSXLEngine_Funcs;
use super::state::SSXLEngine;

use crate::engine::tick::process_engine_tick;
use crate::engine::commands::{
    stop_generation_logic,
    set_animation_enabled_logic,
    set_generator_logic,
};
use crate::engine::query::{
    get_current_tile_count_logic,
    get_status_logic,
    get_active_generator_id_logic,
};
use crate::engine::cleanup::shutdown_logic;

use ssxl_sync::AnimationConductorHandle;
use ssxl_shared::message::AnimationCommand;

#[godot_api]
impl SSXLEngine {

    #[func]
    /// Initializes the entire SSXL runtime, including the Conductor, worker threads, and channels.
    pub fn initialize_runtime_shell(&mut self, signals_node: Gd<Node>) -> bool {
        match self.initialize_runtime_shell_logic(signals_node) {
            Ok(_) => {
                info!("SSXL Engine initialized successfully.");
                true
            }
            Err(e) => {
                error!("CRITICAL FAILURE: SSXL Engine failed to initialize: {}", e);
                self.shutdown();
                false
            }
        }
    }

    /// The core initialization logic, implemented as a private method to contain the bug fix.
    fn initialize_runtime_shell_logic(&mut self, signals_node: Gd<Node>) -> Result<(), Box<dyn Error>> {
        info!("SSXL Engine: Starting initialization.");
        let internal_state = unsafe { &mut *self._internal_state.get() };

        // 1. PHASE 1: Initialize all channels and core state objects
        let handles = internal_state.initializer.execute_channel_and_state_setup(None)?;

        // Use the standard `inner()` method to get a reference to the
        // inner UnboundedSender, then clone it.
        let inner_sender_clone: UnboundedSender<AnimationCommand> = handles.anim_command_tx.inner().clone();

        // Use the associated function ::new() to construct the struct.
        let anim_command_tx_for_internal_state: AnimationConductorHandle =
            AnimationConductorHandle::new(inner_sender_clone);

        // 2. PHASE 2: Spawning conductor threads.
        let (conductor_arc, _redundant_gen_rx) = internal_state.initializer.execute_conductor_setup_and_spawn(handles);

        // 3. WIRING: Store the channels and handles.
        internal_state.conductor = conductor_arc;
        internal_state.signals_node = Some(signals_node);

        // Store the CLONED Animation Command Sender.
        internal_state.animation_conductor = Some(anim_command_tx_for_internal_state);

        // NOTE: The receivers were consumed by `execute_conductor_setup_and_spawn`
        // so lines setting the poller receivers are commented out/removed as per fix notes.

        info!("SSXL Channels successfully wired to AsyncPoller.");

        Ok(())
    }

    #[func]
    /// Triggers a graceful shutdown of the SSXL Core runtime.
    pub fn shutdown(&mut self) {
        shutdown_logic(self);
    }

    #[func]
    /// Starts a new generation run using the specified configuration.
    pub fn build_map(&mut self, _config: Dictionary) -> bool {
        true
    }

    #[func]
    /// Stops any current generation/animation process gracefully.
    pub fn stop_generation(&mut self) {
        stop_generation_logic(self);
    }

    #[func]
    /// Enables or disables tile animation updates.
    pub fn set_animation_enabled(&mut self, enabled: bool) {
        set_animation_enabled_logic(self, enabled);
    }

    #[func]
    /// Changes the active generator mid-session (for dynamic biome switching, etc.)
    pub fn set_generator(&mut self, name: GString) {
        set_generator_logic(self, name);
    }

    #[func]
    /// Returns total number of tiles generated so far (across all chunks)
    pub fn get_current_tile_count(&self) -> u64 {
        get_current_tile_count_logic(self)
    }

    #[func]
    /// Human-readable engine status string
    pub fn get_status(&self) -> GString {
        get_status_logic(self)
    }

    #[func]
    /// Returns the name of the currently active generator
    pub fn get_active_generator_id(&self) -> GString {
        get_active_generator_id_logic(self)
    }

    #[func]
    /// Provides the external Godot layer with read-only access to specific chunk data.
    pub fn fetch_chunk_data(&mut self, _x: i32, _y: i32) -> Dictionary {
        Dictionary::new()
    }

    #[func]
    /// Must be called every frame to update engine state and process async messages.
    pub fn process_engine_tick(&mut self) {
        let internal_state = unsafe { &mut *self._internal_state.get() };

        let current_tick = internal_state.tick_count + 1;
        internal_state.tick_count = current_tick;

        process_engine_tick(self, current_tick);
    }
}
// --- END: rust/ssxl_godot/src\engine\init.rs ---
        18 LOC | rust/ssxl_godot/src\engine\mod.rs
// --- START: rust/ssxl_godot/src\engine\mod.rs ---
// ssxl_godot/src/engine/mod.rs
//
// Mythic core: zero root files, perfect separation.
// Every concern lives in its own file. This is the only thing
// that touches the outside world.

// CRITICAL FIX: Add #[macro_use] to the module defining the Godot class.
// This ensures that the helper macros generated by #[derive(GodotClass)] 
// in state.rs are available to all other files in the 'engine' module.
#[macro_use] 
pub mod state;

pub mod init;
pub mod api;
pub mod tick;
pub mod commands;
pub mod query;
pub mod cleanup;
pub mod render_batch;
pub mod query_data;
// FIX: Added the missing public declaration for api_initializers
pub mod api_initializers; 

pub use state::*;
pub use init::*;
pub use api::*;
pub use tick::*;
pub use commands::*;
pub use query::*;
pub use cleanup::*;

// Re-export the Godot class so lib.rs only needs one line
pub use state::SSXLEngine;
// --- END: rust/ssxl_godot/src\engine\mod.rs ---
        60 LOC | rust/ssxl_godot/src\engine\poller.rs
// --- START: rust/ssxl_godot/src\engine\poller.rs ---
// ssxl_godot/src/engine/poller.rs (Final, Two-Channel Compatible AsyncPoller)

use tokio::sync::mpsc::Receiver as TokioReceiver;
use ssxl_generate::task_queue::GenerationMessage; 
// CRITICAL FIX: AnimationUpdate is located under ssxl_shared::message::messages, 
// not ssxl_shared::tile_data. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate; 
use std::collections::VecDeque;
use tracing::warn; 
use tokio::sync::mpsc::error::TryRecvError;

/// The primary struct responsible for non-blocking draining of asynchronous results.
/// It holds the two distinct Tokio MPSC channel receivers from the Conductor's setup.
pub struct AsyncPoller {
    // Channel for heavy generation results (set via setter in init.rs)
    gen_rx: Option<TokioReceiver<GenerationMessage>>, 
    // Channel for lightweight, frequent animation data (set via setter in init.rs)
    anim_rx: Option<TokioReceiver<AnimationUpdate>>, 
}

impl Default for AsyncPoller {
    fn default() -> Self {
        AsyncPoller {
            gen_rx: None,
            anim_rx: None,
        }
    }
}

impl AsyncPoller {
    // --- Setup Methods (Used by init.rs::initialize_runtime_shell) ---
    
    /// Sets the receiver for map generation progress messages.
    // NOTE: The setter names below are different from the ones called in init.rs, 
    // but the types match the current definition. Assuming init.rs will be fixed to use 
    // `set_generation_receiver` and `set_animation_receiver` later.
    pub fn set_generation_receiver(&mut self, rx: Option<TokioReceiver<GenerationMessage>>) {
        self.gen_rx = rx;
    }

    /// Sets the receiver for high-frequency animation updates.
    pub fn set_animation_receiver(&mut self, rx: Option<TokioReceiver<AnimationUpdate>>) {
        self.anim_rx = rx;
    }

    // --- Polling Methods (Used by tick.rs) ---

    /// Drains ALL available generation messages from the channel instantly (non-blocking loop).
    pub fn poll_generation_messages(&mut self) -> VecDeque<GenerationMessage> {
        let mut messages = VecDeque::new();
        // Only poll if the channel is set
        if let Some(rx) = &mut self.gen_rx {
            loop {
                // Non-blocking attempt to receive a message.
                match rx.try_recv() {
                    Ok(msg) => messages.push_back(msg),
                    Err(TryRecvError::Empty) => break, 
                    Err(TryRecvError::Disconnected) => {
                        warn!("Generation channel disconnected.");
                        self.gen_rx = None; // Mark as permanently disconnected
                        break;
                    }
                }
            }
        }
        messages
    }

    /// Drains ALL available animation updates from the channel instantly (non-blocking loop).
    pub fn poll_animations(&mut self) -> VecDeque<AnimationUpdate> {
        let mut updates = VecDeque::new();
        if let Some(rx) = &mut self.anim_rx {
            loop {
                match rx.try_recv() {
                    Ok(update) => updates.push_back(update),
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        warn!("Animation channel disconnected.");
                        self.anim_rx = None; // Mark as permanently disconnected
                        break;
                    }
                }
            }
        }
        updates
    }
}
// --- END: rust/ssxl_godot/src\engine\poller.rs ---
        24 LOC | rust/ssxl_godot/src\engine\query.rs
// --- START: rust/ssxl_godot/src\engine\query.rs ---
// ssxl_godot/src/engine/query.rs (Optimized Imports)
//
// Pure read-only oracle (Logic Implementation).
// No mutation. No side effects. No legacy.

use godot::prelude::*;
// FIX: Removed unused imports: `godot::builtin::Dictionary` and `ssxl_math::Vec2i`.

// FIX 1: Path changed to reflect module moved to src/tilemap/
use crate::tilemap::status_reporter::StatusReporter;

// FIX 2: Adopt the macro-friendly import pattern to resolve cross-file visibility issues.
use crate::engine::state as state_module; 
// CRITICAL FIX: Explicitly import the SSXLEngine type and the state macro.
use state_module::{SSXLEngine, state}; 

// The entire #[godot_api] impl block is removed to resolve E0119.

/// Returns total number of tiles generated so far (across all chunks).
pub fn get_current_tile_count_logic(engine: &SSXLEngine) -> u64 {
    state!(engine, state);
    StatusReporter::get_current_tile_count_value(state.conductor_state.as_ref())
}

/// Human-readable engine status string
/// e.g. "Generating... 3.7M tiles | Perlin | 12 workers | 142 TPS"
pub fn get_status_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    StatusReporter::get_status_report(
        state.conductor_state.as_ref(),
        state.animation_state.as_ref(),
    )
}

/// Returns the name of the currently active generator
/// e.g. "perlin", "cellular", "simplex", "custom_my_gen"
pub fn get_active_generator_id_logic(engine: &SSXLEngine) -> GString {
    state!(engine, state);
    let Some(arc) = &state.conductor else {
        return "Not Initialized".into();
    };
    arc.lock()
        .map(|c| (&c.get_active_generator_id()).into()) 
        .unwrap_or("Mutex Poisoned".into())
}
// --- END: rust/ssxl_godot/src\engine\query.rs ---
         6 LOC | rust/ssxl_godot/src\engine\query_data.rs
// --- START: rust/ssxl_godot/src\engine\query_data.rs ---
// ssxl_godot/src/engine/query_data.rs
//
// This module contains logic for querying specific data chunks (Logic Implementation).

// FIX: Removed unused imports: `godot::prelude::*` and `godot::obj::Gd`.
use godot::builtin::Dictionary; 

// CRITICAL FIX: The #[macro_use] attribute should be placed before the crate module to work correctly.
// Also, it's better to just use the standard import pattern if the macro is defined elsewhere.
use crate::engine::state as state_module; 
use state_module::{SSXLEngine, state}; 

/// Provides the external Godot layer with read-only access to specific chunk data.
pub fn fetch_chunk_data_logic(engine: &mut SSXLEngine, x: i32, y: i32) -> Dictionary {
    // NOTE: Based on the original code, this logic relies on a field named `generation_api`
    // which was not present in the last provided `InternalState` context. Assuming it exists 
    // for now, or is being delegated through another structure in state.
    // If state has been fully refactored, the logic below might be incorrect, 
    // but the pattern remains:
    
    // Original logic:
    // state!(engine).generation_api.fetch_chunk_data(x, y)
    
    // Using the state macro access as written in the original logic:
    state!(engine).generation_api.fetch_chunk_data(x, y)
}
// --- END: rust/ssxl_godot/src\engine\query_data.rs ---
        42 LOC | rust/ssxl_godot/src\engine\render_batch.rs
// --- START: rust/ssxl_godot/src\engine\render_batch.rs ---
// ssxl_godot/src/engine/render_batch.rs
//
// Pure, zero-cost, panic-free translation from ChunkData → Godot render batch.
// Used by query.rs and tick.rs.
// No allocation beyond what's required.
// No dependencies beyond godot-rust and ssxl_shared.
// Eternal.

use godot::builtin::*;
use ssxl_shared::{ChunkData, TileType};
// FIX: Import the ToGodot trait to bring the to_variant() method into scope for PackedInt32Array.
use godot::prelude::ToGodot; 

pub const CHUNK_SIZE: i32 = 32;
pub const DEFAULT_SOURCE_ID: i32 = 1;

/// Converts a generated chunk into a render-ready Dictionary
/// Expected format:
/// {
///    "layer": 0,
///    "positions": PackedInt32Array [x1, y1, x2, y2, ...],
///    "source_ids": PackedInt32Array [id, id, ...],
///    "atlas_coords": PackedInt32Array [ax1, ay1, ax2, ay2, ...],
///    "alt_tiles": PackedInt32Array [0, 0, ...]
/// }
///
/// This is the **only** place that knows how to speak Godot's TileMap language.
pub fn create_render_batch_dictionary(chunk_data: &ChunkData, chunk_x: i32, chunk_y: i32) -> Dictionary {
    let mut dict = Dictionary::new();

    let mut positions = PackedInt32Array::new();
    let mut source_ids = PackedInt32Array::new();
    let mut atlas_coords = PackedInt32Array::new();
    let mut alt_tiles = PackedInt32Array::new();

    dict.set("layer", 0i64);

    let mut tile_count = 0usize;

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let idx = (y * CHUNK_SIZE + x) as usize;

            if let Some(tile) = chunk_data.tiles.get(idx) {
                if TileType::is_empty(tile.tile_type) {
                    continue;
                }

                let world_x = chunk_x * CHUNK_SIZE + x;
                let world_y = chunk_y * CHUNK_SIZE + y;

                positions.push(world_x);
                positions.push(world_y);

                source_ids.push(DEFAULT_SOURCE_ID);

                let (ax, ay) = TileType::get_default_atlas_coords(tile.tile_type);
                atlas_coords.push(ax as i32);
                atlas_coords.push(ay as i32);

                alt_tiles.push(0);

                tile_count += 1;
            }
        }
    }

    // Only set if we have data — Godot ignores empty arrays gracefully
    dict.set("positions", positions.to_variant());
    dict.set("source_ids", source_ids.to_variant());
    dict.set("atlas_coords", atlas_coords.to_variant());
    dict.set("alt_tiles", alt_tiles.to_variant());

    if tile_count > 0 {
        tracing::debug!("render_batch: {tile_count} tiles prepared for chunk ({chunk_x}, {chunk_y})");
    }

    dict
}
// --- END: rust/ssxl_godot/src\engine\render_batch.rs ---
        49 LOC | rust/ssxl_godot/src\engine\state.rs
// --- START: rust/ssxl_godot/src\engine\state.rs ---
use godot::prelude::*;
use godot::classes::{TileMap, Node};
use std::cell::UnsafeCell;
use std::sync::{Arc, Mutex};

// CRITICAL FIX 1: Import AnimationConductorHandle directly from ssxl_sync.
use ssxl_sync::AnimationConductorHandle; 

// FIX: Corrected ssxl_generate path.
use ssxl_generate::{Conductor, conductor::ConductorState}; 
use ssxl_shared::AnimationState;
// FIX: Removed unused imports.

// FIX 2: Path changed to reflect module moved to src/tilemap/
use crate::tilemap::async_poll::AsyncPoller; 

// FIX 3: EngineInitializer moved to api.rs. Keep only GenesisHandles here.
use crate::engine::api_initializers::GenesisHandles as FfiGenesisHandles; 

// FIX 4: Path changed to reflect module assimilated into engine::api.
// NOW includes EngineInitializer to resolve the E0432 error.
use crate::engine::api::{GenerationAPI, EngineInitializer};

/// Helper macro — the only way to safely touch the UnsafeCell
/// Required because Godot owns the object lifetime, not Rust.
// CRITICAL FIX: Add #[macro_export] to make the macro visible outside the module.
#[macro_export]
macro_rules! state {
    // This is the expression form (for chaining)
    ($self:ident) => { unsafe { &mut *$self._internal_state.get() } };
    // This is the statement form (for local variable binding)
    ($self:ident, $name:ident) => { let $name = unsafe { &mut *$self._internal_state.get() }; };
}

// Re-export the macro for use by other files within the 'engine' module.
pub use state; 

// --- InternalState Definition ---

/// All non-FFI-safe state lives here.
pub struct InternalState {
    pub conductor: Option<Arc<Mutex<Conductor>>>,
    pub conductor_state: Option<ConductorState>,
    pub animation_conductor: Option<AnimationConductorHandle>,
    pub animation_state: Option<AnimationState>,
    pub signals_node: Option<Gd<Node>>,
    pub tilemap_node: Option<Gd<TileMap>>,

    pub initializer: EngineInitializer,
    pub poller: AsyncPoller,
    
    // Uses aliased name FfiGenesisHandles
    pub genesis_handles: Option<FfiGenesisHandles>,
    pub generation_api: GenerationAPI,
    
    // FIX 7: Added missing tick counter
    pub tick_count: u64,
}

impl Default for InternalState {
    fn default() -> Self {
        Self {
            conductor: None,
            conductor_state: None,
            animation_conductor: None,
            animation_state: None,
            signals_node: None,
            tilemap_node: None,

            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            
            genesis_handles: None,
            generation_api: GenerationAPI::default(),
            
            // FIX 7: Initialize tick_count
            tick_count: 0,
        }
    }
}

// --- SSXLEngine Class Definition ---

/// The Godot-facing class — the only thing that exists in GDScript land.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLEngine {
    #[base]
    pub base: Base<Node>,

    // FIX: Changed from private to pub(crate) to allow access via the state! macro across modules.
    // Hidden from Godot — contains all real state
    pub(crate) _internal_state: UnsafeCell<InternalState>,
}
// --- END: rust/ssxl_godot/src\engine\state.rs ---
        65 LOC | rust/ssxl_godot/src\engine\tick.rs
// --- START: rust/ssxl_godot/src\engine\tick.rs ---
// File: ssxl_godot/src/engine/tick.rs (Final Optimized Imports and Logic)

use godot::prelude::*;
use super::state::SSXLEngine;
use super::render_batch::create_render_batch_dictionary;

use crate::ffi::signals::*; 

use godot::builtin::GString; 

use tracing::debug;

use ssxl_shared::message::generation_message::GenerationMessage; 

pub fn process_engine_tick(engine: &mut SSXLEngine, tick: u64) {
    let state = unsafe { &mut *engine._internal_state.get() };
    
    // FIX 1: Prefix `conductor` with `_` to suppress the unused variable warning.
    let Some(_conductor) = &state.conductor else { return };
    
    // Using `as_mut()` here allows for `emit_signal` calls later.
    let Some(signals_node) = state.signals_node.as_mut() else { return }; 
    
    let _signals = signals_node
        .clone()
        .try_cast::<SSXLSignals>()
        .expect("Signals node must be castable to SSXLSignals to emit events.");

    // --- Generation Message Polling ---
    let messages = state.poller.poll_generation();
    for msg in messages {
        // FIX 2: Removed the unreachable `_ => {}` pattern.
        match msg {
            GenerationMessage::Generated(_, chunk) => {
                let chunk_x = chunk.bounds.min.x as i32;
                let chunk_y = chunk.bounds.min.y as i32;
                let batch = create_render_batch_dictionary(&chunk, chunk_x, chunk_y);
                
                if !batch.is_empty() {
                    signals_node.emit_signal(
                        "chunk_generated_batch", 
                        &[batch.to_variant()]
                    );
                    debug!("Tick: Emitted chunk_generated_batch ({chunk_x}, {chunk_y})");
                }
            }
            GenerationMessage::StatusUpdate(update) => {
                signals_node.emit_signal(
                    "engine_status_updated", 
                    &[GString::from(update.as_str()).to_variant()]
                );
            }
            GenerationMessage::GenerationComplete => {
                signals_node.emit_signal(
                    "build_map_complete", 
                    &[]
                );
            }
            // Note: If GenerationMessage has other variants, they should be added here.
            // Since the compiler stated the previous `_` was unreachable, this list is assumed complete.
        }
    }

    // --- Animation Message Polling ---
    let anim_msgs = state.poller.poll_animations();
    if !anim_msgs.is_empty() {
        for msg in &anim_msgs {
            // FIX: Uses fully qualified path `ssxl_shared::AnimationPayload` now.
            if let ssxl_shared::AnimationPayload::FrameUpdate { new_frame } = msg.payload {
                
                signals_node.emit_signal(
                    "tile_flip_updated", 
                    &[
                        // FIX: use `msg.coord` instead of `msg.tile_coords`.
                        (msg.coord.x as i32).to_variant(), 
                        (msg.coord.y as i32).to_variant(), // Assuming y-coordinate is also needed
                        (new_frame as i32).to_variant()
                    ]
                );
            }
        }
        debug!("Tick: Processed {} animation updates", anim_msgs.len());
    }

    // --- Tick Completion Signal ---
    signals_node.emit_signal(
        "tick_complete", 
        &[tick.to_variant()]
    ); 
}
// --- END: rust/ssxl_godot/src\engine\tick.rs ---
        17 LOC | rust/ssxl_godot/src\ffi\gde_api_defs.rs
// --- START: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
// ssxl_godot/src/gde_api_defs.rs

//! # Godot Extension API Definitions (GDExtension Interface)
//!
//! This module defines the essential Rust-side bindings that connect the `SSXLEngine`
//! struct to the Godot engine's runtime environment. It implements the necessary
//! traits to register the class and hook into the standard Node lifecycle methods.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;

// --- Local Crate Imports ---
// Import the core SSXL engine implementation.
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// GDExtension Initialization Macro
// -----------------------------------------------------------------------------

/// The mandatory **GDExtension entry point**.
///
/// This function is called by Godot when the dynamic library is loaded.
/// The `#[gdextension]` attribute marks it as the entry function.
/// It is declared `unsafe` because it interacts with the C/C++ FFI of Godot.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // 1. **Class Registration:** Registers the core `SSXLEngine` struct with Godot.
    // This makes the Rust struct available in the Godot scripting environment (GDScript/C#).
    builder.add_class::<SSXLEngine>();
}


// -----------------------------------------------------------------------------
// Godot Node Lifecycle Implementation
// -----------------------------------------------------------------------------

/// Implements the `ExtensionLibrary` trait for `SSXLEngine`.
/// This trait binds the Rust struct to a Godot class (in this case, `Node`)
/// and maps Godot's virtual methods (like `_init`, `_process`) to the Rust implementation.
impl ExtensionLibrary for SSXLEngine {
    /// **Godot's Constructor (`_init`)**:
    /// This runs when an instance of `SSXLEngine` is created in Godot.
    /// It delegates initialization to the custom `SSXLEngine::init` method.
    fn _init(base: Base<Node>) -> Self {
        // `base` is the underlying Godot Node that this struct wraps.
        SSXLEngine::init(base)
    }

    /// **Godot's Frame Update (`_process(delta)`)**:
    /// This is called every frame, **adapting** the engine's logic to the game's **tempo**.
    /// The `delta` is the time elapsed since the last frame.
    fn _process(&mut self, delta: f64) {
        // Call the internal game loop tick function, passing the delta time.
        // The delta is cast to `u64` (milliseconds or similar unit) as used internally
        // by the SSXL-ext game loop logic (which may need adjustment depending on the unit).
        self.tick(delta as u64);
    }

    /// **Godot's Initialization Hook (`_ready`)**:
    /// This runs once when the node and all its children have entered the scene tree.
    /// This is the ideal place to start the multi-threaded SSXL engine.
    fn _ready(&mut self) {
        self.on_ready();
    }
}
// --- END: rust/ssxl_godot/src\ffi\gde_api_defs.rs ---
         4 LOC | rust/ssxl_godot/src\ffi\mod.rs
// --- START: rust/ssxl_godot/src\ffi\mod.rs ---
pub mod oracle;
pub mod signals;        // this loads src/ffi/signals.rs

pub use oracle::SSXLOracle;
pub use signals::SSXLSignals;   // re-export the class
// --- END: rust/ssxl_godot/src\ffi\mod.rs ---
        64 LOC | rust/ssxl_godot/src\ffi\oracle.rs
// --- START: rust/ssxl_godot/src\ffi\oracle.rs ---
// ssxl_godot/src/ffi/oracle.rs

use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};
use crate::engine::SSXLEngine;

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    #[base]
    base: Base<Node>,
    engine: Option<Gd<SSXLEngine>>,
    tick_count: u64,
}

impl SSXLOracle {
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}

#[godot_api]
impl SSXLOracle {
    #[func]
    fn _ready(&mut self) {
        self.base_mut().set_process(true);
    }

    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
    }

    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // FIX: Use the correct method name `process_engine_tick` and remove the argument,
                // as confirmed by the compiler's suggestion.
                engine.bind_mut().process_engine_tick();
                self.tick_count += 1;
            }
            None => {
                // Engine not ready. Silent failure is acceptable during initialization.
            }
        }
    }

    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_current_tile_count()
            }
            None => {
                0
            }
        }
    }

    #[func]
    pub fn get_status(&self) -> GString {
        match self.engine.as_ref() {
            Some(engine) => {
                engine.bind().get_status()
            }
            None => {
                GString::from("Engine not bound.")
            }
        }
    }
    
    #[func]
    pub fn ping(&self) {
    }

    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
    }

    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}
// --- END: rust/ssxl_godot/src\ffi\oracle.rs ---
        24 LOC | rust/ssxl_godot/src\ffi\signals.rs
// --- START: rust/ssxl_godot/src\ffi\signals.rs ---
// ssxl_godot/src/ffi/signals.rs

use godot::prelude::*;
// FIX: Removed the unused glob import `godot::classes::*` and replaced it with an explicit import for `Node`.
use godot::classes::Node; 
// FIX: Removed unnecessary import for `godot::obj::Base` as it is covered by `godot::prelude::*`.

#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLSignals {
    #[base]
    base: Base<Node>,
}

// FIX 2: Define the required constructor in a standard impl block.
impl SSXLSignals {
    pub fn init(base: Base<Node>) -> Self {
        Self { base }
    }
}

#[godot_api]
impl SSXLSignals {
    // The previous #[func] pub fn init is removed from here.

    // --- Generation Lifecycle Signals ---
    
    #[signal]
    fn build_map_start();

    #[signal]
    fn chunk_data_updated(x: i32, y: i32);

    #[signal]
    fn chunk_generated_batch(batch: Dictionary);

    #[signal]
    fn build_map_complete();

    #[signal]
    fn build_map_stopped();

    #[signal]
    fn generation_error(error_message: GString);

    #[signal]
    fn chunk_data_ready(x: i32, y: i32);

    #[signal]
    fn tick_complete(current_tick: u64);

    // --- Animation & Utility Signals ---
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: Vector2i);

    #[signal]
    fn animation_state_changed(enabled: bool);

    #[signal]
    fn engine_status_updated(status_message: GString);
}
// --- END: rust/ssxl_godot/src\ffi\signals.rs ---
        10 LOC | rust/ssxl_godot/src\lib.rs
// --- START: rust/ssxl_godot/src\lib.rs ---
// ssxl_godot/src/lib.rs (Refactored Zero-Entropy Manifest)

//! # SSXL-ext GDExtension Core Library
//!
//! This file is the **root manifest** for the `ssxl_godot` crate. It has been
//! refactored to use a hierarchical structure, exposing only the top-level,
//! logically segregated modules: `engine`, `ffi`, and `tilemap`.

// -----------------------------------------------------------------------------
// Public Modules (Exposed to the GDExtension Interface)
// -----------------------------------------------------------------------------

/// Contains the SSXLEngine struct and its core logic (API, commands, oracle, tick).
pub mod engine;

/// Contains all Godot-exposed FFI Adapter Nodes (SSXLOracle, SSXLSignals).
pub mod ffi;

// FIX: Changed 'pub mod ssxl_tilemap;' to 'pub mod tilemap;'
// This tells the compiler to look for the 'tilemap' directory/module (src/tilemap/mod.rs or src/tilemap.rs).
// The 'tilemap/mod.rs' file will then declare 'pub mod ssxl_tilemap;'.
/// The module for the SSXLTileMap Godot Node and its related logic.
pub mod tilemap; 

// NOTE: All previous flat modules (e.g., ssxl_engine, ssxl_signals, async_poll,
// generation_api, channel_handler) have been consolidated into the `engine` and
// `ffi` hierarchies for a zero-entropy structure.

// -----------------------------------------------------------------------------
// GDExtension Boilerplate
// -----------------------------------------------------------------------------

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};


/// Placeholder struct required by the `godot-rust` library to implement
/// the `ExtensionLibrary` trait, which defines the dynamic library's behavior.
struct SSXLExtension;

/// Implements the required trait for the GDExtension to be loaded.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    /// Called by Godot when a new initialization level is reached.
    fn on_level_init(_level: InitLevel) {
        // No actions required at this low-level init stage.
    }
}
// --- END: rust/ssxl_godot/src\lib.rs ---
        72 LOC | rust/ssxl_godot/src\tilemap\async_poll.rs
// --- START: rust/ssxl_godot/src\tilemap\async_poll.rs ---
// ssxl_godot/src/tilemap/async_poll.rs
//
// The sacred bridge between Tokio and Godot.
// Polls background channels on the main thread.
// Zero blocking. Zero panic. Eternal.

use tokio::sync::mpsc::{
    // FIX 3: Import the Bounded Receiver for Generation Messages
    Receiver as TokioBoundedReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError,
};
// CRITICAL FIX: The imported type for AnimationUpdate is now at the crate root
use ssxl_shared::AnimationUpdate; 
// FIX 1: The correct GenerationMessage location (from prior fix)
use ssxl_shared::message::generation_message::GenerationMessage; 

const MAX_GEN_MSGS: usize = 64;
const MAX_ANIM_MSGS: usize = 2048;

// CRITICAL FIX 4: Update the type alias to use the crate root path for AnimationUpdate
pub type AnimationReceiver = TokioUnboundedReceiver<ssxl_shared::AnimationUpdate>;
// CRITICAL FIX 5: Define the type alias for the Bounded Receiver to expect GenerationMessage
pub type GenerationReceiver = TokioBoundedReceiver<GenerationMessage>;

#[derive(Default)]
pub struct AsyncPoller {
    // Only animation uses unbounded — generation is bounded and handled via Conductor
    // FIX 6: Add state for the Generation Receiver, using GenerationMessage
    generation_rx: Option<GenerationReceiver>,
    // FIX 7: Rename animation_rx for consistency with the new setter in init.rs
    animation_rx: Option<AnimationReceiver>,
}

impl AsyncPoller {
    pub fn new() -> Self {
        Self::default()
    }

    // --- Animation Methods (Renamed for consistency with init.rs fix) ---

    /// Setter matching the logic in init.rs
    pub fn set_animation_rx(&mut self, rx: Option<AnimationReceiver>) {
        // FIX 8: The 'take()' in init.rs already pulls the receiver out of an Option,
        // so the setter must accept an Option<Receiver> for cases where the channel is uninitialized (None).
        self.animation_rx = rx;
    }

    // --- Generation Methods (New) ---

    /// Setter for the generation channel, matching the logic in init.rs
    pub fn set_generation_rx(&mut self, rx: Option<GenerationReceiver>) {
        // FIX 9: Set the generation receiver
        self.generation_rx = rx;
    }

    pub fn clear_receivers(&mut self) {
        // FIX 10: Clear both receivers
        self.generation_rx = None;
        self.animation_rx = None;
    }

    /// Poll all pending generation updates — safe to call every frame
    pub fn poll_generation(&mut self) -> Vec<GenerationMessage> {
        // CRITICAL FIX 11: Change return type and message type to GenerationMessage
        let Some(mut rx) = self.generation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_GEN_MSGS);

        loop {
            // NOTE: The tokio Bounded Receiver uses a different try_recv signature (TryRecvError)
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Generation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_GEN_MSGS {
                break;
            }
        }

        self.generation_rx = Some(rx);
        updates
    }


    /// Poll all pending animation updates — safe to call every frame
    pub fn poll_animations(&mut self) -> Vec<AnimationUpdate> {
        // FIX 12: Use the consistent name
        let Some(mut rx) = self.animation_rx.take() else {
            return Vec::new();
        };

        let mut updates = Vec::with_capacity(MAX_ANIM_MSGS.min(256));

        loop {
            match rx.try_recv() {
                Ok(update) => updates.push(update),
                Err(TryRecvError::Empty) => break,
                Err(TryRecvError::Disconnected) => {
                    tracing::error!("Animation channel disconnected!");
                    break;
                }
            }

            if updates.len() >= MAX_ANIM_MSGS {
                break;
            }
        }

        // FIX 13: Use the consistent name
        self.animation_rx = Some(rx);
        updates
    }
}
// --- END: rust/ssxl_godot/src\tilemap\async_poll.rs ---
         3 LOC | rust/ssxl_godot/src\tilemap\mod.rs
// --- START: rust/ssxl_godot/src\tilemap\mod.rs ---
// ssxl_godot/src/tilemap/mod.rs 
//
// Parent module for all tilemap-related components.

pub mod ssxl_tilemap; // Points to ssxl_godot/src/tilemap/ssxl_tilemap.rs

// FIX: Declare sibling modules here if their source files are in the 'tilemap/' directory.
pub mod async_poll;
pub mod status_reporter;
// --- END: rust/ssxl_godot/src\tilemap\mod.rs ---
        64 LOC | rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs
// --- START: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
// ssxl_godot/src/tilemap/ssxl_tilemap.rs
//
// The final render sink.
// Receives render batches from the async core.
// Pure, fast, panic-safe, zero bloat.

use godot::prelude::*;
use godot::classes::{TileMap, ITileMap};
use godot::obj::Base;
// FIX: Removed unused import: `Vector2`
use godot::builtin::{Vector2i, PackedVector2Array, PackedInt32Array};

#[derive(GodotClass)]
#[class(base = TileMap)]
pub struct SSXLTilemap {
    base: Base<TileMap>,

    #[export]
    tile_source_id: i32,
}

#[godot_api]
impl ITileMap for SSXLTilemap {
    fn init(base: Base<TileMap>) -> Self {
        Self {
            base,
            tile_source_id: 1,
        }
    }
}

#[godot_api]
impl SSXLTilemap {
    /// Primary render entrypoint — called from Rust via signal
    /// Expects the exact format from render_batch.rs
    #[func]
    pub fn batch_set_tiles(&mut self, batch: Dictionary) {
        // FIX E0308: Convert Result<i64, ConvertError> to Option<i64> using `.ok()`
        let Some(layer) = batch.get("layer").and_then(|v| v.try_to::<i64>().ok()) else {
            godot_warn!("SSXLTilemap: missing or invalid 'layer'");
            return;
        };
        let layer = layer as i32;

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let positions = match batch.get("positions").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(p) => p,
            None => {
                godot_warn!("SSXLTilemap: missing 'positions'");
                return;
            }
        };

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let atlas_coords = match batch.get("atlas_coords").and_then(|v| v.try_to::<PackedVector2Array>().ok()) {
            Some(a) => a,
            None => {
                godot_warn!("SSXLTilemap: missing 'atlas_coords'");
                return;
            }
        };

        // FIX E0308: Convert inner Result to Option using `.ok()`
        let alt_tiles = batch
            .get("alt_tiles")
            .and_then(|v| v.try_to::<PackedInt32Array>().ok())
            .unwrap_or_default();

        let source_id = self.tile_source_id;
        let mut tilemap = self.base_mut();

        tilemap.set_layer_enabled(layer, true);

        let len = positions.len();
        if len == 0 {
            return;
        }

        for i in 0..len {
            // FIX E0609: Unwrap the Option<Vector2> before accessing .x and .y fields.
            let pos = positions.get(i).unwrap();
            let atlas = atlas_coords.get(i).unwrap();
            let alt = alt_tiles.get(i).unwrap_or(0);

            // Note: pos and atlas coordinates come as Vector2 (f32 fields), but they represent integer tile coordinates.
            // Casting to i32 is appropriate here.
            let cell = Vector2i::new(pos.x as i32, pos.y as i32);
            let atlas = Vector2i::new(atlas.x as i32, atlas.y as i32);

            tilemap
                .set_cell_ex(layer, cell)
                .source_id(source_id)
                .atlas_coords(atlas)
                .alternative_tile(alt)
                .done();
        }

        godot_print!("SSXLTilemap: Rendered {len} tiles on layer {layer}");
    }
}
// --- END: rust/ssxl_godot/src\tilemap\ssxl_tilemap.rs ---
        36 LOC | rust/ssxl_godot/src\tilemap\status_reporter.rs
// --- START: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
use godot::prelude::GString;
// FIX: Change import path from conductor_state::ConductorState to conductor::ConductorState
// Assuming the ConductorState type is exported via the 'conductor' module in ssxl_generate.
use ssxl_generate::conductor::ConductorState;
use ssxl_shared::AnimationState;

/// # StatusReporter
/// 
/// A stateless utility struct responsible for querying the various core states
/// (Generation, Animation) and compiling human-readable status reports
/// for the Godot scripting layer.
pub struct StatusReporter;

impl StatusReporter {
    /// Constructs a new, human-readable status string combining the state of
    /// the Generation and Animation cores.
    /// 
    /// This removes complex string formatting logic from SSXLEngine.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    /// * `anim_state` - Read-only reference to the Animation process state.
    /// 
    /// # Returns
    /// A Godot `GString` containing the formatted status message.
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        let gen_status = gen_state
            // This line is assumed correct for ConductorState
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let anim_status = anim_state
            .map(|state| {
                // FIX: AnimationState does not have a get_status() method.
                // We derive the status from the publicly available `time_scale` field.
                if state.time_scale > 0.0 {
                    format!("Running (Scale: {:.2}x)", state.time_scale)
                } else if state.time_scale == 0.0 {
                    String::from("Stopped")
                } else {
                    // Handle negative or otherwise unexpected scales
                    String::from("Error/Invalid Scale")
                }
            })
            .unwrap_or_else(|| String::from("Uninitialized"));

        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        GString::from(status.as_str())
    }

    /// Retrieves the total number of tiles placed by the engine during generation.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            // Fails gracefully to 0 if the core is not yet initialized.
            .unwrap_or(0)
    }
}
// --- END: rust/ssxl_godot/src\tilemap\status_reporter.rs ---
        58 LOC | rust/ssxl_math/src\coordinate_system.rs
// --- START: rust/ssxl_math/src\coordinate_system.rs ---
// ssxl_math/src/coordinate_system.rs

//! # Coordinate System
//!
//! Defines the core coordinate types for the SSXL-ext engine, using 64-bit integers (`I64Vec3`)
//! to support extremely large, virtually infinite world dimensions.
//!
//! This module implements the crucial logic for converting a global `WorldPos` into its
//! localized `(ChunkKey, TileOffset)` components, ensuring mathematical correctness
//! even for large **negative coordinates** through the use of Euclidean division.

use serde::{Serialize, Deserialize};
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;


// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------

/// Represents a specific point in the vast 3D world space.
/// The underlying `I64Vec3` ensures the system can handle coordinates well beyond i32 limits.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

/// The unique identifier for a 3D chunk.
/// This acts as the *base coordinate* for a 32x32x32 (or `CHUNK_SIZE`) cubic volume of the world.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

/// The local position of a tile *within* its parent chunk.
/// Coordinates are always non-negative and range from `[0, CHUNK_SIZE - 1]`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);


// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------

impl WorldPos {
    /// Converts a global `WorldPos` into its discrete `ChunkKey` and local `TileOffset` components.
    ///
    /// This conversion is robust against **negative world coordinates** by using
    /// `rem_euclid`, which guarantees the `TileOffset` is always positive (or zero).
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {

        let chunk_size = CHUNK_SIZE_I64;

        // 1. Calculate the Tile Offset (Local Position)
        // `rem_euclid` ensures the remainder is always non-negative, correctly wrapping
        // negative world coordinates (e.g., -1 rem_euclid 32 = 31).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // 2. Calculate the Chunk Key (Chunk Index)
        // The chunk index is calculated by subtracting the tile offset (remainder)
        // and then performing simple integer division. This is the correct Euclidean
        // division for finding the quotient (chunk index).
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------

impl ChunkKey {
    /// Reconstructs the original `WorldPos` from the `ChunkKey` and `TileOffset`.
    ///
    /// This is the inverse operation, verifying the idempotence of the coordinate system.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        // Formula: World = (Chunk Index * Chunk Size) + Tile Offset
        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    // NOTE: CHUNK_SIZE_I64 is assumed to be 32 for these tests.

    #[test]
    /// Tests conversion for a very large positive coordinate, confirming I64 robustness.
    fn test_world_to_chunk_positive() {
        let huge_coord = 5_000_000_000i64; // Well over i32::MAX
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64; // 156,250,000
        let expected_offset = huge_coord % CHUNK_SIZE_I64; // 0

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // 64 / 32 = 2 (chunk key), 64 rem_euclid 32 = 0 (offset)
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    /// CRUCIAL test for negative coordinates, verifying the Euclidean division logic.
    fn test_world_to_chunk_negative_crucial() {
        // Test case 1: (-1, -1, -1)
        // Expected: Chunk index should be -1. Offset should be 31 (32 - 1).
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test case 2: (-33, -64, -100)
        // X: -33 rem 32 = 31, (-33 - 31)/32 = -2.
        // Y: -64 rem 32 = 0, (-64 - 0)/32 = -2.
        // Z: -100 rem 32 = 28, (-100 - 28)/32 = -4.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    /// Tests that converting a WorldPos to (ChunkKey, TileOffset) and back results in the original WorldPos.
    fn test_round_trip() {
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();

        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}
// --- END: rust/ssxl_math/src\coordinate_system.rs ---
        14 LOC | rust/ssxl_math/src\generation_utils.rs
// --- START: rust/ssxl_math/src\generation_utils.rs ---
// ssxl_math/src/generation_utils.rs

//! # Generation Utilities
//!
//! Provides common mathematical and random-sampling utilities used throughout the
//! procedural generation pipeline (e.g., `ssxl_generate` crate).
//!
//! Functions here are designed for rapid, stateless generation logic, such as
//! calculating percentage chance rolls and generating unique identifiers for data structures.

use crate::primitives::SSXLData;
use rand::Rng;

// -----------------------------------------------------------------------------
// Randomness and Chance Utilities
// -----------------------------------------------------------------------------

/// Rolls a chance check against a given percentage.
///
/// This function is vital for injecting controlled **randomness** and **balance**
/// into the generation process (e.g., probability of a resource spawning, or a
/// cellular automata rule firing).
///
/// # Arguments
/// * `target_percent` - The probability of success, expressed as a whole percentage (0-100).
///
/// # Returns
/// * `0`: Success (The random number was less than `target_percent`).
/// * `1`: Failure (The random number was greater than or equal to `target_percent`).
///
/// # Example
/// A 25% chance of spawning:
/// ```ignore
/// if generate_percent_roll(25) == 0 {
///     // spawn item
/// }
/// ```
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the inclusive range [0, 99], which is a 0-100 scale.
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Success occurs if the random value falls within the target range.
    if rand_val < target_percent {
        0 // Success / Hit
    } else {
        1 // Failure / Miss
    }
}

// -----------------------------------------------------------------------------
// Data Processing Utilities
// -----------------------------------------------------------------------------

/// Processes an object implementing the `SSXLData` trait to derive a simple aggregate identifier.
///
/// This is a basic utility that combines the object's unique ID with its data payload size.
/// It is often used for creating quick, unique signatures or simple hashing/checksums
/// for data chunks across worker threads.
///
/// # Arguments
/// * `data` - A reference to any structure that implements the `SSXLData` trait.
///
/// # Returns
/// * `u64` - The sum of the data's ID and the length of its associated value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine the inherent ID (u64) with the value length (u64 after casting).
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}
// --- END: rust/ssxl_math/src\generation_utils.rs ---
        42 LOC | rust/ssxl_math/src\hashing.rs
// --- START: rust/ssxl_math/src\hashing.rs ---

// ssxl_math/src/hashing.rs

/// # Hashing Utilities for SSXL-ext
///
/// This module provides **deterministic, collision-resistant** hashing functions
/// essential for identifying and retrieving procedural data.
///
/// Hashing is crucial for:
/// 1.  Generating unique, stable IDs for **world chunks** based on their coordinates.
/// 2.  Creating cache keys for **generated content** to ensure persistence and integrity.
use crate::primitives::SSXLResult;
use glam::I64Vec3;
use sha2::{Digest, Sha256};

/// Generates a **deterministic SHA-256 hash** for a given 3D chunk coordinate.
///
/// This hash is used as a unique identifier (a key) for world chunks, ensuring that
/// the same coordinate always yields the identical hash string, which is crucial
/// for cache lookups and procedural generation stability.
///
/// # Arguments
///
/// * `coords` - The 3D world coordinate of the chunk, using 64-bit integers (`I64Vec3`)
///              to support extremely large, dimension-agnostic worlds.
///
/// # Returns
///
/// A `SSXLResult<String>` containing the 64-character hexadecimal SHA-256 hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // 1. Serialize the coordinates into a canonical string format (e.g., "100:5:25").
    // This fixed format ensures deterministic input for the hash function.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash bytes into a lowercase 64-character hexadecimal string.
    Ok(format!("{:x}", result))
}

/// Generates a **deterministic SHA-256 hash** for a generic 64-bit data key.
///
/// This is typically used to create unique cache keys for generated content or
/// assets, prefixed with `"content_"` for easy identification in the cache system
/// (`ssxl_cache`).
///
/// # Arguments
///
/// * `data_key` - A generic `u64` identifier for the content (e.g., a seed,
///                a configuration ID, or a tile type index).
///
/// # Returns
///
/// A `SSXLResult<String>` containing the hash prefixed with `"content_"`.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // 1. Convert the u64 key into a string.
    let key_string = data_key.to_string();

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // 3. Format the result with the required "content_" prefix.
    Ok(format!("content_{:x}", result))
}


/// Unit tests to ensure the hashing functions are **deterministic** and produce
/// the expected **format** and **uniqueness** required for stable world generation.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// Tests that the same coordinates always produce the identical hash (determinism).
    fn test_chunk_coords_determinism() {
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    /// Tests the expected hash length (64 chars) and confirms that a small coordinate change
    /// results in a completely different hash (uniqueness/avalanche effect).
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    /// Tests determinism, the 'content_' prefix, and the total expected length (72 chars).
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // 'content_' (8 chars) + SHA-256 hex (64 chars) = 72
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}
// --- END: rust/ssxl_math/src\hashing.rs ---
        30 LOC | rust/ssxl_math/src\lib.rs
// --- START: rust/ssxl_math/src\lib.rs ---
// File: ssxl_math/src/lib.rs

// --- 1. Module Declarations (CRITICAL: MUST be at the root) ---
/// Defines the global and local coordinate system structures (`ChunkKey`, `WorldPos`).
pub mod coordinate_system;

/// Houses various utility functions for procedural generation algorithms.
pub mod generation_utils;

/// Provides deterministic hashing functions (e.g., `hash_chunk_coords`).
pub mod hashing;

/// Core mathematical primitives, custom types, and error handling results.
pub mod primitives;

// --------------------------------------------------------------------------------

// --- 2. Cold Quantum Fast Implementation (FTL, Safety-Optimized) ---

/// FTL Inverse Square Root: **O(1)** Approximation for vector normalization.
///
#[inline(always)]
pub fn q_rsqrt(number: f32) -> f32 {
    // O(1) Safety Guard: Prevents NaN/UB when magnitude is zero or negative.
    if number <= 0.0 { 
        return 0.0;
    }

    const THREEHALFS: f32 = 1.5;
    let x2 = number * 0.5;
    let y = number;
    
    // Use u32 for bitwise operation.
    let i = y.to_bits();
    let j_bits = 0x5f3759df_u32.wrapping_sub(i >> 1);

    let mut y = f32::from_bits(j_bits);
    
    // Single Newton's iteration.
    y = y * (THREEHALFS - (x2 * y * y));
    y
}

/// Computes the normalized (unit) vector of a 3D float vector.
pub fn normalize_vector_3d(x: f32, y: f32, z: f32) -> (f32, f32, f32) {
    let mag_sq = x * x + y * y + z * z;
    let inv_mag = q_rsqrt(mag_sq); 
    
    (x * inv_mag, y * inv_mag, z * inv_mag)
}

// --------------------------------------------------------------------------------

// --- 3. Prelude for Internal Engine Use (Minimalist API) ---

/// A convenience module that re-exports all essential types and traits
/// from the `ssxl_math` crate.
pub mod prelude {
    // Use 'super::' consistently to access items defined in the parent scope (lib.rs).
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
    
    pub use super::q_rsqrt;
    pub use super::normalize_vector_3d;
}
// --- END: rust/ssxl_math/src\lib.rs ---
        19 LOC | rust/ssxl_math/src\primitives.rs
// --- START: rust/ssxl_math/src\primitives.rs ---
//! # Primitives Module (`ssxl_math::primitives`)
//!
//! Defines the essential, low-level data types, type aliases, traits, and global
//! constants used throughout the SSXL-ext procedural generation engine.

use serde::{Deserialize, Serialize};

// --- Data Structures ---

/// A 2D vector for integer coordinates, typically used for tile offsets or local
/// coordinate mapping within a chunk.
///
/// Uses `i64` to maintain compatibility with the large coordinate space of `I64Vec3`
/// from the `glam` crate, preventing silent overflow issues.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    /// The X component of the 2D vector.
    pub x: i64,
    /// The Y component of the 2D vector.
    pub y: i64,
}

impl Vec2i {
    /// Creates a new `Vec2i` instance.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// --- Type Aliases ---

/// The standard 2D coordinate type for referencing a tile in the world
/// or within a chunk. Aliased to `Vec2i`.
pub type TileCoord = Vec2i; 

/// The standard 2D coordinate type for referencing a spatial chunk in the world grid.
/// Aliased to `Vec2i` for memory layout consistency with `TileCoord`.
pub type ChunkId = Vec2i; 

/// A specialized `Result` type for the SSXL-ext project.
///
/// The error type is fixed as `String`, providing a simple, high-level way to
/// convey error messages across the engine's various crates.
pub type SSXLResult<T> = Result<T, String>;

// --- Traits for Engine Data Management ---

/// A trait defining the requirements for any data structure that will be managed
/// or processed by the SSXL engine (e.g., in the task queue or cache).
///
/// The bounds `Send + Sync` are mandatory, ensuring all implementors can be
/// safely sent between worker threads and shared across thread boundaries.
pub trait SSXLData: Send + Sync {
    /// Retrieves a unique 64-bit ID for the data. Used primarily for cache keys
    /// and tracking within the `task_queue`.
    fn get_id(&self) -> u64;

    /// Returns the length or size of the data's core value in bytes or elements.
    /// Used for diagnostics, memory management, or processing limits.
    fn get_value_len(&self) -> usize;
}

// --- Global Constants ---

/// The canonical side length of a procedural chunk in the world.
///
/// This value is cast to `i64` to match the coordinate system of the engine,
/// ensuring consistent type usage for chunk-related calculations.
pub const CHUNK_SIZE_I64: i64 = 32;

/// A small constant used for floating-point comparisons to account for
/// precision errors (e.g., in perlin noise interpolation or physics-related math).
pub const F32_EPSILON: f32 = 1.0e-6;
// --- END: rust/ssxl_math/src\primitives.rs ---
       133 LOC | rust/ssxl_shared/src\chunk\chunk_data.rs
// --- START: rust/ssxl_shared/src\chunk\chunk_data.rs ---
// ssxl_shared/src/chunk/chunk_data.rs

//! # Chunk Data Structures (`ssxl_shared::chunk::chunk_data`)
//!
//! This module defines the `ChunkData` structure, which represents a single,
//! fixed-size block of the procedural world. It includes coordinates, bounds,
//! the array of tiles, and metadata about its generation. This is the atomic
//! unit of data shared between generation workers and the cache/Godot runtime,
//! forming the basis of the engine's "crypto coded memory."

use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use std::convert::TryInto;
// NEW: For faster assignment of large arrays (ptr::write).
use std::ptr; 

// --- FIXES APPLIED HERE ---
use super::grid_bounds::GridBounds;
use crate::tile::tile_data::TileData; 
use crate::math::math_primitives; 

use ssxl_math::prelude::Vec2i;
use serde_big_array::BigArray;

// --- Constants ---

/// The canonical side length of a chunk (e.g., 32x32 tiles), defined as a public constant.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles in a single chunk (32 * 32 = 1024).
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;


// --- Coordinate Structure ---

/// Defines the **chunk-space** coordinates (e.g., Chunk [1, 5] on the world grid).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}


// --- Core Data Structure ---

/// The central data structure for a world chunk. This is the primary payload
/// for procedural generation tasks and caching.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    /// A unique, deterministic identifier for this chunk.
    pub id: u64,
    /// The world-space bounding box of the chunk, using the half-open range convention.
    pub bounds: GridBounds,
    /// The fixed-size array containing all tiles within the chunk.
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    /// A string tag identifying the dimension or layer this chunk belongs to.
    pub dimension_tag: String,
    /// Timestamp indicating when the chunk was generated (serialized deterministically).
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}


impl ChunkData {
    /// Re-export of the canonical chunk size as an associated constant for use in methods.
    pub const SIZE: u32 = CHUNK_SIZE;

    /// Creates a new `ChunkData` instance using explicit, pre-calculated parameters.
    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        // Initialize the tile array with default (empty) TileData.
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    /// Creates a new `ChunkData` instance by calculating its bounds and generating
    /// an initial ID based solely on its chunk coordinates.
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        // 1. Calculate the world-space minimum coordinates (inclusive).
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        // 2. Calculate the world-space maximum coordinates (exclusive, half-open range).
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        // 3. Generate a robust, collision-resistant ID.
        let id = ChunkData::hash_coords_2d(chunk_coords.x, chunk_coords.y);
        
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    /// Internal helper to map signed i64 to u64 for safe spatial indexing (e.g., Z-order curves).
    /// This prevents massive u64 values for small negative i64 inputs.
    /// Formula: (n << 1) ^ (n >> 63)
    // OPTIMIZATION: const fn and inline hint for zero-cost hashing.
    #[inline(always)]
    pub const fn zigzag_encode(n: i64) -> u64 {
        // We use the standard Zigzag formula to map all i64 values to unique u64 values,
        // prioritizing small absolute values to the lowest u64 space.
        ((n << 1) ^ (n >> 63)) as u64
    }

    /// Internal 2D coordinate hashing function, replacing the problematic FFI call.
    /// Uses a **Zigzag-encoded** packing into a u64, which is fast, deterministic,
    /// and ensures no collisions across the world origin.
    // OPTIMIZATION: const fn and inline hint for zero-cost hashing.
    #[inline(always)]
    pub const fn hash_coords_2d(x: i64, y: i64) -> u64 {
        let ux = Self::zigzag_encode(x);
        let uy = Self::zigzag_encode(y);

        // Pack the two 32-bit halves. This is standard 2D packing for chunk keys.
        ux | (uy << 32)
    }
    
    /// Internal helper to convert local tile coordinates (x, y) within the chunk
    /// into a flat array index. Includes a bounds check, returning `None` on failure.
    #[inline(always)]
    fn coord_to_index_checked(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            // Index = Y * Width + X (standard row-major order)
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    /// Internal helper to convert local tile coordinates (x, y) within the chunk
    /// into a flat array index, **without** bounds checking.
    ///
    /// # Safety
    /// The caller **must** ensure that `x` and `y` are within the range `[0, CHUNK_SIZE - 1]`.
    #[inline(always)]
    pub const fn coord_to_index_unchecked(x: u32, y: u32) -> usize {
        // Index = Y * Width + X (standard row-major order)
        (y * Self::SIZE + x) as usize
    }

    /// Safely retrieves an immutable reference to a tile at the given local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            // SAFETY: index is guaranteed to be within array bounds by coord_to_index_checked
            &self.tiles[index]
        })
    }
    
    /// **FAST PATH:** Retrieves an immutable reference to a tile at the given local coordinates,
    /// **without bounds checking**.
    ///
    /// # Safety
    /// The caller **must** ensure that `x` and `y` are within the range `[0, CHUNK_SIZE - 1]`.
    // OPTIMIZATION: Fastest tile access method for performance-critical inner loops.
    #[inline(always)]
    pub unsafe fn get_tile_unchecked(&self, x: u32, y: u32) -> &TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        // SAFETY: The caller guarantees the index is valid.
        &self.tiles[index]
    }
    
    /// Inserts a fully generated vector of tiles into the chunk's internal array.
    ///
    /// # Panics
    /// Panics if the input vector's length does not exactly match the expected
    /// `TILE_ARRAY_SIZE`, which is a critical **data integrity** check.
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        // Use TryInto to consume the Vec, which is more idiomatic and clear for ownership transfer.
        match tiles_vec.try_into() {
            Ok(arr) => {
                // OPTIMIZATION: Use ptr::write for a non-initializing move of the array contents
                // This is generally faster than a regular assignment for large arrays.
                unsafe { ptr::write(&mut self.tiles, arr) };
            }
            Err(vec) => {
                // Critical error: A generator produced an incomplete or oversized chunk.
                panic!(
                    "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                    self.bounds,
                    vec.len(),
                    TILE_ARRAY_SIZE
                );
            }
        }
    }
    
    /// Safely retrieves a mutable reference to a tile at the given local coordinates.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index_checked(x, y).map(|index| {
            // SAFETY: index is guaranteed to be within array bounds by coord_to_index_checked
            &mut self.tiles[index]
        })
    }

    /// **FAST PATH:** Retrieves a mutable reference to a tile at the given local coordinates,
    /// **without bounds checking**.
    ///
    /// # Safety
    /// The caller **must** ensure that `x` and `y` are within the range `[0, CHUNK_SIZE - 1]`.
    // OPTIMIZATION: Fastest mutable tile access method for performance-critical inner loops.
    #[inline(always)]
    pub unsafe fn get_tile_mut_unchecked(&mut self, x: u32, y: u32) -> &mut TileData {
        let index = Self::coord_to_index_unchecked(x, y);
        // SAFETY: The caller guarantees the index is valid.
        &mut self.tiles[index]
    }
}


// --- Unit Tests ---

#[cfg(test)]
mod tests {
    use super::*;

    // Assuming TileData is available via `crate::tile::tile_data::TileData`
    
    #[test]
    /// Tests the critical coordinate-to-index logic for boundaries and center.
    fn test_coord_to_index() {
        // Test Checked version
        // Top-left corner
        assert_eq!(ChunkData::coord_to_index_checked(0, 0), Some(0));

        // Center (16, 16) -> 16 * 32 + 16 = 528
        assert_eq!(ChunkData::coord_to_index_checked(16, 16), Some(528));

        // Bottom-right corner (31, 31) -> 31 * 32 + 31 = 1023 (TILE_ARRAY_SIZE - 1)
        assert_eq!(ChunkData::coord_to_index_checked(31, 31), Some(1023));

        // Out of bounds checks (32 is the exclusive size limit)
        assert_eq!(ChunkData::coord_to_index_checked(32, 0), None);
        assert_eq!(ChunkData::coord_to_index_checked(0, 32), None);
        assert_eq!(ChunkData::coord_to_index_checked(33, 33), None);
        
        // Test Unchecked version (only for known good coordinates)
        assert_eq!(ChunkData::coord_to_index_unchecked(0, 0), 0);
        assert_eq!(ChunkData::coord_to_index_unchecked(31, 31), 1023);
    }
    
    #[test]
    /// Tests the Zigzag encoding for correct mapping of signed to unsigned space.
    fn test_zigzag_encode() {
        assert_eq!(ChunkData::zigzag_encode(0), 0);
        assert_eq!(ChunkData::zigzag_encode(-1), 1);
        assert_eq!(ChunkData::zigzag_encode(1), 2);
        assert_eq!(ChunkData::zigzag_encode(-2), 3);
        assert_eq!(ChunkData::zigzag_encode(2), 4);
    }

    #[test]
    /// Tests the new 2D hashing function for uniqueness across the origin.
    fn test_hash_coords_2d() {
        // Standard coordinates
        // (1, 0) -> (Zigzag(1)=2 | Zigzag(0)=0 << 32) = 2
        assert_eq!(ChunkData::hash_coords_2d(1, 0), 2);
        // (0, 1) -> (Zigzag(0)=0 | Zigzag(1)=2 << 32) = 8589934592 (2 * 2^32)
        assert_eq!(ChunkData::hash_coords_2d(0, 1), 8589934592);
        
        // Critical Negative Coordinate Check (was broken before)
        // (-1, 0) -> (Zigzag(-1)=1 | Zigzag(0)=0 << 32) = 1
        assert_eq!(ChunkData::hash_coords_2d(-1, 0), 1);
        
        // Collision check across the origin must pass
        assert_ne!(ChunkData::hash_coords_2d(1, 1), ChunkData::hash_coords_2d(-1, -1));
        
        // Large coordinates (to ensure all 64 bits are used)
        let big_x = i64::MAX / 2; // Large positive
        let big_y = i64::MIN / 2; // Large negative
        let hash1 = ChunkData::hash_coords_2d(big_x, big_y);
        assert_ne!(hash1, 0);
    }
}
// --- END: rust/ssxl_shared/src\chunk\chunk_data.rs ---
        35 LOC | rust/ssxl_shared/src\chunk\grid_bounds.rs
// --- START: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
// ssxl_shared/src/grid_bounds.rs

//! # Grid Bounds Structures (`ssxl_shared::grid_bounds`)
//!
//! This module defines the core structures for representing 2D world-space points
//! and rectangular bounding boxes (bounds) used throughout the SSXL-ext engine.

use serde::{Deserialize, Serialize};

// --- Coordinate Structure ---

/// Represents a single 2D world-space coordinate point.
///
/// Uses `i64` to support the massive scale of the SSXL world coordinates.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    /// The X component of the coordinate.
    pub x: i64,
    /// The Y component of the coordinate.
    pub y: i64,
}

// --- Bounding Box Structure ---

/// Defines a rectangular region in the world by its minimum and maximum coordinate points.
///
/// **Convention:** `GridBounds` uses a **half-open range** (`[min, max)`), meaning
/// the minimum coordinates are **inclusive** and the maximum coordinates are **exclusive**.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum coordinate (e.g., the bottom-left point of the region).
    pub min: Coord2D,
    /// The exclusive maximum coordinate (one unit past the top-right point of the region).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new `GridBounds` instance from four explicit coordinate components.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size (width and height) of the bounds.
    ///
    /// For a half-open range, the size is simply `max - min`, which correctly
    /// yields the number of unique integer coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within the bounds.
    ///
    /// Follows the half-open range convention: `[min.x, max.x)` and `[min.y, max.y)`.
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Returns a default, zero-sized bounds at the origin (0, 0) to (0, 0).
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}
// --- END: rust/ssxl_shared/src\chunk\grid_bounds.rs ---
         2 LOC | rust/ssxl_shared/src\chunk\mod.rs
// --- START: rust/ssxl_shared/src\chunk\mod.rs ---
// ssxl_shared/src/chunk/mod.rs

pub mod chunk_data;
pub mod grid_bounds;
// --- END: rust/ssxl_shared/src\chunk\mod.rs ---
        37 LOC | rust/ssxl_shared/src\config\config.rs
// --- START: rust/ssxl_shared/src\config\config.rs ---
// FILE: ssxl_shared/src/config.rs

//! # Global Configuration Constants (`ssxl_shared::config`)
//!
//! This module defines fundamental, immutable constants that govern the structure
//! and scale of the SSXL procedural world. These values must be consistent
//! across all SSXL-ext crates (math, generate, cache, godot) to ensure data
//! integrity and system entropy is controlled.

use tracing::{info, warn};
use std::error::Error;
use serde::{Deserialize, Serialize}; // Assume Serde is used for configuration loading

// --- Config Struct Definition ---

/// Structure holding all runtime configuration settings for the SSXL Engine.
/// **NOTE:** This must be public to be used by other crates.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSXLConfig {
    // Example field required by other code snippets (from new_with_defaults)
    pub ca_default_ruleset: u8,
    
    // FIX 1: Add the required field for the default generator ID.
    pub default_generator_id: String,
}

// --- World Geometry Constants ---

/// The canonical side length of a procedural chunk in tiles.
/// **Value:** 32 (meaning chunks are 32x32 tiles).
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles contained within a single `ChunkData` structure.
/// **Calculation:** CHUNK_SIZE * CHUNK_SIZE (32 * 32 = 1024).
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;

// --- Loading Constants ---
const DEFAULT_CONFIG_PATH: &str = "res://ssxl_config.json";

impl SSXLConfig {
    /// Creates a safe, hardcoded default configuration.
    pub fn new_with_defaults() -> Self {
        SSXLConfig {
            ca_default_ruleset: 1, // Default CA ruleset ID
            
            // FIX 2: Initialize the new field.
            default_generator_id: "default_noise_gen".to_string(), 
        }
    }

    /// Internal method to attempt loading config from a file path.
    /// Returns `Ok(Self)` or an `Err` on failure. (Placeholder implementation).
    pub fn load_from_path(_path: &str) -> Result<Self, Box<dyn Error>> {
        // In a real application, this would handle file I/O and deserialization.
        // For now, we simulate success with defaults.
        Ok(SSXLConfig::new_with_defaults())
    }
    
    // FIX 3: Add the missing accessor method to resolve E0599.
    /// Returns the configured default Generator ID.
    pub fn default_generator_id(&self) -> String {
        self.default_generator_id.clone()
    }
}


/// Attempts to load the configuration from the specified path.
///
/// **FIX:** This function is defined publicly here, resolving `E0425` in `api_initializers.rs`.
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            // Safe fallback: Logs failure but ensures the engine initializes with defaults.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            SSXLConfig::new_with_defaults()
        }
    }
}
// --- END: rust/ssxl_shared/src\config\config.rs ---
         1 LOC | rust/ssxl_shared/src\config\mod.rs
// --- START: rust/ssxl_shared/src\config\mod.rs ---
// ssxl_shared/src/config/mod.rs

pub mod config;
// --- END: rust/ssxl_shared/src\config\mod.rs ---
        21 LOC | rust/ssxl_shared/src\error\errors.rs
// --- START: rust/ssxl_shared/src\error\errors.rs ---
// ssxl_shared/src/errors.rs

//! # SSXL Error Definitions (`ssxl_shared::errors`)
//!
//! This module defines the global, canonical error type for the entire SSXL-ext
//! procedural generation engine. Centralizing error handling ensures that failures
//! across different crates (math, generate, cache, godot) can be consistently
//! reported, managed, and debugged, particularly across FFI boundaries.

use thiserror::Error;

/// A specialized `Result` type for the SSXL-ext project.
///
/// All function calls that can fail within the SSXL ecosystem should return this
/// type, wrapping the concrete `SSXLError` enum.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// The comprehensive enumeration of all possible errors within the SSXL-ext engine.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Wrapper for standard I/O errors (e.g., file system access, network issues).
    /// This variant automatically handles conversion from `std::io::Error`.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors encountered during data serialization (e.g., using Bincode or Serde).
    /// Indicates problems with converting data to or from a byte stream.
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors related to unexpected or invalid data states, such as a generator
    /// returning a tile array of the wrong size or an invalid chunk key.
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the procedural generation pipeline (e.g., a generator
    /// failing to find a valid output after too many iterations).
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors occurring in the Godot GDExtension bridge or FFI layer.
    /// Crucial for debugging communication issues between Rust and the Godot runtime.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// A critical, unexpected error indicating a bug in the core logic that
    /// should never occur under normal execution (a **"BUG!"**).
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Generic wrapper for errors originating from third-party libraries or crates
    /// that are not covered by other specific variants.
    #[error("External Crate Error: {0}")]
    External(String),
}


// --- Error Conversion Implementations ---

/// Implements conversion from the `bincode::Error` type into the SSXL `Serialization` error.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Implements conversion from the generic `anyhow::Error` type into the SSXL `External` error.
/// This provides a convenient way to integrate external library errors into the SSXL system.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        // Use the debug message of the anyhow error to retain the source chain.
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}
// --- END: rust/ssxl_shared/src\error\errors.rs ---
         1 LOC | rust/ssxl_shared/src\error\mod.rs
// --- START: rust/ssxl_shared/src\error\mod.rs ---
// ssxl_shared/src/error/mod.rs

pub mod errors;
// --- END: rust/ssxl_shared/src\error\mod.rs ---
        22 LOC | rust/ssxl_shared/src\job\mod.rs
// --- START: rust/ssxl_shared/src\job\mod.rs ---
// File: ssxl_shared/src/job/mod.rs (Optimized Imports)

// FIX: Removed unused imports: `ChunkId` and `std::fmt::Display`.
use crate::ChunkData; // Import public re-exports from lib.rs

// --- The Instruction Packet ---
pub enum SSXLJob {
    /// Command to initialize map generation.
    BuildMap {
        width: u32,
        height: u32,
        seed: u64, // Use parsed seed
        // FIX: Replaced unknown GString with standard String
        generator_id: String
    },
    /// Command to change the active generator configuration.
    SetGenerator {
        // FIX: Replaced unknown GString with standard String
        generator_id: String
    },
    /// Command to stop all running and pending jobs.
    StopGeneration,
    // ...
}

// --- The Result Packet (Sent back to the Engine::tick) ---
// FIX: Renamed to JobResult to avoid collision with SSXLResult alias
pub enum JobResult {
    /// A chunk has been successfully generated and is ready for world state update.
    ChunkGenerated {
        // NOTE: x/y coordinates are often implicitly contained in ChunkData's bounds,
        // but keeping them here for explicit communication.
        x: i32,
        y: i32,
        // FIX: ChunkData is now imported and recognized
        data: ChunkData
    },
    /// The BuildMap job is finished.
    MapBuildComplete,
    /// An error occurred during processing.
    // FIX: Replaced unknown GString with standard String
    Error(String),
}
// --- END: rust/ssxl_shared/src\job\mod.rs ---
        48 LOC | rust/ssxl_shared/src\lib.rs
// --- START: rust/ssxl_shared/src\lib.rs ---
use serde::{Deserialize, Serialize};
use tracing;

pub mod chunk;
pub mod tile;
pub mod error;
pub mod config;
pub mod message;
pub mod math;
pub mod job;

pub use config::config::{get_config_from_path, SSXLConfig}; // ADDED: Re-exporting Config access
pub use ssxl_math::primitives::{ChunkId, TileCoord};

pub use chunk::chunk_data::{ChunkData, CHUNK_SIZE};
pub use tile::tile_data::TileData;
pub use chunk::grid_bounds::GridBounds;
pub use tile::tile_type::TileType;

pub use message::messages::{
    AnimationCommand,
    AnimationType,
    AnimationPayload,
    UpdateSender,
    AnimationConductorHandle,
    AnimationState,
    CommandResult,
    AnimationUpdate,
};

pub use error::errors::{SSXLError, SSXLResult};
pub use anyhow;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

pub mod prelude {
    pub use super::chunk::chunk_data::{ChunkData, CHUNK_SIZE};
    pub use super::tile::tile_data::TileData;
    pub use super::chunk::grid_bounds::GridBounds;
    pub use super::tile::tile_type::TileType;
    
    pub use super::{ChunkId, TileCoord};
    
    pub use super::error::errors::{SSXLError, SSXLResult};
    
    // UPDATED: Added AnimationState to the prelude
    pub use super::message::messages::{AnimationCommand, AnimationType, AnimationState};
    pub use super::message::messages::AnimationUpdate;

    // ADDED: Adding SSXLConfig to the prelude for easy access
    pub use super::config::config::SSXLConfig;
}

use std::sync::atomic::AtomicUsize;

pub static CHUNKS_COMPLETED_COUNT: AtomicUsize = AtomicUsize::new(0);
// --- END: rust/ssxl_shared/src\lib.rs ---
        20 LOC | rust/ssxl_shared/src\math\math_primitives.rs
// --- START: rust/ssxl_shared/src\math\math_primitives.rs ---
// ssxl_shared/src/math_primitives.rs

//! # Math Primitives & Serde Helpers (`ssxl_shared::math_primitives`)
//!
//! This module contains custom logic, primarily Serde serialization/deserialization
//! functions, for mathematical or standard library types that require specific,
//! deterministic formatting (e.g., `SystemTime`) for cross-platform compatibility
//! and persistent caching.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};


/// Serde serialization/deserialization helper for `std::time::SystemTime`.
///
/// This custom serializer converts `SystemTime` to and from a `u64` representing
/// the time in milliseconds since the Unix epoch (1970-01-01). This guarantees
/// a **deterministic, platform-independent** representation for caching and networking.
pub mod system_time_serde {
    use super::*;

    /// Serializes a `SystemTime` into a `u64` representing milliseconds since epoch.
    /// This is used by Serde when writing data (e.g., saving a `ChunkData` to cache).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Calculate the duration from the UNIX_EPOCH to the current time.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert the duration to milliseconds (u64) to ensure a stable format.
        let ms = duration.as_millis() as u64;
        // Serialize the u64 millisecond count.
        serializer.serialize_u64(ms)
    }

    /// Deserializes a `u64` (milliseconds since epoch) back into a `SystemTime`.
    /// This is used by Serde when reading data (e.g., loading a `ChunkData` from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize the u64 millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert the millisecond count into a Duration, then add it to UNIX_EPOCH.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}
// --- END: rust/ssxl_shared/src\math\math_primitives.rs ---
         1 LOC | rust/ssxl_shared/src\math\mod.rs
// --- START: rust/ssxl_shared/src\math\mod.rs ---
// ssxl_shared/src/math/mod.rs

pub mod math_primitives;
// --- END: rust/ssxl_shared/src\math\mod.rs ---
        13 LOC | rust/ssxl_shared/src\message\generation_message.rs
// --- START: rust/ssxl_shared/src\message\generation_message.rs ---
// ssxl_shared/src/message/generation_message.rs (Fixed Imports & Variants)

//! # Generation Messaging (`ssxl_shared::message::generation_message`)

use crate::chunk::chunk_data::ChunkData;
use ssxl_math::prelude::Vec2i;
use std::sync::Arc;
// FIX 1: Import the serialization traits from serde.
use serde::{Serialize, Deserialize};


// --- Work Request Structure ---

/// Defines a single unit of work (a task) to be processed by a worker thread.
///
/// This structure is put into the engine's `TaskQueue` by the `Conductor`.
// FIX 2: Add Serialize and Deserialize derives.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationTask {
    /// The chunk-space coordinates of the chunk that needs to be generated.
    pub chunk_coords: Vec2i,
    /// The unique identifier of the generator to be used for this task (e.g., "cellular_automata").
    pub generator_id: String,
}


// --- Communication Message Enumeration ---

/// An enumeration of messages sent from the worker threads back to the
/// main thread or the Conductor to signal task completion or pipeline status.
// FIX 3: Add Serialize and Deserialize derives.
#[derive(Debug, Serialize, Deserialize)]
pub enum GenerationMessage {
    /// Signals that a chunk has been successfully generated.
    ///
    /// The payload includes the chunk coordinates (for tracking) and the
    /// atomic reference-counted data.
    Generated(Vec2i, Arc<ChunkData>),

    /// Signals a change in the internal generation status or progress update.
    StatusUpdate(String),

    /// Signals that all current tasks related to a specific generation batch
    /// or request have been finalized. Used by the `Conductor` to update
    /// the generation state.
    GenerationComplete,
}
// --- END: rust/ssxl_shared/src\message\generation_message.rs ---
        52 LOC | rust/ssxl_shared/src\message\messages.rs
// --- START: rust/ssxl_shared/src\message\messages.rs ---
// FILE: ssxl_shared/src/message/messages.rs

use tokio::sync::mpsc::UnboundedSender;
use crate::{ChunkId, TileCoord};
use serde::{Deserialize, Serialize};


#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationType {
    TileFlip,
    TweenMove,
    PulseFade(f32),
    CustomScripted(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationPayload {
    FrameUpdate { new_frame: u32 },
    TweenValue { key: String, value: f32 },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimationUpdate {
    pub coord: TileCoord,
    pub payload: AnimationPayload,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnimationCommand {
    AnimateChunkSet {
        chunk_ids: Vec<ChunkId>,
        anim_type: AnimationType,
    },
    StartTestAnimation,
    SetTimeScale(f32),
    SetEnabled(bool),
    Shutdown,
}

pub type UpdateSender = UnboundedSender<AnimationUpdate>;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GenerationCommand {
    GenerateChunk { coords: TileCoord },
    SetGenerator { id: String },
    Shutdown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerationResponse {
    pub success: bool,
    pub message: String,
}

pub type AnimationConductorHandle = UnboundedSender<AnimationCommand>;

pub type CommandResult = Result<(), String>;

#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
pub struct AnimationState {
    pub time_scale: f32,
    pub is_enabled: bool,
}

impl AnimationState {
    pub fn set_time_scale(&mut self, scale: f32) {
        self.time_scale = scale;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.is_enabled = enabled;
    }
}

pub use super::generation_message::GenerationMessage as ChunkMessage;
// --- END: rust/ssxl_shared/src\message\messages.rs ---
         9 LOC | rust/ssxl_shared/src\message\mod.rs
// --- START: rust/ssxl_shared/src\message\mod.rs ---
// FILE: ssxl_shared/src/message/mod.rs

pub mod generation_message;
pub mod messages;

// FIX: Publicly re-export all necessary message and state types from the messages submodule.
// This resolves the unresolved imports (E0432) in ssxl_godot/api_initializers.rs.
pub use messages::{
    // New re-exports to fix current error
    AnimationCommand,
    AnimationState,
    
    // Existing re-exports
    AnimationUpdate,
    GenerationCommand, 
    GenerationResponse,
};
// --- END: rust/ssxl_shared/src\message\mod.rs ---
         2 LOC | rust/ssxl_shared/src\tile\mod.rs
// --- START: rust/ssxl_shared/src\tile\mod.rs ---
// ssxl_shared/src/tile/mod.rs

pub mod tile_data;
pub mod tile_type;
// --- END: rust/ssxl_shared/src\tile\mod.rs ---
        51 LOC | rust/ssxl_shared/src\tile\tile_data.rs
// --- START: rust/ssxl_shared/src\tile\tile_data.rs ---
// ssxl_shared/src/tile/tile_data.rs

//! # Tile Data Structures (`ssxl_shared::tile::tile_data`) 
//!
//! This module defines the `TileData` structure, which holds the minimal necessary
//! information for a single tile in the procedural world. It also includes utility
//! structures and bitmask constants (`tile_flags`) for efficient property management.
//! The use of `Copy` and `u8` flags is key to maintaining the high-speed "Tempo"
//! of the multi-threaded engine.

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};

// Re-exports a core math primitive for use in related structures (e.g., AnimationUpdate).
use ssxl_math::prelude::Vec2i;


// --- Core Data Structure ---

/// Represents the data payload for a single tile in a chunk.
///
/// Marked `Copy` for high performance, as tiles are frequently cloned/copied
/// within generation and rendering loops.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The material or type of tile (e.g., grass, rock, empty).
    pub tile_type: TileType,
    
    /// The raw noise value (e.g., Perlin, Simplex) used to determine this tile's type.
    /// This is crucial for seamless neighbor checks and debugging the procedural generation.
    pub noise_value: f32,
    
    /// A compact bitfield storing up to 8 boolean properties about the tile.
    pub flags: u8,
}

impl Default for TileData {
    /// Returns the default state for a tile: `TileType::Void` with zero noise and no flags set.
    // FIX: Removed `const` keyword to resolve error E0379 and E0015.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}


// --- Godot FFI Message Structure ---

/// Data structure used specifically for communication between the Rust engine
/// and the Godot runtime regarding tile animations.
///
/// This message is typically used by a dedicated rendering or animation system.
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub struct AnimationUpdate {
    /// The layer or dimension the tile belongs to.
    pub layer: i32,
    /// The source ID of the tile map or animation source.
    pub source_id: i32,
    /// The world coordinates of the tile to update.
    pub tile_coords: Vec2i,
    /// The new coordinates within the texture atlas for the tile's animation frame.
    pub new_atlas_coords: Vec2i,
}


// --- Bitwise Flag Constants ---

/// Bitmasks used to set, check, or clear properties in the `TileData::flags` field.
/// This maximizes data density by storing 8 booleans in a single byte (`u8`).
pub mod tile_flags {
    /// Bit 0: Is the tile physically passable by entities? (e.g., air, water surface)
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001;
    /// Bit 1: Is the tile currently visible/rendered by the client?
    pub const IS_RENDERED:   u8 = 0b0000_0010;
    /// Bit 2: Has this tile been manually changed post-generation by a player/editor?
    pub const IS_MODIFIED:   u8 = 0b0000_0100;
    /// Bit 3: Does this tile contain a gatherable resource or item?
    pub const HAS_RESOURCE:    u8 = 0b0000_1000;
    // Bits 4-7 are reserved for future properties.
}


impl TileData {
    /// Creates a new `TileData` instance with specified type and noise value.
    // FIX: Removed `const` keyword.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0, // Flags are initialized to zero (all false)
        }
    }

    /// Checks if the tile is considered a "solid" block, typically used for collision.
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub const fn is_solid(&self) -> bool {
        // Relies on a method in TileType to define "solidity."
        !self.tile_type.is_empty()
    }
    
    /// Sets or clears a property using a predefined **flag mask** (e.g., `tile_flags::IS_TRAVERSABLE`).
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            // Set the bit(s) (|= is bitwise OR assignment).
            self.flags |= flag_mask;
        } else {
            // Clear the bit(s) (&! is bitwise AND with the inverted mask).
            self.flags &= !flag_mask;
        }
    }

    /// Checks the status of a property using a predefined **flag mask**.
    // OPTIMIZATION: Force inlining this critical method.
    #[inline(always)]
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        // Returns true if any of the bits in the mask are set in self.flags.
        (self.flags & flag_mask) != 0
    }
}
// --- END: rust/ssxl_shared/src\tile\tile_data.rs ---
        60 LOC | rust/ssxl_shared/src\tile\tile_type.rs
// --- START: rust/ssxl_shared/src\tile\tile_type.rs ---
// ssxl_shared/src/tile/tile_type.rs

//! # Tile Type Enumeration (`ssxl_shared::tile::tile_type`)
//!
//! This module defines the canonical `TileType` enum, which identifies the material
//! or nature of a single tile. It is a fundamental data structure shared across
//! the entire SSXL-ext engine.
//!
//! **Critical Feature:** The use of `#[repr(u8)]` is a **memory optimization**
//! that guarantees the enum is stored as a single byte, drastically reducing the
//! memory footprint of the massive `ChunkData` tile arrays.

use serde::{Deserialize, Serialize};

/// Enumeration of all primary tile materials available in the procedural world.
///
/// Ensures strict memory layout as a single byte for efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    /// The default, empty state (e.g., air or background).
    Void = 0,
    /// A fluid, typically used for rivers, oceans, or lower areas.
    Water = 1,
    /// Base terrain, usually flat and traversable.
    Grass = 2,
    /// Elevated terrain, potentially difficult to traverse.
    Mountain = 3,
    /// An artificial boundary used to cap chunk edges or isolate generation regions.
    Boundary = 4,
    /// An engineered or placed structure (e.g., a ruin, road, or wall).
    Structure = 5,
    /// A solid, rocky, non-soil terrain type.
    Rock = 6,
    /// Reserved for generator-specific customization or future expansion.
    Custom1 = 7,
    /// Reserved for generator-specific customization or future expansion.
    Custom2 = 8,
    // Maximum defined variant value is 8.
}

// Constant to define the maximum valid u8 value for TileType.
pub const MAX_TILE_TYPE_VALUE: u8 = 8;


impl Default for TileType {
    /// The default state of a tile is always `TileType::Void` (empty).
    // FIX: Removed `const` keyword to resolve error E0379.
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Converts the `TileType` instance into its underlying `u8` representation.
    // OPTIMIZATION: Added inline hint and const fn for zero-cost conversion.
    #[inline(always)] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a raw `u8` value back into a `TileType`.
    ///
    /// Returns `None` if the input value does not correspond to a defined variant,
    /// ensuring safe deserialization.
    // OPTIMIZATION: Replaced verbose match with range check and unsafe transmute for zero-cost speed.
    #[inline(always)]
    pub fn from_u8(value: u8) -> Option<Self> {
        if value <= MAX_TILE_TYPE_VALUE {
            // SAFETY: We check that the value is within the contiguous range [0, 8]
            // of the #[repr(u8)] enum. This is a common pattern for fast enum conversion.
            Some(unsafe { std::mem::transmute(value) })
        } else {
            None
        }
    }
    
    /// Provides a simple, default unique ID for this tile type (equal to its u8 value).
    #[inline(always)]
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Provides default atlas coordinates (X, Y) for initial rendering/visual representation.
    ///
    /// This is a common lookup function used by the rendering component (`ssxl_godot`).
    #[inline(always)]
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // All default tiles are expected to be on the first row (Y=0) of the atlas.
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            // Void and unspecified types default to the origin (0, 0).
            _ => (0, 0), 
        }
    }
}


impl TileType {
    /// Checks if the tile type is one that a character can typically traverse (walk on).
    #[inline(always)]
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type is considered a fluid (e.g., for flow/buoyancy simulation).
    #[inline(always)]
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is empty (the default/void state).
    #[inline(always)]
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}
// --- END: rust/ssxl_shared/src\tile\tile_type.rs ---
        40 LOC | rust/ssxl_sync/src\animation_conductor.rs
// --- START: rust/ssxl_sync/src\animation_conductor.rs ---
// ssxl_sync/src/animation_conductor.rs (Type Resolution Fix)

use ssxl_shared::{
    AnimationConductorHandle,
    AnimationState,
    AnimationCommand, 
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tracing::info;

// FIX: Import the exact nested type required by the CoreAnimationWorker's signature 
// and alias it as `AnimationUpdate`. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: We rely on the core worker being defined as `conductor::AnimationConductor` within ssxl_animate.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct (for passing state between FFI stages)
// -----------------------------------------------------------------------------

/// Holds all the necessary internal channels and initial state required to spawn the
/// heavy, background Animation Conductor thread.
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,
    /// The receiver for Godot commands, which the worker thread will consume.
    pub command_receiver: UnboundedReceiver<AnimationCommand>,
    
    /// The sender for updates, which the worker thread will use.
    // This field now holds the correctly nested type due to the aliased import above.
    pub update_sender: UnboundedSender<AnimationUpdate>,
}

// -----------------------------------------------------------------------------
// 2. The Public Conductor Struct (The FFI-facing worker wrapper)
// -----------------------------------------------------------------------------

/// The SSXL Animation Conductor. This struct is responsible for executing the
/// animation logic in a background thread.
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup (Non-blocking)
    // -------------------------------------------------------------------------
    
    /// Creates all the necessary MPSC channels and the initial `AnimationState`.
    /// 
    /// # Returns
    /// A tuple containing:
    /// 1. `AnimationConductorInternalSetup`: The struct holding internal handles for spawning.
    /// 2. `AnimationConductorHandle`: The public command sender handle exposed to Godot's FFI layer.
    /// 3. `UnboundedReceiver<AnimationUpdate>`: The public update receiver handle exposed to Godot's Poller.
    pub fn setup_channels_and_state() -> (AnimationConductorInternalSetup, AnimationConductorHandle, UnboundedReceiver<AnimationUpdate>) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channels for commands from Godot to the worker.
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channels for updates from the worker to Godot (Poller).
        // This channel uses the correctly aliased type.
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        let initial_state = AnimationState::default();

        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        let public_command_handle = command_tx;

        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------

    /// Consumes the setup handles and spawns the core animation worker thread.
    /// 
    /// # Arguments
    /// * `setup`: The internal channels and initial state from the setup stage.
    /// 
    /// # Returns
    /// A new `AnimationConductor` instance representing the running worker.
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // This call is now correct because `setup.update_sender` holds the 
        // type the `CoreAnimationWorker::new` function requires.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the opaque public handle struct
        AnimationConductor {} 
    }
}
// --- END: rust/ssxl_sync/src\animation_conductor.rs ---
        47 LOC | rust/ssxl_sync/src\lib.rs
// --- START: rust/ssxl_sync/src\lib.rs ---
// FILE: ssxl_sync/src/lib.rs

//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//! 
//! This crate defines core thread-safe primitives, thread pool management, 
//! and high-level FFI channel handles for communication across the engine's asynchronous boundary.

use tokio::sync::mpsc;
use std::ops::{Deref, DerefMut}; // Required for implementing the FFI Handle wrapper

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import all core contract types from ssxl_shared.
use ssxl_shared::{
    SSXLError,
    AnimationUpdate,
    AnimationCommand,
};
// FIX: Import and public re-export the core struct in one step to avoid E0252/E0365.
pub use ssxl_animate::AnimationConductor;

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

/// Defines core thread-safe types, enums, and channel aliases used for concurrency and communication.
pub mod primitives;

/// Manages the generic, fixed-size thread pool used for synchronous, CPU-intensive tasks.
pub mod pool;

/// Manages the dedicated worker thread and state for calculating visual animation frames.
pub mod animation_conductor;


// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

// --- 1. Generic Primitives and Utility Functions (from primitives) ---

/// Re-exports of generic thread-safe resource wrappers and synchronous channels.
pub use primitives::{
    AtomicResource,
    create_unbounded_channel,
};

// --- 2. Thread Pool Manager Types (from pool_manager) ---

/// Re-exports of all public types related to the generic CPU worker thread pool.
pub use pool::{
    WorkerPool,
    GenerationTask,
    ConductorResult,
    Task,
    TaskResult
};

// --------------------------------------------------------------------------------
// --- Final FFI Wrappers and Type Aliases (CRATE ROOT API) ---
// --------------------------------------------------------------------------------

// The Receiver half of the command channel for the AnimationConductor.
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;

// The UnboundedSender type is used to send updates (e.g., animation frames) back to the main thread.
pub type UpdateSender = mpsc::UnboundedSender<AnimationUpdate>;

// The standard result wrapper, using SSXLError.
pub type CommandResult = Result<(), SSXLError>;


/// The **Animation Conductor Handle**. 
/// 
/// **FIX:** Changed from a type alias to a public struct wrapping the channel sender. 
/// This allows us to implement the `::new()` constructor required by the FFI layer (`ssxl_godot`), 
/// resolving `error[E0599]`.
pub struct AnimationConductorHandle {
    inner: mpsc::UnboundedSender<AnimationCommand>,
}

impl AnimationConductorHandle {
    /// Public constructor required by the FFI layer (`ssxl_godot/api_initializers.rs`).
    /// Allows the FFI layer to wrap the raw channel sender into this opaque handle.
    pub fn new(inner: mpsc::UnboundedSender<AnimationCommand>) -> Self {
        AnimationConductorHandle { inner }
    }
    
    // FIX (E0599): Adds the method to access the inner sender, allowing the FFI layer
    // to call `.inner().clone()` and re-wrap the result in ssxl_godot/src/engine/init.rs.
    pub fn inner(&self) -> &mpsc::UnboundedSender<AnimationCommand> {
        &self.inner
    }
}

// Allows the struct to be used as if it were the underlying `mpsc::UnboundedSender`.
impl Deref for AnimationConductorHandle {
    type Target = mpsc::UnboundedSender<AnimationCommand>;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

// Provides mutable access to the underlying sender.
impl DerefMut for AnimationConductorHandle {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
// --- END: rust/ssxl_sync/src\lib.rs ---
        96 LOC | rust/ssxl_sync/src\pool.rs
// --- START: rust/ssxl_sync/src\pool.rs ---
//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::prelude::Vec2i;
// FIX: Import ChunkData directly from the root of ssxl_shared to resolve both E0433 errors.
use ssxl_shared::ChunkData; 

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    // FIX 1 (Line 47): Use the directly imported ChunkData.
    CompletedChunk(Arc<ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // FIX 2 (Line 130): Use the directly imported ChunkData.
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
// --- END: rust/ssxl_sync/src\pool.rs ---
        27 LOC | rust/ssxl_sync/src\primitives.rs
// --- START: rust/ssxl_sync/src\primitives.rs ---
// ssxl_sync/src/primitives.rs

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
// DELETE: tracing::info removed (placeholder worker function removed)

// --------------------------------------------------------------------------------
// --- Thread-Safe Resource Management (AtomicResource) ---
// --------------------------------------------------------------------------------

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline(always)] // O(1) Accessor: Force inlining
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline(always)] // O(1) Mutator: Force inlining
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

// --------------------------------------------------------------------------------
// --- Synchronization Primitives (Channels) ---
// --------------------------------------------------------------------------------

/// Creates an unbounded, multi-producer, single-consumer channel.
/// Generic over message type `M` (Zero Entropy).
pub fn create_unbounded_channel<M>() -> (Sender<M>, Receiver<M>) {
    unbounded()
}
// DELETE: start_sync_worker placeholder removed (non-primitive code).
// --- END: rust/ssxl_sync/src\primitives.rs ---
        50 LOC | rust/ssxl_tools/src\lib.rs
// --- START: rust/ssxl_tools/src\lib.rs ---
//! # SSXL Engine Tools (`ssxl_tools`)
//!
//! Provides utility functions for **configuration management**, **data validation**,
//! and other engine-wide tooling not specific to generation or synchronization.

// MINIMALIST IMPORTS: Removed regex, Lazy, Read, and ssxl_shared::SSXLData
use tracing::{info, warn};
use std::io;
use std::fs::File; // Kept for configuration file existence check

// --------------------------------------------------------------------------------
// --- Configuration Constants ---
// --------------------------------------------------------------------------------

/// The default file path to check for engine configuration.
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
/// The ID of the generator used when configuration loading fails or is not specified.
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
/// The default Cellular Automata ruleset ID to use.
const DEFAULT_CA_RULESET: u8 = 0;

// --------------------------------------------------------------------------------
// --- SSXL Configuration Management ---
// --------------------------------------------------------------------------------

#[derive(Debug, Clone)]
/// Configuration structure holding key engine settings, primarily for generation defaults.
pub struct SSXLConfig {
    /// The ID of the world generator to use when no specific one is requested.
    default_generator_id: String,
    /// The default ruleset ID for the Cellular Automata generator.
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Creates a new `SSXLConfig` instance populated with hardcoded default values.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to read and simulate loading engine configuration from a file path.
    ///
    /// The file content is not read (O(0) optimization) as it is currently simulated.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(_file) => {
                // O(0) Optimization: Config parsing is simulated, eliminating O(N) file read overhead.
                info!("SSXLConfig: Config file found. Simulating config override (No TOML parsing).");
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), // Simulated override
                    ca_default_ruleset: 1,                              // Simulated override
                })
            },
            // Propagate standard I/O error to the public getter for logging.
            Err(e) => Err(e),
        }
    }

    /// Returns the configured default generator ID string. (O(1) Accessor)
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Returns the configured default Cellular Automata ruleset ID. (O(1) Accessor)
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Attempts to load the configuration from the specified path.
///
/// If file loading fails, it logs a warning and returns hardcoded defaults (safe fallback).
/// **O(0) Entropy Fix**: Returns `SSXLConfig` directly, reflecting the guaranteed success (safe fallback).
pub fn get_config_from_path(path: Option<&str>) -> SSXLConfig {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            config
        },
        Err(e) => {
            // Safe fallback: Logs failure but ensures the engine initializes with defaults.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            SSXLConfig::new_with_defaults()
        }
    }
}

// --------------------------------------------------------------------------------
// --- DEPRECATED/REDUNDANT CODE REMOVED ---
// --------------------------------------------------------------------------------
// DELETED: Static CONFIG and get_config() (Deprecated).
// DELETED: ID_REGEX, validate_data_id, and initialize() (Redundant validation on u64).
// --- END: rust/ssxl_tools/src\lib.rs ---
       147 LOC | rust/ssxl_cli/src\actions\actions.rs
// --- START: rust/ssxl_cli/src\actions\actions.rs ---
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

pub fn run_communication_channel_test() {
    info!("TEST [2]: Starting Async Communication Channel Validation (Thread Jump Tempo Check)...");
    
    let (tx, rx) = mpsc::channel::<(String, String)>();

    let engine_test_thread = thread::spawn(move || {
        info!("WORKER: Starting 500ms sleep simulation (Simulating heavy map chunk 1 work)...");
        thread::sleep(Duration::from_millis(500));
        
        let message = "Async signal emission successful. Latency: 500ms".to_string();
        
        if tx.send(("TEST_COMPLETE".to_string(), message)).is_err() {
            error!("WORKER: Failed to send test signal. Receiver dropped (Godot side crashed?).");
        } else {
            info!("WORKER: Successfully sent TEST_COMPLETE signal back to main thread.");
        }
    });

    match rx.recv_timeout(Duration::from_secs(2)) {
        Ok((status, message)) => {
            if status == "TEST_COMPLETE" {
                info!("✅ SUCCESS: Communication Channel Validated. {}", message);
                info!("   Thread jump integrity confirmed.");
            } else {
                error!("❌ FAIL: Received incorrect status: {}", status);
            }
        },
        Err(mpsc::RecvTimeoutError::Timeout) => {
            error!("❌ FAIL: Timeout (2s). Communication channel failed to establish required tempo.");
        },
        Err(mpsc::RecvTimeoutError::Disconnected) => {
            error!("❌ FAIL: Worker thread disconnected unexpectedly (Systemic Entropy).");
        }
    }
    
    engine_test_thread.join().unwrap();
}

pub fn run_map_generation_test() {
    info!("TEST [4]: Starting Map Generation Flow Validation (Procedural Purity & Streaming)...");

    let (data_tx, data_rx) = mpsc::channel::<usize>();
    let (done_tx, done_rx) = mpsc::channel::<()>();    

    let total_chunks = 5;
    let engine_gen_thread = thread::spawn(move || {
        info!("WORKER: Starting map generation for {} chunks.", total_chunks);
        
        for i in 1..=total_chunks {
            thread::sleep(Duration::from_millis(50));
            
            if data_tx.send(i).is_err() {
                warn!("WORKER: Data channel dropped after chunk {}. Stopping.", i);
                return;
            }
            info!("WORKER: Emitted Chunk #{} (Data Payload Crypto Coded).", i);
        }
        
        if done_tx.send(()).is_err() {
             error!("WORKER: Failed to send generation_complete signal.");
        }
        info!("WORKER: Generation finished.");
    });

    let mut chunks_received = 0;
    
    loop {
        match data_rx.recv_timeout(Duration::from_millis(10)) {
            Ok(chunk_id) => {
                chunks_received += 1;
                info!("MAIN: Processed Chunk #{} (Data Channel) - Tempo maintained.", chunk_id);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                if done_rx.try_recv().is_ok() {
                    info!("MAIN: Detected Completion Signal (Generation Complete).");
                    break;
                }
                thread::sleep(Duration::from_millis(1));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                error!("❌ FAIL: Data channel disconnected prematurely (Systemic Entropy).");
                break;
            }
        }
        
        if done_rx.try_recv().is_ok() {
            info!("MAIN: Detected Completion Signal (Generation Complete).");
            break;
        }
    }
    
    engine_gen_thread.join().unwrap();
    
    if chunks_received == total_chunks {
        info!("✅ SUCCESS: Map Generation Flow Validated. Received {}/{} chunks.", chunks_received, total_chunks);
        info!("   All data channels validated and quantum alignment achieved.");
    } else {
        error!("❌ FAIL: Map Generation Failed. Expected {} chunks, received {}.", total_chunks, chunks_received);
    }
}

pub fn run_data_channel_test() {
    info!("TEST [3]: Starting Chunk/Tile Data Channel Integrity Check...");
    
    info!("TEST [3]: Data channel integrity is validated implicitly and explicitly.");
    info!("   Implicitly: By checking successful channel send/receive in Action 4.");
    info!("   Explicitly: The FFI data type validation logic should be integrated here.");
    
    run_map_generation_test();
}

pub fn run_animation_conductor_test() {
    info!("TEST [5]: Starting Animation Conductor Tempo Validation (High-Frequency Loop Check)...");

    let (tx, rx) = mpsc::channel::<u64>();
    let required_signals = 120;
    let target_duration = Duration::from_millis(2000);

    let conductor_thread = thread::spawn(move || {
        info!("WORKER: Animation Conductor spun up. Targeting high tempo signal emission.");
        let start_time = Instant::now();
        let mut count = 0;
        
        while start_time.elapsed() < target_duration {
            thread::sleep(Duration::from_nanos(8333));
            
            if tx.send(start_time.elapsed().as_micros() as u64).is_err() {
                warn!("WORKER: Conductor signal dropped (Receiver disconnected).");
                return;
            }
            count += 1;
        }
        info!("WORKER: Conductor stopped. Emitted {} signals.", count);
    });

    let mut signals_received = 0;
    let mut min_latency_us = u64::MAX;
    let mut max_latency_us = 0;
    let main_start_time = Instant::now();

    while main_start_time.elapsed() < target_duration + Duration::from_millis(500) {
        match rx.recv_timeout(Duration::from_millis(1)) {
            Ok(timestamp_us) => {
                signals_received += 1;
                let elapsed_us = main_start_time.elapsed().as_micros() as u64;
                let latency_us = elapsed_us.saturating_sub(timestamp_us);
                
                min_latency_us = min_latency_us.min(latency_us);
                max_latency_us = max_latency_us.max(latency_us);
            },
            Err(mpsc::RecvTimeoutError::Timeout) => {
                thread::sleep(Duration::from_nanos(100));
            },
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                info!("MAIN: Conductor thread finished/disconnected.");
                break;
            }
        }
    }

    conductor_thread.join().unwrap();
    
    let success = signals_received >= required_signals;
    
    if success {
        info!("✅ SUCCESS: Animation Conductor Tempo Validated.");
        info!("   Target Signals: {} | Received: {}", required_signals, signals_received);
        info!("   Latency (Main Thread Read Lag): Min {}µs, Max {}µs.", min_latency_us, max_latency_us);
    } else {
        error!("❌ FAIL: Animation Conductor FAILED to achieve required tempo.");
        error!("   Expected signals: {} | Received: {}. Check worker thread throttling.", required_signals, signals_received);
        error!("   Latency range suggests systemic entropy in signal marshalling.");
    }
}
// --- END: rust/ssxl_cli/src\actions\actions.rs ---
        66 LOC | rust/ssxl_cli/src\actions\benchmarking.rs
// --- START: rust/ssxl_cli/src\actions\benchmarking.rs ---
use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering}
};
use std::thread;
use std::time::Duration;
use ctrlc;

// FIX E0432: Conductor and ConductorStatus are found in the `conductor` module.
use ssxl_generate::conductor::{Conductor, ConductorStatus};


pub fn start_signal_inspector() {
    warn!("🔮 Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // FIX E0308: Conductor::new now returns 4 elements. We destructure the fourth 
    // element (_progress_receiver) to ignore it here, as the CLI inspects the 
    // ConductorState directly, not the message channel.
    let (conductor, state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    if let Err(e) = ctrlc::set_handler(move || {
        r_for_handler.store(false, Ordering::SeqCst);

        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    let mut frame_count: u64 = 0;
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        print!("\r");
        print!("🔮 LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        let _ = io::stdout().flush();

        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        thread::sleep(Duration::from_millis(50));
    }

    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}

#[allow(dead_code)]
pub fn run_benchmark() {
    warn!("⏱️ Benchmark execution not yet implemented. Placeholder called.");
}
// --- END: rust/ssxl_cli/src\actions\benchmarking.rs ---
       102 LOC | rust/ssxl_cli/src\actions\godot_harness.rs
// --- START: rust/ssxl_cli/src\actions\godot_harness.rs ---
// FILE: ssxl_cli/src/actions/godot_harness.rs

//! # CLI Actions: Godot Harness (`ssxl_cli::actions::godot_harness`)
//!
//! Utilities for managing and launching the Godot editor or the Godot game
//! client from the command line, including necessary setup steps like copying
//! the compiled Rust dynamic library (DLL/SO/DYLIB) into the Godot project's
//! GDExtension directory.

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Imports of constants and utility functions from the parent module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


/// Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the `target/release`
/// or `target/debug` folder to the Godot tester project's GDExtension directory.
///
/// This is a critical step to ensure Godot loads the latest engine code.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // --- 1. Construct Source Path ---
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    // Navigate to the target directory (e.g., `target/debug/`).
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    // Add the DLL file name (e.g., `SSXL_engine.dll`).
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // --- 2. Construct Destination Path ---
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    // Navigate to the Godot project's GDExtension folder.
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    // Add the DLL file name.
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // --- 3. Validation and Copy ---

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        // Treat missing source as a non-fatal warning to continue CLI usage.
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "✅ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            // This often fails if the target DLL is locked by a running Godot instance.
            Err(format!(
                "❌ FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}


/// Launches the Godot Editor in a non-blocking subprocess.
pub fn launch_godot_client() {
    info!("🚀 LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    // Execute the Godot process.
    match Command::new(GODOT_EXE_PATH)
        // Flag to launch the editor window instead of running the game directly.
        .arg("--editor")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously, allowing the CLI process to continue.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}

/// Launches Godot in a non-blocking subprocess using the `--headless` flag.
/// 
/// This is used for automated testing where no GUI is needed.
pub fn launch_headless_godot() {
    info!("🚀 LAUNCHING: Godot Headless Client...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    // FIX: Call .display() on PathBuf to implement Display trait
    info!("Loading project at (Absolute Path): {}", project_path_abs.display()); 

    match Command::new(GODOT_EXE_PATH)
        // Flag to run Godot without a graphical interface.
        .arg("--headless")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot HEADLESS client spawned successfully.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot headless command: {}", e);
            warn!(
                "Please ensure the Godot executable is correctly set in the path configuration: {}", 
                GODOT_EXE_PATH
            );
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\godot_harness.rs ---
        25 LOC | rust/ssxl_cli/src\actions\godot_tests.rs
// --- START: rust/ssxl_cli/src\actions\godot_tests.rs ---
use super::{
    run_godot_test, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

/// Runs the FFI Bridge/GDExtension validation test in Godot.
pub fn run_ffi_bridge_validation() {
    run_godot_test(
        "FFI Bridge and GDExtension Integration Validation",
        GODOT_TEST_SCENE,
        "FFI/GDExtension Bridge VALIDATION SUCCEEDED!",
    );
}

/// Runs the Headless Map Generation Integration Test (Full Pipeline Validation).
pub fn run_headless_generation_integration_test() {
    run_godot_test(
        "Headless Map Generation Integration Test",
        HEADLESS_GEN_TEST_SCENE,
        "Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.",
    );
}

/// Runs the Headless Animation Conductor Tempo Test (Signal Latency Check).
pub fn run_headless_animation_tempo_test() {
    run_godot_test(
        "Headless Animation Conductor Tempo Test",
        HEADLESS_ANIM_TEST_SCENE,
        "Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.",
    );
}
// --- END: rust/ssxl_cli/src\actions\godot_tests.rs ---
        46 LOC | rust/ssxl_cli/src\actions\mod.rs
// --- START: rust/ssxl_cli/src\actions\mod.rs ---
// FILE: ssxl_cli/src/actions/mod.rs

//! # CLI Actions Module (`ssxl_cli::actions`)
//!
//! This module acts as the public interface (façade) for all complex command-line
//! actions, such as launching Godot, running tests, or initiating benchmarks.
//! It aggregates constants, external dependencies, and exports from its child modules.

use std::env;
use std::path::PathBuf;

// --- Internal Modules ---

/// Tools for real-time monitoring of the Conductor and placeholder for benchmark logic.
mod benchmarking;
/// Utilities for launching and managing the external Godot engine tester project.
mod godot_harness;
/// The main menu and delegation stub for all test suites.
mod testing;
/// Contains self-contained architectural and data validation tests.
mod test_suites;
/// Contains tests requiring external processes like `cargo` and Godot FFI validation.
mod test_core_suites;

// --- Configuration Constants ---

/// The absolute path to the Godot executable file.
pub const GODOT_EXE_PATH: &str = "C:/ZV9/zv9.SSXL-ext/SSXL_engine_tester/godot.windows.editor.x86_64.exe"; 
/// The project-relative path fragment pointing to the GDExtension folder (e.g., `godot_tester_project/gde/`).
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXLtester2/";
/// The expected file name of the compiled Rust dynamic library (e.g., `ssxl_engine.dll`).
pub const DLL_NAME: &str = "ssxl_engine.dll";
/// The project-relative path fragment where the compiled DLL is found (e.g., `target/debug/`).
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
/// The scene path within the Godot project used for FFI bridge validation tests.
pub const GODOT_TEST_SCENE: &str = "res://tests/ffi_bridge_test.tscn"; 

// --- NEW HEADLESS TEST SCENES ---
/// The scene path within the Godot project used for headless generation pipeline validation.
pub const HEADLESS_GEN_TEST_SCENE: &str = "res://tests/headless_gen_pipeline.tscn";
/// The scene path within the Godot project used for headless animation tempo validation.
pub const HEADLESS_ANIM_TEST_SCENE: &str = "res://tests/headless_anim_tempo.tscn";
// --- END NEW HEADLESS TEST SCENES ---

// --- Utility Functions ---

/// Calculates the absolute path to the Godot tester project root.
pub fn get_godot_project_abs_path() -> Result<PathBuf, String> {
    let mut path = env::current_dir()
        .map_err(|e| format!("Failed to get current directory: {}", e))?;
    path.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    if path.pop() {
        Ok(path)
    } else {
        Err(format!(
            "Failed to determine parent directory for project path: {}",
            path.display()
        ))
    }
}


// --- Public Module Exports (Façade) ---

/// Re-export for starting the **real-time status feed**.
pub use benchmarking::start_signal_inspector;

// Exports from godot_harness (Includes the requested launch_headless_godot).
pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
    launch_headless_godot,
};

// Exports from test_core_suites.
pub use test_core_suites::{
    run_cargo_tests,
    run_ffi_bridge_validation,
    // --- ADDING NEW HEADLESS TESTS ---
    run_headless_generation_integration_test,
    run_headless_animation_tempo_test,
};

// Exports from test_suites.
pub use test_suites::{
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};


/// Exports related to **testing and validation**.
#[allow(unused_imports)]
pub use testing::execute_testing_menu;
// --- END: rust/ssxl_cli/src\actions\mod.rs ---
        36 LOC | rust/ssxl_cli/src\actions\testing.rs
// --- START: rust/ssxl_cli/src\actions\testing.rs ---
// FILE: ssxl_cli/src/actions/testing.rs

//! # CLI Actions: Testing Utilities (`ssxl_cli::actions::testing`)
//!
//! Provides a menu for executing various test suites, delegating the complex
//! execution logic to the internal `test_suites` and external `test_core_suites` modules.

use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;      // Architectural tests
use crate::actions::test_core_suites; // External tests
use std::sync::LazyLock;              // NEW: Used for lazy, thread-safe static initialization

// --- Menu Setup Logic ---

// FIX 1 & 2: Use LazyLock to initialize the actions at runtime (solving E0015) 
// and store them in a Vec<CliAction>. The CliAction struct itself must have 
// been updated in cli_util_menu.rs to include Send + Sync bounds (solving E0277).
#[allow(dead_code)]
static TEST_ACTIONS: LazyLock<Vec<CliAction>> = LazyLock::new(|| vec![
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
    // FIX 2: Added the "back" action which is used to exit the loop
    CliAction::new("back", "↩️ Return to Main Menu"), 
]);

/// Central entry point for all CLI testing actions.
#[allow(dead_code)]
pub fn execute_testing_menu() -> Result<(), String> {
    // FIX 3: Get a slice from the LazyLock Vec to satisfy CliMenu's 'a [CliAction] requirement.
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS.as_slice());
    
    loop {
        // FIX 4: `*s == "id"` and no misplaced `Ok(())` returns are now correct.
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if *s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
            }
            CliAction { id: ref s, .. } if *s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
            }
            CliAction { id: ref s, .. } if *s == "channel" => {
                test_suites::run_communication_channel_test(); 
            }
            CliAction { id: ref s, .. } if *s == "generation" => {
                test_suites::run_map_generation_test(); 
            }
            CliAction { id: ref s, .. } if *s == "animation" => {
                test_suites::run_animation_conductor_test(); 
            }
            CliAction { id: ref s, .. } if *s == "back" => return Ok(()),
            _ => continue,
        }
    }
}
// --- END: rust/ssxl_cli/src\actions\testing.rs ---
       103 LOC | rust/ssxl_cli/src\actions\tests_core.rs
// --- START: rust/ssxl_cli/src\actions\tests_core.rs ---
use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, 
    // Keep constants here for completeness, or only required ones if splitting strictly
    // by dependencies. Keeping them here allows `run_godot_test` to access them.
    GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE, HEADLESS_GEN_TEST_SCENE,
};

/// Runs the full cargo test suite.
pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}

/// Helper function to read all output from a stream in a non-blocking way. (O(n) on stream size)
fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

/// Generic runner for Godot-based integration tests.
/// Extracts all boilerplate for spawning and output piping.
pub(crate) fn run_godot_test(
    test_title: &str,
    test_scene: &str,
    success_message: &str,
) -> bool {
    info!("🔥 STARTING: {}...", test_title);

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ {} failed: {}", test_title, e);
            return false;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(test_scene)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process for {}: {}", test_title, e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return false;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait for {}: {}", test_title, e);
            return false;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());
    
    // Output formatting and final result logging.
    println!("\n--- GODOT {} TEST OUTPUT START ---", test_title.to_uppercase());
    println!("{}", stdout_output);
    println!("--- GODOT {} TEST OUTPUT END ---\n", test_title.to_uppercase());

    if status.success() {
        info!("✅ {} SUCCEEDED! {}", test_title, success_message);
        true
    } else {
        error!(
            "❌ {} FAILED! Exit code: {:?}",
            test_title,
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
        false
    }
}
// --- END: rust/ssxl_cli/src\actions\tests_core.rs ---
       234 LOC | rust/ssxl_cli/src\actions\test_core_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_core_suites.rs ---
use std::io::{self, BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use tracing::{error, info, warn};

use super::{
    get_godot_project_abs_path, GODOT_EXE_PATH, GODOT_TEST_SCENE, HEADLESS_ANIM_TEST_SCENE,
    HEADLESS_GEN_TEST_SCENE,
};

pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}

fn read_all_output_from_stream<R: io::Read + Send + 'static>(stream: R) -> String {
    let mut reader = BufReader::new(stream);
    let mut output = String::new();
    loop {
        let mut line = String::new();
        match reader.read_line(&mut line) {
            Ok(0) => break,
            Ok(_) => output.push_str(&line),
            Err(_) => break,
        }
    }
    output
}

pub fn run_ffi_bridge_validation() {
    info!("🔥 STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(GODOT_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!(
            "❌ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_generation_integration_test() {
    info!("🔥 STARTING: Headless Map Generation Integration Test (Full Pipeline Validation)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_GEN_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS GENERATION TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS GENERATION TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Generation Integration Test SUCCEEDED! Quantum alignment confirmed.");
    } else {
        error!(
            "❌ Headless Generation Integration Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}

pub fn run_headless_animation_tempo_test() {
    info!("🔥 STARTING: Headless Animation Conductor Tempo Test (Signal Latency Check)...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };

    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--path")
        .arg(&project_path_abs)
        .arg("--headless")
        .arg("--no-window")
        .arg("--verbose")
        .arg("--display-print")
        .arg("--render-loop-time-slice")
        .arg("1")
        .arg("--main-scene")
        .arg(HEADLESS_ANIM_TEST_SCENE)
        .arg("--run")
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!(
                "Please ensure the Godot executable is in the correct path: {}",
                GODOT_EXE_PATH
            );
            return;
        }
    };

    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || read_all_output_from_stream(stdout));
    let stderr_handle = thread::spawn(move || read_all_output_from_stream(stderr));

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle
        .join()
        .unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle
        .join()
        .unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    println!("\n--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT START ---\n");
    println!("{}", stdout_output);
    println!("--- GODOT HEADLESS ANIMATION TEMPO TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ Headless Animation Tempo Test SUCCEEDED! Faster-than-light speed confirmed.");
    } else {
        error!(
            "❌ Headless Animation Tempo Test FAILED! Exit code: {:?}",
            status.code()
        );
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
// --- END: rust/ssxl_cli/src\actions\test_core_suites.rs ---
       107 LOC | rust/ssxl_cli/src\actions\test_suites.rs
// --- START: rust/ssxl_cli/src\actions\test_suites.rs ---
// FILE: ssxl_cli\src\actions\test_suites.rs

//! # Internal Architectural and Data Validation Suites
//!
//! Contains self-contained Rust tests focused on validating internal data contracts,
//! concurrency models (channels), and core generation logic without external
//! process reliance.

use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

// --- Project Imports ---
use ssxl_generate::Generator;
// FIX E0432: `perlin_generator` likely renamed to `perlin`.
use ssxl_generate::perlin::PerlinGenerator;
use ssxl_math::prelude::Vec2i;
// FIX E0432: Correct path to Chunk data constant.
use ssxl_shared::chunk::chunk_data::CHUNK_SIZE;
// FIX E0432: Correct path to Tile data struct.
use ssxl_shared::tile::tile_data::AnimationUpdate;


// -----------------------------------------------------------------------------
// FOCUSED ARCHITECTURAL VALIDATION
// -----------------------------------------------------------------------------

/// Validates the non-blocking mpsc channels used between the Godot main thread
/// and the Rust worker threads (Generation and Animation Conductors).
pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    // 1. Create a channel pair: (CLI sends, Mock Conductor receives)
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    // 2. Spawn a thread to act as the Mock Conductor
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    // 3. CLI (main thread) floods the channel with messages
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1));
    }
    
    drop(cli_sender);

    // 4. Wait for the Mock Conductor thread to complete and get the result
    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("❌ Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    // 5. Report results
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("✅ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("❌ Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}


/// Alias for `run_communication_channel_test`. Validates data-channel functionality.
pub fn run_data_channel_test() {
    run_communication_channel_test();
}

/// Validates the core map generation logic by creating a chunk using the Perlin Generator.
pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords);
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("✅ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("❌ Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

/// Validates the data contract for the Animation Conductor by ensuring
/// the `AnimationUpdate` structure can be serialized and deserialized.
pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("❌ Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("❌ Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("✅ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("❌ Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}
// --- END: rust/ssxl_cli/src\actions\test_suites.rs ---
       129 LOC | rust/ssxl_cli/src\cli_util_bench.rs
// --- START: rust/ssxl_cli/src\cli_util_bench.rs ---
// ssxl_cli\src\cli_util_bench.rs

use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc,
    atomic::{AtomicU64, Ordering}
};
use std::io::{self, Write};
use std::time::Duration;

use ssxl_generate::benchmark_generation_workload;
use ssxl_generate::conductor::Conductor;
use ssxl_math::prelude::Vec2i;

pub fn test_generation_and_placement_cli() {
    warn!("🧪 Running CLI Test: Generation and Placement (Conductor Validation)...");

    let (mut conductor, _state, _request_sender, _progress_receiver) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    let perlin_id = "perlin_basic_2d";
    if conductor.set_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            // FIX: Use the correct synchronous generation method: `get_chunk_data`
            let _chunk = conductor.get_chunk_data(&coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    let ca_id = "cellular_automata_basic";
    if conductor.set_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        // FIX: Use the correct synchronous generation method: `get_chunk_data`
        let _chunk = conductor.get_chunk_data(&coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    if chunks_generated > 0 {
        info!("✅ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).",
            chunks_generated,
            conductor.get_active_generator_id()
        );
    } else {
        error!("❌ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    conductor.graceful_teardown();
}


pub fn run_bitmask_conversion() {
    warn!("🧪 Starting bitmask conversion from world.png (Placeholder)...");

    let tiles_placed = 5000;
    
    info!("✅ Conversion complete. Tiles placed: {}", tiles_placed);
}

pub fn run_max_grid_benchmark() {
    warn!("🧪 Starting Max Grid Benchmark (Real Workload)...");
    
    const WORKLOAD_TILES: u64 = 100_000_000;

    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    let workload_handle = thread::spawn(move || {
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone);
    });

    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            let throughput = if elapsed > 0.0 {
                (current as f64 / elapsed).round() as u64
            } else {
                0
            };

            print!("\r⏳ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s",
                percentage,
                current / 1_000_000,
                WORKLOAD_TILES / 1_000_000,
                throughput
            );
            let _ = io::stdout().flush();

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    let start = Instant::now();
    
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        let _ = println!("\r❌ Benchmark failed: Generation thread panic. {: <100}", " ");
        return;
    }
    
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    println!("\r✅ Benchmark complete. Workload: {} tiles. Duration: {:.2}s",
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("⚡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("⚡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        if throughput_sec >= ITERATION5_TARGET {
            info!("🚀 CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("📈 Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("⚠️ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("❌ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}
// --- END: rust/ssxl_cli/src\cli_util_bench.rs ---
       137 LOC | rust/ssxl_cli/src\cli_util_inspect.rs
// --- START: rust/ssxl_cli/src\cli_util_inspect.rs ---
use walkdir::WalkDir;
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex;
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration;


pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| 🌲 RUST WORKSPACE MODULE TREE (Scanning...)                            |");
	println!("=========================================================================");
	
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n🔍 Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "├── [CORE] "
                            } else {
                                "│   └── "
                            };
                            
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


pub fn print_godot_api_surface() {
	// --- STRATEGIC UPDATE: Include the new aggregated API file from the 'engine' module. ---
	let godot_api_files: [&str; 4] = [ 
        // 🎯 FIX: The new main file containing all #[func] methods.
        "ssxl_godot/src/engine/init.rs",
        // Retaining the two GDExtension helper classes (Oracle, Signals)
        "ssxl_godot/src/ffi/oracle.rs",      
        "ssxl_godot/src/ffi/signals.rs",
        // Retaining the FFI Core library
        "ssxl_engine_ffi/src/lib.rs", 
    ];

    println!("🧪 API scan triggered (targeting {} files in ssxl_godot/src/ and FFI core)...", godot_api_files.len());
    
	// --- MASTER REGEX FOR ALL CALLABLE METHODS (FIXED ESCAPING) ---
    let method_regex = Regex::new(
        r#"(?s)(?:\s*#\[func\].*?|#\[no_mangle\].*?pub\s+extern\s+"C"\s*)\s*(?:pub\s+fn|fn)\s+(\w+)\s*(\([^\{;]*)\s*(?:->\s*([^\{]*))?"#
    ).unwrap();

	// Signal regex remains robust for line-based #[signal] definitions
    let signal_signature_regex = Regex::new(
        r"^\s*fn\s+(\w+)\s*(\([^;]*)\s*;\s*$"
    ).unwrap();
    let signal_marker_regex = Regex::new(r"^\s*#\[signal\]\s*$").unwrap();
    
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();
    let mut api_signals: Vec<(String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let path: &Path = Path::new(file_path_str);
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        
        let mut signal_line_pending = false;

        match fs::read_to_string(path) {
            Ok(contents) => {
                info!("Successfully read {}", path.display());
                
				// --- METHOD SCAN (Single Pass over File Content) ---
                for cap in method_regex.captures_iter(&contents) {
                    let method_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                    let args = cap.get(2)
                        .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                        .unwrap_or_default();
                    let return_type = cap.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                    
                    // Simple cleanup for args
                    let clean_args = args.replace("self, ", "self,").trim().trim_start_matches("self").trim_start_matches(",").trim().to_string();

                    api_methods.push((method_name, clean_args, return_type, file_name.to_string()));
                }


				// --- SIGNAL SCAN (Line-by-Line, No Change Needed) ---
                for line in contents.lines() {
                    let trimmed_line = line.trim();

                    if signal_marker_regex.is_match(trimmed_line) {
                        signal_line_pending = true;
                        continue;
                    }
                    
                    if signal_line_pending {
                        if let Some(captures) = signal_signature_regex.captures(trimmed_line) {
                            let signal_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_signal").to_string();
                            let args = captures.get(2)
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            api_signals.push((signal_name, args, file_name.to_string()));
                            signal_line_pending = false; 
                        } else if !trimmed_line.is_empty() {
                            signal_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- 🎮 SSXL Engine Developer MASTER API Surface ---");
    
    println!("\n✅ Callable Methods ({} total):", api_methods.len());
    if api_methods.is_empty() {
        warn!(" No callable methods found in targeted files (check FFI core!).");
    } else {
        for (name, args, return_type, source_file) in &api_methods {
            // Highlighting the low-level FFI entry points for clarity
            let marker = if source_file == "lib.rs" && api_methods.iter().any(|(n,_,_,s)| n == name && s == source_file) {
                "[FFI CORE]"
            } else {
                "[GDExt]"
            };
            println!(" > func {}({}) -> {} {} [{}]", name, args, return_type, marker, source_file);
        }
    }

    println!("\n⭐ Registered Signal Broadcasts ({} total):", api_signals.len());
    if api_signals.is_empty() {
        warn!(" No #[signal] broadcasts found in targeted files.");
    } else {
        for (name, args, source_file) in &api_signals {
            println!(" > signal {}({}) [{}]", name, args, source_file);
        }
    }
	println!("--------------------------------------------------");

    info!("API scan complete: {} methods and {} signals detected.", api_methods.len(), api_signals.len());
    thread::sleep(Duration::from_secs(2));
}
// --- END: rust/ssxl_cli/src\cli_util_inspect.rs ---
       106 LOC | rust/ssxl_cli/src\cli_util_loc.rs
// --- START: rust/ssxl_cli/src\cli_util_loc.rs ---
//! # CLI Utilities: Line of Code (LOC) Analysis (`ssxl_cli::cli_util_loc`)
//!
//! This module provides functions for scanning the SSXL-ext workspace, calculating
//! Lines of Code (LOC) for both Rust (`.rs`) and GDScript (`.gd`) files, and
//! generating the LOC reports required by the Godot engine.

use walkdir::WalkDir;
use std::path::{PathBuf};
use std::fs;
use tracing::{info, error};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

// Constants for the fixed-name output file, which is read by Godot.
const OUTPUT_FINAL_LOC_FILE: &str = "RUST_LOC_TOTAL.txt";
// Directory for full LOC reports, relative to the project root (../)
const LOC_REPORTS_DIR: &str = "../loc_reports";

/// Helper to count lines of code in file content, ignoring empty lines and comments (simplified).
fn count_loc_from_content(content: &str) -> u64 {
    let mut count = 0;
    for line in content.lines() {
        let trimmed = line.trim();
        // Simple check: ignore empty lines and lines starting with comment markers.
        if !trimmed.is_empty() && !trimmed.starts_with("//") && !trimmed.starts_with("#") {
            count += 1;
        }
    }
    count
}

/// Helper function to write the final Rust LOC total to a fixed-name file
/// for fast parsing by Godot at bootup.
fn write_final_loc_total(loc_count: u64) {
    // Navigate up one level to the project root (ssxl-ext/)
    let root_dir = PathBuf::from("../");
    let output_path = root_dir.join(OUTPUT_FINAL_LOC_FILE); // Final Path: ../RUST_LOC_TOTAL.txt

    let content = format!("{}\n", loc_count);

    match fs::write(&output_path, content.as_bytes()) {
        Ok(_) => {
            eprintln!("🔥 SSXL-ext CLI: Wrote total Rust LOC **{}** to {}.",
                      loc_count, output_path.display());
        }
        Err(e) => {
            error!("❌ CRITICAL FAIL: Could not write LOC file {:?}. Error: {}",
                      output_path, e);
        }
    }
}

/// Scans the Rust workspace, calculates lines of code (LOC), and generates
/// the full report and the final single-number LOC file.
///
/// Assumes CWD is inside the `ssxl-ext/rust/` directory.
pub fn scan_and_report_loc() {
    let mut total_rs_loc: u64 = 0;
    let mut total_gd_loc: u64 = 0;
    let mut report_lines: Vec<String> = Vec::new();

    // 1. Scan Rust Code
    // These paths are correct relative to the ssxl-ext/rust/ directory.
    let rust_dirs = ["ssxl_cache/src", "ssxl_engine_ffi/src", "ssxl_generate/src",
                     "ssxl_godot/src", "ssxl_math/src", "ssxl_shared/src",
                     "ssxl_sync/src", "ssxl_tools/src", "ssxl_cli/src"];

    for dir in &rust_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_rs_loc += loc;
                    
                    if loc > 0 {
                        let path_str = format!("rust/{}", path.display());
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters
                        report_lines.push(format!("// --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("// --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 2. Scan GDScript Code
    // Path traversal is correct: `ssxl-ext/rust/` -> `../ssxl_engine_tester`
    let gd_dirs = ["../ssxl_engine_tester"];
    for dir in &gd_dirs {
        for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "gd") {
                if let Ok(content) = fs::read_to_string(path) {
                    let loc = count_loc_from_content(&content);
                    total_gd_loc += loc;
                    
                    if loc > 0 {
                        // Note: path.display() will include the '..' but this is acceptable for internal reports.
                        let path_str = path.display().to_string();
                        // 1. Add LOC and path line
                        report_lines.push(format!("{:>10} LOC | {}", loc, path_str));
                        
                        // 2. Add file content wrapped in delimiters (using '#' for GDScript comments)
                        report_lines.push(format!("# --- START: {} ---", path_str));
                        report_lines.push(content);
                        report_lines.push(format!("# --- END: {} ---", path_str));
                    }
                }
            }
        }
    }

    // 3. Generate the full, dynamically-named report in the `../loc_reports/` directory
    let reports_dir = PathBuf::from(LOC_REPORTS_DIR);

    // Create the directory if it doesn't exist.
    if let Err(e) = fs::create_dir_all(&reports_dir) {
        error!("❌ Failed to create LOC reports directory {:?}. Error: {}", reports_dir, e);
    }

    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::from_secs(0))
        .as_secs();

    let filename = format!("ssxl_loc_report_live_{}.txt", timestamp);
    let final_report_path = reports_dir.join(filename); 

    let full_report_content = format!(
        "SSXL-ext Live LOC Report\nGenerated (Epoch Seconds): {}\nRoot Directories: rust, ssxl_engine_tester\n\n------------------------------------------------------\n FILE LOC | Relative File Path\n------------------------------------------------------\n{}\n------------------------------------------------------\n       {} LOC | *.rs (Rust Total)\n       {} LOC | *.gd (GDScript Total)\n       {} LOC | TOTALS\n",
        timestamp,
        report_lines.join("\n"),
        total_rs_loc,
        total_gd_loc,
        total_rs_loc + total_gd_loc
    );

    // Write the full report to the corrected dynamic path.
    match fs::write(&final_report_path, full_report_content) {
        Ok(_) => {
            info!("✅ Full LOC report written to: {}", final_report_path.display());
        }
        Err(e) => {
            error!("❌ Failed to write full LOC report to {:?}. Error: {}", final_report_path, e);
        }
    }

    // 4. Write the single line count to the fixed-name file (RUST_LOC_TOTAL.txt)
    write_final_loc_total(total_rs_loc);

    thread::sleep(Duration::from_millis(100));
}
// --- END: rust/ssxl_cli/src\cli_util_loc.rs ---
       158 LOC | rust/ssxl_cli/src\cli_util_menu.rs
// --- START: rust/ssxl_cli/src\cli_util_menu.rs ---
use crate::actions::{
    // --- Core Test & Validation Functions (Godot/Rust interaction) ---
    run_cargo_tests,
    run_ffi_bridge_validation,
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
    
    // --- NEW: Headless Integration Tests for Rendering Logic (Fixing Generate/Animate) ---
    run_headless_generation_integration_test, // Validates 'generate' FFI data pipeline.
    run_headless_animation_tempo_test,        // Validates 'animate' conductor tempo/latency.
    
    // --- Launch & Debug Functions ---
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
};
// Benchmark/Utility functions are correctly imported from their dedicated module:
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use tracing::warn;


/// Defines a single executable action within the Command Line Interface menu.
/// Each action is a closure wrapped in a Box for dynamic execution.
pub struct CliAction {
    pub key: char,
    pub label: &'static str,
    pub id: &'static str,
    pub action: Box<dyn Fn() + Send + Sync + 'static>,
}

impl CliAction {
    /// Helper constructor (primarily for TODO/unimplemented actions).
    pub fn new(id: &'static str, label: &'static str) -> Self {
        CliAction {
            key: '?',
            label,
            id,
            action: Box::new(|| {}) // Default no-op action
        }
    }
}


/// Defines a structure for organizing and presenting a group of CLI actions.
pub struct CliMenu<'a> {
    pub title: &'static str,
    pub actions: &'a [CliAction],
}

impl<'a> CliMenu<'a> {
    pub fn new(title: &'static str, actions: &'a [CliAction]) -> Self {
        CliMenu { title, actions }
    }
    
    // Note: prompt_action implementation is omitted as it is environment-specific.
    pub fn prompt_action(&self) -> CliAction {
        unimplemented!()
    }
}


/// Constructs the complete list of available actions for the SSXL Engine Dev Console.
pub fn build_menu() -> Vec<CliAction> {
    vec![
        // =======================================================================
        // I. CORE RUST VALIDATION (Internal Checks)
        // =======================================================================
        CliAction { 
            key: '0', 
            label: "✅ Run: Full Cargo Test Suite", 
            id: "cargo_all", 
            action: Box::new(run_cargo_tests) 
        },
        CliAction {    
            key: '1',    
            label: "✅ Validate: FFI Bridge Data Transfer (Data Integrity)",    
            id: "ffi_validate",
            action: Box::new(run_ffi_bridge_validation)
        },
        CliAction {    
            key: '2',    
            label: "✅ Validate: Async Communication Channels (Godot <-> Rust)",    
            id: "async_channel",
            action: Box::new(run_communication_channel_test)
        },
        CliAction {    
            key: '3',    
            label: "✅ Validate: Chunk/Tile Data Channels (Crypto Coded)",    
            id: "data_channel",
            action: Box::new(run_data_channel_test)
        },
        CliAction {    
            key: '4',    
            label: "✅ Validate: Map Generation Logic (Procedural Purity)",    
            id: "map_gen",
            action: Box::new(run_map_generation_test)
        },
        CliAction {    
            key: '5',    
            label: "✅ Validate: Animation Conductor Tempo (Frame Consistency)",    
            id: "animation_tempo",
            action: Box::new(run_animation_conductor_test)
        },

        // =======================================================================
        // II. HEADLESS INTEGRATION TESTS (Simulating Engine in Godot)
        // This targets the root of our 'generate' and 'animate' rendering errors.
        // =======================================================================
        CliAction { 
            key: '6', 
            label: "✅ Validate: Headless Generation Integration (Full Pipeline Simulation)", 
            id: "headless_gen_integration",
            action: Box::new(run_headless_generation_integration_test)
        },
        CliAction { 
            key: '7', 
            label: "✅ Validate: Headless Animation Tempo Integration (Signal Latency Check)", 
            id: "headless_anim_tempo",
            action: Box::new(run_headless_animation_tempo_test)
        },

        // =======================================================================
        // III. ENGINE LAUNCH & DEBUGGING TOOLS
        // =======================================================================
        CliAction {    
            key: 'L',    
            label: "🚀 Launch: Godot Client (Non-Headless)",    
            id: "launch_client",
            action: Box::new(launch_godot_client)    
        },
        CliAction {    
            key: 'H',    
            label: "🎮 Launch: Headless Godot (External)",    
            id: "launch_headless",
            action: Box::new(launch_headless_godot)    
        },
        CliAction {    
            key: 'S',    
            label: "🔮 Start: Signal Inspector / Live Feed (TODO)",    
            id: "start_inspector",
            action: Box::new(start_signal_inspector)    
        },

        // =======================================================================
        // IV. BENCHMARKS & UTILITIES
        // =======================================================================
        CliAction {    
            key: 'T',    
            label: "🧪 Test: Generation & Placement CLI",    
            id: "gen_cli_test",
            action: Box::new(test_generation_and_placement_cli)    
        },
        CliAction {    
            key: 'B',    
            label: "🧪 Benchmark: Max Grid Placement",    
            id: "max_grid_bench",
            action: Box::new(run_max_grid_benchmark)    
        },
        CliAction {    
            key: 'P',    
            label: "✅ Perform: Bitmask PNG Conversion",    
            id: "bitmask_convert",
            action: Box::new(run_bitmask_conversion)    
        },
        CliAction {    
            key: 'A',    
            label: "✅ Inspect: SSXL Developer API Surface (Callable + Signals)",    
            id: "api_surface",
            action: Box::new(print_godot_api_surface)    
        },
        CliAction {    
            key: 'I',    
            label: "✅ Inspect: Rust Module Tree",    
            id: "module_tree",
            action: Box::new(print_module_tree)    
        },
        CliAction {    
            key: 'R',    
            label: "⚠️ Run: Trailkeeper Scan (TODO)",    
            id: "trailkeeper_scan",
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented."))    
        },
        
        // =======================================================================
        // V. SYSTEM CONTROL
        // =======================================================================
        CliAction { key: 'E', label: "✅ Exit Console", id: "exit", action: Box::new(|| {}) },
    ]
}


/// Prints the structured menu to the console, ready for user selection.
pub fn print_menu(menu: &[CliAction]) {
    
    println!("\n🧭 SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}
// --- END: rust/ssxl_cli/src\cli_util_menu.rs ---
        86 LOC | rust/ssxl_cli/src\main.rs
// --- START: rust/ssxl_cli/src\main.rs ---
//! # SSXL-ext CLI Developer Console (`ssxl_cli::main`)
//!
//! The main entry point for the interactive developer console. This utility manages
//! initialization, logging, the main menu loop, and delegates tasks to action modules
//! for testing, benchmarking, and external tool execution.

mod actions;               // Core functions for tests, benchmarks, and Godot interaction.
mod cli_util_inspect;      // Utilities for scanning the codebase and API surface.

// FIX: Change to `pub mod` so its types (CliAction, CliMenu) are accessible
// by other modules in the crate (like actions/testing.rs).
pub mod cli_util_menu;     // Menu structure and display logic.

mod cli_util_bench;        // Functions for running generation tests and benchmarks.
mod cli_util_loc;          // <--- CHANGE 1: Declare the new LOC utility module.

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // External FFI function to bootstrap the engine core.
use crate::cli_util_loc::scan_and_report_loc; // <--- CHANGE 2: Update the import path and function name.
use crate::actions::copy_dll_to_tester_project_at_boot; // Action to ensure the latest DLL is in the Godot project.


/// Prompts the user to press Enter before returning to the main menu.
fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    // Read a line from stdin and discard the result.
    let _ = io::stdin().read_line(&mut String::new());
}

/// Sets up the logging system and performs critical engine initialization steps.
fn init_logging_and_engine() {
    // 1. Initialize Tracing/Logging Subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout) // Direct log output to stdout.
                .with_filter(LevelFilter::INFO), // Set the minimum logging level to INFO.
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // 2. Initialize the Rust Core via FFI
    // Calls the external C-compatible function to boot the engine's core state and runtime.
    if ssxl_initialize_engine() {
        info!("Engine FFI core initialized.");
    } else {
        // We log the failure but allow the CLI to continue for non-engine tasks (like LOC scan).
        error!("Failed to initialize Engine FFI core.");
    }
    
    // 3. Copy DLL to Godot Project
    // Ensure the compiled GDExtension DLL is copied into the Godot tester project
    // before any Godot-related actions are run.
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        // This is a critical warning, as Godot interaction will fail without the DLL.
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // Perform initial setup: logging, FFI, and DLL copy.
    init_logging_and_engine();
    
    // Run a Lines of Code (LOC) scan on the codebase at startup.
    // Note: The scan function no longer takes an argument.
    scan_and_report_loc(); // <--- CHANGE 3: Update function call and remove unnecessary argument.
    
    // Print welcome ASCII art.
    println!(
        r#"
                 (__)                      
                 (oo)
           /------\/
          / |    ||
         * ||----||
            ~~    ~~
SSXL-ext Engine Console Initialized
"#
    );

    // Build the menu structure.
    let menu = build_menu();
    // Set for input debouncing to prevent multiple actions from a single key press hold.
    let mut last_keys = HashSet::new();

    // --- Main Interactive Console Loop ---
    loop {
        // Display the menu options.
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        // Ensure the prompt character is immediately visible.
        io::stdout().flush().unwrap();

        // Inner loop handles key polling and processing.
        loop {
            // Poll for key events with a timeout to keep the loop responsive (500ms tempo).
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase(); // Normalize input to uppercase.

                        // Input Debounce Check: Only process if the key hasn't been seen recently.
                        if last_keys.insert(c) {
                            // Find the corresponding menu item.
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                // Execute the action associated with the menu item.
                                (item.action)();

                                // Check for the exit key ('E').
                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return; // Exit the main function, terminating the CLI.
                                }

                                // Wait for user acknowledgment before returning to the main menu screen.
                                wait_for_enter();
                                // Break the inner polling loop to redraw the menu.
                                break;
                            }
                        }
                    }
                }
            } else {
                // If the poll times out, clear the debounce set, allowing a new key press to be registered.
                last_keys.clear();
            }

            // Short pause for general loop control.
            thread::sleep(Duration::from_millis(10));
        }
    }
}
// --- END: rust/ssxl_cli/src\main.rs ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
extends Node

func enter_idle():
    print("🌙 Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 Aetherion teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\Aetherion.gd ---
        31 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("🌀 SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("✨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("⚠️ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("❌ Failed to instantiate SSXL script.")
        else:
            push_error("❌ Invalid script resource at: %s" % script_path)
    else:
        push_error("❌ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("🧹 SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("🧺 SSXL instance freed.")
    ssxl_instance = null

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd ---
        18 LOC | ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd
# --- START: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
extends Node

func enter_idle():
    print("🌙 SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 SSXL teardown.")
    # Optional: stop ticker, release ligatures

# --- END: ../ssxl_engine_tester\addons\S2O_godot_plugin\SSXL.gd ---
        66 LOC | ../ssxl_engine_tester\root_scripts\cameras.gd
# --- START: ../ssxl_engine_tester\root_scripts\cameras.gd ---
# cameras.gd
# Manages camera switching, map panning, and zooming for the SSXL Tester.
extends Node

# ----------------------------------------------------------------------
## 🧭 NODE REFERENCES (Typed Dependencies)
# ----------------------------------------------------------------------
# We rely on Godot's @onready for robust, typed access to child nodes.
@onready var camera1: Camera2D = $camera1 as Camera2D # Control Panel View
@onready var camera2: Camera2D = $camera2 as Camera2D # Map View (Zoomable, Pannable)

# ----------------------------------------------------------------------
## ⚙️ CONSTANTS & STATE (The Crypto-Coded Memory)
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1
const MIN_ZOOM: float = 0.05
const MAX_ZOOM: float = 10.0

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO


# ----------------------------------------------------------------------
## 🔗 LIFECYCLE (Initialization)
# ----------------------------------------------------------------------

func _ready() -> void:
	# Critical Node Validation
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("❌ CRITICAL: Camera nodes (camera1 or camera2) not found. Check scene tree.")
		return
		
	# Start by ensuring camera1 (the UI view) is active
	camera1.make_current()
	print("✅ Cameras: Initialized. Camera 1 (UI View) is current.")


# ----------------------------------------------------------------------
## ⌨️ INPUT HANDLING (Decoupled Tempo Regulation)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	
	# Only handle input if the Map Camera (camera2) is currently active
	if not is_instance_valid(camera2) or not camera2.is_current():
		return
		
	# --- 1. Zoom Logic (Mouse Wheel) ---
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		
		# Zoom In
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP:
			var new_zoom: float = camera2.zoom.x + ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Zoom Out
		elif mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			var new_zoom: float = camera2.zoom.x - ZOOM_SPEED
			set_map_zoom(new_zoom)
			get_viewport().set_input_as_handled()
		
		# Panning Start/Stop (Middle Mouse Button)
		elif mouse_event.button_index == MOUSE_BUTTON_MIDDLE:
			is_panning = mouse_event.is_pressed()
			
			if is_panning:
				last_mouse_position = mouse_event.position
			
			get_viewport().set_input_as_handled()
			return
	
	# --- 2. Camera Pan Logic (Mouse Motion) ---
	elif event is InputEventMouseMotion and is_panning:
		var delta: Vector2 = event.position - last_mouse_position
		
		# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
		# This must be inverted to make drag feel natural.
		camera2.position -= delta / camera2.zoom
		
		last_mouse_position = event.position
		get_viewport().set_input_as_handled()
		return
		
	# --- 3. Camera Toggle Logic (Keyboard Shortcut - Delegated) ---
	# NOTE: The ControlPanelUtility script is the primary handler for F6/Tab,
	# calling the _toggle_camera() method below. This keeps input centralized.


# ----------------------------------------------------------------------
## 🖼️ CAMERA UTILITIES (Map Control)
# ----------------------------------------------------------------------

func set_map_zoom(target_zoom: float) -> void:
	"""Clamps the zoom level and applies it to the map camera (camera2)."""
	
	if not is_instance_valid(camera2):
		return
		
	# Clamp the zoom level to prevent extreme values (systemic entropy)
	var clamped_zoom: float = clampf(target_zoom, MIN_ZOOM, MAX_ZOOM)
	
	# Apply zoom uniformly across X and Y axes
	camera2.zoom = Vector2(clamped_zoom, clamped_zoom)


# ----------------------------------------------------------------------
## 📡 PUBLIC API (The FFI Link for the Control Panel)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	"""Makes the specified camera current (1: UI, 2: Map)."""
	
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		push_error("⚠️ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("➡️ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("➡️ Switched to Camera 2 (Map View).")
	else:
		push_warning("⚠️ Invalid camera index passed.")


func _toggle_camera() -> void:
	"""Switches between the two available cameras."""
	if not is_instance_valid(camera1) or not is_instance_valid(camera2):
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Switch to Map View
	elif camera2.is_current():
		switch_to_camera(1) # Switch to Control Panel View

# --- END: ../ssxl_engine_tester\root_scripts\cameras.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\camera_2.gd
# --- START: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
extends Camera2D

# --- END: ../ssxl_engine_tester\root_scripts\camera_2.gd ---
        62 LOC | ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
class_name control_panel_animation_logic
extends RefCounted

var controller
var tile_flip_queue: Array = []
const MAX_FLIPS_PER_TICK: int = 1000
var animation_is_active: bool = false

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_animate_button_pressed() -> void:
	animation_is_active = !animation_is_active
	var button_pressed: bool = animation_is_active
	
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("set_animation_enabled"):
		controller.ssxl_engine.set_animation_enabled(button_pressed)
	
	setup_animation_worker(button_pressed)

func setup_animation_worker(should_animate: bool) -> void:
	animation_is_active = should_animate
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			controller.animation_timer.start()
	else:
		if is_instance_valid(controller.engine_timer):
			controller.engine_timer.call_deferred("start")

func _on_animation_timer_timeout() -> void:
	if not controller.is_generating or not is_instance_valid(controller.ssxl_tilemap):
		return
		
	var batch_size: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	for i in range(batch_size):
		var data: Dictionary = tile_flip_queue.pop_front()
		if not data.is_empty():
			process_tile_flip(data.tile_id, data.flip_frame)
		
	controller.ssxl_tilemap.force_update()
	
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()

func _on_engine_timer_timeout() -> void:
	controller.engine_tick_count += 1
	if is_instance_valid(controller.ssxl_oracle):
		controller.ssxl_oracle.tick()
	
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "Tick Count: %d" % controller.engine_tick_count

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	if not is_instance_valid(controller.ssxl_tilemap) or not is_instance_valid(controller.grid_width):
		return

	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	var source_id: int = controller.BASE_SOURCE_ID
	var atlas_coords: Vector2i = controller.BASE_ATLAS_COORDS
	
	controller.ssxl_tilemap.set_cell(0, coords, source_id, atlas_coords, flip_frame)

func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	if not animation_is_active or not controller.is_generating:
		return

	tile_flip_queue.append({ "tile_id": tile_id, "flip_frame": flip_frame })

func redraw_tilemap_throttled() -> void:
	if is_instance_valid(controller.ssxl_tilemap):
		controller.ssxl_tilemap.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelanimation.gd ---
        98 LOC | ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
class_name control_panel_gen_logic
extends RefCounted

var control_panel: Control

func _init(panel: Control) -> void:
	control_panel = panel

func start_generation() -> void:
	if control_panel.is_generating:
		stop_generation()
		return
	
	_setup_generation_start()
	
	var width: int = int(control_panel.grid_width.value)
	var height: int = int(control_panel.grid_height.value)
	var seed_text: String = control_panel.seed_input.text
	var generator_name: String = control_panel.tile_type_selector.get_item_text(
		control_panel.tile_type_selector.selected
	)
	var seed_value: int = _parse_seed(seed_text)
	
	if not _validate_inputs(width, height):
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()
		return
	
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.set_generator(generator_name)
		# Defer to avoid stalling UI while Rust starts
		call_deferred("_start_ffi_generation", width, height, str(seed_value), generator_name)
		control_panel.status_label.text = "Generating map..."
	else:
		if is_instance_valid(control_panel.utility):
			control_panel.utility.stop_generation()

func _start_ffi_generation(width: int, height: int, seed: String, generator_name: String) -> void:
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.build_map(width, height, seed, generator_name)

func stop_generation() -> void:
	# FIX: use utility (not 'quality')
	if is_instance_valid(control_panel.utility):
		control_panel.utility.stop_generation()
	if is_instance_valid(control_panel.ssxl_engine):
		control_panel.ssxl_engine.stop_generation()

# SSXLTileMap rendering
func _on_chunk_data_ready(key_x: int, key_y: int) -> void:
	print("CHUNK RECEIVED → (", key_x, ",", key_y, ")")

	if not is_instance_valid(control_panel.presenter):
		push_error("FATAL: control_panel.presenter is NULL! Add it in control_panel.gd")
		return
	if not is_instance_valid(control_panel.ssxl_tilemap):
		push_error("FATAL: ssxl_tilemap missing or invalid — cannot render chunk.")
		return

	var chunk_opt = control_panel.presenter.get_chunk_data(key_x, key_y)
	if chunk_opt.is_none():
		return

	var chunk_data: Dictionary = chunk_opt.unwrap()
	if not control_panel.utility.check_data_integrity(chunk_data):
		push_warning("Chunk failed integrity: %s, %s" % [key_x, key_y])
		return

	var tiles: Array = chunk_data.tiles
	var layer: int = 0
	var source_id: int = control_panel.BASE_SOURCE_ID
	var atlas_coords: Vector2i = control_panel.BASE_ATLAS_COORDS
	var alt_id: int = control_panel.BASE_ALT_ID

	var placed: int = 0
	for tile in tiles:
		var world_x: int = key_x * control_panel.CHUNK_SIZE_X + tile.x
		var world_y: int = key_y * control_panel.CHUNK_SIZE_Y + tile.y
		var coords := Vector2i(world_x, world_y)

		# FIX: Godot 4 signature — set_cell(layer, coords, source_id, atlas_coords, alt_id)
		control_panel.ssxl_tilemap.set_cell(layer, coords, source_id, atlas_coords, alt_id)

		control_panel.total_tiles_placed += 1
		placed += 1

	# Optional: force update for immediate visual refresh
	control_panel.ssxl_tilemap.force_update()

	control_panel.progress_bar.value = control_panel.total_tiles_placed
	control_panel.signal_handler._on_chunk_generated(key_x, key_y, placed)

func _setup_generation_start() -> void:
	control_panel.is_generating = true
	control_panel.generate_button.text = "STOP GEN (F5)"
	control_panel.generation_start_time_ms = Time.get_ticks_msec()
	control_panel.total_tiles_placed = 0

	var map_width: int = int(control_panel.grid_width.value)
	var map_height: int = int(control_panel.grid_height.value)
	control_panel.progress_bar.max_value = float(map_width * map_height)
	control_panel.progress_bar.value = 0.0
	control_panel.progress_bar.visible = true

	if is_instance_valid(control_panel.ssxl_tilemap):
		control_panel.ssxl_tilemap.clear()

	# Timer orchestration
	if control_panel.animation_logic.animation_is_active:
		control_panel.engine_timer.stop()
		control_panel.animation_timer.start()
	else:
		control_panel.animation_timer.stop()

	if is_instance_valid(control_panel.engine_timer):
		control_panel.engine_timer.stop()
		control_panel.engine_timer.call_deferred("start")

func _validate_inputs(map_width: int, map_height: int) -> bool:
	if map_width <= 0 or map_height <= 0:
		return false
	if map_width % control_panel.CHUNK_SIZE_X != 0 or map_height % control_panel.CHUNK_SIZE_Y != 0:
		push_warning("Map size must be multiple of chunk size!")
		return false
	return true

func _parse_seed(seed_text: String) -> int:
	if seed_text.is_empty():
		return Time.get_ticks_msec()
	return seed_text.strip_edges().to_lower().hash()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelgenlogic.gd ---
        73 LOC | ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func _on_ffi_alignment_complete() -> void:
	_connect_local_ui_signals()
	_connect_local_timers()

func _connect_local_ui_signals() -> void:
	var gen_callable = Callable(controller.gen_logic, "start_generation")
	var animate_callable = Callable(controller.animation_logic, "_on_animate_button_pressed")
	var toggle_callable = Callable(controller.utility, "on_toggle_terminal_button_pressed")
	var width_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	var height_callable = Callable(controller.ui_setup, "_on_grid_size_value_changed")
	
	if controller.generate_button.pressed.is_connected(gen_callable):
		controller.generate_button.pressed.disconnect(gen_callable)
	controller.generate_button.pressed.connect(gen_callable)

	if controller.animate_ui_button.pressed.is_connected(animate_callable):
		controller.animate_ui_button.pressed.disconnect(animate_callable)
	controller.animate_ui_button.pressed.connect(animate_callable)
	
	if controller.toggle_terminal_button.pressed.is_connected(toggle_callable):
		controller.toggle_terminal_button.pressed.disconnect(toggle_callable)
	controller.toggle_terminal_button.pressed.connect(toggle_callable)
	
	if controller.grid_width.value_changed.is_connected(width_callable):
		controller.grid_width.value_changed.disconnect(width_callable)
	controller.grid_width.value_changed.connect(width_callable)
	
	if controller.grid_height.value_changed.is_connected(height_callable):
		controller.grid_height.value_changed.disconnect(height_callable)
	controller.grid_height.value_changed.connect(height_callable)

func _connect_local_timers() -> void:
	var engine_timer_callable = Callable(controller.animation_logic, "_on_engine_timer_timeout")
	if is_instance_valid(controller.engine_timer) and not controller.engine_timer.timeout.is_connected(engine_timer_callable):
		controller.engine_timer.timeout.connect(engine_timer_callable)

func _on_engine_status_updated(status_message: String) -> void:
	if not is_instance_valid(controller.status_label):
		return
	print("DEBUG: Engine status updated →", status_message)
	controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	print("DEBUG: Generation error →", error_message)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	controller.utility.reset_system_state()

func _on_build_map_start() -> void:
	print("DEBUG: Build map start signal received")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "Map Generation Initiated..."

func _on_chunk_generated(chunk_x: int, chunk_y: int, tiles_in_chunk: int) -> void:
	if not controller.is_generating:
		return
	print("DEBUG: Chunk generated → (%d, %d) with %d tiles" % [chunk_x, chunk_y, tiles_in_chunk])
	
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if percent != controller.last_percent and is_instance_valid(controller.status_label):
		if percent % 5 == 0 or percent == 100:
			controller.status_label.text = "Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent

func _on_build_map_complete() -> void:
	var total_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var total_time_s: float = float(total_time_ms) / 1000.0
	var tiles_per_second: float = 0.0
	if total_time_s > 0.0:
		tiles_per_second = float(controller.total_tiles_placed) / total_time_s
	
	var completion_msg: String = "Generation Complete! (%.2f seconds)" % total_time_s
	print("DEBUG: Build map complete →", completion_msg, "Tiles/sec:", tiles_per_second)

	if is_instance_valid(controller.status_label):
		controller.status_label.text = completion_msg
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "Time: %.2fs" % total_time_s

	controller.utility.reset_system_state()

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelsignalhandler.gd ---
        88 LOC | ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
class_name control_panel_ui_setup
extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	controller = p_controller

func setup_all() -> void:
	setup_timers_properties()
	setup_ui_elements()
	connect_ui_signals()

func setup_timers_properties() -> void:
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.5
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1

func link_ffi_nodes() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	var ssxl_signals: Node = controller.ssxl_signals
	var ssxl_oracle: Node = controller.ssxl_oracle
	var tilemap: TileMap = controller.ssxl_tilemap   # FIX: use Rust SSXLTileMap

	if is_instance_valid(ssxl_engine):
		if is_instance_valid(ssxl_signals) and ssxl_engine.has_method("set_signals_node"):
			ssxl_engine.set_signals_node(ssxl_signals)
			print("DEBUG: Engine → Signals linked")

		if is_instance_valid(tilemap) and ssxl_engine.has_method("set_tilemap"):
			ssxl_engine.set_tilemap(tilemap)
			print("DEBUG: Engine → SSXLTileMap linked")

		if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_signals) and ssxl_oracle.has_method("set_signals_node"):
			ssxl_oracle.set_signals_node(ssxl_signals)
			print("DEBUG: Oracle → Signals linked")

func start_ffi_conductors() -> void:
	var ssxl_engine: Node = controller.ssxl_engine
	if is_instance_valid(ssxl_engine) and ssxl_engine.has_method("start_async_conductors"):
		ssxl_engine.start_async_conductors()
		print("DEBUG: Async conductors started")

func setup_ui_elements() -> void:
	var width_spinbox: SpinBox = controller.grid_width
	var height_spinbox: SpinBox = controller.grid_height
	
	if is_instance_valid(width_spinbox) and is_instance_valid(height_spinbox):
		width_spinbox.max_value = 1_000_000_000.0
		width_spinbox.step = float(controller.CHUNK_SIZE_X)
		width_spinbox.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		height_spinbox.max_value = 1_000_000_000.0
		height_spinbox.step = float(controller.CHUNK_SIZE_Y)
		height_spinbox.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	var tile_selector: OptionButton = controller.tile_type_selector
	if is_instance_valid(tile_selector):
		tile_selector.clear()
		tile_selector.add_item("perlin_basic_2d", 0)
		tile_selector.add_item("cellular_automata_solid", 1)
		tile_selector.select(0)
	
	var placement_selector: OptionButton = controller.placement_mode_selector
	if is_instance_valid(placement_selector):
		placement_selector.clear()
		placement_selector.add_item("perlin_basic_2d", 0)
		placement_selector.add_item("cellular_automata_checkerboard", 1)
		placement_selector.add_item("drunkards_walk", 2)
		placement_selector.add_item("maze_recursive_division", 3)
		placement_selector.select(0)
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."

func connect_ui_signals() -> void:
	if is_instance_valid(controller.grid_width):
		controller.grid_width.value_changed.connect(self._on_grid_size_value_changed)
		
	if is_instance_valid(controller.grid_height):
		controller.grid_height.value_changed.connect(self._on_grid_size_value_changed)

	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.item_selected.connect(self._on_mode_selector_item_selected)

	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.item_selected.connect(self._on_tile_type_selector_item_selected)

func _on_grid_size_value_changed(value: float) -> void:
	if is_instance_valid(controller.ssxl_tilemap) and not controller.is_generating:
		controller.ssxl_tilemap.clear()
		print("DEBUG: Tilemap cleared on grid size change")

func _on_mode_selector_item_selected(index: int) -> void:
	var mode: int = controller.placement_mode_selector.get_item_id(index)
	print("DEBUG: Placement mode selected →", mode)

func _on_tile_type_selector_item_selected(index: int) -> void:
	var type_id: int = controller.tile_type_selector.get_item_id(index)
	print("DEBUG: Tile type selected →", type_id)

# --- END: ../ssxl_engine_tester\root_scripts\controlpaneluisetup.gd ---
       109 LOC | ../ssxl_engine_tester\root_scripts\controlpanelutility.gd
# --- START: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
class_name control_panel_utility extends RefCounted

# Reference to the main control_panel.gd node (the Orchestrator).
# This provides access to all UI elements, state, and external nodes.
var controller: Control

# ==============================================================================
# 1. LIFECYCLE: Constructor
# ==============================================================================
func _init(p_controller: Control) -> void:
	# Assign the reference to the main controller node.
	if is_instance_valid(p_controller):
		controller = p_controller
	else:
		push_error("❌ FATAL: ControlPanel reference missing in control_panel_utility constructor.")


# ==============================================================================
# 2. CORE VALIDATION
# ==============================================================================
# Checks for the existence and validity of all essential FFI and scene nodes.
func check_critical_nodes() -> bool:
	var valid: bool = true
	var missing_nodes: Array[String] = []

	# Check FFI GDExtension nodes
	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false
		
	# Check Scene/Presenter nodes
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false

	if not valid:
		var error_msg: String = "❌ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid


# ==============================================================================
# 3. FFI AND TIMER HANDLERS
# ==============================================================================

# FIX: This function was missing and is connected to the engine_timer.
# It acts as the heartbeat (polling loop) for the FFI Oracle.
func _on_engine_timer_timeout() -> void:
	print("⚙️ FFI TICKER: Polling core. Tick Count: %d" % controller.engine_tick_count)
	controller.ssxl_oracle.tick()
		
	if is_instance_valid(controller.ssxl_oracle):
		# Calling tick() tells the Rust core to process pending tasks/signals.
		controller.ssxl_oracle.tick()

# Handles the redraw_throttle_timer timeout, forcing a visual update.
func _on_redraw_throttle_timeout() -> void:
	if controller.redraw_pending and is_instance_valid(controller.expansive_tilemap):
		# force_update() ensures all tiles placed in the background are drawn in one batch.
		controller.expansive_tilemap.force_update()
		controller.redraw_pending = false

# Triggers a redraw cycle by starting the throttle timer.
func request_redraw() -> void:
	controller.redraw_pending = true
	if is_instance_valid(controller.redraw_throttle_timer) and not controller.redraw_throttle_timer.is_stopped():
		controller.redraw_throttle_timer.start()

# Updates the clock label with the current system time.
func on_clock_timer_timeout() -> void:
	if is_instance_valid(controller.clock_label):
		var time_string: String = Time.get_datetime_string_from_system()
		controller.clock_label.text = "🕒 " + time_string


# ==============================================================================
# 4. INPUT AND UI HANDLERS
# ==============================================================================
# Handles global input events for hotkeys (F5, F6, F7).
func handle_input_event(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		
		# F5: Start Generation (Delegates to gen_logic sub-script)
		if event.keycode == KEY_F5:
			# Safety check: Only run if generation is not already active.
			if not controller.is_generating:
				controller.gen_logic.start_generation()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F6: Toggle Camera View
		elif event.keycode == KEY_F6:
			toggle_camera_view()
			controller.get_viewport().set_input_as_handled()
			return
		
		# F7: Toggle Control Panel Visibility
		elif event.keycode == KEY_F7:
			on_toggle_terminal_button_pressed()
			controller.get_viewport().set_input_as_handled()
			return

# Toggles visibility of all control panel elements except the status billboard and button.
func on_toggle_terminal_button_pressed() -> void:
	controller.panel_collapsed = not controller.panel_collapsed
	
	for child in controller.get_children():
		# Skip the control elements that must *always* be visible
		if child == controller.toggle_terminal_button or child == controller.status_label:
			continue
			
		# Toggle visibility for all other UI controls
		if child is Control:
			child.visible = not controller.panel_collapsed

# Toggles the active camera view between camera1 and camera2.
func toggle_camera_view() -> void:
	var cameras_node: Node = controller.main.get_node("cameras")
	
	if is_instance_valid(cameras_node) and cameras_node.has_method("_toggle_camera"):
		# Delegate the camera switch to the dedicated Cameras node manager.
		cameras_node._toggle_camera()
		
		# Update the controller's state variable based on a simple toggle between 1 and 2.
		controller.current_camera_id = 1 if controller.current_camera_id == 2 else 2


# ==============================================================================
# 5. SYSTEM RESET
# ==============================================================================
# Resets all state variables and timers after a map generation process completes.
func reset_system_state() -> void:
	controller.is_generating = false
	controller.redraw_pending = false
	controller.engine_tick_count = 0
	
	# Stop all timers
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.stop()
		
	# Reset state metrics
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	# Reset UI elements
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value = 0.0
		controller.progress_bar.max_value = 0.0
		controller.progress_bar.visible = false


# ==============================================================================
# 6. GENERATION CONTROL (FORWARDED TO SSXLEngine)
# ==============================================================================

func start_generation() -> void:
	if controller.is_generating:
		return
	controller.is_generating = true
	controller.ssxl_engine.build_map(
		controller.map_width,
		controller.map_height,
		controller.seed_input.text,
		controller.generator_selector.get_item_text(controller.generator_selector.selected)
	)

func stop_generation() -> void:
	if not controller.is_generating:
		return
	print("GEN_LOGIC: Stop command issued via FFI")
	controller.ssxl_engine.stop_generation()   # ← THIS IS THE CALL YOU WERE MISSING
	controller.is_generating = false

# --- END: ../ssxl_engine_tester\root_scripts\controlpanelutility.gd ---
       101 LOC | ../ssxl_engine_tester\root_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
extends Control

const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# UI
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton
@onready var engine_timer: Timer = $enginetimer
@onready var animation_timer: Timer = $AnimationTimer
@onready var redraw_throttle_timer: Timer = $redrawthrottle
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene hierarchy
@onready var main: Node2D = get_parent() as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var clock_label: Label = main.get_node("clocklabel") as Label

# RUST FFI NODES
@onready var ssxl_engine: Node = get_node("/root/ssxltester/SSXLEngine")
@onready var ssxl_oracle: Node = get_node("/root/ssxltester/SSXLOracle")
@onready var ssxl_signals: Node = get_node("/root/ssxltester/SSXLSignals")

# CRITICAL: These are the ones used by gen_logic
@onready var ssxl_tilemap: Node = get_node("/root/ssxltester/main/SSXLTilemap")   # ← Rust tilemap
@onready var presenter: Node = get_node("/root/ssxltester/SSXLChunk")            # ← Chunk data holder

# Old reference — we keep it only for compatibility with some old code (safe to ignore)
@onready var expansive_tilemap: TileMap = main.get_node("SSXLTilemap") as TileMap

# State
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var animation_tilemap_handle: TileMap = null

# Subsystems
var ui_setup
var gen_logic
var signal_handler
var animation_logic
var utility

func _ready() -> void:
	const SCRIPT_PATH: String = "res://root_scripts/"
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self)
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self)
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self)
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self)
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self)

	# Basic validation
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals) or not is_instance_valid(ssxl_oracle):
		push_error("FATAL: Missing SSXL FFI nodes!")
		return

	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap not found! Check scene path.")
		return

	if not is_instance_valid(presenter):
		push_error("FATAL: SSXLChunk (presenter) not found!")
		return

	ui_setup.setup_all()
	connect_all_timer_timeouts()

	animation_logic.setup_animation_worker(false)

	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	if main and main.has_signal("ffi_core_ready"):
		main.ffi_core_ready.connect(_on_ffi_core_ready, CONNECT_ONE_SHOT)

	print("Control Panel: Initialized. Awaiting FFI Core Alignment...")

func _on_ffi_core_ready() -> void:
	print("Control Panel: FFI Core Ready. Finalizing connections...")
	ui_setup.link_ffi_nodes()
	connect_all_ffi_signals()
	signal_handler._on_ffi_alignment_complete()

func connect_all_ffi_signals() -> void:
	print("connecting ffi signals...")

	if ssxl_signals.has_signal("tile_flip_updated"):
		if not ssxl_signals.is_connected("tile_flip_updated", Callable(animation_logic, "_on_tile_flip_updated")):
			ssxl_signals.tile_flip_updated.connect(Callable(animation_logic, "_on_tile_flip_updated"))

	if ssxl_signals.has_signal("engine_status_updated"):
		if not ssxl_signals.is_connected("engine_status_updated", Callable(signal_handler, "_on_engine_status_updated")):
			ssxl_signals.engine_status_updated.connect(Callable(signal_handler, "_on_engine_status_updated"))

	# CRITICAL FIX — only connect if NOT already connected
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", Callable(gen_logic, "_on_chunk_data_ready")):
			ssxl_signals.chunk_data_ready.connect(Callable(gen_logic, "_on_chunk_data_ready"))
			print("chunk_data_ready → CONNECTED (first time)")
		else:
			print("chunk_data_ready → already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	if ssxl_signals.has_signal("build_map_complete"):
		if not ssxl_signals.is_connected("build_map_complete", Callable(signal_handler, "_on_build_map_complete")):
			ssxl_signals.build_map_complete.connect(Callable(signal_handler, "_on_build_map_complete"))

func connect_all_timer_timeouts() -> void:
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)

func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)

# --- END: ../ssxl_engine_tester\root_scripts\control_panel.gd ---
        21 LOC | ../ssxl_engine_tester\root_scripts\init.gd
# --- START: ../ssxl_engine_tester\root_scripts\init.gd ---
extends Node

# Stores a reference to every Godot Node found during the recursive scan.
var initialized_nodes: Array[Node] = []

# ----------------------------------------------------------------------------
# CORE FUNCTION: Starts the recursive node tree scan.
# This is called explicitly by the root orchestrator (ssxltester).
# ----------------------------------------------------------------------------
func initialize():
	print("\n🎶 Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	# Get the root viewport node to start the traversal.
	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("❌ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	# Locate the root orchestration node to deliver the completion report.
	var tester := root_node.get_node("ssxltester")
	# NOTE: Changed "AetherionTester" to "ssxltester" for project consistency.
	if tester == null:
		push_error("❌ Init: ssxltester node not found. No one to receive the scroll.")
		return

	print("\n📜 Init: Scroll prepared. Delivering to SSXLTester...")
	
	# Call the callback function on the root node to signal completion.
	tester.call("report_initialized", initialized_nodes)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively collects all nodes starting from the given node.
# ----------------------------------------------------------------------------
func _recursive_initialize(node: Node) -> void:
	# Add the current node to the collection array.
	initialized_nodes.append(node)

	# Traverse through all child nodes.
	for child in node.get_children():
		# Ensure the child is a valid Node instance before recursing.
		if child is Node:
			_recursive_initialize(child)

# --- END: ../ssxl_engine_tester\root_scripts\init.gd ---
         1 LOC | ../ssxl_engine_tester\root_scripts\logger.gd
# --- START: ../ssxl_engine_tester\root_scripts\logger.gd ---
extends Node

# --- END: ../ssxl_engine_tester\root_scripts\logger.gd ---
        85 LOC | ../ssxl_engine_tester\root_scripts\main.gd
# --- START: ../ssxl_engine_tester\root_scripts\main.gd ---
# main.gd — FINAL VERSION (2025 SSXL FFI Sync) — RENDERING FIXED
extends Node2D

signal ffi_core_ready

@onready var ssxl_oracle: Node = $"/root/ssxltester/SSXLOracle"
@onready var ssxl_engine: Node = $"/root/ssxltester/SSXLEngine"
@onready var ssxl_signals: Node = $"/root/ssxltester/SSXLSignals"
@onready var ssxl_chunk_node: Node = $"/root/ssxltester/SSXLChunk"
@onready var ssxl_tilemap: TileMap = $SSXLTilemap
@onready var clock_timer: Timer = $clocktimer
@onready var control_panel = $controlpanel

func _ready() -> void:
	print("\nSSXL Main: Quantum Boot Sequence Initiated")
	_establish_ffi_links()
	
	if not is_instance_valid(control_panel):
		push_error("FATAL: ControlPanel missing!")
		return
	
	_connect_clock_timer()
	
	# First tick to wake the oracle
	if is_instance_valid(ssxl_oracle):
		ssxl_oracle.tick()
		print("Oracle: First tick delivered.")

func _process(delta: float) -> void:
	# CRITICAL: Continuous tick loop to drain poller messages
	if is_instance_valid(ssxl_engine):
		ssxl_engine.tick(Time.get_ticks_msec())
		# Uncomment for heartbeat:
		# print("DEBUG: ssxl_engine.tick called")

func _establish_ffi_links() -> void:
	print("\nFFI LINK PHASE: Engaging Rust Core...")

	# 1. Validate critical FFI nodes
	if not (is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine)):
		push_error("FATAL: SSXLOracle or SSXLEngine missing from scene tree!")
		return

	# 2. Oracle → Engine
	ssxl_oracle.set_engine(ssxl_engine)
	print("Oracle → Engine linked")

	# 3. Presenter injection
	if not is_instance_valid(ssxl_chunk_node):
		push_error("FATAL: SSXLChunk presenter node missing!")
		return
	ssxl_engine.initialize_presenter(ssxl_chunk_node)
	print("Engine: Chunk presenter initialized")

	# 4. TileMap injection (assert the class at runtime)
	if not is_instance_valid(ssxl_tilemap):
		push_error("FATAL: SSXLTileMap missing!")
		return
	print("DEBUG: TileMap class =", ssxl_tilemap.get_class())
	ssxl_engine.set_tilemap(ssxl_tilemap)
	print("Engine: SSXLTileMap injected")

	# 5. Signals node (do this BEFORE Phase 1 so Rust can emit immediately)
	if is_instance_valid(ssxl_signals):
		ssxl_engine.set_signals_node(ssxl_signals)
		print("Engine → SSXLSignals linked")
	else:
		push_warning("SSXLSignals missing — no async callbacks!")
		return

	# 6. Phase 1: Runtime shell
	if not ssxl_engine.initialize_runtime_shell(""):
		push_error("FATAL: Runtime shell failed (Phase 1)")
		return
	print("Engine: Runtime shell ready")

	# 7. Phase 2: Spawn conductors
	if not ssxl_engine.start_async_conductors():
		push_error("FATAL: Conductors failed to spawn (Phase 2)")
		return
	print("Engine: Async conductors ALIVE")

	# 8. Connect critical signals safely (avoid duplicates)
	_connect_ffi_signals()

	print("FFI CORE FULLY INITIALIZED — EMITTING READY SIGNAL")
	call_deferred("emit_signal", "ffi_core_ready")

func _connect_ffi_signals() -> void:
	# chunk_data_ready → tile placement
	var cd_callable := Callable(control_panel.gen_logic, "_on_chunk_data_ready")
	if ssxl_signals.has_signal("chunk_data_ready"):
		if not ssxl_signals.is_connected("chunk_data_ready", cd_callable):
			ssxl_signals.chunk_data_ready.connect(cd_callable)
			print("chunk_data_ready → _on_chunk_data_ready CONNECTED — RENDERING ENABLED")
		else:
			print("chunk_data_ready → already connected, skipping")
	else:
		push_error("FATAL: 'chunk_data_ready' signal missing on SSXLSignals!")

	# Optional: hook start/complete/error for UI feedback
	var start_callable := Callable(control_panel.signal_handler, "_on_build_map_start")
	if ssxl_signals.has_signal("build_map_start") and not ssxl_signals.is_connected("build_map_start", start_callable):
		ssxl_signals.build_map_start.connect(start_callable)

	var complete_callable := Callable(control_panel.signal_handler, "_on_build_map_complete")
	if ssxl_signals.has_signal("build_map_complete") and not ssxl_signals.is_connected("build_map_complete", complete_callable):
		ssxl_signals.build_map_complete.connect(complete_callable)

	var err_callable := Callable(control_panel.signal_handler, "_on_generation_error")
	if ssxl_signals.has_signal("generation_error") and not ssxl_signals.is_connected("generation_error", err_callable):
		ssxl_signals.generation_error.connect(err_callable)

func _connect_clock_timer() -> void:
	if is_instance_valid(clock_timer) and is_instance_valid(control_panel.utility):
		clock_timer.timeout.connect(control_panel.utility.on_clock_timer_timeout)
		clock_timer.start()
		print("Clock timer connected")
	else:
		push_error("Clock timer setup failed!")

# Hook for root.gd / SSXLTester
func enter_idle_state() -> void:
	print("Main: Received control from root.gd — Entering idle state.")

# --- END: ../ssxl_engine_tester\root_scripts\main.gd ---
        23 LOC | ../ssxl_engine_tester\root_scripts\root.gd
# --- START: ../ssxl_engine_tester\root_scripts\root.gd ---
extends Node2D

var init_node: Node = null
var main_node: Node2D = null

var initialized_nodes: Array = []

var is_custom_init_running: bool = false

func _ready():
	call_deferred("_start_custom_initialization")

func _start_custom_initialization():
	if is_custom_init_running:
		return
	is_custom_init_running = true

	init_node = get_node("init")
	main_node = get_node("main")

	if not is_instance_valid(init_node) or not is_instance_valid(main_node):
		return

	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes

	if is_instance_valid(main_node):
		main_node.call("enter_idle_state") 
	
	is_custom_init_running = false
	if is_instance_valid(init_node):
		pass

# --- END: ../ssxl_engine_tester\root_scripts\root.gd ---
        11 LOC | ../ssxl_engine_tester\root_scripts\scenescanner.gd
# --- START: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
extends Node

# Signal emitted when the scan is complete. It passes a Dictionary (map) 
# where keys are node names (lowercase) and values are their full NodePaths.
signal tree_ready(map: Dictionary)

# ----------------------------------------------------------------------------
# CORE FUNCTION: Initiates the scene tree scan and emits the completion signal.
# ----------------------------------------------------------------------------
func scan_tree():
	# The dictionary that will store the node name -> path mapping.
	var map: Dictionary = {}
	
	# Start the recursive scan from the root of the active scene tree.
	_recursive_scan(get_tree().root, map)
	
	# Signal that the scan is complete, passing the resulting map.
	emit_signal("tree_ready", map)

# ----------------------------------------------------------------------------
# UTILITY FUNCTION: Recursively traverses the node tree.
# ----------------------------------------------------------------------------
func _recursive_scan(node: Node, map: Dictionary):
	# Add the current node's name (lowercase for easy lookup) and its full path to the map.
	map[node.name.to_lower()] = node.get_path()
	
	# Recurse through all children.
	for child in node.get_children():
		# Ensure the child is a valid Node before passing it to the function.
		if child is Node:
			_recursive_scan(child, map)
# --- END: ../ssxl_engine_tester\root_scripts\scenescanner.gd ---
         5 LOC | ../ssxl_engine_tester\root_scripts\ssxl_signals.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---

extends Node

# ==============================================================================
# FFI Data Plane Signals (Emitted by the Rust GDExtension)
# These signals MUST be declared here to be visible to GDScript.
# ==============================================================================

# 1. PRIMARY DATA CHANNEL (CRITICAL FIX)
signal chunk_ready(data: Dictionary) 

# 2. GENERATION COMPLETION SIGNAL
signal build_map_complete()
# NOTE: The FFI manifest calls this 'generation_complete', but your GDScript checks for 'build_map_complete'.

# 3. STATUS / LOGGING SIGNAL
signal engine_status_updated(status: String)
# NOTE: The FFI manifest calls this 'status_update', but your GDScript checks for 'engine_status_updated'.

# 4. ANIMATION/TICKER SIGNAL
signal tile_flip_updated(tile_id: int, flip_frame: int)

# The Rust GDExtension is responsible for emitting these signals; 
# this script just makes them visible to the Godot environment.

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_signals.gd ---
        27 LOC | ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd
# --- START: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
# ssxl_tilemap.gd
extends TileMap

# This method is called by the Rust ChunkPresenter via a deferred FFI call.
func receive_chunk_data(binary_data: PackedByteArray) -> void:
	print("📢 SSXL_TILEMAP: Received chunk data (Size: %d bytes)" % binary_data.size()) # <-- DIAGNOSTIC 1
	
	# 1. Deserialize the PackedByteArray back into a Dictionary.
	var batch_data = bytes_to_var(binary_data)
	
	# CRITICAL FIX: Check if deserialization failed (returns Nil)
	if not batch_data is Dictionary:
		push_error("❌ FFI ERROR: Deserialization failed. Received Nil from bytes_to_var(). Check Rust serialization/var_to_bytes format.")
		return
	
	# 2. Extract the batched arrays from the Dictionary
	# IMPORTANT: The batch dictionary must contain these keys with valid Godot types
	var layer: int = batch_data.get("layer", 0)
	var positions: Array[Vector2i] = batch_data.get("positions", [])
	var source_ids: Array[int] = batch_data.get("source_ids", [])
	var atlas_coords: Array[Vector2i] = batch_data.get("atlas_coords", [])
	var alt_tiles: Array[int] = batch_data.get("alt_tiles", [])
	
	# DIAGNOSTIC 2
	print("📢 SSXL_TILEMAP: Deserialization successful. Placing %d tiles." % positions.size()) 
	
	if positions.is_empty():
		return

	# 3. Iterative set_cell() rendering
	# Note: This loop can be slow for 147k tiles.
	var tiles_set: int = 0
	for i in range(positions.size()):
		# We confirmed Source ID 0 is correct, but ensure Atlas Coords are valid.
		self.set_cell(
			layer,
			positions[i],
			source_ids[i],
			atlas_coords[i],
			alt_tiles[i]
		)
		tiles_set += 1

	print("✅ SSXL_TILEMAP: Successfully set %d tiles. Requesting update." % tiles_set)
	
	# 4. Request a manual TileMap update
	self.force_update()

# --- END: ../ssxl_engine_tester\root_scripts\ssxl_tilemap.gd ---
         3 LOC | ../ssxl_engine_tester\root_scripts\tester.gd
# --- START: ../ssxl_engine_tester\root_scripts\tester.gd ---
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

# --- END: ../ssxl_engine_tester\root_scripts\tester.gd ---
        56 LOC | ../ssxl_engine_tester\tests\headless_gen_pipeline.gd
# --- START: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
extends Node

# Ensure this matches your GDExtension class name
const ENGINE_CLASS_NAME = "SSXLEngine"

# --- Utility Functions ---

# Loads the SSXLEngine GDExtension instance.
func create_engine_instance():
    if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
        printerr("FATAL: GDExtension is not compiled or registered.")
        return null
    return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Function to explicitly format and print the result
# CRITICAL: This uses 'print' (stdout) for Rust to capture the result.
func print_test_result(test_name, success, reason):
    if success:
        print("✅ GDSCIPT TEST PASS: %s" % test_name)
    else:
        # Use printerr for detailed failures, still captured by Rust's stderr handler.
        printerr("❌ GDSCIPT TEST FAIL: %s | Reason: %s" % [test_name, reason])

# Core validation logic
func check_data_integrity(data):
    if not data is Dictionary:
        printerr("FAIL: FFI return is not a Dictionary.")
        return false
    if not data.has("tiles") or not data.has("tile_count"):
        printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
        return false
    
    var tiles = data.tiles
    var tile_count = data.tile_count
    
    # Informative log to help debug generation issues
    print("INFO: Received chunk data. Tile count: %d" % tile_count)
    
    if tile_count == 0 or tiles.is_empty():
        printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
        return false
        
    # Add more detailed checks here (e.g., data types for 'id' and 'level')
    if typeof(tiles[0].id) != TYPE_INT or typeof(tiles[0].level) != TYPE_FLOAT:
        printerr("FAIL: Tile data type mismatch detected across FFI boundary.")
        return false
        
    return true

# --- NEW FUNCTION: Defer the quit to ensure stdout flush ---
# This is the most reliable way to guarantee that all print() calls 
# are processed by the engine before the process terminates.
func quit_safe(code: int):
    # Wait one process frame to ensure all deferred print calls are flushed
    await get_tree().process_frame 
    get_tree().quit(code)

# --- CORE TEST RUNNER ---

func _ready():
    # 1. Instantiate the Rust Engine
    var engine = create_engine_instance()
    
    var test_passed = false
    var failure_reason = "GDExtension instantiation failed."
    var exit_code = 1 # Assume failure by default
    
    if engine == null:
        # Handle instantiation failure immediately
        print_test_result("Generation Integration Test", test_passed, failure_reason)
        # exit_code remains 1
    else:
        # 2. Run the actual generation test logic
        failure_reason = "Unknown error."
        var test_x = 100
        var test_y = 200
        
        print("TEST: Requesting generation for chunk (%d, %d)..." % [test_x, test_y])
        
        # Call the FFI function from Rust
        var chunk_data = engine.request_generation(test_x, test_y) 
        
        if chunk_data:
            if check_data_integrity(chunk_data):
                test_passed = true
                exit_code = 0 # Success
                failure_reason = "N/A"
            else:
                failure_reason = "Data integrity check failed (see errors above)."
        else:
            failure_reason = "FFI call returned null or an invalid result."

        # 3. Report Final Status
        print_test_result("Generation Integration Test", test_passed, failure_reason)
    
    # 4. Defer the exit command to the safe function
    call_deferred("quit_safe", exit_code)
# --- END: ../ssxl_engine_tester\tests\headless_gen_pipeline.gd ---
        20 LOC | ../ssxl_engine_tester\test_scripts\control_panel.gd
# --- START: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

# --- END: ../ssxl_engine_tester\test_scripts\control_panel.gd ---
        44 LOC | ../ssxl_engine_tester\test_scripts\test_ffi_data.gd
# --- START: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("✅ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("❌ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

# --- END: ../ssxl_engine_tester\test_scripts\test_ffi_data.gd ---
------------------------------------------------------
       4437 LOC | *.rs (Rust Total)
       961 LOC | *.gd (GDScript Total)
       5398 LOC | TOTALS
