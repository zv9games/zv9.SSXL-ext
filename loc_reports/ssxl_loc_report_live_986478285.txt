SSXL-ext Live LOC Report
Generated (UTC): 2025-11-12 00:39:57
Generated (Epoch Seconds): 1762907998
Root Directories: .\rust, .\SSXL_engine_tester
Target Extensions: rs, gd, gdc, toml, md

------------------------------------------------------
 FILE LOC | Relative File Path
------------------------------------------------------
       82 LOC | rust\cargo.toml
       76 LOC | rust\manifest.rs
        8 LOC | rust\manifest_tips.rs
        9 LOC | rust\no_space_batch.rs
       13 LOC | rust\config\engine.toml
       19 LOC | rust\ssxl_animate\Cargo.toml
       57 LOC | rust\ssxl_animate\src\animation_logic.rs
       77 LOC | rust\ssxl_animate\src\conductor.rs
       83 LOC | rust\ssxl_animate\src\lib.rs
       56 LOC | rust\ssxl_animate\src\worker.rs
       13 LOC | rust\ssxl_cache\Cargo.toml
       89 LOC | rust\ssxl_cache\src\lib.rs
       34 LOC | rust\ssxl_cli\Cargo.toml
      176 LOC | rust\ssxl_cli\src\cli_util_bench.rs
      152 LOC | rust\ssxl_cli\src\cli_util_inspect.rs
      125 LOC | rust\ssxl_cli\src\cli_util_menu.rs
      124 LOC | rust\ssxl_cli\src\main.rs
       99 LOC | rust\ssxl_cli\src\actions\benchmarking.rs
      100 LOC | rust\ssxl_cli\src\actions\godot_harness.rs
       68 LOC | rust\ssxl_cli\src\actions\mod.rs
       47 LOC | rust\ssxl_cli\src\actions\testing.rs
       90 LOC | rust\ssxl_cli\src\actions\test_core_suites.rs
      137 LOC | rust\ssxl_cli\src\actions\test_suites.rs
      120 LOC | rust\ssxl_cli\src\scan\file_walker.rs
       13 LOC | rust\ssxl_cli\src\scan\mod.rs
       97 LOC | rust\ssxl_cli\src\scan\report_formatter.rs
       33 LOC | rust\ssxl_cli\src\scan\report_section_formatter.rs
      100 LOC | rust\ssxl_cli\src\scan\report_writer.rs
       15 LOC | rust\ssxl_engine_ffi\Cargo.toml
      130 LOC | rust\ssxl_engine_ffi\src\lib.rs
       24 LOC | rust\ssxl_generate\Cargo.toml
       88 LOC | rust\ssxl_generate\src\batch_processor.rs
       25 LOC | rust\ssxl_generate\src\benchmark_logic.rs
      176 LOC | rust\ssxl_generate\src\cellular_automata_generator.rs
      193 LOC | rust\ssxl_generate\src\conductor.rs
      105 LOC | rust\ssxl_generate\src\conductor_state.rs
       83 LOC | rust\ssxl_generate\src\config_validator.rs
       30 LOC | rust\ssxl_generate\src\generator.rs
       82 LOC | rust\ssxl_generate\src\generator_manager.rs
       71 LOC | rust\ssxl_generate\src\lib.rs
       97 LOC | rust\ssxl_generate\src\perlin_generator.rs
       50 LOC | rust\ssxl_generate\src\runtime_manager.rs
       19 LOC | rust\ssxl_generate\src\sync.rs
      143 LOC | rust\ssxl_generate\src\task_queue.rs
       16 LOC | rust\ssxl_generate\src\ca\mod.rs
       44 LOC | rust\ssxl_generate\src\ca\neighbor_check.rs
       56 LOC | rust\ssxl_generate\src\ca\rule_set.rs
       28 LOC | rust\ssxl_godot\Cargo.toml
      166 LOC | rust\ssxl_godot\src\animation_api.rs
      132 LOC | rust\ssxl_godot\src\api_initializers.rs
      161 LOC | rust\ssxl_godot\src\async_poll.rs
       67 LOC | rust\ssxl_godot\src\build.rs
      116 LOC | rust\ssxl_godot\src\channel_handler.rs
      166 LOC | rust\ssxl_godot\src\chunk_presenter.rs
       91 LOC | rust\ssxl_godot\src\engine_core_logic.rs
       56 LOC | rust\ssxl_godot\src\gde_api_defs.rs
      144 LOC | rust\ssxl_godot\src\generation_api.rs
       56 LOC | rust\ssxl_godot\src\lib.rs
      162 LOC | rust\ssxl_godot\src\ssxl_engine.rs
      108 LOC | rust\ssxl_godot\src\ssxl_oracle.rs
       59 LOC | rust\ssxl_godot\src\ssxl_signals.rs
       50 LOC | rust\ssxl_godot\src\status_reporter.rs
       16 LOC | rust\ssxl_math\Cargo.toml
      118 LOC | rust\ssxl_math\src\coordinate_system.rs
       62 LOC | rust\ssxl_math\src\generation_utils.rs
       97 LOC | rust\ssxl_math\src\hashing.rs
       50 LOC | rust\ssxl_math\src\lib.rs
       58 LOC | rust\ssxl_math\src\primitives.rs
       14 LOC | rust\ssxl_shared\cargo.toml
      162 LOC | rust\ssxl_shared\src\chunk_data.rs
       22 LOC | rust\ssxl_shared\src\config.rs
       60 LOC | rust\ssxl_shared\src\errors.rs
       40 LOC | rust\ssxl_shared\src\generation_message.rs
       64 LOC | rust\ssxl_shared\src\grid_bounds.rs
       72 LOC | rust\ssxl_shared\src\lib.rs
       41 LOC | rust\ssxl_shared\src\math_primitives.rs
       25 LOC | rust\ssxl_shared\src\messages.rs
      123 LOC | rust\ssxl_shared\src\tile_data.rs
      107 LOC | rust\ssxl_shared\src\tile_type.rs
       24 LOC | rust\ssxl_sync\Cargo.toml
       91 LOC | rust\ssxl_sync\src\animation_conductor.rs
       65 LOC | rust\ssxl_sync\src\lib.rs
      149 LOC | rust\ssxl_sync\src\pool_manager.rs
       44 LOC | rust\ssxl_sync\src\primitives.rs
       10 LOC | rust\ssxl_tools\Cargo.toml
      127 LOC | rust\ssxl_tools\src\lib.rs
       21 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\Aetherion.gd
       31 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd
       21 LOC | SSXL_engine_tester\addons\S2O_godot_plugin\SSXL.gd
      109 LOC | SSXL_engine_tester\root_scripts\cameras.gd
        1 LOC | SSXL_engine_tester\root_scripts\camera_2.gd
      118 LOC | SSXL_engine_tester\root_scripts\controlpanelanimation.gd
      182 LOC | SSXL_engine_tester\root_scripts\controlpanelgenlogic.gd
       68 LOC | SSXL_engine_tester\root_scripts\controlpanelsignalhandler.gd
      121 LOC | SSXL_engine_tester\root_scripts\controlpaneluisetup.gd
      155 LOC | SSXL_engine_tester\root_scripts\controlpanelutility.gd
      133 LOC | SSXL_engine_tester\root_scripts\control_panel.gd
       37 LOC | SSXL_engine_tester\root_scripts\engine_monitor.gd
       22 LOC | SSXL_engine_tester\root_scripts\init.gd
        1 LOC | SSXL_engine_tester\root_scripts\logger.gd
       70 LOC | SSXL_engine_tester\root_scripts\main.gd
      100 LOC | SSXL_engine_tester\root_scripts\main1.gd
       22 LOC | SSXL_engine_tester\root_scripts\root.gd
       10 LOC | SSXL_engine_tester\root_scripts\scenescanner.gd
        5 LOC | SSXL_engine_tester\root_scripts\tester.gd
       23 LOC | SSXL_engine_tester\test_scripts\control_panel.gd
       72 LOC | SSXL_engine_tester\test_scripts\test_ffi_data.gd
------------------------------------------------------
     8069 LOC | TOTAL
------------------------------------------------------


======================================================
          RAW SOURCE CODE DUMP (FOR CONTEXT)
======================================================
======================================================
======================================================
[workspace]
# Defines the members (crates) of the SSXL Engine workspace, grouped by
# their architectural layer as defined in the development plan.
members = [
    # 1. Foundation Layer (Core Data & Primitives - P1)
    "ssxl_shared",
    "ssxl_math",
    "ssxl_sync",

    # 2. Processing Layer (Computation & Persistence - P2)
    "ssxl_generate",
    "ssxl_cache",

    # 3. Interface Layer (External Bridges - P3)
    "ssxl_engine_ffi",
    "ssxl_godot",

    # 4. Tooling & Execution Layer
    "ssxl_tools",
    "ssxl_cli",
	"ssxl_animate",
]
resolver = "2" # Use the new cargo feature resolver

[workspace.package]
edition = "2021"
license = "MIT OR Apache-2.0"
rust-version = "1.75" # Set a standard base Rust version

[workspace.dependencies]
# ------------------------------------------------------------------
# CORE UTILITIES & DATA MANAGEMENT
# ------------------------------------------------------------------
serde               = { version = "1.0", features = ["derive"] }
serde_json          = "1.0"
serde-big-array = "0.4.1"
bincode             = "1.3"
thiserror           = "1.0"  # Canonical error definition (used by aetherion_shared)
uuid                = { version = "1.8", features = ["v4", "fast-rng"] }
# FIX: Added anyhow to workspace dependencies to resolve the inheritance error.
anyhow              = "1.0" 

# ------------------------------------------------------------------
# TRACING AND DIAGNOSTICS
# ------------------------------------------------------------------
tracing             = "0.1" # Core tracing library (replaces 'log')
tracing-subscriber  = "0.3" # Used to manage and output tracing data (replaces 'env_logger')

# ------------------------------------------------------------------
# TIME, RANDOMNESS, AND PARSING
# ------------------------------------------------------------------
chrono              = { version = "0.4", features = ["serde"] } 
rand                = { version = "0.8", features = ["small_rng"] }
rand_pcg            = "0.9"
nom                 = "7.1"
regex               = "1.11"
once_cell           = "1.19" # Preferred over lazy_static for statics

# ------------------------------------------------------------------
# CONCURRENCY AND MATH
# ------------------------------------------------------------------
tokio               = { version = "1.37", features = ["sync", "rt-multi-thread", "macros"] } # The primary async runtime
rayon               = "1.10" # Used for parallel synchronous processing
crossbeam           = "0.8"
crossbeam-channel   = "0.5"
parking_lot         = "0.12" # High-performance synchronization primitives
glam                = "0.28" # High-performance linear algebra library (Vectors, Matrices)
sha2                = "0.10"
image               = "0.24" # For image processing in aetherion_tools
noise               = "0.9"
async-trait         = "0.1"
# ------------------------------------------------------------------
# CLI AND CONSOLE UTILITIES
# ------------------------------------------------------------------
crossterm           = "0.27" 
walkdir             = "2.5" 
ctrlc               = "3.4"
godot = { version = "0.4.0", features = ["serde"] } 
godot-ffi = { path = "../../zv9.gdext/godot-ffi", features = ["api-custom"] }
fastrand = "2.0"
num_cpus = "1.17.0"

[workspace.lints.rust]
unsafe_code      = "deny"
unused_variables = "warn"
dead_code        = "warn"

[workspace.features]
default   = []
profile   = []
parallel  = []
fast_rng  = []

>>> FILE END: rust\cargo.toml <<<

======================================================
======================================================
SSXL-ext is a mythic core — a modular, dimension-agnostic  
procedural generation engine coded in Rust as a GDExtension  
for Godot 4.2+ →).

🪶 Manifest v9.0.seed


#files


C:/ZV9/zv9.SSXL-ext/rust

Crate: ssxl_cache/src
├── [CORE]  lib.rs $

🔍 Crate: ssxl_engine_ffi/src
├── [CORE]  lib.rs $

🔍 Crate: ssxl_generate/src
│   └──  batch_processor.rs $
│   └──  benchmark_logic.rs $
│   └──  ca\mod.rs $
│   └──  ca\neighbor_check.rs $
│   └──  ca\rule_set.rs $
│   └──  cellular_automata_generator.rs $
│   └──  conductor.rs $
│   └──  conductor_state.rs $
│   └──  config_validator.rs $
│   └──  generator.rs $
│   └──  generator_manager.rs $
├── [CORE]  lib.rs $
│   └──  perlin_generator.rs $
│   └──  runtime_manager.rs $
│   └──  sync.rs $
│   └──  task_queue.rs $

🔍 Crate: ssxl_godot/src
│   └──  animation_api.rs $
│   └──  api_initializers.rs $
│   └──  async_poll.rs $
│   └──  build.rs $
│   └──  channel_handler.rs $
│   └──  chunk_presenter.rs $
│   └──  gde_api_defs.rs $
│   └──  generation_api.rs $
├── [CORE]  lib.rs $
│   └──  ssxl_engine.rs $
│   └──  ssxl_oracle.rs $
│   └──  ssxl_signals.rs $

🔍 Crate: ssxl_math/src
│   └──  coordinate_system.rs $
│   └──  generation_utils.rs $
│   └──  hashing.rs $
├── [CORE]  lib.rs $
│   └──  primitives.rs $

🔍 Crate: ssxl_shared/src
│   └──  chunk_data.rs $
│   └──  config.rs $
│   └──  errors.rs $
│   └──  generation_message.rs $
│   └──  grid_bounds.rs $
├── [CORE]  lib.rs $
│   └──  math_primitives.rs $
│   └──  messages.rs $
│   └──  tile_data.rs $
│   └──  tile_type.rs $

🔍 Crate: ssxl_sync/src
│   └──  animation_conductor.rs $
├── [CORE]  lib.rs $
│   └──  pool_manager.rs $
│   └──  primitives.rs $

🔍 Crate: ssxl_tools/src
├── [CORE]  lib.rs $

🔍 Crate: ssxl_cli/src
│   └──  actions\benchmarking.rs $
│   └──  actions\godot_harness.rs $
│   └──  actions\mod.rs $
│   └──  actions\testing.rs $
│   └──  cli_util_bench.rs $
│   └──  cli_util_inspect.rs $
│   └──  cli_util_menu.rs $
├── [CORE]  main.rs $
│   └──  scan\file_walker.rs $
│   └──  scan\mod.rs $
│   └──  scan\report_formatter.rs $



>>> FILE END: rust\manifest.rs <<<

======================================================
======================================================
tidbits:

1.
Search the Windows Start Menu for "Edit the system environment variables" and open it.

Click the "Environment Variables..." button.

Under "User variables for [YourName]", click "New...".

Set the Variable name to GODOT4_BIN.

Set the Variable value to C:\zv9\zv9.SSXL-ext\SSXL_engine_tester\godot.windows.editor.x86_64.exe.

Click OK.



>>> FILE END: rust\manifest_tips.rs <<<

======================================================
======================================================
# powershell command. removes no break space. 

(Get-Content -Path ssxl_sync/src/lib.rs) -replace [char]0x00A0, ' ' | Set-Content -Path ssxl_sync/src/lib.rs

# powershell command. removes new visibile corruption from no break space removal. 

# Step 2: Replace the corrupted 'Â' character (U+00C2) with nothing, and the NBSP (U+00A0) with a standard space.
(Get-Content -Path ssxl_sync/src/lib.rs) -replace [char]0x00C2, '' -replace [char]0x00A0, ' ' | Set-Content -Path ssxl_sync/src/lib.rs

#powershell command. cleans the whole directory. 

Get-ChildItem -Path . -Include *.rs -Recurse | ForEach-Object {
    (Get-Content $_.FullName) -replace [char]0x00C2, '' -replace [char]0x00A0, ' ' | Set-Content $_.FullName
}
>>> FILE END: rust\no_space_batch.rs <<<

======================================================
======================================================
# config/engine.toml

# --- Core Engine Settings ---
[engine]
# Enables/disables advanced logging features (e.g., debug tracing)
# logging_level = "info" # Example setting not in SSXLConfig, but common

# --- Generation Defaults ---
[generation]
# The generator ID to use when no specific generator is requested by the FFI/CLI.
# Options include "perlin_basic_2d", "cellular_automata_basic", etc.
default_generator_id = "perlin_basic_2d"

# The specific ruleset ID to use for the Cellular Automata generator (if selected).
# 0: Basic Cave, 1: Maze/Dungeon, etc.
ca_default_ruleset = 1
>>> FILE END: rust\config\engine.toml <<<

======================================================
======================================================
# ssxl_animate/Cargo.toml

[package]
name = "ssxl_animate"
version = "0.1.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_sync = { path = "../ssxl_sync", features = ["godot-bindings"] }
# --- EXTERNAL DEPENDENCIES ---

# CORE GDExtension BINDINGS
godot = { workspace = true }
godot-ffi = { workspace = true }
# Workspace standard logging framework
tracing = { workspace = true }
tokio = { workspace = true }
rand = { workspace = true }
async-trait = { workspace = true }


>>> FILE END: rust\ssxl_animate\Cargo.toml <<<

======================================================
======================================================
// ssxl_animate/src/animation_logic.rs
//! Defines the concrete, pure logic for executing individual animation effects.
//! This module contains only CPU-bound functions with no I/O, threading, or Godot dependencies.

use crate::{AnimationUpdate, AnimationPayload};
use ssxl_shared::primitives::ChunkId; 
use ssxl_math::primitives::TileCoord; 

/// Defines the various types of animation behaviors that workers can execute.
#[derive(Debug, Clone)]
pub enum AnimationType {
    TileFlip,      // Simple state toggle
    TweenMove,     // Complex vector interpolation
    PulseFade(f32), // State with parameter (e.g., intensity)
    CustomScripted(String),
}

/// Executes the core animation logic for a single spatial chunk.
/// 
/// This function is pure: it takes data and returns data. It is perfectly suited 
/// for **Rayon's parallel execution** over the ChunkId.
pub fn execute_for_chunk(chunk_id: ChunkId, anim_type: AnimationType) -> Vec<AnimationUpdate> {
    // 1. Fetch the tiles relevant to this chunk_id (from a thread-safe cache/map).
    let tiles_in_chunk: Vec<TileCoord> = get_tiles_for_chunk(chunk_id);
    let mut updates = Vec::with_capacity(tiles_in_chunk.len());

    for coord in tiles_in_chunk {
        // 2. Compute the new state based on the requested animation type.
        let payload = match anim_type {
            AnimationType::TileFlip => {
                // Example: Calculate the next frame based on tile position/global time (not shown).
                AnimationPayload::FrameUpdate { new_frame: (coord.x.checked_add(coord.y).unwrap_or(0)) % 4 }
            },
            AnimationType::PulseFade(intensity) => {
                // Example: Perform complex Perlin noise or sine-wave calculation here.
                let value = calculate_tween_value(coord, intensity);
                AnimationPayload::TweenValue { key: "alpha".into(), value }
            }
            AnimationType::TweenMove | AnimationType::CustomScripted(_) => continue, 
        };
        updates.push(AnimationUpdate { coord, payload });
    }
    updates
}

/// Placeholder for heavy math logic, keeping `execute_for_chunk` clean.
fn calculate_tween_value(_coord: TileCoord, intensity: f32) -> f32 {
    // This is where the complex, CPU-intensive **tween calculation** should live.
    // Example: (1.0 - sin(coord.x * PI / 10.0)) * intensity
    1.0 * intensity // Return a calculated value between 0.0 and 1.0
}

/// Placeholder for a function that fetches tile coordinates belonging to a chunk.
fn get_tiles_for_chunk(_chunk_id: ChunkId) -> Vec<TileCoord> {
    // TODO: Final implementation must optimize this data access, likely via ssxl_cache.
    // Return a simplified, fixed set for logic testing purposes.
    vec![
        TileCoord { x: 0, y: 0, z: 0 },
        TileCoord { x: 1, y: 0, z: 0 },
        TileCoord { x: 0, y: 1, z: 0 },
        TileCoord { x: 1, y: 1, z: 0 },
    ]
}
>>> FILE END: rust\ssxl_animate\src\animation_logic.rs <<<

======================================================
======================================================
use crate::{ConductorBehavior, AnimationCommand, CommandResult, AnimationState, UpdateSender};
use crate::worker::process_command_parallel; // CRITICAL: Import the delegation function
use async_trait::async_trait;
use tokio::sync::mpsc::UnboundedReceiver;
use tracing::warn;

/// The core, single-threaded struct responsible for managing all animation workers.
/// It holds the Receiver for commands and the Sender for updates to the Godot main thread.
pub struct AnimationConductor {
    // The Receiver side of the command channel
    command_rx: UnboundedReceiver<AnimationCommand>,
    // This Sender is USED to pass to the worker.
    update_tx: UpdateSender, 
    state: AnimationState,
}

impl AnimationConductor {
    pub fn new(
        command_rx: UnboundedReceiver<AnimationCommand>,
        update_tx: UpdateSender,
        initial_state: AnimationState,
    ) -> Self {
        AnimationConductor {
            command_rx,
            update_tx,
            state: initial_state,
        }
    }
}

#[async_trait]
impl ConductorBehavior for AnimationConductor {
    async fn start_loop(&mut self) {
        // The main event loop for the Conductor. This loop manages the **tempo**.
        // It awaits a command, then immediately processes it (delegates) or acts on it (state change).
        while let Some(command) = self.command_rx.recv().await {
            let _ = self.process_command(command);
        }
    }

    /// Processes a command, delegating heavy computation to the worker pool.
    /// This function MUST return quickly to keep the Conductor's tempo fast.
    fn process_command(&mut self, command: AnimationCommand) -> CommandResult {
        match command {
            // ----------------------------------------------------
            // 1. Delegate High-Performance Work (Tile Updates)
            // ----------------------------------------------------
            // This handles the primary procedural tile generation and animation requests.
            AnimationCommand::AnimateChunks { .. } | AnimationCommand::StartTestAnimation => {
                // CRITICAL OPTIMIZATION: Delegate work and clone the sender for the worker
                // This call SUBMITS the job to a parallel thread/task and returns immediately.
                process_command_parallel(command, self.update_tx.clone());
                Ok(())
            }
            // ----------------------------------------------------
            // 2. Local State Management
            // ----------------------------------------------------
            AnimationCommand::SetTimeScale(scale) => {
                // NOTE: This state update is safe because it only runs on the async Conductor thread.
                self.state.set_time_scale(scale); 
                Ok(())
            }
            // ----------------------------------------------------
            // 3. System Commands
            // ----------------------------------------------------
            AnimationCommand::Shutdown => {
                // Close the receiver, which will gracefully exit the start_loop
                self.command_rx.close();
                Ok(())
            }
            // Catch-all is mandatory for robust systems
            _ => {
                warn!("Received unhandled command: {:?}", command);
                Ok(())
            }
        }
    }

    fn get_state(&self) -> AnimationState {
        self.state.clone()
    }
}
>>> FILE END: rust\ssxl_animate\src\conductor.rs <<<

======================================================
======================================================
//! # ssxl_animate
//!
//! This crate contains the **Animation Conductor** and associated logic responsible for
//! managing all real-time visual updates, tweens, and complex tile animations for the
//! SSXL-ext engine. It operates asynchronously, feeding updates back to the Godot
//! main thread via non-blocking communication channels.

// --- Standard Library & External Crates ---
use tracing::info;
use std::sync::{Arc, Mutex};
use async_trait::async_trait;
use tokio::sync::mpsc; // CRITICAL: Used for the asynchronous, non-blocking channel

// --- SSXL Internal Crates ---
// NOTE: We rely on ssxl_sync to define the core command and state types.
use ssxl_sync::{
    AnimationCommand,
    AnimationConductorHandle, // Alias for Sender<AnimationCommand>
    AnimationState,
    UpdateSender,             // Alias for Sender<AnimationUpdate>
    CommandResult,
};
use ssxl_math::primitives::TileCoord; 

// --- Internal Modules ---
mod conductor;             
mod worker;              
mod animation_logic;       


// -----------------------------------------------------------------------------
// Core Public API
// -----------------------------------------------------------------------------

pub use conductor::AnimationConductor;
pub use animation_logic::AnimationType; 

/// Defines the primary trait for the Animation Conductor.
/// This trait enforces the necessary async structure for the runtime.
#[async_trait]
pub trait ConductorBehavior: Send + Sync + 'static {
    async fn start_loop(&mut self);

    fn process_command(&mut self, command: AnimationCommand) -> CommandResult;

    fn get_state(&self) -> AnimationState;
}

/// Initializes and returns the necessary components for the Animation Conductor.
///
/// Returns: (Command Handle, Arc<Mutex<Conductor>>)
/// The Handle is sent to the Godot FFI layer (`ssxl_sync`) to send commands.
pub fn initialize_animation_conductor(
    // The UpdateSender is the pipe from the *workers* back to the Godot FFI poller.
    // It is passed through the Conductor to the Worker module.
    update_tx: UpdateSender,
    initial_state: AnimationState,
) -> (AnimationConductorHandle, Arc<Mutex<AnimationConductor>>) {
    info!("ssxl_animate: Initializing Animation Conductor circuit.");
    
    // Wire the command channel: The primary control line
    let (command_tx, command_rx) = mpsc::unbounded_channel();
    
    let handle: AnimationConductorHandle = command_tx; 

    // Create the core conductor structure which owns the Receiver (command_rx).
    let conductor = AnimationConductor::new(
        command_rx, 
        update_tx,
        initial_state,
    );

    // Conductor is wrapped in Arc<Mutex> for safe shutdown/runtime management.
    (handle, Arc::new(Mutex::new(conductor)))
}

// -----------------------------------------------------------------------------
// Data Structures (The Update Wire)
// -----------------------------------------------------------------------------

/// The message type sent back to the Godot main thread for visual updates.
#[derive(Debug, Clone)]
pub struct AnimationUpdate {
    /// The tile coordinates being affected.
    pub coord: TileCoord,
    /// The specific visual state change (e.g., new tile ID, frame, color).
    pub payload: AnimationPayload,
}

#[derive(Debug, Clone)]
pub enum AnimationPayload {
    /// Update to the tile's frame index (e.g., for sprite sheet animation)
    FrameUpdate { new_frame: i32 },
    /// Request to change the tile's data or type
    TileSwap { new_tile_id: i32 },
    /// Generic value change for complex tweens (e.g., alpha, color)
    TweenValue { key: String, value: f32 },
}
>>> FILE END: rust\ssxl_animate\src\lib.rs <<<

======================================================
======================================================
// ssxl_animate/src/worker.rs
//! Core worker module responsible for executing complex, parallel, CPU-bound animation tasks.
//! All heavy calculation for large-scale procedural tile animation is executed here
//! using Rayon for data parallelism over spatial chunks.

use rayon::prelude::*;
use tracing::info;
use ssxl_sync::{AnimationCommand, UpdateSender};
use ssxl_shared::primitives::ChunkId; // Assuming ChunkId is defined here or imported
use crate::animation_logic;          // Import functions from sibling module
use crate::AnimationType;            // Use public type from lib.rs

/// Initializes the global Rayon thread pool for maximal data parallelism.
/// This should be called once during engine initialization.
pub fn initialize_worker_pool(count: usize) {
    // Only attempt to configure if not already configured.
    if rayon::ThreadPoolBuilder::new()
        .num_threads(count)
        .build_global()
        .is_ok()
    {
        info!("Animation worker pool (Rayon) initialized with {} threads.", count);
    } else {
        // This is normal if called multiple times or configured elsewhere.
        info!("Animation worker pool (Rayon) found or failed to initialize.");
    }
}

/// Executes the animation command in parallel, delegating work immediately off
/// the Conductor's async thread to the Rayon pool.
///
/// This function *must* return instantly to maintain the Conductor's fast tempo.
pub fn process_command_parallel(command: AnimationCommand, update_tx: UpdateSender) {
    if let AnimationCommand::AnimateChunkSet { chunk_ids, anim_type } = command {
        
        // Use std::thread::spawn to move execution off the Conductor's single async
        // task and safely into a closure that executes the parallel computation.
        std::thread::spawn(move || {
            
            // CRITICAL: The parallel iterator ensures the workload is split across all
            // available Rayon threads, processing chunks concurrently.
            chunk_ids.par_iter().for_each(|&chunk_id: &ChunkId| {
                
                // 1. Perform animation calculation (pure, math-heavy logic)
                let tile_updates = animation_logic::execute_for_chunk(
                    chunk_id, 
                    anim_type.clone()
                );
                
                // 2. Send all results back to the main thread's poller via the channel.
                for update in tile_updates {
                    // Use .ok() to silently ignore send errors (e.g., if the receiver has shut down).
                    let _ = update_tx.send(update).ok(); 
                }
            });

            info!("Finished parallel processing for chunk set.");
        });
    }
}
>>> FILE END: rust\ssxl_animate\src\worker.rs <<<

======================================================
======================================================
[package]
name = "ssxl_cache"
edition = "2021"

[dependencies]
# Internal Dependencies (Local Crates)
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_sync = { path = "../ssxl_sync" }

# External Dependencies (Workspace-Inherited)
bincode = { workspace = true }
sha2 = { workspace = true }
glam = { workspace = true }
tracing = { workspace = true }

>>> FILE END: rust\ssxl_cache\Cargo.toml <<<

======================================================
======================================================
//! In-memory caching layer for storing and retrieving procedural generation data (Chunks).
//!
//! This module defines the core thread-safe cache (`ChunkCache`) responsible for holding
//! `ChunkData` generated by the SSXL engine. It is optimized for high-speed concurrent
//! access across multiple worker threads using `ssxl_sync::AtomicResource`.

use ssxl_math::coordinate_system::ChunkKey;
use ssxl_sync::AtomicResource;
use ssxl_shared::chunk_data::ChunkData;
use std::collections::HashMap;
use std::io; // Required for the Result type, ensuring robust initialization and I/O interface.
use tracing::{info, warn};

// --- 1. Type Definitions ---

/// Type alias for the thread-safe core map.
/// Maps a unique spatial identifier (`ChunkKey`) to the chunk's content (`ChunkData`).
type CacheMap = HashMap<ChunkKey, ChunkData>;

// --- 2. Cache Structure ---

/// The thread-safe, in-memory cache for generated Chunk data.
///
/// Wraps a standard HashMap in an **AtomicResource** to allow safe, concurrent
/// read/write access across game engine worker threads. This is the **tempo** optimization.
#[derive(Debug, Clone)]
pub struct ChunkCache {
    /// The underlying storage map protected by an `AtomicResource`.
    storage: AtomicResource<CacheMap>,
}

impl ChunkCache {
    /// Creates a new, empty, thread-safe cache instance.
    ///
    /// The return type is wrapped in `Result<Self, io::Error>` to align with the
    /// Conductor's initialization interface, promoting robust project **completion**.
    pub fn new() -> Result<Self, io::Error> {
        info!("SSXL ChunkCache initialized: Ready for thread-safe storage.");
        Ok(ChunkCache {
            // Initialize the AtomicResource with an empty HashMap.
            storage: AtomicResource::new(HashMap::new()),
        })
    }

    /// Attempts to retrieve a ChunkData by its ChunkKey (Cache Load implementation).
    ///
    /// # Arguments
    /// * `key`: The unique spatial key identifying the desired chunk.
    ///
    /// # Returns
    /// `Ok(Some(ChunkData))` if found, or `Ok(None)` if a cache miss occurs.
    pub fn load_chunk(&self, key: &ChunkKey) -> Result<Option<ChunkData>, io::Error> {
        // Acquire a read lock on the internal map.
        let map = self.storage.read();

        // Retrieve the data, clone it (to give the caller ownership), and wrap in Ok.
        Ok(map.get(key).cloned())
    }

    /// Inserts a ChunkData into the cache (Cache Save implementation).
    ///
    /// # Arguments
    /// * `key`: The unique spatial key to store the chunk under.
    /// * `data`: A reference to the chunk data to be cloned and stored.
    ///
    /// # Returns
    /// `Ok(())` on successful insertion or update.
    pub fn save_chunk(&self, key: &ChunkKey, data: &ChunkData) -> Result<(), io::Error> {
        // Acquire a write lock on the internal map.
        let mut map = self.storage.write();

        // Insert the cloned data. If `insert` returns `None`, it was a new key.
        // We use `info` for new data and `warn` for overwrites for easy debug monitoring.
        if map.insert(*key, data.clone()).is_none() {
            info!("Saved new chunk to cache: {:?}", key);
        } else {
            // Otherwise, an existing chunk was overwritten (this shouldn't happen often).
            warn!("Overwrote existing chunk in cache: {:?}", key);
        }
        Ok(())
    }

    /// Reports the current number of chunks stored in the cache.
    ///
    /// This requires briefly acquiring a read lock to access the underlying map.
    pub fn len(&self) -> usize {
        self.storage.read().len()
    }

    /// Clears all entries from the cache.
    ///
    /// Acquires a write lock to empty the underlying HashMap (a **bulldozer** operation).
    pub fn clear(&self) {
        self.storage.write().clear();
        info!("SSXL ChunkCache cleared.");
    }

    /// Checks if the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}
>>> FILE END: rust\ssxl_cache\src\lib.rs <<<

======================================================
======================================================
[package]
name = "ssxl_cli"
version = "0.6.0"
edition = "2021"

[[bin]]
name = "ssxl"
path = "src/main.rs"

[dependencies]
# --- INTERNAL DEPENDENCIES (Foundation & FFI) ---
# CLI needs access to all core data types for diagnostics and the FFI layer to test the runtime.
ssxl_shared     = { path = "../ssxl_shared" }
ssxl_engine_ffi = { path = "../ssxl_engine_ffi" }
ssxl_tools      = { path = "../ssxl_tools" }
ssxl_generate   = { path = "../ssxl_generate" }
ssxl_math   = { path = "../ssxl_math" }

# --- EXTERNAL DEPENDENCIES (Execution & UI) ---
# Asynchronous runtime and macros
tokio           = { workspace = true, features = ["rt-multi-thread", "macros"] }
# Workspace standard logging framework (replaces log/env_logger)
tracing         = { workspace = true }
# Time utilities, often needed for logging/benchmarking output
chrono          = { workspace = true }
# Interactive Console UI library
crossterm       = { workspace = true }
# File system traversal (for module tree inspector)
walkdir         = { workspace = true }
# Parallel processing (for running benchmarks)
rayon           = { workspace = true }
# Regular expressions (for any complex parsing tasks)
regex           = { workspace = true }
tracing-subscriber = { workspace = true }
ctrlc           = { workspace = true }
bincode = { workspace = true }
serde = { workspace = true }
>>> FILE END: rust\ssxl_cli\Cargo.toml <<<

======================================================
======================================================
// ssxl_cli/src/cli_util_bench.rs

//! # CLI Utilities: Benchmarking and Validation (`ssxl_cli::cli_util_bench`)
//!
//! Provides CLI-specific functions for testing core engine features and running
//! performance benchmarks, primarily focusing on world generation logic.

use tracing::{info, warn, error};
use std::time::Instant;
use std::thread;
use std::sync::{
    Arc, 
    atomic::{AtomicU64, Ordering} // AtomicU64 for thread-safe tile counting
};
use std::io::{self, Write};
use std::time::Duration;

// Imports of core engine components.
use ssxl_generate::benchmark_generation_workload; // External function that runs the actual benchmark work
use ssxl_generate::conductor::Conductor; // The main asynchronous world manager
use ssxl_math::Vec2i; // Coordinate type

// --- Test Utilities ---

/// Runs a high-level test to validate that the `Conductor` can initialize,
/// switch active generators, and successfully generate single chunks on demand.
pub fn test_generation_and_placement_cli() {
    warn!("🧪 Running CLI Test: Generation and Placement (Conductor Validation)...");

    // Initialize the Conductor. We only need the Conductor handle for this test.
    let (mut conductor, _state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    let test_coords = [
        Vec2i::new(0, 0),
        Vec2i::new(-1, 0),
        Vec2i::new(100, 100),
    ];
    let mut chunks_generated = 0;

    // Test Case 1: Perlin Noise Generator
    let perlin_id = "perlin_mvg";
    if conductor.set_active_generator(perlin_id).is_ok() {
        info!("-> Active Generator set to: {}", perlin_id);
        for &coords in &test_coords {
            // Synchronously request a chunk generation.
            let _chunk = conductor.generate_single_chunk(coords);
            info!("  - Generated chunk {:?} successfully.", coords);
            chunks_generated += 1;
        }
    } else {
        warn!("Generator '{}' not found. Skipping Perlin test.", perlin_id);
    }
    
    // Test Case 2: Cellular Automata Generator
    let ca_id = "cellular_automata_basic";
    if conductor.set_active_generator(ca_id).is_ok() {
        info!("-> Active Generator set to: {}", ca_id);
        let coords = Vec2i::new(50, 50);
        let _chunk = conductor.generate_single_chunk(coords);
        info!("  - Generated chunk {:?} successfully.", coords);
        chunks_generated += 1;
    } else {
        warn!("Generator '{}' not found. Skipping CA test.", ca_id);
    }

    // Final result reporting.
    if chunks_generated > 0 {
        info!("✅ CLI Generation Test SUCCESS: Generated {} chunks across {} generator(s).", 
            chunks_generated, 
            // NOTE: This will report the last successful generator ID.
            conductor.get_active_generator_id() 
        );
    } else {
        error!("❌ CLI Generation Test FAILED: Zero chunks were generated. Check Conductor initialization and generator IDs.");
    }

    // Clean up the Conductor's worker threads and runtime.
    conductor.graceful_teardown();
}


/// Placeholder for a utility function that converts an image file into engine bitmask data.
pub fn run_bitmask_conversion() {
    warn!("🧪 Starting bitmask conversion from world.png (Placeholder)...");

    // Simulated result.
    let tiles_placed = 5000;
    
    info!("✅ Conversion complete. Tiles placed: {}", tiles_placed);
}

// --- Benchmark ---

/// Executes the Max Grid Generation Benchmark, which stresses the asynchronous
/// generation pipeline with a large, simulated workload.
pub fn run_max_grid_benchmark() {
    warn!("🧪 Starting Max Grid Benchmark (Real Workload)...");
    
    // Define the total number of tiles the benchmark should process.
    const WORKLOAD_TILES: u64 = 100_000_000; 

    // An Atomic counter shared between the workload thread and the reporting thread.
    let processed_tiles = Arc::new(AtomicU64::new(0));
    let workload_counter_clone = processed_tiles.clone();
    let ticker_counter_clone = processed_tiles.clone();

    // --- Workload Thread (Generates Tiles) ---
    let workload_handle = thread::spawn(move || {
        // This function blocks and increments `workload_counter_clone`.
        benchmark_generation_workload(WORKLOAD_TILES, workload_counter_clone); 
    });

    // --- Ticker Thread (Reports Progress) ---
    let start_time = Instant::now();
    let ticker_handle = thread::spawn(move || {
        let total = WORKLOAD_TILES as f64;
        
        loop {
            let current = ticker_counter_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            // Calculate progress percentage and clamp to 100%.
            let percentage = ((current as f64 / total) * 100.0).min(100.0).round() as u64;

            // Calculate instantaneous throughput (tiles per second).
            let throughput = if elapsed > 0.0 { 
                (current as f64 / elapsed).round() as u64 
            } else { 
                0 
            };

            // Display progress using carriage return (`\r`) to update the same line.
            print!("\r⏳ Progress: {: >3}% ({: >8}M / {}M) | Throughput: ~{: >9} tiles/s", 
                percentage, 
                current / 1_000_000, // Display current in Millions
                WORKLOAD_TILES / 1_000_000, // Display total in Millions
                throughput
            );
            let _ = io::stdout().flush(); // Ensure output is immediately displayed.

            if current >= WORKLOAD_TILES {
                break;
            }
            thread::sleep(Duration::from_millis(50));
        }
    });

    // --- Execution & Final Reporting ---

    let start = Instant::now();
    
    // Wait for the generation workload to complete. Handle panics gracefully.
    if let Err(e) = workload_handle.join() {
        error!("Workload thread panicked: {:?}", e);
        // Overwrite the ticker line with a failure message.
        let _ = println!("\r❌ Benchmark failed: Generation thread panic. {: <100}", " "); 
        return; 
    }
    
    // Wait for the ticker thread to finish (it breaks its loop after the workload completes).
    ticker_handle.join().unwrap();
    
    let duration = start.elapsed();
    let duration_secs = duration.as_secs_f64();
    let duration_millis = duration.as_millis() as f64;
    let actual_tiles_placed = WORKLOAD_TILES;
    
    // Final summary print.
    println!("\r✅ Benchmark complete. Workload: {} tiles. Duration: {:.2}s", 
        actual_tiles_placed, duration_secs);

    if duration_secs > 0.0 {
        let throughput_sec = (actual_tiles_placed as f64 / duration_secs).round() as u64;
        let throughput_ms = actual_tiles_placed as f64 / duration_millis;
        
        println!("⚡ Max Throughput: ~{} tiles/sec", throughput_sec);
        println!("⚡ Diagnostics: {:.2} Million tiles/ms", throughput_ms / 1_000_000.0);
        
        // Define performance targets for status reporting.
        const MVG_BASELINE: u64 = 10_000_000;
        const ITERATION5_TARGET: u64 = 18_000_000;

        // Grade the performance result.
        if throughput_sec >= ITERATION5_TARGET {
            info!("🚀 CRITICAL SUCCESS: Throughput of {} tiles/sec EXCEEDS the Iteration 5 Target of {} tiles/sec!", throughput_sec, ITERATION5_TARGET);
        } else if throughput_sec >= MVG_BASELINE {
            info!("📈 Performance OK: Throughput of {} tiles/sec meets or exceeds the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
        } else {
            error!("⚠️ Performance CRITICAL: Throughput of {} tiles/sec is BELOW the MVG Baseline of {} tiles/sec.", throughput_sec, MVG_BASELINE);
            warn!("Use Signal Inspector to diagnose the concurrency bottleneck.");
        }

    } else {
        error!("❌ Benchmark failed: Workload was too small or timer error (duration was 0.0s). Increase WORKLOAD_TILES.");
    }
}
>>> FILE END: rust\ssxl_cli\src\cli_util_bench.rs <<<

======================================================
======================================================
// ssxl_cli/src/cli_util_inspect.rs

//! # CLI Utilities: Inspection and Codebase Analysis (`ssxl_cli::cli_util_inspect`)
//!
//! This module provides utility functions for inspecting the structure of the SSXL-ext
//! Rust workspace and scanning the exposed Godot API surface. These tools are used
//! for development, debugging, and verification of the engine's public interface.

use walkdir::WalkDir; // Crate for iterating over directory trees
use std::path::{Path, PathBuf};
use std::fs;
use regex::Regex; // Crate for regular expressions
use tracing::{info, warn, error};
use std::thread;
use std::time::Duration; 


/// Scans the SSXL-ext workspace and prints a structured, visual tree of all `.rs` files.
///
/// This provides a quick overview of the codebase structure, highlighting core files (`lib.rs`, `main.rs`).
pub fn print_module_tree() {
	println!("\n=========================================================================");
	println!("| 🌲 RUST WORKSPACE MODULE TREE (Scanning...)                           |");
	println!("=========================================================================");
	
	// List of all crate source directories in the workspace.
	let crate_dirs = [
		"ssxl_cache/src",
		"ssxl_engine_ffi/src",
		"ssxl_generate/src",
		"ssxl_godot/src",
		"ssxl_math/src",
		"ssxl_shared/src",
		"ssxl_sync/src",
		"ssxl_tools/src",
		"ssxl_cli/src",
	];

	for crate_dir in crate_dirs {
        let crate_path = PathBuf::from(crate_dir);
		println!("\n🔍 Crate: {}", crate_dir);

		if crate_path.exists() && crate_path.is_dir() {
            // Walk the directory starting at a depth of 1 (excluding the root `src` folder).
			for entry in WalkDir::new(&crate_path).min_depth(1) {
				match entry {
					Ok(e) => {
                        let path = e.path();
                        // Check if the path is a file and ends with the .rs extension.
                        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                            
                            let file_name = path.file_name().map_or("", |name| name.to_str().unwrap_or(""));

                            // Differentiate between core files and nested module files for visualization.
                            let prefix = if file_name == "lib.rs" || file_name == "main.rs" {
                                "├── [CORE] "
                            } else {
                                "│   └── "
                            };
                            
                            // Print the path relative to the crate's `src/` directory.
                            if let Ok(relative_path) = path.strip_prefix(&crate_path) {
                                println!("{} {}", prefix, relative_path.display());
                            } else {
                                // Fallback if strip_prefix fails (shouldn't happen here).
                                println!("{} {}", prefix, path.display());
                            }
                        }
					},
					Err(e) => warn!("Error walking directory {}: {}", crate_dir, e),
				}
			}
		} else {
			warn!("Path does not exist or is not a directory: {}", crate_dir);
		}
	}
	println!("=========================================================================\n");
}


/// Scans specific `ssxl_godot` files to extract and print function signatures
/// marked with the `#[func]` attribute, exposing the engine's public API surface.
pub fn print_godot_api_surface() {
    // Files where the Godot API methods are typically defined.
	let godot_api_files: [&str; 3] = [
        "ssxl_godot/src/ssxl_engine.rs",
        "ssxl_godot/src/ssxl_oracle.rs", // Assumed file for oracle/query functions
        "ssxl_godot/src/ssxl_signals.rs",
    ];

    println!("🧪 API scan triggered (targeting {} files in ssxl_godot/src/)...", godot_api_files.len());
    
    // Regex to capture function signature: `pub fn method_name(args) -> return_type {`
    let fn_signature_regex = Regex::new(
        r"^\s*pub\s+fn\s+(\w+)\s*(\([^\{]*)\s*(?:->\s*([^\{]*))?\s*\{"
    ).unwrap();

    // Regex to find the Godot `#[func]` marker line.
    let func_marker_regex = Regex::new(r"^\s*#\[func\]\s*$").unwrap();

    // Vector to store (method_name, args, return_type, source_file) tuples.
    let mut api_methods: Vec<(String, String, String, String)> = Vec::new();

    for file_path_str in godot_api_files.iter() {
        let godot_lib_path: &Path = Path::new(file_path_str);
        // Extract the filename for reporting.
        let file_name = Path::new(file_path_str).file_name().unwrap().to_str().unwrap();
        let mut func_line_pending = false;

        match fs::read_to_string(godot_lib_path) {
            Ok(contents) => {
                info!("Successfully read {}", godot_lib_path.display());
                
                for line in contents.lines() {
                    // Step 1: Detect the #[func] marker.
                    if func_marker_regex.is_match(line) {
                        func_line_pending = true;
                        continue;
                    }

                    // Step 2: If the marker was found, check the next non-empty line for the function signature.
                    if func_line_pending {
                        if let Some(captures) = fn_signature_regex.captures(line) {
                            
                            // Capture Group 1: Method name
                            let method_name = captures.get(1).map(|m| m.as_str()).unwrap_or("unknown_method").to_string();
                            
                            // Capture Group 2: Arguments (including parentheses)
                            let args = captures.get(2)
                                // Clean up the argument string: remove surrounding parentheses and trim whitespace.
                                .map(|m| m.as_str().trim_start_matches('(').trim_end_matches(')').trim().to_string())
                                .unwrap_or_default();
                            
                            // Capture Group 3: Return type (optional). Defaults to `()` if not present.
                            let return_type = captures.get(3).map_or("()".to_string(), |m| m.as_str().trim().to_string());
                            
                            // Store the captured method details.
                            api_methods.push((method_name, args, return_type, file_name.to_string()));
                            
                            func_line_pending = false; // Reset state after successful capture.
                        } else if !line.trim().is_empty() {
                            // If we hit a non-#[func], non-function line, reset the pending flag.
                            func_line_pending = false;
                        }
                    }
                }
            },
            Err(e) => {
                error!("Failed to read file {}: {}", file_path_str, e);
            }
        }
    }

	println!("\n--- 🎮 SSXL Engine Godot API Surface ---");
    if api_methods.is_empty() {
        warn!("No #[func] methods found in the targeted ssxl_godot API files. Is the Godot binding active?");
    } else {
        println!("Registered {} callable methods:", api_methods.len());
        // Print all detected API methods in a standardized format.
        for (name, args, return_type, source_file) in &api_methods {
            println!("  ✅ func {}({}) -> {} [{}]", name, args, return_type, source_file);
        }
    }
	println!("-------------------------------------------\n");

    info!("API scan complete: {} methods detected.", api_methods.len());
    // Pause briefly for dramatic effect and to ensure logging is flushed.
    thread::sleep(Duration::from_secs(2));
}
>>> FILE END: rust\ssxl_cli\src\cli_util_inspect.rs <<<

======================================================
======================================================
// ssxl_cli/src/cli_util_menu.rs

//! # CLI Utilities: Dev Console Menu (`ssxl_cli::cli_util_menu`)
//!
//! Defines the interactive main menu structure and logic for the SSXL-ext
//! developer console. It maps user-input keys to specific actions (tests,
//! benchmarks, inspection, or external tool launches).

// Imports of action functions from sibling modules within `ssxl_cli`.
use crate::actions::{
    run_cargo_tests,
    launch_godot_client,
    launch_headless_godot,
    start_signal_inspector,
    run_ffi_bridge_validation,
    // NEW FOCUSED TESTS
    run_communication_channel_test,
    run_data_channel_test,
    run_map_generation_test,
    run_animation_conductor_test,
};
use crate::cli_util_inspect::{print_godot_api_surface, print_module_tree};
use crate::cli_util_bench::{run_bitmask_conversion, run_max_grid_benchmark, test_generation_and_placement_cli};
use tracing::warn;

/// Represents a single selectable entry in the CLI menu.
pub struct MenuItem {
    /// The character key the user presses to execute this item's action.
    pub key: char,
    /// The descriptive label displayed in the console menu.
    pub label: &'static str,
    /// A trait object holding the function to be executed when the item is selected.
    pub action: Box<dyn Fn()>,
}

/// Constructs the complete list of menu items for the developer console.
///
/// Each item is a `MenuItem` struct mapping a key to a specific action function.
pub fn build_menu() -> Vec<MenuItem> {
    vec![
        // --- Core Testing & Validation (Keys 0-5) ---
        MenuItem { key: '0', label: "✅ Run: Full Cargo Test Suite", action: Box::new(run_cargo_tests) },
        MenuItem { 
            key: '1', 
            label: "✅ Validate: FFI Bridge Data Transfer (Data Integrity)", 
            action: Box::new(run_ffi_bridge_validation)
        },
        MenuItem { 
            key: '2', 
            label: "✅ Validate: Async Communication Channels (Godot <-> Rust)", 
            action: Box::new(run_communication_channel_test)
        },
        MenuItem { 
            key: '3', 
            label: "✅ Validate: Chunk/Tile Data Channels (Crypto Coded)", 
            action: Box::new(run_data_channel_test)
        },
        MenuItem { 
            key: '4', 
            label: "✅ Validate: Map Generation Logic (Procedural Purity)", 
            action: Box::new(run_map_generation_test)
        },
        MenuItem { 
            key: '5', 
            label: "✅ Validate: Animation Conductor Tempo (Frame Consistency)", 
            action: Box::new(run_animation_conductor_test)
        },

        // --- External Harness & Inspection (Keys L, H, S) ---
        MenuItem { 
            key: 'L', 
            label: "🚀 Launch: Godot Client (Non-Headless)", 
            action: Box::new(launch_godot_client) 
        },
        MenuItem { 
            key: 'H', 
            label: "🎮 Launch: Headless Godot (External)", 
            action: Box::new(launch_headless_godot) 
        },
        MenuItem { 
            key: 'S', 
            label: "🔮 Start: Signal Inspector / Live Feed (TODO)", 
            action: Box::new(start_signal_inspector) 
        },

        // --- Benchmarks & Utilities (Keys T, B, P, A, I, R) ---
        MenuItem { 
            key: 'T', 
            label: "🧪 Test: Generation & Placement CLI", 
            action: Box::new(test_generation_and_placement_cli) 
        },
        MenuItem { 
            key: 'B', 
            label: "🧪 Benchmark: Max Grid Placement", 
            action: Box::new(run_max_grid_benchmark) 
        },
        MenuItem { 
            key: 'P', 
            label: "✅ Perform: Bitmask PNG Conversion", 
            action: Box::new(run_bitmask_conversion) 
        },
        MenuItem { 
            key: 'A', 
            label: "✅ Inspect: Godot-Callable API Surface", 
            action: Box::new(print_godot_api_surface) 
        },
        MenuItem { 
            key: 'I', 
            label: "✅ Inspect: Rust Module Tree", 
            action: Box::new(print_module_tree) 
        },
        MenuItem { 
            key: 'R', 
            label: "⚠️ Run: Trailkeeper Scan (TODO)", 
            // Inline action for a simple placeholder warning.
            action: Box::new(|| warn!("TODO: Trailkeeper scan not yet implemented.")) 
        },
        
        // --- Exit ---
        MenuItem { key: 'E', label: "✅ Exit Console", action: Box::new(|| {}) },
    ]
}


/// Prints the formatted menu to the console, showing the key and label for each item.
pub fn print_menu(menu: &[MenuItem]) {
    
    println!("\n🧭 SSXL-ext Engine Dev Console\n");
    for item in menu {
        println!("[{}] {}", item.key, item.label);
    }
    println!("\nSelect an option by pressing its number key or letter key...\n");
}
>>> FILE END: rust\ssxl_cli\src\cli_util_menu.rs <<<

======================================================
======================================================
// ssxl_cli/src/main.rs
//! # SSXL-ext CLI Developer Console (`ssxl_cli::main`)
//!
//! The main entry point for the interactive developer console. This utility manages
//! initialization, logging, the main menu loop, and delegates tasks to action modules
//! for testing, benchmarking, and external tool execution.

mod actions;             // Core functions for tests, benchmarks, and Godot interaction.
mod cli_util_inspect;    // Utilities for scanning the codebase and API surface.
mod cli_util_menu;       // Menu structure and display logic.
mod cli_util_bench;      // Functions for running generation tests and benchmarks.
mod scan;                // Codebase scanning (e.g., Lines of Code - LOC).

use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use crossterm::event::{self, Event, KeyCode};

use tracing::{info, error};
use tracing_subscriber::{self, filter::LevelFilter, prelude::*};

use crate::cli_util_menu::{build_menu, print_menu};
use ssxl_engine_ffi::ssxl_initialize_engine; // External FFI function to bootstrap the engine core.
use crate::scan::execute_loc_scan; // Function to run the Lines of Code scanner.
use crate::actions::copy_dll_to_tester_project_at_boot; // Action to ensure the latest DLL is in the Godot project.


/// Prompts the user to press Enter before returning to the main menu.
fn wait_for_enter() {
    println!("\nPress Enter to return to menu...");
    // Read a line from stdin and discard the result.
    let _ = io::stdin().read_line(&mut String::new());
}

/// Sets up the logging system and performs critical engine initialization steps.
fn init_logging_and_engine() {
    // 1. Initialize Tracing/Logging Subscriber
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(io::stdout) // Direct log output to stdout.
                .with_filter(LevelFilter::INFO), // Set the minimum logging level to INFO.
        )
        .init();

    info!("SSXLBinary: Interactive CLI initializing.");

    // 2. Initialize the Rust Core via FFI
    // Calls the external C-compatible function to boot the engine's core state and runtime.
    if ssxl_initialize_engine() {
        info!("Engine FFI core initialized.");
    } else {
        // We log the failure but allow the CLI to continue for non-engine tasks (like LOC scan).
        error!("Failed to initialize Engine FFI core.");
    }
    
    // 3. Copy DLL to Godot Project
    // Ensure the compiled GDExtension DLL is copied into the Godot tester project
    // before any Godot-related actions are run.
    if let Err(e) = copy_dll_to_tester_project_at_boot() {
        // This is a critical warning, as Godot interaction will fail without the DLL.
        error!("DLL Copy Failed: {}", e);
    }
}

fn main() {
    // Perform initial setup: logging, FFI, and DLL copy.
    init_logging_and_engine();
    
    // Run a Lines of Code (LOC) scan on the codebase at startup.
    execute_loc_scan(); 

    // Print welcome ASCII art.
    println!(
        r#"
              (__)
              (oo)
        /------\/
       / |    ||
      * ||----||
        ~~     ~~
SSXL-ext Engine Console Initialized
"#
    );

    // Build the menu structure.
    let menu = build_menu();
    // Set for input debouncing to prevent multiple actions from a single key press hold.
    let mut last_keys = HashSet::new();

    // --- Main Interactive Console Loop ---
    loop {
        // Display the menu options.
        print_menu(&menu);
        info!("Console: Awaiting menu selection...");
        print!("> ");
        // Ensure the prompt character is immediately visible.
        io::stdout().flush().unwrap();

        // Inner loop handles key polling and processing.
        loop {
            // Poll for key events with a timeout to keep the loop responsive (500ms tempo).
            if event::poll(Duration::from_millis(500)).unwrap() {
                if let Event::Key(key_event) = event::read().unwrap() {
                    if let KeyCode::Char(c) = key_event.code {
                        let c = c.to_ascii_uppercase(); // Normalize input to uppercase.

                        // Input Debounce Check: Only process if the key hasn't been seen recently.
                        if last_keys.insert(c) {
                            // Find the corresponding menu item.
                            if let Some(item) = menu.iter().find(|m| m.key == c) {
                                info!("Menu: Selected: {}", item.label);
                                println!("\n[{}] {}\n", c, item.label);
                                
                                // Execute the action associated with the menu item.
                                (item.action)();

                                // Check for the exit key ('E').
                                if c == 'E' {
                                    info!("Exit: Console closed. Engine shutdown complete.");
                                    return; // Exit the main function, terminating the CLI.
                                }

                                // Wait for user acknowledgment before returning to the main menu screen.
                                wait_for_enter();
                                // Break the inner polling loop to redraw the menu.
                                break;	
                            }
                        }
                    }
                }
            } else {
                // If the poll times out, clear the debounce set, allowing a new key press to be registered.
                last_keys.clear();
            }

            // Short pause for general loop control.
            thread::sleep(Duration::from_millis(10));
        }
    }
}
>>> FILE END: rust\ssxl_cli\src\main.rs <<<

======================================================
======================================================
// ssxl_cli/src/actions/benchmarking.rs

//! # CLI Actions: Monitoring and Benchmarking (`ssxl_cli::actions::benchmarking`)
//!
//! Provides command-line interface tools for interacting with the SSXL engine's
//! asynchronous systems. This includes real-time status inspection of the
//! `Conductor` and facilities for running performance benchmarks.

use tracing::{info, warn, error};
use std::io::{self, Write};
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, Ordering} // Atomic types for thread-safe signaling
};
use std::thread;
use std::time::Duration;
use ctrlc; // Crate for handling Ctrl-C signals

// Assumed imports: Conductor and ConductorStatus must be re-exported from a parent module
// (likely from the ssxl_generate crate, re-exported via ssxl_cli/src/lib.rs).
use super::{Conductor, ConductorStatus};


/// Initializes the main world generation Conductor and begins a live, real-time
/// feed of its status to the command line.
///
/// This function blocks the current thread until the process is terminated via
/// Ctrl-C or the Conductor signals a fatal state (Error/ShuttingDown).
pub fn start_signal_inspector() {
    warn!("🔮 Initializing Conductor and starting Signal Inspector (Real-Time Feed)...");

    // Attempt to initialize the Conductor, which starts the Tokio runtime and worker threads.
    let (conductor, state, _progress_receiver, _request_sender) = match Conductor::new(None) {
        Ok(result) => result,
        Err(e) => {
            error!("❌ Failed to initialize Conductor/Runtime: {}", e);
            return;
        }
    };

    // --- Graceful Shutdown Setup ---

    // 1. Wrap the Conductor in a structure that allows for shared, mutable ownership
    // and consumption from the signal handler thread.
    let conductor_shutdown_safe = Arc::new(Mutex::new(Some(conductor)));
    let shutdown_clone = conductor_shutdown_safe.clone();

    // 2. Use a thread-safe atomic boolean to control the main inspection loop.
    let running = Arc::new(AtomicBool::new(true));
    let r_for_handler = running.clone();

    // 3. Set the Ctrl-C handler to trigger graceful shutdown.
    if let Err(e) = ctrlc::set_handler(move || {
        // Stop the main inspection loop.
        r_for_handler.store(false, Ordering::SeqCst);

        // Attempt to take the Conductor out of the Mutex/Option and call its teardown method.
        if let Some(c) = shutdown_clone.lock().unwrap().take() {
            c.graceful_teardown();
        }
        let _ = writeln!(io::stdout(), "\nInspector: Shutdown signal received. Waiting for Conductor...");
    }) {
        error!("Could not set Ctrl-C handler: {}", e);
        return;
    }

    info!("Inspector: Press Ctrl-C to stop the live feed and gracefully shut down the Conductor.");

    // --- Live Feed Loop ---

    let mut frame_count: u64 = 0;
    // Arbitrary maximum tile generation rate used for display.
    const MVG_BASELINE: u64 = 10_000_000;

    while running.load(Ordering::SeqCst) {
        frame_count += 1;

        // Fetch current state variables from the thread-safe state tracker.
        let status = state.get_status();
        let queue_depth = state.get_queue_depth();
        let active_id = state.get_active_generator_id();

        // Print the status line, using '\r' (carriage return) to overwrite the line
        // without scrolling the console.
        print!("\r");
        print!("🔮 LIVE FEED | Frame: {: >4} | Status: {: <12} | Generator: {: <25} | Queue Depth: ~{: >6} | MVG Baseline: {} tiles/s | Press Ctrl-C to exit.",
            frame_count,
            format!("{:?}", status),
            active_id,
            queue_depth,
            MVG_BASELINE
        );
        // Flush stdout to ensure the output is immediately written to the terminal.
        let _ = io::stdout().flush();

        // Check for internal shutdown signals from the Conductor itself (e.g., internal error).
        if status == ConductorStatus::ShuttingDown || status == ConductorStatus::Error {
            // Signal the loop to stop and try to manually trigger cleanup one last time.
            running.store(false, Ordering::SeqCst);

            if let Some(c) = conductor_shutdown_safe.lock().unwrap().take() {
                c.graceful_teardown();
            }
            break;
        }

        // Pause for a brief duration (50ms refresh rate).
        thread::sleep(Duration::from_millis(50));
    }

    // Overwrite the last printed line with spaces to clear it cleanly.
    let _ = writeln!(io::stdout(), "\r{: <200}", " ");
    info!("Inspector shutdown complete. Conductor runtime terminated.");
}


/// Placeholder function for running engine performance benchmarks.
#[allow(dead_code)] // Suppressing the warning as this is a public API for the CLI.
pub fn run_benchmark() {
    warn!("⏱️ Benchmark execution not yet implemented. Placeholder called.");
}
>>> FILE END: rust\ssxl_cli\src\actions\benchmarking.rs <<<

======================================================
======================================================
// FILE: ssxl_cli/src/actions/godot_harness.rs
// Cleanup: Removed unused placeholder functions `launch_headless_godot` and `run_godot_harness`.

//! # CLI Actions: Godot Harness (`ssxl_cli::actions::godot_harness`)
//!
//! Utilities for managing and launching the Godot editor or the Godot game
//! client from the command line, including necessary setup steps like copying
//! the compiled Rust dynamic library (DLL/SO/DYLIB) into the Godot project's
//! GDExtension directory.

use std::process::Command;
use tracing::{info, warn, error};
use std::fs;
use std::env;

// Imports of constants and utility functions from the parent module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    RELATIVE_PROJECT_PATH_FRAGMENT,
    DLL_NAME,
    SOURCE_DLL_PATH_FRAGMENT,
};


/// Copies the compiled Rust dynamic library (DLL/SO/DYLIB) from the `target/release`
/// or `target/debug` folder to the Godot tester project's GDExtension directory.
///
/// This is a critical step to ensure Godot loads the latest engine code.
pub fn copy_dll_to_tester_project_at_boot() -> Result<(), String> {
    info!("Attempting to copy {} to Godot tester project...", DLL_NAME);

    // --- 1. Construct Source Path ---
    let mut source = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for source path construction: {}", e))?;
    // Navigate to the target directory (e.g., `target/debug/`).
    source.push(SOURCE_DLL_PATH_FRAGMENT);
    // Add the DLL file name (e.g., `SSXL_engine.dll`).
    source.push(DLL_NAME);
    let source_path = source.as_path();

    // --- 2. Construct Destination Path ---
    let mut destination = env::current_dir()
        .map_err(|e| format!("Failed to get current directory for destination path construction: {}", e))?;
    // Navigate to the Godot project's GDExtension folder.
    destination.push(RELATIVE_PROJECT_PATH_FRAGMENT);
    // Add the DLL file name.
    destination.push(DLL_NAME);
    let destination_path = destination.as_path();

    // --- 3. Validation and Copy ---

    if !source_path.exists() {
        warn!(
            "Source DLL not found at: {}. Have you run `cargo build` recently?", 
            source_path.display()
        );
        // Treat missing source as a non-fatal warning to continue CLI usage.
        return Ok(());
    }

    match fs::copy(source_path, destination_path) {
        Ok(_) => {
            info!(
                "✅ DLL Copied: {} -> {}", 
                source_path.file_name().unwrap_or_default().to_string_lossy(), 
                destination_path.display()
            );
            Ok(())
        }
        Err(e) => {
            // This often fails if the target DLL is locked by a running Godot instance.
            Err(format!(
                "❌ FAILED to copy DLL. Check permissions or if the Godot Editor is currently running and locking the file. Error: {}", 
                e
            ))
        }
    }
}


/// Launches the Godot Editor in a non-blocking subprocess.
pub fn launch_godot_client() {
    info!("🚀 LAUNCHING: Godot Editor (Non-Headless) for scene debugging...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Launch failed: {}", e);
            return;
        }
    };

    info!("Attempting to launch Godot from: {}", GODOT_EXE_PATH);
    info!("Loading project at (Absolute Path): {}", project_path_abs);

    // Execute the Godot process.
    match Command::new(GODOT_EXE_PATH)
        // Flag to launch the editor window instead of running the game directly.
        .arg("--editor")
        // Argument specifying the path to the Godot project folder.
        .arg("--path")
        .arg(&project_path_abs)
        // Use `spawn()` to run the command asynchronously, allowing the CLI process to continue.
        .spawn()
    {
        Ok(_) => {
            info!("✅ Godot EDITOR spawned successfully. Please close the Godot window to continue CLI use.");
        }
        Err(e) => {
            error!("❌ Failed to execute Godot command: {}", e);
            warn!("Please ensure the Godot executable is correctly set in the path configuration: {}", GODOT_EXE_PATH);
        }
    }
}
>>> FILE END: rust\ssxl_cli\src\actions\godot_harness.rs <<<

======================================================
======================================================
// FILE: ssxl_cli/src/actions/mod.rs
// Cleanup: Removed the unused `launch_headless_godot` export.

//! # CLI Actions Module (`ssxl_cli::actions`)
//!
//! This module acts as the public interface (façade) for all complex command-line
//! actions, such as launching Godot, running tests, or initiating benchmarks.
//! It aggregates constants, external dependencies, and exports from its child modules.

use std::env;

// --- Internal Modules ---

/// Tools for real-time monitoring of the Conductor and placeholder for benchmark logic.
mod benchmarking;
/// Utilities for launching and managing the external Godot engine tester project.
mod godot_harness;
/// The main menu and delegation stub for all test suites.
mod testing;
/// Contains self-contained architectural and data validation tests.
mod test_suites;
/// Contains tests requiring external processes like `cargo` and Godot FFI validation.
mod test_core_suites;

// --- Public Re-exports from Sibling Crates ---

/// Re-export of the core world generation manager.
pub use ssxl_generate::conductor::Conductor;
/// Re-export of the conductor's thread-safe status enumeration.
pub use ssxl_generate::conductor_state::ConductorStatus;

// --- Configuration Constants ---

/// **Path to the Godot Executable.** Assumed to be relative to the CLI's root directory.
pub const GODOT_EXE_PATH: &str = "./../SSXL_engine_tester/godot.windows.editor.x86_64.exe";
/// **Relative path fragment** to the root of the Godot testing project.
pub const RELATIVE_PROJECT_PATH_FRAGMENT: &str = "../SSXL_engine_tester";
/// **The GDExtension DLL file name.** Should be consistent across platforms (with a proper build system).
pub const DLL_NAME: &str = "SSXL_engine.dll";
/// **Relative path fragment** from the CLI root to where `cargo` places the compiled DLL.
pub const SOURCE_DLL_PATH_FRAGMENT: &str = "target/debug/";
/// **The primary test scene** path, relative to the Godot project root.
pub const GODOT_TEST_SCENE: &str = "res://test_scene/test_ffi_data.tscn";


// --- Utility Functions ---

/// Calculates the **absolute, canonicalized path** to the Godot project directory.
///
/// This is necessary because Godot may expect an absolute path, and it resolves
/// relative paths from the current working directory of the CLI.
///
/// # Returns
/// - `Ok(String)`: The absolute path to the Godot project folder.
/// - `Err(String)`: Description of the error (e.g., CWD failure, path not found).
pub fn get_godot_project_abs_path() -> Result<String, String> {
    let mut current_dir = env::current_dir()
        .map_err(|e| format!("Failed to determine CWD: {}", e))?;

    // Append the relative path fragment to the current working directory.
    current_dir.push(RELATIVE_PROJECT_PATH_FRAGMENT);

    // Canonicalize resolves symlinks, handles `..`, and ensures the path actually exists.
    current_dir.canonicalize()
        .map(|p| p.to_string_lossy().to_string())
        .map_err(|e| format!(
            "Cannot resolve project path fragment '{}': {}. Does the directory exist?", 
            RELATIVE_PROJECT_PATH_FRAGMENT, 
            e
        ))
}

// --- Public Module Exports (Façade) ---

/// Re-export for starting the **real-time status feed**.
pub use benchmarking::start_signal_inspector;

/// Exports related to **Godot integration and launching**.
pub use godot_harness::{
    copy_dll_to_tester_project_at_boot,
    launch_godot_client,
};

/// Exports related to **testing and validation**.
pub use testing::execute_testing_menu;
>>> FILE END: rust\ssxl_cli\src\actions\mod.rs <<<

======================================================
======================================================
// FILE: ssxl_cli/src/actions/testing.rs

//! # CLI Actions: Testing Utilities (`ssxl_cli::actions::testing`)
//!
//! Provides a menu for executing various test suites, delegating the complex
//! execution logic to the internal `test_suites` and external `test_core_suites` modules.

use crate::cli_util_menu::{CliAction, CliMenu};
use crate::actions::test_suites;      // Architectural tests
use crate::actions::test_core_suites; // External tests

// --- Menu Setup Logic ---

const TEST_ACTIONS: &[CliAction] = &[
    CliAction::new("cargo", "Run all standard `cargo test` suites (unit/integration)."),
    CliAction::new("ffi", "Run FFI bridge and GDExtension integration validation (Headless Godot)."),
    CliAction::new("channel", "Run Communication Channel Tempo Test."),
    CliAction::new("generation", "Run Map Generation Test (Perlin Generator)."),
    CliAction::new("animation", "Run Animation Conductor Data Contract Test."),
];

/// Central entry point for all CLI testing actions.
pub fn execute_testing_menu() -> Result<(), String> {
    let menu = CliMenu::new("Testing and Validation Suites", TEST_ACTIONS);
    
    loop {
        match menu.prompt_action() {
            CliAction { id: ref s, .. } if s == "cargo" => {
                test_core_suites::run_cargo_tests(); 
                Ok(())
            }
            CliAction { id: ref s, .. } if s == "ffi" => {
                test_core_suites::run_ffi_bridge_validation(); 
                Ok(())
            }
            CliAction { id: ref s, .. } if s == "channel" => {
                test_suites::run_communication_channel_test(); 
                Ok(())
            }
            CliAction { id: ref s, .. } if s == "generation" => {
                test_suites::run_map_generation_test(); 
                Ok(())
            }
            CliAction { id: ref s, .. } if s == "animation" => {
                test_suites::run_animation_conductor_test(); 
                Ok(())
            }
            CliAction { id: ref s, .. } if s == "back" => return Ok(()),
            _ => continue,
        }
    }
}
>>> FILE END: rust\ssxl_cli\src\actions\testing.rs <<<

======================================================
======================================================
// FILE: ssxl_cli\src\actions\test_core_suites.rs

//! # Core Integration and External Test Suites
//!
//! Houses tests that rely on external tools like `cargo test` or involve heavy
//! I/O and process management (e.g., headless Godot execution and FFI bridge validation).

use std::process::{Command, Stdio};
use tracing::{info, error, warn};
use std::thread;
use std::io;
use std::time::Instant;

// Import utilities from the actions module.
use super::{
    get_godot_project_abs_path,
    GODOT_EXE_PATH,
    GODOT_TEST_SCENE,
};


// -----------------------------------------------------------------------------
// EXTERNAL TESTING SUITES 
// -----------------------------------------------------------------------------

/// Executes the full, default `cargo test` suite for the entire workspace.
pub fn run_cargo_tests() {
    println!("🚀 Running full cargo test suite...");

    let status = Command::new("cargo")
        .args(&["test", "--", "--nocapture"])
        .status()
        .expect("Failed to run cargo test command. Is cargo installed?");

    if status.success() {
        info!("✅ All Rust unit and integration tests passed.");
    } else {
        error!("❌ Some Rust tests failed. See output above.");
    }
}


/// Runs the core integration test against a headless Godot instance to validate
/// the FFI bridge and GDExtension module loading/calls.
pub fn run_ffi_bridge_validation() {
    info!("🔥 STARTING: FFI Bridge and GDExtension Integration Validation...");

    let project_path_abs = match get_godot_project_abs_path() {
        Ok(path) => path,
        Err(e) => {
            error!("❌ Validation failed: {}", e);
            return;
        }
    };
    
    let mut command = Command::new(GODOT_EXE_PATH);
    command
        .arg("--headless")
        .arg("--path").arg(&project_path_abs)
        .arg("--scene").arg(GODOT_TEST_SCENE)
        .arg("--quit")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = match command.spawn() {
        Ok(c) => c,
        Err(e) => {
            error!("❌ Failed to spawn Godot process: {}", e);
            warn!("Please ensure the Godot executable is in the correct path: {}", GODOT_EXE_PATH);
            return;
        }
    };

    // --- Capture and Read Output Concurrently ---
    let stdout = child.stdout.take().expect("Failed to capture stdout stream");
    let stderr = child.stderr.take().expect("Failed to capture stderr stream");

    let stdout_handle = thread::spawn(move || {
        io::read_to_string(stdout).unwrap_or_else(|_| "Failed to read stdout.".to_string())
    });

    let stderr_handle = thread::spawn(move || {
        io::read_to_string(stderr).unwrap_or_else(|_| "Failed to read stderr.".to_string())
    });

    let status = match child.wait() {
        Ok(s) => s,
        Err(e) => {
            error!("❌ Godot process failed to wait: {}", e);
            return;
        }
    };

    let stdout_output = stdout_handle.join().unwrap_or_else(|_| "Stdout reading thread panicked.".to_string());
    let stderr_output = stderr_handle.join().unwrap_or_else(|_| "Stderr reading thread panicked.".to_string());

    // --- Report Results ---
    println!("\n--- GODOT TEST OUTPUT START ---");
    println!("{}", stdout_output);
    println!("--- GODOT TEST OUTPUT END ---\n");

    if status.success() {
        info!("✅ FFI/GDExtension Bridge VALIDATION SUCCEEDED!");
    } else {
        error!("❌ FFI/GDExtension Bridge VALIDATION FAILED! Exit code: {:?}", status.code());
        eprintln!("--- GODOT ERROR OUTPUT ---");
        eprintln!("{}", stderr_output);
    }
}
>>> FILE END: rust\ssxl_cli\src\actions\test_core_suites.rs <<<

======================================================
======================================================
// FILE: ssxl_cli\src\actions\test_suites.rs

//! # Internal Architectural and Data Validation Suites
//!
//! Contains self-contained Rust tests focused on validating internal data contracts,
//! concurrency models (channels), and core generation logic without external
//! process reliance.

use tracing::{info, error};
use std::time::{Duration, Instant};
use std::sync::mpsc;
use bincode::{serialize, deserialize};

// --- Project Imports ---
use ssxl_generate::Generator;
use ssxl_generate::perlin_generator::PerlinGenerator;
use ssxl_math::Vec2i;
use ssxl_shared::chunk_data::CHUNK_SIZE;
use ssxl_shared::tile_data::AnimationUpdate;


// -----------------------------------------------------------------------------
// FOCUSED ARCHITECTURAL VALIDATION
// -----------------------------------------------------------------------------

/// Validates the non-blocking mpsc channels used between the Godot main thread
/// and the Rust worker threads (Generation and Animation Conductors).
pub fn run_communication_channel_test() {
    info!("--- Starting Communication Channel Test (Godot <-> Rust Tempo) ---");
    let test_duration = Duration::from_millis(100);
    
    // 1. Create a channel pair: (CLI sends, Mock Conductor receives)
    let (cli_sender, conductor_receiver) = mpsc::channel::<String>();
    
    // 2. Spawn a thread to act as the Mock Conductor
    let conductor_handle = std::thread::spawn(move || {
        let mut messages_received = 0;
        let start = Instant::now();
        
        while start.elapsed() < test_duration {
            match conductor_receiver.try_recv() {
                Ok(msg) => {
                    if msg == "TEST_COMMAND" {
                        messages_received += 1;
                    }
                },
                Err(mpsc::TryRecvError::Empty) => {
                    std::thread::yield_now();
                },
                Err(mpsc::TryRecvError::Disconnected) => break,
            }
        }
        messages_received
    });
    
    // 3. CLI (main thread) floods the channel with messages
    let mut messages_sent = 0;
    let start = Instant::now();
    while start.elapsed() < test_duration {
        if cli_sender.send("TEST_COMMAND".to_string()).is_ok() {
            messages_sent += 1;
        }
        std::thread::sleep(Duration::from_millis(1)); 
    }
    
    drop(cli_sender);

    // 4. Wait for the Mock Conductor thread to complete and get the result
    let messages_received = match conductor_handle.join() {
        Ok(count) => count,
        Err(_) => {
            error!("❌ Mock Conductor thread panicked during join.");
            return;
        }
    };
    
    // 5. Report results
    let success = messages_received > 0;

    info!("Test Duration: {:?}", start.elapsed());
    info!("Total messages SENT: {}", messages_sent);
    info!("Total messages RECEIVED: {}", messages_received);

    if success {
        info!("✅ Communication Channel Test SUCCESS: Non-blocking channel functional. Received {} messages.", messages_received);
    } else {
        error!("❌ Communication Channel Test FAILED: Did not receive any messages or thread failed to join.");
    }
}


/// Alias for `run_communication_channel_test`. Validates data-channel functionality.
pub fn run_data_channel_test() {
    run_communication_channel_test();
}

/// Validates the core map generation logic by creating a chunk using the Perlin Generator.
pub fn run_map_generation_test() {
    info!("--- Starting Map Generation Test (Perlin Generator) ---");
    let generator = PerlinGenerator::new(64.0);
    let chunk_coords = Vec2i::new(10, 20);
    
    let start = Instant::now();
    let chunk = generator.generate_chunk(chunk_coords); 
    let duration = start.elapsed();

    let expected_size = (CHUNK_SIZE * CHUNK_SIZE) as usize;
    let success = chunk.tiles.len() == expected_size;

    info!("Generated Chunk ID: {}", chunk.id);
    info!("Generation Time: {:?} ({:.2} tiles/sec)", duration, (expected_size as f64) / duration.as_secs_f64());
    
    if success {
        info!("✅ Map Generation Test SUCCESS: Chunk data integrity verified ({} tiles).", expected_size);
    } else {
        error!("❌ Map Generation Test FAILED: Expected {} tiles, got {}.", expected_size, chunk.tiles.len());
    }
}

/// Validates the data contract for the Animation Conductor by ensuring
/// the `AnimationUpdate` structure can be serialized and deserialized.
pub fn run_animation_conductor_test() {
    info!("--- Starting Animation Conductor Data Contract Test ---");

    let original_update = AnimationUpdate {
        layer: 1,
        source_id: 101,
        tile_coords: Vec2i::new(500, -300),
        new_atlas_coords: Vec2i::new(5, 7),
    };

    let encoded = match serialize(&original_update) {
        Ok(e) => e,
        Err(e) => {
            error!("❌ Serialization FAILED: {}", e);
            return;
        }
    };
    
    let decoded: AnimationUpdate = match deserialize(&encoded) {
        Ok(d) => d,
        Err(e) => {
            error!("❌ Deserialization FAILED: {}", e);
            return;
        }
    };

    let success = original_update.tile_coords == decoded.tile_coords && original_update.new_atlas_coords == decoded.new_atlas_coords;

    info!("Serialized size: {} bytes", encoded.len());

    if success {
        info!("✅ Animation Conductor Data Test SUCCESS: AnimationUpdate serialized and deserialized correctly.");
    } else {
        error!("❌ Animation Conductor Data Test FAILED: Decoded data did not match original.");
    }
}
>>> FILE END: rust\ssxl_cli\src\actions\test_suites.rs <<<

======================================================
======================================================
//! # File Walker and LOC Scanner (`ssxl_cli::actions::file_walker`)
//!
//! Provides utilities for recursively traversing the filesystem. Primarily used
//! to perform a Lines of Code (LOC) count on source files, excluding common
//! build and obsolete directories.

use std::fs;
use std::io;
use std::path::{Path, PathBuf};
use tracing::{warn, error};

/// The default root directory for the LOC scan, assumed to be relative to the CLI execution path.
pub const RUST_DIR: &str = "../rust/";
pub const GODOT_TESTER_DIR: &str = "../SSXL_engine_tester/"; // Renamed for consistency

/// An array of all default directories that should be scanned.
/// The CLI command should be able to extend this list with arguments.
pub const DEFAULT_SCAN_ROOTS: &[&str] = &[
    RUST_DIR,
    GODOT_TESTER_DIR,
];


/// Represents the data collected for a single file during a scan.
#[derive(Debug, Clone)]
pub struct FileLoc {
    /// The absolute or relative path to the file.
    pub path: PathBuf,
    /// The count of lines in the file (Lines of Code).
    pub loc: usize,
}

// --------------------------------------------------------------------------------------------------
// NEW LOGIC: Multi-Root Orchestration
// --------------------------------------------------------------------------------------------------

/// Initiates a scan across multiple root directories and aggregates the results.
///
/// This function should be called by the main CLI action.
///
/// # Arguments
/// * `roots`: A slice of directory paths to scan.
/// * `extensions`: A slice of file extensions to target (e.g., &["rs", "gd"]).
///
/// # Returns
/// A `Result` containing a vector of all `FileLoc` structs collected, or an `io::Error` on failure.
pub fn scan_multiple_roots(roots: &[&str], extensions: &[&str]) -> io::Result<Vec<FileLoc>> {
    let mut total_results = Vec::new();

    for root_str in roots {
        let root_path = PathBuf::from(root_str);
        if !root_path.exists() {
            warn!("Skipping non-existent scan root: {}", root_path.display());
            continue;
        }

        for extension in extensions.iter() {
            match scan_single_root_loc(&root_path, extension) {
                Ok(mut file_locs) => total_results.append(&mut file_locs),
                Err(e) => {
                    // Log the error but keep going! A failure in one path shouldn't halt the whole scan.
                    error!("Failed to scan root '{}' for extension '{}': {}", root_path.display(), extension, e);
                }
            }
        }
    }
    // We return Ok even if some individual scans failed, as long as we gathered some data.
    Ok(total_results)
}


// --------------------------------------------------------------------------------------------------
// RENAMED HELPER: Single-Root, Single-Extension Scan
// --------------------------------------------------------------------------------------------------

/// Initiates a recursive scan starting from a single given root path and a single extension.
///
/// It delegates the actual traversal and processing to the `scan_dir` helper function.
///
/// # Arguments
/// * `root_path`: The starting directory for the scan.
/// * `extension`: The file extension to target (e.g., "rs" for Rust files).
///
/// # Returns
/// A `Result` containing a vector of `FileLoc` structs on success, or an `io::Error` on failure.
pub fn scan_single_root_loc(root_path: &Path, extension: &str) -> io::Result<Vec<FileLoc>> {
    let mut results = Vec::new();
    // PathBuf changed to &Path for better ergonomics
    scan_dir(root_path, extension, &mut results)?;
    Ok(results)
}


// --------------------------------------------------------------------------------------------------
// TRAVERSAL HELPER: Internal Recursive Logic
// --------------------------------------------------------------------------------------------------

/// Recursively traverses a directory, counting LOC for files matching the given extension.
fn scan_dir(path: &Path, extension: &str, results: &mut Vec<FileLoc>) -> io::Result<()> {
    if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                // Skip common build output directories.
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "target") {
                    warn!("LOC Scanner skipping build output directory: {}", path.display());
                    continue;
                }
                
                // Skip obsolete/archived directories.
                if path.file_name().map_or(false, |n| n.to_string_lossy() == "iteration5") {
                    warn!("LOC Scanner skipping obsolete directory: {}", path.display());
                    continue;
                }

                // Recurse into valid subdirectories.
                scan_dir(&path, extension, results)?;
            } else if path.extension().map_or(false, |ext| ext == extension) {
                // Process file if its extension matches the target.
                match fs::read_to_string(&path) {
                    Ok(content) => {
                        // Count lines by counting line endings.
                        let loc = content.lines().count();
                        results.push(FileLoc { path, loc });
                    }
                    Err(e) => {
                        error!("Failed to read file {}: {}", path.display(), e);
                    }
                }
            }
        }
    }
    Ok(())
}
>>> FILE END: rust\ssxl_cli\src\scan\file_walker.rs <<<

======================================================
======================================================
// ssxl_cli/src/scan/mod.rs 

//! # Codebase Scan Utilities (`ssxl_cli::scan`)
//!
//! This module groups all functionality related to scanning and analyzing the
//! SSXL-ext codebase, such as calculating Lines of Code (LOC) and generating
//! reports. It serves as a façade to its internal sub-modules.

// Removed all unused imports: tracing macros, std::io, std::env, std::fs, std::process::Command, and std::process::Stdio.

/// Internal module responsible for recursively walking the file system.
mod file_walker;
/// Internal module responsible for generating and displaying the scan results.
mod report_formatter;


// Publicly re-export the main entry point for the LOC scan utility.
pub use report_formatter::execute_loc_scan;
>>> FILE END: rust\ssxl_cli\src\scan\mod.rs <<<

======================================================
======================================================
// rust\ssxl_cli\src\scan\report_formatter.rs (Revised - UNDER 180 LOC)

//! # LOC Report Formatter (`ssxl_cli::scan::report_formatter`)
//!
//! This module orchestrates the Lines of Code (LOC) scan process. It calls the
//! file walker, aggregates the results, and delegates report formatting to the
//! `report_writer` module.

use std::fs;
use std::io::Write; 
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use tracing::{info, error};

// ⚡️ UPDATED: Import the necessary components from `file_walker`.
use super::file_walker::{scan_multiple_roots, DEFAULT_SCAN_ROOTS};

// 💥 NEW: Import the specialized writing functions and constants.
mod report_writer; 
use report_writer::{write_report_header, write_summary_table, write_content_dump, TARGET_EXTENSIONS};


/// Prefix for the generated report filenames.
const OUTPUT_FILENAME_PREFIX: &str = "ssxl_loc_report_";
/// Directory where all LOC reports will be saved, relative to the CWD.
const OUTPUT_DIR: &str = "../loc_reports/";


/// Generates a string representation of the current system time in seconds since the epoch.
/// This is used to ensure unique and chronologically sortable report filenames.
fn get_timestamp_string() -> String {
    let now = SystemTime::now();
    // Calculate duration since the UNIX epoch, defaulting to 0 if the time is before the epoch.
    let since_the_epoch = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    format!("{}", since_the_epoch.as_secs())
}

/// The main entry point for the LOC scan.
///
/// It performs the scan, calculates totals, generates a report file with a summary
/// and a full content dump, and prints the totals to the console.
pub fn execute_loc_scan() {
    // NOTE: Using TARGET_EXTENSIONS imported from report_writer.
    let root_desc = format!("{} (and {} other extensions)", DEFAULT_SCAN_ROOTS.join(", "), TARGET_EXTENSIONS.len() - 1);
    info!("LOC Scanner: Starting multi-root recursive scan for {}", root_desc);
    
    let scan_start = SystemTime::now();

    // 1. 🚀 Perform the multi-root, multi-extension scan.
    let mut loc_results = match scan_multiple_roots(DEFAULT_SCAN_ROOTS, TARGET_EXTENSIONS) {
        Ok(results) => results,
        Err(e) => {
            error!("LOC Scanner: Multi-root scan failed: {}", e);
            return;
        }
    };
    
    let scan_duration = scan_start.elapsed()
        .map_or("N/A".to_string(), |d| format!("{:.2}ms", d.as_millis() as f32));

    // 2. Aggregate results.
    let total_loc: usize = loc_results.iter().map(|f| f.loc).sum();
    let file_count = loc_results.len();

    // 3. Prepare output path and filename.
    let timestamp_str = get_timestamp_string();
    let output_filename = format!("{}{}.txt", OUTPUT_FILENAME_PREFIX, timestamp_str);
    let output_path = PathBuf::from(OUTPUT_DIR).join(&output_filename);

    // Ensure the report output directory exists, creating it if necessary.
    if let Err(e) = fs::create_dir_all(PathBuf::from(OUTPUT_DIR)) {
        error!("Failed to create output directory {}: {}", OUTPUT_DIR, e);
        return;
    }

    // 4. Create and write the report file.
    match fs::File::create(&output_path) {
        Ok(mut file) => {
            // Sort results by LOC, descending, to highlight the largest files first.
            loc_results.sort_unstable_by(|a, b| b.loc.cmp(&a.loc));
            
            // ⭐️ DELEGATED: Write the report sections.
            if let Err(e) = write_report_header(&mut file, &root_desc, &scan_duration, total_loc, file_count, &timestamp_str) {
                error!("Failed to write header to LOC report: {}", e);
                return;
            }

            if let Err(e) = write_summary_table(&mut file, &loc_results) {
                error!("Failed to write summary table to LOC report: {}", e);
            }

            if let Err(e) = write_content_dump(&mut file, &loc_results) {
                error!("Failed to write content dump to LOC report: {}", e);
            }
            
            // Write the report footer.
            if file.write_all(b"\n\n======================================================\nEND OF REPORT\n======================================================\n").is_err() {
                error!("Failed to write report footer.");
            }

            // 5. Print console summary.
            info!("LOC Report: Successfully created report file: {}", output_path.display());
            println!("\n[ LOC Scan Complete ]");
            // 🎯 Print the combined file types.
            println!("Target Extensions: {}", TARGET_EXTENSIONS.join(", "));
            println!("Total Files Scanned: {}", file_count);
            println!("Total Lines of Code: {}", total_loc);
            println!("Report saved to: {}", output_path.display());
        }
        Err(e) => {
            error!("Failed to create LOC report file {}: {}", output_path.display(), e);
        }
    }
}
>>> FILE END: rust\ssxl_cli\src\scan\report_formatter.rs <<<

======================================================
======================================================
// rust\ssxl_cli\src\scan\report_section_formatter.rs (New File)

use nu_ansi_term::Color;
use std::fmt::Write;
// Assume utility types/structs are imported or passed in

/// Generates a formatted table of all files and their LOC.
pub fn format_file_loc_table(report_data: &ReportData) -> String {
    let mut table_output = String::new();
    // Use a fixed width or dynamic calculation to align columns
    let max_loc_width = report_data.files.iter()
        .map(|f| f.loc.to_string().len()).max().unwrap_or(0);
    
    // Header
    writeln!(table_output, "{} | {}", 
        Color::Cyan.bold().paint(format!("{:>max_loc_width$}", "LOC")),
        Color::Cyan.bold().paint("File Path")
    ).unwrap();

    // Separator
    let separator = "-".repeat(max_loc_width) + " + " + &"-".repeat(60);
    writeln!(table_output, "{}", Color::Fixed(8).paint(separator)).unwrap();

    // Rows
    for file_entry in &report_data.files {
        let loc_colored = match file_entry.loc {
            0 => Color::Black.bold().on(Color::Fixed(8)).paint(format!("{:>max_loc_width$}", file_entry.loc)),
            loc if loc > 180 => Color::Red.bold().paint(format!("{:>max_loc_width$}", loc)),
            loc if loc > 150 => Color::Yellow.bold().paint(format!("{:>max_loc_width$}", loc)),
            _ => Color::Green.paint(format!("{:>max_loc_width$}", file_entry.loc)),
        };
        writeln!(table_output, "{} | {}", loc_colored, file_entry.path).unwrap();
    }

    table_output
}

// Add other extraction functions here, like:
// pub fn format_summary_header(...) -> String { ... }
>>> FILE END: rust\ssxl_cli\src\scan\report_section_formatter.rs <<<

======================================================
======================================================
// rust\ssxl_cli\src\scan\report_writer.rs (New File)
//!
//! This module contains the low-level logic for writing the LOC report
//! to disk, separated from the scanning orchestration logic.

use std::fs;
use std::io::{self, Write};
use std::path::{PathBuf};
use tracing::error;

// NOTE: Assumes FileLoc is a public type available in the `scan` module,
// likely defined in file_walker.rs, but redefined here for standalone logic.
// In the real project, we would use: `use super::file_walker::FileLoc;`
#[derive(Debug)]
pub struct FileLoc {
    pub path: PathBuf,
    pub loc: usize,
}

/// Define all target extensions for the multi-lingual project.
pub const TARGET_EXTENSIONS: &[&str] = &["rs", "gd", "gdc", "toml", "md"];


/// Writes the metadata and header section to the report file.
pub fn write_report_header(
    file: &mut fs::File,
    root_desc: &str,
    scan_duration: &str,
    total_loc: usize,
    file_count: usize,
    timestamp_str: &str,
) -> io::Result<()> {
    let header = format!(
        "SSXL-ext Codebase LOC Report\n\
        Generated (Epoch Seconds): {}\n\
        Root Directories: {}\n\
        Target Extensions: {}\n\
        Scan Time: {}\n\
        Total Files Scanned: {}\n\
        Total Lines of Code (LOC): {}\n\n\
        ------------------------------------------------------\n\
        {:>5} LOC | Relative File Path\n\
        ------------------------------------------------------\n",
        timestamp_str,
        root_desc,
        TARGET_EXTENSIONS.join(", "),
        scan_duration,
        file_count,
        total_loc,
        "FILE" // Column header for LOC count
    );
    file.write_all(header.as_bytes())
}

/// Writes a table listing each file, its LOC count, and its relative path.
pub fn write_summary_table(
    file: &mut fs::File,
    loc_results: &[FileLoc],
) -> io::Result<()> {
    for result in loc_results {
        let path_str = result.path.display().to_string();
        let line = format!("{:>5} LOC | {}\n", result.loc, path_str);
        file.write_all(line.as_bytes())?;
    }
    Ok(())
}

/// Appends the full contents of every scanned file to the report, separated by clear headers.
pub fn write_content_dump(
    file: &mut fs::File,
    loc_results: &[FileLoc],
) -> io::Result<()> {
    let content_header = format!(
        "\n\n\n\n======================================================\n\
        SSXL-ext Codebase DETAILED CONTENT DUMP\n\
        ======================================================\n"
    );
    file.write_all(content_header.as_bytes())?;

    for result in loc_results {
        let path_str = result.path.display().to_string();
        
        let file_separator = format!(
            "\n\n\n//////////////////////////////////////////////////////\n\
            // FILE: {} ({} LOC)\n\
            //////////////////////////////////////////////////////\n\n",
            path_str,
            result.loc
        );

        file.write_all(file_separator.as_bytes())?;

        // Read and write the full content of the file.
        match fs::read_to_string(&result.path) {
            Ok(content) => {
                if let Err(e) = file.write_all(content.as_bytes()) {
                    // Use a tracing error for write failures.
                    error!("Failed to write content for {}: {}", path_str, e);
                }
            }
            Err(e) => {
                let error_message = format!("\n[ ERROR: FAILED TO READ FILE CONTENT: {} ]\n", e);
                if file.write_all(error_message.as_bytes()).is_err() {
                    error!("Failed to write error message for {}.", path_str);
                }
            }
        }
    }
    Ok(())
}
>>> FILE END: rust\ssxl_cli\src\scan\report_writer.rs <<<

======================================================
======================================================
[package]
name = "ssxl_engine_ffi"
version = "0.6.0"
edition = "2021"


[dependencies]
# --- INTERNAL DEPENDENCIES (Core Logic) ---
# FFI needs access to all the core data and logic it is bridging.
ssxl_shared   = { path = "../ssxl_shared" }
ssxl_math     = { path = "../ssxl_math" }
ssxl_godot	  = { path = "../ssxl_godot" }

# --- EXTERNAL DEPENDENCIES ---
# The standard C library definitions for safe FFI (e.g., c_char, c_void)
libc               = "0.2" 
# Workspace standard logging framework
tracing            = { workspace = true } 

>>> FILE END: rust\ssxl_engine_ffi\Cargo.toml <<<

======================================================
======================================================
// ssxl_engine_ffi/src/lib.rs

//! Foreign Function Interface (FFI) Bridge for the SSXL Engine.
//!
//! This module exposes C-compatible functions to external host environments (like Godot's
//! GDExtension), allowing them to start, stop, and query the SSXL procedural generation
//! runtime, which is managed by the thread-safe `Conductor` singleton.

use std::ffi::CString;
use std::sync::OnceLock;
use std::os::raw::c_char; // Explicitly import c_char for FFI clarity

use ssxl_generate::{Conductor, start_runtime_placeholder};
use ssxl_shared::initialize_shared_data;
use tracing::{info, error};

// --- 1. Thread-Safe Singleton for the Conductor ---

/// A thread-safe, one-time initialization container for the core Conductor runtime.
/// Using OnceLock ensures that the Conductor is initialized exactly once, protecting
/// against initialization race conditions across different FFI calls.
static CONDUCTOR: OnceLock<Conductor> = OnceLock::new();

// --- 2. FFI Functions for Runtime Management ---

/// Starts the SSXL Conductor runtime if it is not already running.
///
/// This function is idempotent: calling it multiple times will only initialize the
/// runtime once. It is the primary entry point for the external engine.
///
/// # Safety/FFI
/// Marked `extern "C"` and `#[no_mangle]` for C-ABI compatibility.
///
/// # Returns
/// `true` if the runtime is running (either started now or was already running),
/// `false` if initialization failed.
#[no_mangle]
pub extern "C" fn ssxl_start_runtime() -> bool {
    // Ensure core engine configuration data is initialized first.
    initialize_shared_data();

    if CONDUCTOR.get().is_some() {
        info!("FFI Bridge: Runtime already running.");
        return true;
    }

    // Attempt to initialize and set the Conductor singleton.
    match Conductor::new(None) {
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            if CONDUCTOR.set(conductor).is_err() {
                // Should only happen in a severe race condition during first initialization.
                error!("FFI Bridge: Conductor::set() failed (Possible race condition).");
                return false;
            }
            info!("FFI Bridge: Conductor Runtime started successfully.");
            true
        }
        Err(e) => {
            tracing::error!("FFI Bridge: Failed to initialize Conductor: {:?}", e);
            false
        }
    }
}

/// Signals the Conductor to begin a graceful shutdown sequence.
///
/// The FFI consumer should call this before unloading the DLL/shared library.
/// This prevents systemic entropy by allowing worker threads to finish.
#[no_mangle]
pub extern "C" fn ssxl_shutdown_runtime() {
    if let Some(conductor) = CONDUCTOR.get() {
        // The conductor's destructor will handle waiting for threads if necessary.
        conductor.signal_shutdown_graceful();
        info!("FFI Bridge: Conductor Runtime signalled for shutdown.");
    }
}

/// Checks if the Conductor runtime has been successfully initialized.
///
/// # Returns
/// `true` if the Conductor is initialized and accessible, `false` otherwise.
#[no_mangle]
pub extern "C" fn ssxl_is_runtime_ready() -> bool {
    CONDUCTOR.get().is_some()
}

/// A convenience alias for the primary initialization function.
#[no_mangle]
pub extern "C" fn ssxl_initialize_engine() -> bool {
    ssxl_start_runtime()
}

// --- 3. FFI Functions for Diagnostics and Debugging ---

/// Triggers a structural test sequence within the Conductor's runtime manager.
/// This is typically used for integration testing or initial smoke checks.
#[no_mangle]
pub extern "C" fn ssxl_trigger_runtime_test() {
    info!("FFI Bridge: Received command to trigger Conductor structural test.");
    start_runtime_placeholder();
    info!("FFI Bridge: Conductor test sequence complete.");
}

/// Retrieves a formatted status string from the engine.
///
/// # Safety/FFI Contract
/// The calling environment is responsible for calling `ssxl_free_string` on the
/// returned raw pointer to prevent a memory leak, as the string is allocated
/// on the Rust heap.
///
/// # Returns
/// A raw C-style string pointer (`*mut c_char`).
#[no_mangle]
pub extern "C" fn ssxl_get_status(id: u32) -> *mut c_char {
    let status = format!(
        "Engine status for id {}: Runtime Running: {}",
        id,
        CONDUCTOR.get().is_some()
    );
    match CString::new(status) {
        // Consume the CString, transferring ownership of the raw pointer to C.
        Ok(c_string) => c_string.into_raw(),
        // Return a safe error string on failure (e.g., status contained a null byte).
        Err(_) => CString::new("Error: Invalid Status String").unwrap().into_raw(),
    }
}

/// Frees a string pointer that was allocated by Rust and passed to C.
///
/// This function fulfills the FFI memory contract. It takes ownership of the
/// raw pointer and reconstructs the CString, which then frees the memory
/// when it goes out of scope.
///
/// # Safety
/// The caller must ensure that `s` is a valid pointer that was originally
/// returned by a Rust FFI function (like `ssxl_get_status`).
#[no_mangle]
pub extern "C" fn ssxl_free_string(s: *mut c_char) {
    unsafe {
        // Check for null pointer defensively.
        if s.is_null() { return }
        // Reconstruct CString from the raw pointer, taking ownership.
        // When `_` drops, the memory is safely deallocated.
        let _ = CString::from_raw(s);
    }
}
>>> FILE END: rust\ssxl_engine_ffi\src\lib.rs <<<

======================================================
======================================================
[package]
name = "ssxl_generate"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES (Foundation Layer) ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math   = { path = "../ssxl_math" }
ssxl_sync   = { path = "../ssxl_sync" }
ssxl_tools = { path = "../ssxl_tools" }

# --- EXTERNAL DEPENDENCIES (Core Computation) ---
# For parallel execution of generation algorithms
rayon            = { workspace = true }
# Core randomness library
rand             = { workspace = true }
# Used for saving/loading bitmap images (optional textures/noise visualizations)
image            = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing          = { workspace = true }
tokio            = { workspace = true }
noise            = { workspace = true }
glam             = { workspace = true }
fastrand = { workspace = true }
num_cpus = { workspace = true }
>>> FILE END: rust\ssxl_generate\Cargo.toml <<<

======================================================
======================================================
// ssxl_generate/src/batch_processor.rs

//! Logic for executing large, synchronous batches of chunk generation requests.
//!
//! This module coordinates the parallel generation of a defined rectangular area of the
//! world map. It uses the Tokio runtime to manage the task execution and the Rayon
//! crate for CPU-bound, fine-grained parallelism across available threads, ensuring
//! high-speed completion of generation tasks.

use tokio::runtime::Handle;
use tokio::sync::mpsc::Sender;
use tracing::info;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

use rayon::prelude::*; // Key library for parallel iteration

use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;

use crate::config_validator::GeneratorConfig;
use crate::task_queue::{handle_chunk_unit, GenerationMessage, CHUNK_SIZE};
use crate::conductor_state::ConductorState;
use crate::generator_manager::DynGenerator;

/// Spawns a new generation task that processes a full batch of chunks in parallel.
///
/// This function is non-blocking to the caller (usually the Conductor) and hands off
/// the CPU-intensive work to a separate thread pool via `spawn_blocking`.
///
/// # Arguments
/// * `runtime_handle`: The handle to the Tokio runtime's executor.
/// * `generators_clone`: Map of all registered generators for selection.
/// * `chunk_cache_clone`: Thread-safe cache for reading/writing generated data.
/// * `active_generator_id`: Identifier of the generator to use for this batch.
/// * `progress_sender_clone`: Channel sender for sending completion/progress messages back to Conductor.
/// * `internal_state_clone`: A copy of the Conductor's shared state (used for queue depth tracking).
/// * `config_clone`: The configuration defining the area and size of the generation request.
pub fn spawn_batch_generation_task(
    runtime_handle: &Handle,
    generators_clone: HashMap<String, Arc<DynGenerator>>,
    chunk_cache_clone: Arc<Mutex<ChunkCache>>,
    active_generator_id: String,
    progress_sender_clone: Sender<GenerationMessage>,
    internal_state_clone: ConductorState,
    config_clone: GeneratorConfig,
) {
    info!("Conductor spawning BATCH generation task. Config: {}", config_clone);

    // Use `spawn_blocking` to move the synchronous, CPU-bound generation work off
    // of the async runtime's main thread pool, preventing executor starvation.
    runtime_handle.spawn_blocking(move || {
        // Increment the queue depth immediately to track the active task count.
        internal_state_clone.increment_queue_depth();

        // Calculate the grid size for the batch, rounding up to the nearest chunk boundary.
        let chunk_size_i64: i64 = CHUNK_SIZE as i64;
        
        // Ensure map dimensions are used as i64 for the calculation.
        let map_width_i64: i64 = config_clone.width as i64;
        let map_height_i64: i64 = config_clone.height as i64;

        // Calculate the chunk counts using the correct ceiling division formula: (a + b - 1) / b
        let width_in_chunks = (map_width_i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (map_height_i64 + chunk_size_i64 - 1) / chunk_size_i64;

        // Generate a vector of all ChunkKey coordinates (Vec2i) for the entire batch area.
        // The range (0..N) correctly includes coordinates 0 up to N-1.
        let all_chunk_coords: Vec<Vec2i> = (0..width_in_chunks)
            .flat_map(|x| (0..height_in_chunks).map(move |y| Vec2i::new(x, y)))
            .collect();
        
        // Added check for 0x0 map request, although likely prevented by ConfigValidator.
        if all_chunk_coords.is_empty() {
             info!("Batch generation task received a map size of 0x0 chunks. Task finished immediately.");
        }


        // --- Core Parallel Processing ---
        all_chunk_coords
            // Convert the iterator to a parallel iterator using Rayon.
            .par_iter()
            // Process each chunk in parallel across all available CPU threads.
            .for_each(|&chunk_coords| {
                handle_chunk_unit(
                    chunk_coords,
                    &active_generator_id,
                    &generators_clone,
                    &chunk_cache_clone,
                    &progress_sender_clone,
                );
            });

        // Send a final message to the Conductor indicating the entire batch is complete.
        // `blocking_send` is used because this closure is running on a synchronous blocking thread.
        let _ = progress_sender_clone.blocking_send(GenerationMessage::GenerationComplete);

        // Decrement the queue depth, signaling to the Conductor that this task is done.
        internal_state_clone.decrement_queue_depth();

        info!("Batch generation task finished processing command: {}", config_clone);
    });
}
>>> FILE END: rust\ssxl_generate\src\batch_processor.rs <<<

======================================================
======================================================
// ssxl_generate/src/benchmark_logic.rs

use tracing::{info, warn};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}}; // ADDED: For concurrent progress reporting

pub fn benchmark_generation_workload(
    workload_tiles: u64, 
    processed_tiles_counter: Arc<AtomicU64> // NEW: Shared atomic counter for progress
) {
    warn!("Generator: Executing generation workload for {} tiles...", workload_tiles);

    const UPDATE_INTERVAL: u64 = 10_000_000; 

    let mut result: u64 = 0;
    
    for i in 0..workload_tiles {
        result = result.wrapping_add(i % 17);
        
        if (i + 1) % UPDATE_INTERVAL == 0 {
            processed_tiles_counter.fetch_add(UPDATE_INTERVAL, Ordering::Relaxed);
        }
    }

    let final_update = workload_tiles % UPDATE_INTERVAL;
    if final_update > 0 {
        processed_tiles_counter.fetch_add(final_update, Ordering::Relaxed);
    }
    
    info!("Generator: Workload simulation complete. Final check value: {}", result);
}
>>> FILE END: rust\ssxl_generate\src\benchmark_logic.rs <<<

======================================================
======================================================
//ssxl_generate/src/cellular_automata_generator.rs
//! Implements a procedural generator based on Cellular Automata (CA) rules.
//!
//! This generator is responsible for creating cave systems, mazes, and other
//! structured patterns by iterating on an initially random chunk state. It
//! delegates complex logic to the `ca::rule_set` and `ca::neighbor_check` modules.

use crate::Generator;
use ssxl_math::Vec2i;
use fastrand; // Lightweight, fast, and thread-safe PRNG
use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    grid_bounds::GridBounds,
    tile_data::TileData,
    tile_type::TileType,
};
use tracing::{info, warn};

use crate::ca::rule_set::{RULE_SOLID, RULE_CHECKERBOARD, get_next_tile_type};
use crate::ca::neighbor_check::count_live_neighbors;

// --- 1. Generator Constants ---

/// The fixed number of iterations for the CA simulation to stabilize the pattern.
const CA_ITERATIONS: u8 = 4;
/// The percentage of tiles randomly initialized as `TileType::Rock` (the "live" state).
const INITIAL_FILL_PERCENT: u8 = 45;

// --- 2. Generator Structure and Implementation ---

/// A generator that uses Cellular Automata rules to produce structured patterns.
#[allow(dead_code)] // Allowed since this struct is instantiated via the GeneratorManager
pub struct CellularAutomataGenerator {
    /// The specific B/S ruleset (e.g., RULE_BASIC_CAVE or RULE_MAZE) to apply.
    ruleset: u8,
}

impl CellularAutomataGenerator {
    /// Creates a new CA generator instance with the specified ruleset.
    pub fn new(ruleset: u8) -> Self {
        CellularAutomataGenerator { ruleset }
    }
}

// --- 3. Internal Generation Helper Functions ---

/// Generates static, non-simulated patterns (Solid or Checkerboard).
///
/// This bypasses the iterative CA steps entirely for simple, fixed designs.
fn generate_static_pattern(chunk_coords: Vec2i, ruleset: u8) -> ChunkData {
    let chunk_tile_size = CHUNK_SIZE as i64;
    
    // Calculate world boundaries for the ChunkData metadata
    let world_start_x = chunk_coords.x * chunk_tile_size;
    let world_start_y = chunk_coords.y * chunk_tile_size;
    
    // Create a unique 64-bit Chunk ID
    let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
    
    let bounds = GridBounds::new(
        world_start_x,
        world_start_y,
        world_start_x + chunk_tile_size,
        world_start_y + chunk_tile_size,
    );
    
    let dimension_name = match ruleset {
        RULE_SOLID => "Solid_Fill".to_string(),
        RULE_CHECKERBOARD => "Checkerboard".to_string(),
        _ => "Static_Pattern_Unknown".to_string(),
    };
    
    let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
    let mut tiles = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

    for y in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let tile_type = match ruleset {
                RULE_SOLID => TileType::Rock,
                RULE_CHECKERBOARD => {
                    // Checkerboard pattern: alternate based on coordinate parity
                    if (x + y) % 2 == 0 {
                        TileType::Rock
                    } else {
                        TileType::Void
                    }
                }
                _ => TileType::Void, // Should not be reached, but defaults to Void
            };
            tiles.push(TileData::new(tile_type, 0.0));
        }
    }

    chunk_data.insert_tiles(tiles);
    info!("CA Generator: Finished static chunk at {:?}.", chunk_coords);
    chunk_data
}

/// Applies one iteration (step) of the Cellular Automata simulation.
///
/// This involves creating a copy of the tile array to prevent changes in the current
/// iteration from affecting neighbor counts for subsequent tiles in the same iteration.
fn apply_ca_step(chunk_data: &mut ChunkData, ruleset: u8) {
    // Clone the current state to calculate the *next* state without self-interference.
    let mut new_tiles: Vec<TileData> = chunk_data.tiles.iter().cloned().collect();

    for x in 0..CHUNK_SIZE {
        for y in 0..CHUNK_SIZE {
            let index = (y * CHUNK_SIZE + x) as usize;
            let current_tile = &chunk_data.tiles[index];
            
            // 1. Check Neighbors (Delegated to specialized module)
            let live_neighbors = count_live_neighbors(chunk_data, x as u32, y as u32);

            // 2. Apply Rule Set (Delegated to specialized module)
            let new_type = get_next_tile_type(
                current_tile.tile_type,
                live_neighbors,
                ruleset
            );

            // 3. Update the new tile state, preserving the original noise value (if any).
            new_tiles[index] = TileData::new(new_type, current_tile.noise_value);
        }
    }
    // Swap the updated tile array back into the ChunkData.
    chunk_data.insert_tiles(new_tiles);
}

// --- 4. Trait Implementation (Generator API) ---

impl Generator for CellularAutomataGenerator {
    /// Returns a unique identifier string for this generator instance.
    fn id(&self) -> &str {
        match self.ruleset {
            crate::ca::rule_set::RULE_MAZE => "cellular_automata_maze",
            crate::ca::rule_set::RULE_SOLID => "cellular_automata_solid",
            crate::ca::rule_set::RULE_CHECKERBOARD => "cellular_automata_checkerboard",
            crate::ca::rule_set::RULE_BASIC_CAVE | _ => "cellular_automata_basic",
        }
    }

    /// The main logic to generate a single chunk of data.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        info!("CA Generator: Starting chunk generation at {:?} with ruleset {}.", chunk_coords, self.ruleset);

        // Handle static patterns quickly without the iterative CA loop.
        if self.ruleset == RULE_SOLID || self.ruleset == RULE_CHECKERBOARD {
            warn!("CA Generator: Using static pattern ruleset ({}). Bypassing CA steps.", self.ruleset);
            return generate_static_pattern(chunk_coords, self.ruleset);
        }

        // --- Seeding for Determinism (Crypto Coded Memory) ---
        // Creates a unique, deterministic seed based on the chunk coordinates.
        let seed_x = chunk_coords.x as u64;
        let seed_y = chunk_coords.y as u64;
        // Use a large prime number for mixing (0x9e3779b97f4a7c15 is the golden ratio approximation)
        let seed = seed_x.wrapping_mul(0x9e3779b97f4a7c15).wrapping_add(seed_y);
        fastrand::seed(seed);
        info!("CA Generator: Seeded PRNG with deterministic value: {}.", seed);
        
        // --- Initialization ---
        let chunk_tile_size = CHUNK_SIZE as i64;
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size,
        );

        let dimension_name = self.id().to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);
        let mut tiles = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Initial randomization based on INITIAL_FILL_PERCENT
        for _ in 0..(CHUNK_SIZE * CHUNK_SIZE) {
            let random_val: u8 = fastrand::u8(0..100);
            let is_rock = random_val < INITIAL_FILL_PERCENT;

            let tile_type = if is_rock {
                TileType::Rock
            } else {
                TileType::Void
            };
            tiles.push(TileData::new(tile_type, 0.0));
        }
        chunk_data.insert_tiles(tiles);

        // --- Simulation Iterations ---
        for i in 0..CA_ITERATIONS {
            apply_ca_step(&mut chunk_data, self.ruleset);
            info!("CA Generator: Iteration {} complete.", i + 1);
        }

        warn!("CA Generator: Finished chunk at {:?}. Result is ready.", chunk_coords);
        chunk_data
    }
}
>>> FILE END: rust\ssxl_generate\src\cellular_automata_generator.rs <<<

======================================================
======================================================
// ssxl_generate/src/conductor.rs

//! The Conductor: Central command and control for the SSXL procedural generation runtime.
//!
//! The Conductor initializes all core components (runtime, cache, generators) and manages
//! the asynchronous request and progress channels, ensuring thread-safe, high-speed
//! world generation. This is the **Conductor Genesis** system.

use tokio::sync::mpsc::{self, Sender};
use tracing::{info, error};
use std::sync::{Arc, Mutex};
use std::io;

use ssxl_math::Vec2i;
use ssxl_cache::ChunkCache;
use ssxl_shared::chunk_data::ChunkData;
use ssxl_tools::get_config_from_path;

use crate::runtime_manager::RuntimeManager;
use crate::config_validator::{ConfigValidator, GeneratorConfig};
use crate::task_queue::{
    handle_chunk_unit, start_request_loop,
    GenerationTask as ChunkRequest, GenerationMessage,
};
pub use crate::conductor_state::{ConductorState, ConductorStatus};
use crate::generator_manager::GeneratorManager;
// Removed: use crate::Generator; // Resolved: Unused import warning.
use crate::batch_processor::spawn_batch_generation_task;

// --- 1. Channel Constants ---

/// Bound for the progress channel (Conductor -> External World). Generous buffer for status updates.
const PROGRESS_CHANNEL_BOUND: usize = 1024;
// Removed: const REQUEST_CHANNEL_BOUND: usize = 128; // Resolved: Constant was unused (channel is unbounded).

// --- 2. Conductor Structure ---

/// The core runtime manager and orchestrator for the SSXL Engine.
pub struct Conductor {
    /// Manages the Tokio asynchronous runtime.
    runtime_manager: RuntimeManager,
    /// Manages all registered procedural generation algorithms.
    generator_manager: GeneratorManager,
    /// Thread-safe state tracking (Status, Active Generator ID).
    internal_state: ConductorState,
    /// Thread-safe, in-memory cache for generated chunk data (The **crypto coded memory**).
    chunk_cache: Arc<Mutex<ChunkCache>>,
    /// Sender for progress updates (e.g., ChunkGenerated, GenerationComplete).
    progress_sender: Sender<GenerationMessage>,
    // Removed: request_sender field. // Resolved: This sender is returned to the caller for FFI use, so the Conductor itself does not need to store it.
}

impl Conductor {
    /// Initializes the entire SSXL generation runtime.
    ///
    /// This function sets up the Tokio runtime, the cache, the generators, and starts
    /// the main request processing loop on a background task.
    ///
    /// # Returns
    /// A tuple containing: (The Conductor itself, ConductorState for external monitoring,
    /// progress receiver, and the unbounded request sender).
    pub fn new(config_path: Option<&str>) -> Result<(Self, ConductorState, mpsc::Receiver<GenerationMessage>, mpsc::UnboundedSender<ChunkRequest>), io::Error> {
        
        // Load initial configuration
        let config = get_config_from_path(config_path)?;

        // Initialize the asynchronous runtime manager
        let runtime_manager = RuntimeManager::new()?;
        let handle = runtime_manager.get_handle();

        // Initialize generator manager and prepare map for sharing
        let generator_manager = GeneratorManager::new().map_err(|e| {
            io::Error::new(io::ErrorKind::Other, format!("Generator setup failed: {}", e))
        })?;
        let generators_for_loop = Arc::new(generator_manager.get_map_clone());

        // Initialize thread-safe chunk cache
        let chunk_cache = Arc::new(Mutex::new(ChunkCache::new().map_err(|e| {
            error!("Failed to initialize ChunkCache: {:?}", e);
            io::Error::new(io::ErrorKind::Other, format!("Cache initialization failed: {:?}", e))
        })?));
        let chunk_cache_for_loop = chunk_cache.clone();

        // Set up communication channels
        let (progress_sender, progress_receiver) = mpsc::channel(PROGRESS_CHANNEL_BOUND);
        let (request_sender, request_receiver) = mpsc::unbounded_channel(); // Unbounded for flexibility

        // Initialize state tracker
        let initial_id = generator_manager.get_initial_id(config.get_default_generator_id());
        let state = ConductorState::new(initial_id.clone());
        state.set_status(ConductorStatus::Running);
        let state_for_loop = state.clone();

        info!("Conductor initialized. Active generator: {}", initial_id);

        // Start the request processing loop on the Tokio runtime
        start_request_loop(
            handle,
            request_receiver,
            progress_sender.clone(),
            generators_for_loop,
            chunk_cache_for_loop,
            Arc::new(state_for_loop),
        );

        let conductor = Conductor {
            runtime_manager,
            generator_manager,
            internal_state: state.clone(),
            chunk_cache,
            progress_sender: progress_sender.clone(),
            // Removed 'request_sender: request_sender.clone(),'
        };

        // Return the conductor and the external interface components (state, receivers, senders)
        // The 'request_sender' is returned here for use by the external caller.
        Ok((conductor, state, progress_receiver, request_sender))
    }
    
    /// Returns the ID of the generator currently selected for use.
    pub fn get_active_generator_id(&self) -> String {
        self.internal_state.get_active_generator_id()
    }

    /// Starts a large, CPU-intensive batch generation task using `spawn_batch_generation_task`.
    ///
    /// This is the **bulldozer** operation, leveraging Rayon to generate chunks in parallel
    /// on a separate blocking thread pool to maintain the async core's **tempo**.
    pub fn start_generation(&mut self, config: GeneratorConfig) -> Result<(), Box<dyn std::error::Error>> {
        ConfigValidator::validate_map_dimensions(&config)?;

        self.set_active_generator(&config.generator_name)?;
        
        self.internal_state.set_status(ConductorStatus::Generating);

        // Spawn the batch task onto the blocking pool via the RuntimeManager's handle.
        spawn_batch_generation_task(
            &self.runtime_manager.get_handle(),
            self.generator_manager.get_map_clone(),
            self.chunk_cache.clone(),
            self.internal_state.get_active_generator_id(),
            self.progress_sender.clone(),
            self.internal_state.clone(),
            config,
        );

        Ok(())
    }

    /// Synchronously retrieves a single chunk's data, either from cache or by immediate generation.
    ///
    /// This uses a temporary channel to force a blocking wait for the result, making it
    /// suitable for external FFI calls that require an immediate return value.
    pub fn get_chunk_data(&self, chunk_coords: &Vec2i) -> ChunkData {
        let active_generator_id = self.internal_state.get_active_generator_id();

        // Create a temporary, tightly-bound MPSC channel for a one-shot request/response.
        let (temp_sender, mut temp_receiver) = mpsc::channel(1);

        // Run the chunk generation logic. It checks the cache first.
        handle_chunk_unit(
            *chunk_coords,
            &active_generator_id,
            self.generator_manager.get_map_ref(),
            &self.chunk_cache,
            &temp_sender, // Sender will send result back through this channel.
        );
        
        // Block the current thread and wait for the result from the temporary channel.
        match temp_receiver.blocking_recv() {
            Some(GenerationMessage::ChunkGenerated(_coords, chunk_data_arc)) => {
                // Attempt to unwrap the Arc if possible, otherwise clone the ChunkData.
                Arc::try_unwrap(chunk_data_arc).unwrap_or_else(|arc| (*arc).clone())
            },
            _ => {
                // If the channel closes or sends an unexpected message, panic.
                panic!("get_chunk_data failed to receive ChunkGenerated message.");
            }
        }
    }

    /// Sets the generator to be used for all future requests, if the ID is valid.
    pub fn set_active_generator(&mut self, id: &str) -> Result<(), String> {
        if self.generator_manager.get_map_ref().contains_key(id) {
            info!("Active generator set to: {}", id);
            self.internal_state.set_active_generator_id(id);
            Ok(())
        } else {
            let err = format!("Generator ID '{}' not found. Available IDs: {:?}", id, self.generator_manager.get_map_ref().keys());
            error!("{}", err);
            Err(err)
        }
    }

    /// Runs the generation process for a single chunk immediately, without cache check or channels.
    /// Used mainly for internal structural tests or single-run debug generation.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let active_id = self.internal_state.get_active_generator_id();
        self.generator_manager.generate_single_chunk(chunk_coords, &active_id)
    }

    /// Signals the Conductor's internal state that the batch generation task is complete.
    /// Sets status back to Running (Idle) after a batch generation is done.
    pub fn signal_generation_complete(&self) {
        info!("SSXL Conductor received GenerationComplete. Setting status to Running (Idle).");
        self.internal_state.set_status(ConductorStatus::Running);
    }
    
    /// Signals the Conductor's internal state that shutdown is beginning.
    pub fn signal_shutdown_graceful(&self) {
        info!("SSXL Conductor signaled for shutdown. Setting status to ShuttingDown.");
        self.internal_state.set_status(ConductorStatus::ShuttingDown);
    }

    /// Performs a full, graceful teardown of the entire runtime.
    pub fn graceful_teardown(self) {
        self.signal_shutdown_graceful();
        // The RuntimeManager handles shutting down the Tokio threads gracefully.
        self.runtime_manager.shutdown_graceful();
        info!("SSXL Conductor full teardown complete.");
    }
}
>>> FILE END: rust\ssxl_generate\src\conductor.rs <<<

======================================================
======================================================
// ssxl_generate/src/conductor_state.rs

//! Defines the ConductorState, which is the thread-safe, shared state of the SSXL engine.
//!
//! This structure provides real-time status, queue depth, and active generator tracking
//! for all components, functioning as the **crypto-coded memory** for the Conductor.

use tracing::error;
// Added AtomicU64 to support u64 return type for tile count
use std::sync::{Arc, Mutex, atomic::{AtomicUsize, AtomicU64, Ordering}};

// --- 1. Conductor Status Enum ---

/// Enumerates the operational states of the SSXL Conductor runtime.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConductorStatus {
    /// The runtime is starting up and initializing core components.
    Initializing,
    /// The runtime is fully operational and waiting for requests.
    Running,
    /// Request processing and generation are temporarily halted.
    Paused,
    /// A large batch generation task is actively running (**Bulldozer** mode).
    Generating,
    /// A graceful shutdown has been initiated.
    ShuttingDown,
    /// A critical, non-recoverable error has occurred.
    Error,
}

// --- 2. Conductor State Structure ---

/// Thread-safe structure holding the shared state for the Conductor and all worker threads.
#[derive(Clone)]
pub struct ConductorState {
    /// The current operational status. Protected by a Mutex as updates are infrequent.
    status: Arc<Mutex<ConductorStatus>>,
    /// The number of pending chunk generation requests. Uses AtomicUsize for efficient, lock-free updates.
    queue_depth: Arc<AtomicUsize>,
    /// The ID string of the currently selected generator. Protected by a Mutex.
    active_generator_id: Arc<Mutex<String>>,
    /// ⭐ **FIX:** The total number of tiles successfully placed during the current generation run.
    tile_counter: Arc<AtomicU64>,
}
#[allow(dead_code)]
impl ConductorState {
    /// Creates a new state instance, initialized to `Initializing`.
    pub fn new(initial_generator_id: String) -> Self {
        ConductorState {
            status: Arc::new(Mutex::new(ConductorStatus::Initializing)),
            queue_depth: Arc::new(AtomicUsize::new(0)),
            active_generator_id: Arc::new(Mutex::new(initial_generator_id)),
            tile_counter: Arc::new(AtomicU64::new(0)), // Initialize the new counter
        }
    }

    /// Retrieves the current operational status of the Conductor.
    /// Logs an error and returns `ConductorStatus::Error` if the mutex is poisoned.
    pub fn get_status(&self) -> ConductorStatus {
        match self.status.lock() {
            Ok(guard) => *guard,
            Err(e) => {
                error!("Mutex poisoned when reading status: {}", e);
                ConductorStatus::Error
            }
        }
    }
    
    /// Returns true if the Conductor is in a state where it can actively process or accept tasks.
    pub fn is_active(&self) -> bool {
        let current_status = self.get_status();
        current_status == ConductorStatus::Running || current_status == ConductorStatus::Generating
    }

    /// Retrieves the current depth (number of pending requests) of the task queue.
    /// Uses relaxed memory ordering for maximum **tempo**, as strict ordering isn't critical.
    pub fn get_queue_depth(&self) -> usize {
        self.queue_depth.load(Ordering::Relaxed)
    }

    /// ⭐ **FIX:** Retrieves the total number of tiles successfully placed.
    /// This resolves the need for `tile_count` access in the consumer crate.
    pub fn get_tiles_placed(&self) -> u64 {
        self.tile_counter.load(Ordering::Relaxed)
    }

    /// Retrieves the ID of the currently selected generator.
    pub fn get_active_generator_id(&self) -> String {
        // Using unwrap() assumes the Mutex will not be poisoned under normal engine operation.
        self.active_generator_id.lock().unwrap().clone()
    }

    /// Atomically increases the queue depth count. Used when a new task is posted.
    pub fn increment_queue_depth(&self) {
        self.queue_depth.fetch_add(1, Ordering::Relaxed);
    }

    /// Atomically decreases the queue depth count. Used after a task is completed.
    pub fn decrement_queue_depth(&self) {
        // Note: fetch_sub handles underflow if used incorrectly, but should typically remain >= 0.
        self.queue_depth.fetch_sub(1, Ordering::Relaxed);
    }
    
    /// ⭐ **FIX:** Atomically increases the tile count by the specified amount.
    /// Used by worker threads after placing a batch of tiles.
    pub(crate) fn increment_tile_count(&self, amount: u64) {
        self.tile_counter.fetch_add(amount, Ordering::Relaxed);
    }

    /// Updates the operational status. Only visible within the `ssxl_generate` crate.
    pub(crate) fn set_status(&self, new_status: ConductorStatus) {
        *self.status.lock().unwrap() = new_status;
    }

    /// Updates the active generator ID string. Only visible within the `ssxl_generate` crate.
    pub(crate) fn set_active_generator_id(&self, id: &str) {
        *self.active_generator_id.lock().unwrap() = id.to_string();
    }
}
>>> FILE END: rust\ssxl_generate\src\conductor_state.rs <<<

======================================================
======================================================
// ssxl_generate/config_validator.rs

//! Contains the structural definition for batch generation requests and the
//! logic for validating user-defined map dimensions against engine limits.
//!
//! This ensures stability and prevents excessive memory usage during large-scale
//! **Bulldozer** generation tasks.

use tracing::{error, info};
use std::fmt;

/// The canonical size of a chunk in tiles, used for dimension conversion.
/// (Local definition for validation, typically sourced from ssxl_shared).
const CHUNK_SIZE: i64 = 64;

/// The hard safety limit on the total number of chunks allowed to be generated
/// or held in active memory to prevent system overload.
const MAX_ACTIVE_CHUNKS: i64 = 100_000_000;

// --- 1. Configuration Data Structure ---

/// Configuration parameters defining a single batch world generation request.
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    /// Desired world width in tiles.
    pub width: usize,
    /// Desired world height in tiles.
    pub height: usize,
    /// The deterministic seed string for the generation process (**Crypto-coded memory**).
    pub seed: String,
    /// The ID of the generator to execute (e.g., 'cellular_automata_basic').
    pub generator_name: String,
}

impl fmt::Display for GeneratorConfig {
    /// Implements display for easy logging and error reporting.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ Width: {}, Height: {}, Seed: '{}', Generator: '{}' }}",
            self.width, self.height, self.seed, self.generator_name
        )
    }
}

// --- 2. Validation Logic ---

/// Utility struct containing static methods for validating generator configurations.
pub struct ConfigValidator;

impl ConfigValidator {
    /// Validates that the requested map dimensions (width, height) are sane and
    /// do not exceed the `MAX_ACTIVE_CHUNKS` limit.
    ///
    /// This step is crucial for maintaining system **balance** and ensuring project **completion**.
    ///
    /// # Arguments
    /// * `config`: The generation request parameters.
    ///
    /// # Returns
    /// `Ok(())` if validation passes, or `Err(String)` with an error message otherwise.
    pub fn validate_map_dimensions(config: &GeneratorConfig) -> Result<(), String> {
        info!("Validating batch generation command with config: {}", config);

        let chunk_size_i64 = CHUNK_SIZE;

        // Calculate world size in chunks (uses integer division ceiling trick for partial chunks).
        let width_in_chunks = (config.width as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let height_in_chunks = (config.height as i64 + chunk_size_i64 - 1) / chunk_size_i64;
        let total_chunks = width_in_chunks * height_in_chunks;

        // Validation Check 1: Must generate at least one chunk.
        if total_chunks <= 0 {
            let error_msg = format!(
                "Validation Failed: Calculated chunk count is zero for size {}x{}. Dimensions are too small.",
                config.width, config.height
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        // Validation Check 2: Must not exceed the safety limit.
        if total_chunks > MAX_ACTIVE_CHUNKS {
            let error_msg = format!(
                "Validation Failed: Max chunks limit exceeded. Requested {} chunks ({}x{}) but the limit is {}. Adjust MAX_ACTIVE_CHUNKS or reduce map size.",
                total_chunks, width_in_chunks, height_in_chunks, MAX_ACTIVE_CHUNKS
            );
            error!("{}", error_msg);
            return Err(error_msg);
        }

        info!(
            "Validation Passed: Map size is {}x{} chunks (Total: {}). Starting **Bulldozer** operation.",
            width_in_chunks, height_in_chunks, total_chunks
        );
        Ok(())
    }
}
>>> FILE END: rust\ssxl_generate\src\config_validator.rs <<<

======================================================
======================================================
// ssxl_generate/src/generator.rs
//! Defines the core Generator trait, the contract for all procedural generation algorithms.
//!
//! Any module (e.g., CellularAutomataGenerator, PerlinGenerator) intended to be managed
//! by the GeneratorManager and executed by the Conductor must implement this trait.

use ssxl_shared::chunk_data::ChunkData;

use ssxl_math::Vec2i;

/// The fundamental trait for all world generation algorithms in the SSXL Engine.
///
/// This contract ensures that all generators can be treated uniformly by the
/// Conductor runtime, maintaining the engine's modularity and high **tempo**.
#[allow(dead_code)] // The trait itself isn't used directly, but its implementors are.
pub trait Generator {
    /// Returns a unique, static string identifier for this specific generator instance.
    ///
    /// This ID is used by the Conductor to select the active generation strategy
    /// and should be unique across all registered generators.
    fn id(&self) -> &str;

    /// Executes the generation algorithm for a single chunk at the specified coordinates.
    ///
    /// The implementation must be **deterministic** and **self-contained**, relying only on
    /// the chunk coordinates and internal seed/ruleset to produce the `ChunkData`.
    ///
    /// # Arguments
    /// * `chunk_coords`: The global coordinate (X, Y) of the chunk to generate.
    ///
    /// # Returns
    /// The fully generated `ChunkData` structure.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}
>>> FILE END: rust\ssxl_generate\src\generator.rs <<<

======================================================
======================================================
// ssxl_generate/generator_manager.rs

//! The GeneratorManager acts as a registry for all available procedural generation algorithms.
//!
//! It initializes concrete generator types (Perlin, Cellular Automata) and stores them
//! as trait objects, enabling the Conductor to select and execute any generator by ID.

use tracing::{info, warn};
use std::collections::HashMap;
use std::sync::Arc;

use ssxl_math::Vec2i;
use ssxl_shared::chunk_data::ChunkData;

use crate::Generator;
use crate::perlin_generator::PerlinGenerator;
use crate::cellular_automata_generator::CellularAutomataGenerator;

use crate::ca::rule_set::{
    RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD,
};

/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
/// This allows the HashMap to store different generator types uniformly.
pub type DynGenerator = Box<dyn Generator + Send + Sync>;

// --- 1. Manager Structure ---

/// Manages and provides access to all initialized generation algorithms.
pub struct GeneratorManager {
    /// The core registry: Maps generator ID strings to thread-safe generator instances.
    generators: HashMap<String, Arc<DynGenerator>>,
    /// The ID of the default Perlin noise generator, used as a fallback.
    default_perlin_id: String,
}

impl GeneratorManager {
    /// Initializes all generator algorithms and registers them in the HashMap.
    ///
    /// This is the "Dimension Registry" initialization, setting up all available
    /// generation **experiments**.
    pub fn new() -> Result<Self, String> {
        let mut generators: HashMap<String, Arc<DynGenerator>> = HashMap::new();
        
        // 1. Register Perlin Generator (The base noise layer)
        let perlin: DynGenerator = Box::new(PerlinGenerator::new(64.0));
        let default_perlin_id = perlin.id().to_string();
        // Wrap in Arc for thread-safe sharing with worker tasks.
        generators.insert(default_perlin_id.clone(), Arc::new(perlin));
        
        // 2. Register Cellular Automata Generators (The structured content layers)
        let ca_generators = [RULE_BASIC_CAVE, RULE_MAZE, RULE_SOLID, RULE_CHECKERBOARD];
        for rule in ca_generators.iter().cloned() {
            let gen: DynGenerator = Box::new(CellularAutomataGenerator::new(rule));
            generators.insert(gen.id().to_string(), Arc::new(gen));
        }

        info!("Registered {} generator algorithms.", generators.len());

        Ok(GeneratorManager { generators, default_perlin_id })
    }

    /// Returns a reference to the internal generator map.
    /// Used by the Conductor for immediate, local lookups.
    pub fn get_map_ref(&self) -> &HashMap<String, Arc<DynGenerator>> {
        &self.generators
    }

    /// Returns a clone of the internal generator map.
    /// Used when spawning new background tasks that need to own a map copy (e.g., the Request Loop).
    pub fn get_map_clone(&self) -> HashMap<String, Arc<DynGenerator>> {
        self.generators.clone()
    }
    
    /// Executes the generation process for a single chunk using the specified active generator ID.
    ///
    /// Used primarily by the Conductor for synchronous, single-chunk requests.
    pub fn generate_single_chunk(&self, chunk_coords: Vec2i, active_id: &str) -> ChunkData {
        let generator_arc = self.generators
            .get(active_id)
            // Panic is appropriate here as the generator ID should have been validated previously.
            .unwrap_or_else(|| panic!("Cannot find active generator with ID: {}", active_id));

        // Dereference the Arc<DynGenerator> and call the trait method.
        generator_arc.generate_chunk(chunk_coords)
    }

    /// Determines the initial active generator ID, prioritizing the config ID and falling back to default Perlin.
    pub fn get_initial_id(&self, config_id: &str) -> String {
        if self.generators.contains_key(config_id) {
            config_id.to_string()
        } else {
            warn!("Config default generator ID '{}' not found. Falling back to Perlin: {}", config_id, self.default_perlin_id);
            self.default_perlin_id.clone()
        }
    }
}
>>> FILE END: rust\ssxl_generate\src\generator_manager.rs <<<

======================================================
======================================================
// ssxl_generate/src/lib.rs

//! The core library crate for the SSXL procedural generation engine.
//!
//! This crate orchestrates the asynchronous runtime, manages generator algorithms,
//! and provides the central Conductor API for world creation.

use ssxl_shared::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use tracing::{info, error};

// --- 1. Internal Module Definitions ---

/// Core command and control center for the generation engine.
pub mod conductor;
/// Logic for stress-testing and profiling generator algorithms.
pub mod benchmark_logic;
/// Perlin noise based generator implementation.
pub mod perlin_generator;
/// Cellular Automata based generator implementation.
pub mod cellular_automata_generator;
/// Module containing Cellular Automata specific rules and utilities.
pub mod ca; 
/// Manages the Tokio asynchronous runtime.
pub mod runtime_manager; 
/// Utilities for validating generation request configurations.
pub mod config_validator;
/// Manages the asynchronous chunk generation task queue.
pub mod task_queue;
/// Thread-safe state tracking for the Conductor.
pub mod conductor_state;
/// Registry for all available generation algorithms.
pub mod generator_manager;
/// Logic for processing large batch generation requests (**Bulldozer** operation).
pub mod batch_processor;
/// Module for synchronous types used for external communication (Senders/Receivers).
pub mod sync; 


// --- 2. Core Generator Trait Definition ---

/// The fundamental contract for all world generation algorithms.
/// (Duplicated here from `generator.rs` for convenience and to define the public contract).
pub trait Generator {
    /// Returns a unique, static string identifier for this generator.
    fn id(&self) -> &str;

    /// Executes the deterministic generation algorithm for a single chunk.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData;
}


// --- 3. Public API Exports (Re-exports for external use) ---

// Concrete Generator implementations
pub use cellular_automata_generator::CellularAutomataGenerator;
pub use perlin_generator::PerlinGenerator;

// Conductor and Configuration Types
pub use conductor::Conductor;
pub use config_validator::GeneratorConfig; 

// Synchronization and Task Types (For FFI and API integration)
pub use sync::ConductorProgressReceiver;
pub use sync::ConductorRequestSender;
pub use task_queue::GenerationTask; 

// Benchmark Utility
pub use benchmark_logic::benchmark_generation_workload;


// --- 4. Initialization Placeholder (Example/Debug) ---

/// A placeholder function to test Conductor initialization and immediate graceful shutdown.
/// This simulates a quick external call to verify runtime setup and teardown.
pub fn start_runtime_placeholder() {
    match Conductor::new(None) {
        Ok((conductor, _state, _progress_receiver, _request_sender)) => {
            info!("Runtime created successfully. Testing immediate graceful teardown...");
            
            // Execute the cleanup logic
            conductor.graceful_teardown();
        }
        Err(e) => {
            error!("Failed to initialize Conductor/Runtime: {:?}", e);
        }
    }
}
>>> FILE END: rust\ssxl_generate\src\lib.rs <<<

======================================================
======================================================
// ssxl_generate/src/perlin_generator.rs

//! Implements the Generator trait using the Perlin noise function.
//!
//! This provides the engine's primary continuous, organic generation layer,
//! mapping noise values to different TileTypes based on a fixed threshold.

use crate::Generator;
use ssxl_shared::chunk_data::{ChunkData, CHUNK_SIZE};
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_math::Vec2i;
use ssxl_shared::tile_data::TileData;
use ssxl_shared::tile_type::TileType;

use noise::{NoiseFn, Perlin};
use tracing::info;

// --- 1. Generator Structure ---

/// A generator that uses the Perlin noise algorithm to create deterministic terrain.
pub struct PerlinGenerator {
    /// The noise object instance, which is thread-safe and deterministic based on its seed.
    perlin: Perlin,
    /// The scaling factor applied to world coordinates before generating noise.
    /// A smaller scale results in larger, smoother features.
    scale: f64,
}

impl PerlinGenerator {
    /// Creates a new PerlinGenerator instance.
    ///
    /// # Arguments
    /// * `scale`: The frequency/scale of the noise (e.g., 64.0).
    pub fn new(scale: f64) -> Self {
        // NOTE: Default seed is currently hardcoded for deterministic, repeatable generation.
        const DEFAULT_SEED: u32 = 42;
        
        PerlinGenerator {
            perlin: Perlin::new(DEFAULT_SEED),
            scale,
        }
    }
}

// --- 2. Generator Trait Implementation ---

impl Generator for PerlinGenerator {
    /// Returns the unique identifier for this generator.
    fn id(&self) -> &str {
        "perlin_basic_2d"
    }

    /// Generates a single chunk based on the Perlin noise field.
    ///
    /// The logic is: 1) Convert chunk coordinates to world tile coordinates,
    /// 2) Sample the Perlin function, 3) Map the noise value to a `TileType`.
    fn generate_chunk(&self, chunk_coords: Vec2i) -> ChunkData {
        let chunk_tile_size = CHUNK_SIZE as i64;

        // Calculate the world coordinate of the chunk's bottom-left corner.
        let world_start_x = chunk_coords.x * chunk_tile_size;
        let world_start_y = chunk_coords.y * chunk_tile_size;

        // Create a unique Chunk ID by packing the 2D coordinates into a 64-bit integer.
        let chunk_id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);

        // Define the world bounds covered by this chunk.
        let bounds = GridBounds::new(
            world_start_x,
            world_start_y,
            world_start_x + chunk_tile_size,
            world_start_y + chunk_tile_size
        );

        let dimension_name = "2D_Noise".to_string();

        let mut chunk_data = ChunkData::new(chunk_id, bounds, dimension_name);

        // Pre-allocate vector to hold all tile data for the chunk.
        let mut tiles: Vec<TileData> = Vec::with_capacity((CHUNK_SIZE * CHUNK_SIZE) as usize);

        // Iterate through all tiles within the chunk.
        for y in 0..chunk_tile_size {
            for x in 0..chunk_tile_size {
                let world_x = (world_start_x + x) as f64;
                let world_y = (world_start_y + y) as f64;

                // Sample the Perlin noise function. Coordinates are scaled down.
                let noise_value = self.perlin.get([world_x / self.scale, world_y / self.scale]);

                // Perlin output is typically [-1.0, 1.0]. Normalize to [0.0, 1.0].
                let normalized_value = (noise_value + 1.0) / 2.0;

                // Thresholding: Map the noise value to a concrete TileType (Water, Grass, Mountain).
                let tile_type = if normalized_value < 0.35 {
                    TileType::Water
                } else if normalized_value < 0.60 {
                    TileType::Grass
                } else {
                    TileType::Mountain
                };

                // Create the TileData, storing the raw noise value as metadata (useful for blending/details).
                let tile = TileData::new(tile_type, normalized_value as f32);
                tiles.push(tile);
            }
        }

        // Insert the generated tile array into the chunk data structure.
        chunk_data.insert_tiles(tiles);

        info!(
            "MVG generated Chunk {:?} using Perlin ({} tiles processed)",
            chunk_coords,
            (CHUNK_SIZE * CHUNK_SIZE)
        );

        chunk_data
    }
}
>>> FILE END: rust\ssxl_generate\src\perlin_generator.rs <<<

======================================================
======================================================
// ssxl_generate/src/runtime_manager.rs

//! Manages the Tokio asynchronous runtime for the SSXL generation engine.
//!
//! The RuntimeManager is responsible for initializing the multi-threaded
//! runtime, providing handles to worker threads, and coordinating a graceful shutdown,
//! ensuring the highest possible **tempo** for asynchronous operations.

use tokio::runtime::{Runtime, Handle};
use tracing::info;
use num_cpus;
use std::io;

/// Manages the lifecycle of the underlying Tokio asynchronous runtime.
pub struct RuntimeManager {
    /// The core Tokio multi-threaded runtime instance.
    runtime: Runtime,
}

impl RuntimeManager {
    /// Initializes a new multi-threaded Tokio runtime.
    ///
    /// The runtime is configured to use the same number of worker threads as the
    /// machine's logical CPU cores, maximizing parallelism for generation tasks.
    pub fn new() -> Result<Self, io::Error> {
        let num_cores = num_cpus::get();
        info!("Tokio Runtime initializing with {} worker threads (all logical cores).", num_cores);

        let runtime = tokio::runtime::Builder::new_multi_thread()
            // Set worker count to the number of logical cores.
            .worker_threads(num_cores)
            // Enable all features (timers, I/O) for general utility.
            .enable_all()
            .build()?;
            
        Ok(RuntimeManager { runtime })
    }

    /// Returns a clone of the runtime's handle.
    ///
    /// This handle is used by the **Conductor** to spawn new asynchronous tasks
    /// and to execute CPU-heavy tasks on the dedicated blocking thread pool.
    pub fn get_handle(&self) -> Handle {
        self.runtime.handle().clone()
    }

    /// Signals the Tokio runtime to begin a graceful shutdown in the background.
    ///
    /// This allows all remaining tasks to complete their current work before the
    /// threads are finally torn down.
    pub fn shutdown_graceful(self) {
        info!("Tokio Runtime signaling graceful shutdown.");
        // This method instructs the runtime to shut down without blocking the current thread.
        self.runtime.shutdown_background();
        info!("Tokio Runtime full teardown complete.");
    }
}
>>> FILE END: rust\ssxl_generate\src\runtime_manager.rs <<<

======================================================
======================================================
// ssxl_generate/src/sync.rs

//! Defines public type aliases for synchronization primitives used to communicate
//! with the Conductor from external systems (like FFI wrappers).
//!
//! This module simplifies the public API by wrapping complex Tokio channel types.

use tokio::sync::mpsc;
use crate::task_queue::GenerationMessage;
use crate::task_queue::GenerationTask;

// --- Public Synchronization Type Aliases ---

/// An unbounded sender for posting new chunk generation requests to the Conductor's task queue.
///
/// This is the primary input channel for the SSXL generation engine, allowing users to
/// queue up work (`GenerationTask`) without blocking.
pub type ConductorRequestSender = mpsc::UnboundedSender<GenerationTask>;

/// The receiver for all progress updates and completion messages from the Conductor.
///
/// This channel delivers structured updates (`GenerationMessage`) such as `ChunkGenerated`
/// and `GenerationComplete` back to the external caller.
pub type ConductorProgressReceiver = mpsc::Receiver<GenerationMessage>;
>>> FILE END: rust\ssxl_generate\src\sync.rs <<<

======================================================
======================================================
// ssxl_generate/src/task_queue.rs

//! Manages the asynchronous request loop for chunk generation and the core logic
//! for handling a single chunk request (cache check, generation, and storage).

use tokio::runtime::Handle;
use tokio::sync::mpsc;
use tracing::{info, error, warn};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

use glam::I64Vec3;
use ssxl_math::{Vec2i, prelude::ChunkKey};

use ssxl_cache::ChunkCache;
use crate::Generator;
use crate::conductor_state::ConductorState;

use ssxl_shared::chunk_data::ChunkData;
// Import the canonical size from ssxl_shared and cast it locally for coordinate math.
use ssxl_shared::config::CHUNK_SIZE as SHARED_CHUNK_SIZE;
pub use ssxl_shared::generation_message::{GenerationMessage, GenerationTask};


/// Type alias for a thread-safe, dynamically dispatched Generator trait object.
type DynGenerator = Box<dyn Generator + Send + Sync>;

/// Canonical chunk size in i64 format for coordinate math.
pub const CHUNK_SIZE: i64 = SHARED_CHUNK_SIZE as i64;


// --- 1. Single Chunk Processing Unit ---

/// The atomic unit of work for chunk generation.
///
/// This synchronous function performs the cache lookup, calls the generator if needed,
/// saves the result to the cache, and sends a completion message.
///
/// **Crucially, this must be run on a blocking thread pool (e.g., via `spawn_blocking`)
/// because generator functions are CPU-intensive and synchronous.**
pub fn handle_chunk_unit(
    chunk_coords: Vec2i,
    generator_name: &str,
    generators: &HashMap<String, Arc<DynGenerator>>,
    chunk_cache: &Arc<Mutex<ChunkCache>>,
    progress_sender: &mpsc::Sender<GenerationMessage>,
) {
    let key_vec3 = I64Vec3::new(chunk_coords.x, chunk_coords.y, 0);
    let chunk_key = ChunkKey(key_vec3);
    let chunk_data: ChunkData;

    // Attempt to acquire the lock for the chunk cache
    match chunk_cache.lock() {
        Ok(cache_lock) => { // <-- REMOVED `mut` HERE
            // 1. Check Cache (Crypto-coded memory)
            match cache_lock.load_chunk(&chunk_key) {
                Ok(Some(data)) => {
                    info!("Chunk Unit: Retrieved chunk {:?} from cache (Gen: {}).", chunk_coords, generator_name);
                    chunk_data = data;
                },
                Ok(None) => {
                    // 2. Generate if Cache Miss
                    info!("Chunk Unit: Chunk {:?} not found in cache. Generating with {}.", chunk_coords, generator_name);
                    let generator_arc = generators
                        .get(generator_name)
                        .expect("Generator ID must be registered in Conductor.");
                    
                    chunk_data = generator_arc.generate_chunk(chunk_coords);
                    
                    // 3. Save to Cache
                    if let Err(e) = cache_lock.save_chunk(&chunk_key, &chunk_data) {
                        error!("Chunk Unit: Failed to save chunk {:?} to cache: {:?}", chunk_coords, e);
                    } else {
                        info!("Chunk Unit: Saved chunk {:?} to cache.", chunk_coords);
                    }
                },
                Err(e) => {
                    // Cache system error, generate without caching
                    warn!("Chunk Unit: Cache load failed for {:?}: {:?}. Falling back to generation without caching.", chunk_coords, e);
                    let generator_arc = generators
                        .get(generator_name)
                        .expect("Generator ID must be registered in Conductor.");
                    chunk_data = generator_arc.generate_chunk(chunk_coords);
                }
            }
        },
        Err(e) => {
            // Cache Mutex Poisoned: Indicates a critical, unrecoverable state. Generate without caching.
            error!("Chunk Unit: Cache Mutex poisoned: {}. Falling back to generation without caching.", e);
            let generator_arc = generators
                .get(generator_name)
                .expect("Generator ID must be registered in Conductor.");
            chunk_data = generator_arc.generate_chunk(chunk_coords);
        }
    }
    
    // 4. Send Completion/Progress Message
    let chunk_data_arc = Arc::new(chunk_data);
    
    // Use blocking_send as this function is already running on a blocking thread.
    if let Err(e) = progress_sender.blocking_send(
        GenerationMessage::ChunkGenerated(chunk_coords, chunk_data_arc)
    ) {
        error!("Chunk Unit: Failed to send ChunkGenerated message for {:?}: {:?}", chunk_coords, e);
    }
}


// --- 2. Asynchronous Request Loop ---

/// Spawns the main request processing loop onto the Tokio runtime handle.
///
/// This loop listens for new generation tasks and offloads the synchronous work
/// to the dedicated `tokio::task::spawn_blocking` thread pool, maintaining the
/// asynchronous core's **tempo**.
pub fn start_request_loop(
    rt_handle: Handle,
    mut request_rx: mpsc::UnboundedReceiver<GenerationTask>,
    progress_tx: mpsc::Sender<GenerationMessage>,
    generators: Arc<HashMap<String, Arc<DynGenerator>>>,
    chunk_cache: Arc<Mutex<ChunkCache>>,
    conductor_state: Arc<ConductorState>,
) {
    rt_handle.spawn(async move {
        info!("Generation Task Queue active. Listening for requests.");
        
        // Loop while the sender side of the channel is open.
        while let Some(task) = request_rx.recv().await {
            // Check Conductor State (Pause/Shutdown)
            if !conductor_state.as_ref().is_active() { 
                warn!("Request received while Conductor is paused or shutting down. Dropping task: {:?}", task.chunk_coords);
                // Decrement queue depth is omitted here as it's assumed to be handled by the caller/request loop logic elsewhere.
                continue;
            }

            // Prepare thread-safe clones for the blocking task
            let progress_tx_clone = progress_tx.clone();
            let generators_clone = generators.clone();
            let chunk_cache_clone = chunk_cache.clone();

            // Offload CPU-intensive work to the dedicated blocking thread pool.
            tokio::task::spawn_blocking(move || {
                handle_chunk_unit(
                    task.chunk_coords,
                    &task.generator_id,
                    &generators_clone,
                    &chunk_cache_clone,
                    &progress_tx_clone,
                );
            });
        }
        
        // Loop exited (sender was dropped), signifying engine shutdown.
        info!("Generation Task Queue shutting down.");
        // FIX: Replaced illegal blocking call with the correct asynchronous send.
        if progress_tx.send(GenerationMessage::GenerationComplete).await.is_err() { 
            error!("Failed to send final GenerationComplete message.");
        }
    });
}
>>> FILE END: rust\ssxl_generate\src\task_queue.rs <<<

======================================================
======================================================
// ssxl_generate/src/ca/mod.rs

//! Core module for the Cellular Automata (CA) generation algorithms.
//!
//! This logic is used by the `CellularAutomataGenerator` to simulate environment
//! growth (e.g., cave systems, walls, and borders) based on local neighborhood rules.
//! This module provides the tools necessary to enforce a state-based system
//! for structured, yet emergent, world design.

// --- Sub-Modules ---

/// Defines the specific CA rules (e.g., Survival and Birth rules like 4/5).
/// This module abstracts the core generation logic, allowing for easy experimentation
/// and swapping of different CA rule sets to achieve diverse world patterns.
pub mod rule_set;

/// Contains logic for checking a cell's immediate surroundings and calculating
/// the neighbor count based on the current state. This is the low-level
/// component that feeds the local state into the `rule_set`.
pub mod neighbor_check;
>>> FILE END: rust\ssxl_generate\src\ca\mod.rs <<<

======================================================
======================================================
// ssxl_generate/src/neighbor_check.rs

use ssxl_shared::{
    chunk_data::{ChunkData, CHUNK_SIZE},
    tile_type::TileType,
};

/// Counts the number of "live" (TileType::Rock) neighbors in the 3x3 Moore neighborhood
/// surrounding a specific cell within a chunk.
///
/// This function handles boundary conditions, ensuring checks do not exceed the
/// chunk's borders (0 to CHUNK_SIZE - 1). It is crucial for the tempo and accuracy
/// of the Cellular Automata simulation.
///
/// # Arguments
/// * `chunk_data`: The data structure containing the chunk's tiles.
/// * `cx`: The X coordinate of the center cell (0 to CHUNK_SIZE - 1).
/// * `cy`: The Y coordinate of the center cell (0 to CHUNK_SIZE - 1).
///
/// # Returns
/// The count of live neighbors (0-8).
pub fn count_live_neighbors(chunk_data: &ChunkData, cx: u32, cy: u32) -> u8 {
    let mut count = 0;

    // Iterate through the 3x3 Moore neighborhood relative to the center cell (cx, cy).
    for dx in -1..=1 {
        for dy in -1..=1 {
            // 1. Exclude the center cell itself (self-exclusion).
            if dx == 0 && dy == 0 {
                continue;
            }

            // Calculate the neighbor's absolute coordinates.
            let nx = cx as i32 + dx;
            let ny = cy as i32 + dy;

            // 2. Perform boundary checks. Ensure the neighbor is within the chunk's bounds.
            if nx >= 0 && nx < CHUNK_SIZE as i32 && ny >= 0 && ny < CHUNK_SIZE as i32 {
                // Convert valid (nx, ny) coordinates back to the 1D array index.
                let index = (ny as u32 * CHUNK_SIZE + nx as u32) as usize;

                // 3. Check for the "live" state, defined as TileType::Rock.
                if chunk_data.tiles[index].tile_type == TileType::Rock {
                    count += 1;
                }
            }
        }
    }
    count
}
>>> FILE END: rust\ssxl_generate\src\ca\neighbor_check.rs <<<

======================================================
======================================================
// ssxl_generate/src/ca/rule_set.rs
use ssxl_shared::tile_type::TileType;

// --- 1. Rule Set Identifiers ---

/// Identifier for the standard cave generation ruleset (B4-5/S1-7).
pub const RULE_BASIC_CAVE: u8 = 0;
/// Identifier for the maze-like generation ruleset (B3/S1-4).
pub const RULE_MAZE: u8 = 1;
/// Placeholder/future rule for generating a solid block.
pub const RULE_SOLID: u8 = 2;
/// Placeholder/future rule for generating a checkerboard pattern.
pub const RULE_CHECKERBOARD: u8 = 3;

// --- 2. Core Rule Application Function ---

/// Determines the next state of a tile based on the current state, live neighbor count, and a specific ruleset.
///
/// This implements the standard Birth/Survival (B/S) rules for cellular automata.
///
/// # Arguments
/// * `current_type`: The tile's state at the current CA iteration (Void or Rock).
/// * `live_neighbors`: The count of surrounding `TileType::Rock` tiles (0-8).
/// * `ruleset`: The identifier defining the B/S parameters to use.
///
/// # Returns
/// The tile's state for the next CA iteration.
pub fn get_next_tile_type(current_type: TileType, live_neighbors: u8, ruleset: u8) -> TileType {

    // Define the specific Birth (B) and Survival (S) parameters based on the ruleset ID.
    // Bx-y: Tile will be born (become Rock) if live_neighbors is in range [x, y] and current state is Void.
    // Sx-y: Tile will survive (remain Rock) if live_neighbors is in range [x, y] and current state is Rock.
    let (birth_min, birth_max, survive_min, survive_max) = match ruleset {
        RULE_MAZE => (3, 3, 1, 4),               // B3/S1-4 (Favors thin, complex structures with few dead ends)
        RULE_BASIC_CAVE | _ => (4, 5, 1, 7),     // B4-5/S1-7 (Favors large, open, robust cave systems)
    };

    match current_type {
        // --- Survival Check: If the tile is currently Rock (alive) ---
        TileType::Rock => {
            if live_neighbors >= survive_min && live_neighbors <= survive_max {
                // Within survival range: Rock survives.
                TileType::Rock
            } else {
                // Outside survival range: Rock dies (becomes Void).
                TileType::Void
            }
        }
        // --- Birth Check: If the tile is currently Void (dead) ---
        TileType::Void => {
            if live_neighbors >= birth_min && live_neighbors <= birth_max {
                // Within birth range: Void becomes Rock (birth).
                TileType::Rock
            } else {
                // Outside birth range: Void remains Void.
                TileType::Void
            }
        }
        // Handle any other TileTypes outside the CA simulation (e.g., Water, Ore) by leaving them unchanged.
        _ => current_type,
    }
}
>>> FILE END: rust\ssxl_generate\src\ca\rule_set.rs <<<

======================================================
======================================================
# ssxl_godot/Cargo.toml

[package]
name = "ssxl_godot"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_generate = { path = "../ssxl_generate" }
ssxl_sync = { path = "../ssxl_sync", features = ["godot-bindings"] }
# --- EXTERNAL DEPENDENCIES ---

# CORE GDExtension BINDINGS
godot = { workspace = true }
godot-ffi = { workspace = true }
# Workspace standard logging framework
tracing = { workspace = true }
tokio = { workspace = true }
rand = { workspace = true }

###############################################################
# REQUIRED FIX FOR GDExtension LINKER ERROR (E0127)
###############################################################
[lib]
crate-type = ["cdylib"]
name = "ssxl_engine"
# The name "ssxl_engine" forces the creation of 
# 'ssxl_engine.dll' in the target directory,
# which Godot expects to find via the .gdextension file.
>>> FILE END: rust\ssxl_godot\Cargo.toml <<<

======================================================
======================================================
// ssxl_godot/src/animation_api.rs (CLEANED)

//!
//! Provides the public API interface for Godot to interact with the
//! asynchronous **Animation Conductor**.
//!
//! This adapter is responsible for:
//! 1. Translating Godot calls into structured `AnimationCommand` messages.
//! 2. Synchronously retrieving generated `ChunkData` from the main **Conductor**.
//! 3. Sending chunk data and commands to the animation worker thread for visual updates.

use godot::classes::{Node, TileMap};
use godot::obj::Gd;

use std::sync::{Arc, Mutex};
use tracing::{info, error, warn};

use ssxl_generate::Conductor;
use ssxl_math::Vec2i;
use ssxl_sync::{AnimationConductorHandle, AnimationCommand};


// -----------------------------------------------------------------------------
// 1. API Structure
// -----------------------------------------------------------------------------

/// The Godot API layer for controlling the background animation processing thread.
///
/// It holds non-owning, bounded references (`'a`) to the essential Conductor handles.
#[derive(Default)]
pub struct AnimationAPI<'a> {
    /// Handle used to send commands to the Animation Conductor (responsible for frame updates).
    animation_conductor: Option<&'a AnimationConductorHandle>,
    /// Thread-safe reference to the main Generation Conductor (used to retrieve completed chunk data).
    _conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

impl<'a> AnimationAPI<'a> {
    /// Constructs a new AnimationAPI, setting the internal references upon initialization.
    pub fn new(
        animation_conductor: Option<&'a AnimationConductorHandle>,
        conductor: Option<&'a Arc<Mutex<Conductor>>>,
    ) -> Self {
        AnimationAPI {
            animation_conductor,
            _conductor: conductor,
        }
    }


    // -------------------------------------------------------------------------
    // 2. High-Level Command Mapping (FIX APPLIED HERE)
    // -------------------------------------------------------------------------

    /// Receives a string command from Godot and maps it to the appropriate `AnimationCommand` enum.
    /// This provides a flexible entry point for custom scripting.
    pub fn send_command_by_name(&self, command_name: String) {
        if let Some(handle) = self.animation_conductor {
            let command = match command_name.as_str() {
                "StartTestAnimation" => {
                    info!("AnimationAPI: Mapping to StartTestAnimation command.");
                    AnimationCommand::StartTestAnimation
                },
                "StopTestAnimation" => {
                    info!("AnimationAPI: Mapping to StopTestAnimation command.");
                    AnimationCommand::StopTestAnimation
                },
                // FIX: Map the Godot API strings to the core AnimationCommand variants
                "ANIMATION_ENABLE" => {
                    info!("AnimationAPI: Mapping to Start command (ENABLE).");
                    AnimationCommand::Start
                },
                "ANIMATION_DISABLE" => {
                    info!("AnimationAPI: Mapping to Stop command (DISABLE).");
                    AnimationCommand::Stop
                },
                _ => {
                    warn!("AnimationAPI: Received unrecognized command: {}", command_name);
                    return;
                }
            };

            if let Err(e) = handle.send(command) {
                error!("AnimationAPI: Failed to send command to worker: {}", e);
            }
        } else {
            warn!("AnimationAPI: Command '{}' received, but animation conductor is not initialized.", command_name);
        }
    }

    // -------------------------------------------------------------------------
    // 3. Specific Control Methods
    // -------------------------------------------------------------------------

    /// Starts a predefined test animation sequence.
    pub fn start_test_animation(&self, _tilemap_node: Option<&Gd<TileMap>>) {
        if let Some(handle) = self.animation_conductor {
            let command = AnimationCommand::StartTestAnimation;

            match handle.send(command) {
                Ok(_) => info!("AnimationAPI: Sent StartTestAnimation command."),
                Err(e) => error!("Failed to send StartTestAnimation command: {}", e),
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start test animation.");
        }
    }

    /// Stops the running test animation sequence.
    pub fn stop_test_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping 30x30 test animation.");

            if let Err(e) = handle.send(AnimationCommand::StopTestAnimation) {
                error!("Failed to send StopTestAnimation command: {}", e);
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop test animation.");
        }
    }

    /// Configures the animation framerate and sends the global start command.
    pub fn start_loading_animation(
        &self,
        framerate: f32,
        _signals_node: Option<&Gd<Node>>,
    ) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Starting loading animation at {:.2} FPS.", framerate);

            // Send two distinct commands: one for settings, one for state change.
            let update_result = handle.send(AnimationCommand::UpdateFramerate(framerate));
            let start_result = handle.send(AnimationCommand::Start);

            if let Err(e) = update_result {
                error!("Failed to send UpdateFramerate command: {}", e);
            }
            if let Err(e) = start_result {
                error!("Failed to send Start command: {}", e);
            }

        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot start animation.");
        }
    }

    /// Stops the generic loading animation sequence.
    pub fn stop_loading_animation(&self, _signals_node: Option<&Gd<Node>>) {
        if let Some(handle) = self.animation_conductor {
            info!("AnimationAPI: Stopping loading animation.");

            if let Err(e) = handle.send(AnimationCommand::Stop) {
                error!("Failed to send Stop command: {}", e);
            }

        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot stop animation.");
        }
    }

    // -------------------------------------------------------------------------
    // 4. Data Transfer Method
    // -------------------------------------------------------------------------

    /// Retrieves pre-generated chunk data from the main Conductor and registers it
    /// with the animation system for display/interpolation.
    pub fn register_chunk_for_animation(&self, chunk_x: i32, chunk_y: i32) {
        if let Some(handle) = self.animation_conductor {

            let coords = Vec2i::new(chunk_x as i64, chunk_y as i64);

            if let Some(conductor_arc) = self._conductor {
                // Lock the Conductor Mutex to call the synchronous data retrieval method.
                let result = conductor_arc.lock().map(|conductor| {

                    // Synchronously get the data (this will perform generation if not cached).
                    let chunk_data = conductor.get_chunk_data(&coords);
                    let chunk_arc = Arc::new(chunk_data);

                    // Send the thread-safe, generated chunk data to the animation worker.
                    handle.send(AnimationCommand::RegisterChunk(chunk_arc))
                        .map_err(|e| error!("Failed to send RegisterChunk command: {}", e))
                        .ok();
                    info!("AnimationAPI: Registered chunk ({}, {}) for animation.", chunk_x, chunk_y);
                });

                if let Err(e) = result {
                    error!("Failed to lock Conductor mutex for chunk registration: {}", e);
                }
            } else {
                warn!("Generation Conductor is not initialized. Cannot register chunk data.");
            }
        } else {
            warn!("AnimationAPI: Animation Conductor is not initialized. Cannot register chunk.");
        }
    }
}
>>> FILE END: rust\ssxl_godot\src\animation_api.rs <<<

======================================================
======================================================
// ssxl_godot/src/api_initializers.rs

//! # Godot Engine Initializers (`ssxl_godot::api_initializers`)
//!
//! Manages the initialization and graceful shutdown of the two core background
//! asynchronous systems: the **Generation Conductor** and the **Animation Conductor**.
//! This is the FFI layer's entry point for starting the Rust engine runtime.

use std::sync::{Arc, Mutex};
use tracing::{info, error};

// --- Imports from ssxl_generate ---
use ssxl_generate::{
    Conductor,
    ConductorProgressReceiver,
    // Removed: ConductorRequestSender,
};
use ssxl_generate::conductor_state::ConductorState;

// --- Imports from ssxl_sync ---
use ssxl_sync::{
    AnimationConductor,
    AnimationConductorHandle,
    AnimationReceiver,
    AnimationCommand,
};
use ssxl_sync::AnimationState;

/// Responsible for initializing and managing the lifecycle of the entire SSXL Engine runtime.
#[derive(Debug, Default)]
pub struct EngineInitializer {}

impl EngineInitializer {
    pub fn new() -> Self {
        EngineInitializer {}
    }

    // --- 1. Generation Conductor Initialization ---

    /// Initializes the main world generation system (Conductor).
    ///
    /// The Conductor is wrapped in `Arc<Mutex<...>>` to allow thread-safe
    /// synchronous access (e.g., for `get_chunk_data`) from the Godot main thread.
    pub fn ensure_conductor(
        &self
    ) -> (
        // Thread-safe handle to the Conductor struct itself.
        Option<Arc<Mutex<Conductor>>>,
        // Receiver for generated chunk data and progress messages.
        Option<ConductorProgressReceiver>,
        // The thread-safe state tracker for the generation pipeline.
        Option<ConductorState>
    ) {
        info!("EngineInitializer: Attempting to initialize Conductor...");
        
        // Conductor::new starts the Tokio runtime and the main request loop.
        match Conductor::new(None) {
            Ok((conductor, state, gen_rx, _request_tx)) => {
                info!("Conductor initialized and background thread started successfully.");
                // We return the Conductor in a Mutex/Arc for thread-safe access from Godot.
                (Some(Arc::new(Mutex::new(conductor))), Some(gen_rx), Some(state))
            }
            Err(e) => {
                error!("Failed to initialize Conductor: {}", e);
                (None, None, None)
            }
        }
    }

    // --- 2. Animation Conductor Initialization ---

    /// Initializes the dedicated animation processing system (AnimationConductor).
    ///
    /// This runs a separate thread loop to handle tile/visual interpolation updates
    /// without blocking the Godot main thread or the Generation Conductor's runtime.
    pub fn ensure_animation_conductor(
        &self
    ) -> (
        // Sender for control commands (e.g., Start, Stop, UpdateFramerate).
        Option<AnimationConductorHandle>,
        // Receiver for the resulting AnimationFrames to be consumed by Godot.
        Option<AnimationReceiver>,
        // The thread-safe state tracker for the animation pipeline.
        Option<AnimationState>
    ) {
        info!("EngineInitializer: Attempting to initialize AnimationConductor...");
        
        // Use an `if let Ok` pattern for clean error handling.
        let Ok((conductor_struct, anim_rx_found, anim_state_found)) = AnimationConductor::new() else {
            error!("Failed to initialize AnimationConductor.");
            return (None, None, None);
        };
        
        info!("AnimationConductor initialized and thread started successfully.");
        
        (
            Some(conductor_struct.get_command_sender()),
            Some(anim_rx_found),
            Some(anim_state_found)
        )
    }

    // --- 3. Graceful Shutdown ---

    /// Performs a graceful shutdown of both background conductors.
    ///
    /// Takes ownership of the handles to ensure they are cleaned up and resources released.
    pub fn shutdown(
        &self,
        mut anim_handle: Option<AnimationConductorHandle>,
        mut conductor_arc: Option<Arc<Mutex<Conductor>>>,
    ) {
        info!("EngineInitializer: Starting graceful shutdown process...");
        
        // 1. Shut down Generation Conductor (requires unique ownership)
        if let Some(arc) = conductor_arc.take() {
            // Attempt to unwrap the Arc to ensure we have the *only* reference.
            match Arc::try_unwrap(arc) {
                Ok(mutex) => {
                    info!("Shutting down Conductor...");
                    // Unwrap the Mutex (panic if poisoned) and call the teardown method.
                    mutex.into_inner().unwrap().graceful_teardown();
                    info!("Conductor shutdown complete.");
                }
                Err(_) => {
                    // If Arc couldn't be unwrapped, another thread holds a reference, which is an error.
                    error!("Could not unwrap Conductor Arc; other references may exist. Conductor may leak resources.");
                }
            }
        }

        // 2. Shut down Animation Conductor (by sending a command)
        if let Some(handle) = anim_handle.take() {
            // Send a Stop command to the animation thread's receiver.
            match handle.send(AnimationCommand::Stop) {
                Ok(_) => info!("AnimationConductor shutdown command sent successfully."),
                Err(e) => error!("Failed to send shutdown command to AnimationConductor: {}", e),
            }
            // Note: The animation thread will terminate after processing the Stop command.
            info!("AnimationConductor shutdown command issued.");
        }
        
        info!("EngineInitializer: All background runtimes terminated.");
    }
}
>>> FILE END: rust\ssxl_godot\src\api_initializers.rs <<<

======================================================
======================================================
//! # AsyncPoller
//!
//! This module implements the `AsyncPoller` struct, which acts as a crucial **thread-safe bridge**
//! between the SSXL-ext engine's **Rust worker threads** (Generation and Animation) and the
//! **Godot main thread**. It uses non-blocking channel polling (`try_recv`) to safely drain
//! messages without stalling the game engine loop.

// --- Godot GDExtension Imports ---
use godot::classes::Node;
use godot::obj::{GodotClass, Inherits, Gd};
use godot::meta::ToGodot;
// --- Standard Library Imports ---
use std::sync::Arc;
// --- External Asynchronous Runtime Imports (Tokio) ---
use tokio::sync::mpsc::{
    Receiver as TokioReceiver,
    UnboundedReceiver as TokioUnboundedReceiver,
    error::TryRecvError as TokioTryRecvError
};
// --- SSXL-ext Shared & Generation Crates Imports ---
use ssxl_shared::messages::ChunkMessage;
use ssxl_generate::task_queue::GenerationMessage;
use ssxl_shared::tile_data::AnimationUpdate;
use ssxl_shared::grid_bounds::GridBounds;
use ssxl_shared::chunk_data::ChunkData;


// -----------------------------------------------------------------------------
// Constants and Type Aliases
// -----------------------------------------------------------------------------

/// **CRITICAL THROTTLE:** Max number of chunk messages to process in a single Godot frame.
/// This prevents the main thread from stalling when the Rust core finishes generating too quickly.
/// (64 chunks * 32x32 tiles/chunk = ~65,000 tile updates per frame at 60 FPS)
const MAX_GENERATION_MESSAGES_PER_POLL: usize = 64; 

/// Type alias for the bounded channel receiver used by the **Generation** conductor.
pub type GenerationReceiver = TokioReceiver<GenerationMessage>;

/// Type alias for the unbounded channel receiver used by the **Animation** conductor.
pub type AnimationReceiver = TokioUnboundedReceiver<AnimationUpdate>;


// -----------------------------------------------------------------------------
// AsyncPoller Struct and Implementation
// -----------------------------------------------------------------------------

/// # AsyncPoller
///
/// Manages the receiver ends of the inter-thread message passing system.
/// It is responsible for draining these channels during the Godot frame loop.
#[derive(Default)]
pub struct AsyncPoller {
    /// Receiver for messages from the SSXL-ext **Generation** pipeline.
    generation_receiver: Option<GenerationReceiver>,
    /// Receiver for messages from the SSXL-ext **Animation** pipeline.
    animation_receiver: Option<AnimationReceiver>,
}

impl AsyncPoller {
    /// Creates a new, default instance of the `AsyncPoller`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the receiver for generated chunk data messages.
    pub fn set_generation_receiver(&mut self, receiver: Option<GenerationReceiver>) {
        self.generation_receiver = receiver;
    }

    /// Sets the receiver for real-time animation update messages.
    pub fn set_animation_receiver(&mut self, receiver: Option<AnimationReceiver>) {
        self.animation_receiver = receiver;
    }

    /// Clears both receivers, typically called during engine shutdown.
    pub fn clear_receivers(&mut self) {
        self.generation_receiver = None;
        self.animation_receiver = None;
    }

    // -------------------------------------------------------------------------
    // Polling Logic: Generation (THROTTLED)
    // -------------------------------------------------------------------------

    /// Polls the generation channel for available messages, **throttling** the
    /// maximum number of messages processed per Godot frame.
    pub fn poll_generation_messages(&mut self) -> Vec<ChunkMessage> {
        // Pre-allocate vector capacity to the throttle limit.
        let mut messages = Vec::with_capacity(MAX_GENERATION_MESSAGES_PER_POLL);
        let mut messages_processed = 0;

        if let Some(mut receiver) = self.generation_receiver.take() {
            loop {
                // 1. Throttle Check: Stop processing if the limit is reached this frame.
                if messages_processed >= MAX_GENERATION_MESSAGES_PER_POLL {
                    break; 
                }

                match receiver.try_recv() {
                    Ok(message) => {
                        let chunk_message = match message {
                            // A chunk has been successfully generated.
                            GenerationMessage::ChunkGenerated(_coords, chunk_data_arc) => {
                                // Performance Optimization (Zero-Copy) using Arc::try_unwrap
                                let chunk_data = Arc::try_unwrap(chunk_data_arc)
                                    .unwrap_or_else(|arc| (*arc).clone());
                                ChunkMessage::Generated(chunk_data)
                            }
                            // The entire generation batch is complete (sentinel message).
                            GenerationMessage::GenerationComplete => {
                                ChunkMessage::Generated(ChunkData::new(
                                    0,
                                    GridBounds::default(),
                                    "complete".to_string(), // Sentinel string
                                ))
                            }
                        };
                        messages.push(chunk_message);
                        messages_processed += 1; // 2. Increment throttle counter
                    }
                    // Non-blocking exit: Channel is currently empty.
                    Err(TokioTryRecvError::Empty) => break,
                    // Critical Error: Generation channel disconnected.
                    Err(TokioTryRecvError::Disconnected) => {
                        eprintln!("[SSXL-SYNC ERROR] Generation channel disconnected.");
                        // Restore the receiver (even if disconnected) to prevent a panic on 'take()' next frame.
                        self.generation_receiver = Some(receiver);
                        return messages;
                    }
                }
            }
            // 3. Restore the receiver to the poller for the next Godot frame's poll.
            self.generation_receiver = Some(receiver);
        }

        messages
    }

    // -------------------------------------------------------------------------
    // Polling Logic: Animation (Non-Throttled)
    // -------------------------------------------------------------------------

    /// Polls the animation channel for updates and emits a Godot signal for each one.
    pub fn poll_animation_updates<T: GodotClass + Inherits<Node>>(
        &mut self,
        emitter: &mut Gd<T>,
    ) {
        if let Some(mut receiver) = self.animation_receiver.take() {
            loop {
                match receiver.try_recv() {
                    Ok(update) => {
                        // Upcast to a base Node to use `emit_signal`.
                        let mut node = emitter.clone().upcast::<Node>();
                        node.emit_signal(
                            "tile_flip_updated", // Signal defined in ssxl_signals.rs
                            &[
                                (update.tile_coords.x as i32).to_variant(),
                                (update.new_atlas_coords.x as i32).to_variant(),
                            ],
                        );
                    }
                    // Non-blocking exit: Channel is currently empty.
                    Err(TokioTryRecvError::Empty) => break,
                    // Critical Error: Animation channel disconnected.
                    Err(TokioTryRecvError::Disconnected) => {
                        eprintln!("[SSXL-SYNC ERROR] Animation channel disconnected.");
                        // Do NOT restore the receiver, as it is permanently closed.
                        return;
                    }
                }
            }
            // Restore the receiver to the poller for the next frame's poll.
            self.animation_receiver = Some(receiver);
        }
    }

    /// Public wrapper for polling animation updates, called directly from the `SSXLEngine`.
    pub fn poll_animations(&mut self, emitter: &mut Gd<Node>) {
        self.poll_animation_updates(emitter);
    }
}
>>> FILE END: rust\ssxl_godot\src\async_poll.rs <<<

======================================================
======================================================
// rust/SSXL_godot/src/build.rs

//! # Build Script for SSXL-ext GDExtension Deployment
//!
//! This script runs *before* the main compilation of the `ssxl_godot` crate.
//! Its purpose is to **automate the deployment** of the compiled GDExtension
//! dynamic library (`ssxl_engine.dll`) from the Cargo `target` directory
//! directly into the Godot test project (`ssxl_engine_tester`). This enables
//! fast iteration and "faster than light speed" development **tempo**.

use std::env;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    // 1. CARGO INSTRUCTION: Rerun on change
    // Tells Cargo to re-run this build script if the script itself is modified.
    println!("cargo:rerun-if-changed=build.rs");

    // 2. PATH SETUP: Determine the root of the current crate's manifest.
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR not set"));

    // 3. ARTIFACT NAME: The name of the resulting dynamic library (DLL on Windows).
    let dll_name = "ssxl_engine.dll";

    // 4. PROFILE: Determine the build profile (e.g., "debug" or "release").
    // This is crucial as the DLL location depends on the profile folder within 'target/'.
    let profile = env::var("PROFILE")
        .expect("PROFILE environment variable not set");

    // --- Path Calculation ---

    // 5. SOURCE PATH: Calculate the path to the newly compiled DLL.
    // The structure is generally: /workspace/rust/ssxl_godot -> /workspace/rust -> target/profile/ssxl_engine.dll
    let src_path = manifest_dir
        .parent().unwrap()      // Moves from `/rust/ssxl_godot` to `/rust`
        .join("target")
        .join(&profile)         // Inserts "debug" or "release"
        .join(dll_name);

    // 6. DESTINATION PATH: Calculate the path to the Godot test project folder.
    // The structure is: /workspace/rust/ssxl_godot -> /workspace/rust -> /workspace -> ssxl_engine_tester/ssxl_engine.dll
    let dst_path = manifest_dir
        .parent().unwrap()      // Moves from `/rust/ssxl_godot` to `/rust`
        .parent().unwrap()      // Moves from `/rust` to `/workspace` root
        .join("ssxl_engine_tester") // The Godot project folder
        .join(dll_name);

    // --- Deployment Execution (Windows-Specific) ---

    // 7. COMMAND: Execute a Windows shell command (`cmd /C copy`) to perform the deployment.
    // `/C` executes the command and then terminates.
    // `/Y` suppresses prompting to confirm overwriting the existing file.
    let status = Command::new("cmd")
        .args(&["/C", "copy", "/Y"])
        .arg(&src_path)
        .arg(&dst_path)
        .status();

    // 8. RESULT HANDLING: Report the outcome using Cargo warnings.
    match status {
        Ok(s) if s.success() => {
            // Success: The experiment's result is deployed and ready for testing!
            println!("cargo:warning=✅ SUCCESS (CMD): Deployed {} to {}", dll_name, dst_path.display());
        }
        Ok(s) => {
            // Failure with status code: Common if files are locked (e.g., Godot is running).
            println!("cargo:warning=🚨 CRITICAL FAILURE (CMD): DLL deployment failed with exit code: {:?}", s.code());
            println!("cargo:warning=  Source Path: {}", src_path.display());
            println!("cargo:warning=  Dest Path: {}", dst_path.display());
            println!("cargo:warning=  Note: The shell command failed. Check file locks (is Godot editor running?) or path permissions.");
        }
        Err(e) => {
             // System error: Command could not even be executed.
            println!("cargo:warning=❌ SYSTEM ERROR (CMD): Failed to execute copy command: {}", e);
        }
    }
}
>>> FILE END: rust\ssxl_godot\src\build.rs <<<

======================================================
======================================================
//! # ChannelHandler
//!
//! This module implements the `ChannelHandler`. It acts as the central **dispatcher**
//! on the Godot main thread, receiving raw messages from the `AsyncPoller` and delegating:
//! 1. Generation messages to the `ChunkPresenter` for deferred rendering.
//! 2. Animation updates directly into Godot signals for real-time responsiveness.

// --- Godot GDExtension Imports ---
use godot::classes::Node;
use godot::obj::Gd;
use godot::builtin::{GString, ToVariant}; // Added ToVariant for func param
use godot::prelude::Callable;

// --- SSXL-ext Internal Crates Imports ---
use ssxl_generate::Conductor;
use ssxl_shared::tile_data::AnimationUpdate;
use ssxl_shared::messages::ChunkMessage;
use ssxl_generate::task_queue::GenerationMessage; // Note: Needed if Poller returns raw messages

// --- Local Crate Imports ---
use crate::chunk_presenter::ChunkPresenter;

// --- Standard Library Imports ---
use std::sync::{Arc, Mutex};
use tracing::{info, error};


// -----------------------------------------------------------------------------
// ChannelHandler Struct (Unchanged)
// -----------------------------------------------------------------------------

/// Manages the context required to process messages and apply them to the Godot scene tree.
#[derive(Debug, Default, Clone)]
pub struct ChannelHandler {
    presenter: Option<ChunkPresenter>,
    signals_node: Option<Gd<Node>>,
}

impl ChannelHandler {
    pub fn new() -> Self {
        ChannelHandler::default()
    }

    pub fn set_presenter_handle(&mut self, presenter: ChunkPresenter) {
        self.presenter = Some(presenter);
    }

    pub fn set_signals_node(&mut self, signals_node: Option<Gd<Node>>) {
        self.signals_node = signals_node;
    }

    // -------------------------------------------------------------------------
    // Processing Logic: Generation (Deferred Rendering)
    // -------------------------------------------------------------------------

    /// Processes a batch of newly generated chunk messages.
    pub fn process_generation_messages_deferred(
        &mut self,
        messages: Vec<ChunkMessage>,
        conductor: Option<Arc<Mutex<Conductor>>>,
    ) -> Option<GString> {
        // ... (Existing logic for Generation messages remains here) ...
        if messages.is_empty() {
            return None;
        }

        let mut is_complete = false;

        if let Some(ref presenter) = self.presenter {
            for msg in messages {
                if let ChunkMessage::Generated(data) = &msg {
                    if data.dimension_tag == "complete" {
                        is_complete = true;
                        continue;
                    }
                }

                if let Some(deferred_call) = presenter.create_deferred_present_call(msg) {
                    deferred_call.call_deferred(&[]);
                } else {
                    error!("Failed to create deferred call for chunk message. Is TileMap set on Presenter?");
                }
            }
        }

        // --- Post-Processing: Handle Completion Status ---
        if is_complete {
            if let Some(arc_mutex_conductor) = conductor {
                match arc_mutex_conductor.lock() {
                    Ok(conductor_lock) => {
                        conductor_lock.signal_generation_complete();
                        info!("GenerationComplete received. Conductor status set to Running (Idle).");
                    },
                    Err(e) => {
                        error!("Failed to acquire Conductor lock to set status: {}", e);
                        return Some(GString::from("ERR_CONDUCTOR_MUTEX_POISONED"));
                    }
                }
            } else {
                error!("GenerationComplete received, but Conductor reference is None.");
            }
        }

        None
    }

    // -------------------------------------------------------------------------
    // Processing Logic: Animation (Real-time Signal Emission)
    // -------------------------------------------------------------------------

    /// Processes a batch of real-time animation updates and emits Godot signals.
    /// This logic was moved from AsyncPoller to remove main-thread processing load.
    pub fn process_animation_messages(&mut self, updates: Vec<AnimationUpdate>) {
        if updates.is_empty() {
            return;
        }

        if let Some(mut node) = self.signals_node.clone() {
            for update in updates {
                // Ensure the node reference is available and we can upcast (though clone/upcast is complex)
                // Assuming self.signals_node is already a valid Gd<Node> capable of emitting.
                
                // Emitting the signal that the TileMap code should be listening to.
                node.emit_signal(
                    "tile_flip_updated",
                    &[
                        // tile_coords.x is used as the general tile_id for the signal contract
                        (update.tile_coords.x as i32).to_variant(),
                        // new_atlas_coords.x is used as the new frame ID for the flip
                        (update.new_atlas_coords.x as i32).to_variant(),
                    ],
                );
            }
        }
    }
}
>>> FILE END: rust\ssxl_godot\src\channel_handler.rs <<<

======================================================
======================================================
//! # ChunkPresenter
//!
//! The dedicated rendering layer for SSXL-ext. This component operates exclusively
//! on the **Godot main thread**, taking generated `ChunkData` and **AnimationUpdates**
//! and translating them into direct calls to the Godot `TileMap` API (`set_cell_ex`).
//!
//! 💥 **Update:** This component is now registered as a Godot class to allow for
//! deferred rendering via Godot's `Callable` mechanism.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::{TileMap, Node};
use godot::builtin::Vector2i; // Needed for explicit coordinate types
use godot::obj::{Gd, Base}; // 💥 FIX: Added Base for GodotClass derive
use godot::prelude::{Callable, GodotClass, ToVariant, FromVariant}; // 💥 FIX: Added GodotClass, ToVariant, FromVariant for conversion

// --- SSXL-ext Shared Crates Imports ---
use ssxl_shared::{ChunkData, CHUNK_SIZE};
use ssxl_shared::messages::ChunkMessage;
use ssxl_shared::tile_data::AnimationUpdate;

// --- Standard Library Imports ---
use std::io::Error as GodotError;
use tracing::{error};


// -----------------------------------------------------------------------------
// Core Constants for Godot TileMap Interaction
// -----------------------------------------------------------------------------

/// The TileMap layer index used by SSXL. Set to 0 (the first layer).
const SSXL_LAYER: i32 = 0;

/// The TileSet Source ID for the atlas containing the core tiles. Set to 0.
const ATLAS_SOURCE_ID: i32 = 0;

/// Name of the method to call on the ChunkPresenter when a deferred chunk needs rendering.
const DEFERRED_RENDER_METHOD_NAME: &str = "present_chunk_internal";


// -----------------------------------------------------------------------------
// ChunkPresenter Struct
// -----------------------------------------------------------------------------

/// # ChunkPresenter
///
/// A handler for presenting SSXL data onto a Godot `TileMap`.
#[derive(Clone, Default, Debug, GodotClass)] // 💥 FIX: Added GodotClass derive
#[class(base=Node)] // 💥 FIX: Set base to Node so it can be targeted by Callable
pub struct ChunkPresenter {
    #[base] // 💥 FIX: Required field for base methods
    base: Base<Node>,
    /// 💥 NEW: The reference to the target TileMap node for rendering.
    tilemap_node: Option<Gd<TileMap>>,
}


#[godot_api]
impl ChunkPresenter {
    /// Constructs a new instance of the ChunkPresenter.
    pub fn new() -> Self {
        ChunkPresenter::default()
    }

    /// Sets the target TileMap node. Must be called once during engine setup.
    pub fn set_tilemap_node(&mut self, tilemap_node: Gd<TileMap>) {
        self.tilemap_node = Some(tilemap_node);
    }

    // -------------------------------------------------------------------------
    // Deferred Rendering API
    // -------------------------------------------------------------------------

    /// Creates a Godot `Callable` that, when executed, will apply the given
    /// `ChunkMessage` to the internal `TileMap` reference.
    /// Returns `None` if the TileMap is not set.
    pub fn create_deferred_present_call(&self, msg: ChunkMessage) -> Option<Callable> {
        // Get a Gd<Node> handle for the presenter itself.
        let presenter_node = self.base().clone(); 

        // The message must implement ToVariant (via GodotConvert).
        let msg_variant = msg.to_variant();

        // 💥 FIX: Use Callable::from_object_method
        Some(Callable::from_object_method(
            &presenter_node,
            DEFERRED_RENDER_METHOD_NAME, // "present_chunk_internal"
        ).with_arguments(&[msg_variant]))
    }

    /// 💥 NEW: This is the **internal method** called by the deferred `Callable`.
    #[func]
    pub fn present_chunk_internal(&mut self, msg_variant: Variant) {
        // The message must implement FromVariant (via GodotConvert).
        let msg = match msg_variant.try_to::<ChunkMessage>() {
            Ok(m) => m,
            Err(e) => {
                error!("Failed to deserialize ChunkMessage from Variant in deferred call: {:?}", e);
                return;
            }
        };

        // Use the presenter's internal TileMap reference.
        if let Some(ref mut tile_map) = self.tilemap_node {
            if let ChunkMessage::Generated(chunk_data) = msg {
                if let Err(e) = self.apply_chunk_data(tile_map, chunk_data) {
                    error!("Error applying chunk data in deferred call: {:?}", e);
                }
            }
        } else {
            error!("Cannot present chunk: TileMap reference is missing.");
        }
    }


    // -------------------------------------------------------------------------
    // Immediate Rendering API (Animation)
    // -------------------------------------------------------------------------

    /// Handles a single, real-time animation update from the Animation conductor.
    #[allow(dead_code)]
    pub fn update_animated_tile_using_internal_ref(&self, update: AnimationUpdate) {
        if let Some(ref mut tile_map) = self.tilemap_node.clone() {
            // 1. Convert SSXL internal coordinates (i64/u64) to Godot's i32 Vector2i format.
            let cell_pos = Vector2i::new(
                update.tile_coords.x as i32,
                update.tile_coords.y as i32
            );
            let atlas_coords = Vector2i::new(
                update.new_atlas_coords.x as i32,
                update.new_atlas_coords.y as i32
            );

            // 2. Set the tile using Godot's fluent setter API.
            let _ = tile_map.set_cell_ex(
                SSXL_LAYER,
                cell_pos
            )
            .source_id(ATLAS_SOURCE_ID)
            .atlas_coords(atlas_coords)
            .alternative_tile(0);
        } else {
            error!("Cannot update animated tile: TileMap reference is missing.");
        }
    }


    // -------------------------------------------------------------------------
    // Core Rendering Logic (Internal)
    // -------------------------------------------------------------------------

    /// Core logic to iterate over all tiles in a chunk and render them to the TileMap.
    fn apply_chunk_data(&self, tile_map: &mut Gd<TileMap>, chunk_data: ChunkData) -> Result<(), GodotError> {
        let chunk_size_i32 = CHUNK_SIZE as i32;

        // 1. Calculate the starting cell position (the origin) of this chunk.
        let chunk_grid_x = (chunk_data.bounds.min.x / CHUNK_SIZE as i64) as i32;
        let chunk_grid_y = (chunk_data.bounds.min.y / CHUNK_SIZE as i64) as i32;

        let chunk_pos_grid = Vector2i::new(
            chunk_grid_x * chunk_size_i32,
            chunk_grid_y * chunk_size_i32,
        );

        // 2. Iterate through every tile in the ChunkData array (row by row).
        for y in 0..CHUNK_SIZE {
            for x in 0..CHUNK_SIZE {
                let index = (y * CHUNK_SIZE + x) as usize;
                let tile = &chunk_data.tiles[index];

                let tile_type = tile.tile_type;

                let (_tile_id_render, (atlas_x, atlas_y)) = (tile_type.get_default_tile_id(), tile_type.get_default_atlas_coords());

                // Skip rendering empty/air tiles to save engine work.
                if tile_type.is_empty() {
                    continue;
                }

                // 3. Calculate the global position of the individual tile cell.
                let cell_pos = chunk_pos_grid + Vector2i::new(x as i32, y as i32);

                let atlas_coords = Vector2i::new(
                    atlas_x as i32,
                    atlas_y as i32
                );

                // 4. Apply the cell data to the Godot TileMap.
                let _ = tile_map.set_cell_ex(
                    SSXL_LAYER,
                    cell_pos
                )
                .source_id(ATLAS_SOURCE_ID)
                .atlas_coords(atlas_coords)
                .alternative_tile(0);
            }
        }

        // Force a synchronous update of the TileMap's rendering.
        tile_map.force_update();

        Ok(())
    }
}
>>> FILE END: rust\ssxl_godot\src\chunk_presenter.rs <<<

======================================================
======================================================
use godot::prelude::*;
use godot::classes::{Node, TileMap};
use godot::obj::Gd;
use godot::builtin::GString;
use std::sync::{Arc, Mutex};
use ssxl_generate::Conductor;
use ssxl_generate::conductor_state::ConductorState;
use ssxl_sync::{AnimationConductorHandle, AnimationState, Receiver};
use crate::api_initializers::EngineInitializer;
use crate::generation_api::GenerationAPI;
use crate::animation_api::AnimationAPI;
use crate::ssxl_engine::SSXLEngine; // Import the host struct

// -----------------------------------------------------------------------------
// 1. Core Setup Logic (Moves complexity out of SSXLEngine::initialize_core)
// -----------------------------------------------------------------------------

/// Assumption: We are adding this method to the existing EngineInitializer impl.
/// This method encapsulates all thread spawning and handle creation, which used
/// to take up ~15 lines in SSXLEngine::initialize_core.
impl EngineInitializer {
    /// Executes the full multi-threaded core setup, returning all necessary handles.
    pub fn execute_core_setup(
    ) -> (
        Option<Arc<Mutex<Conductor>>>, Option<Receiver>, Option<ConductorState>, 
        Option<AnimationConductorHandle>, Option<Receiver>, Option<AnimationState>
    ) {
        // The complex logic (info! logs, thread spawning, result unwrapping)
        // for ensure_conductor() and ensure_animation_conductor() lives here now.
        let (conductor_arc, gen_rx, gen_state) = EngineInitializer::ensure_conductor();
        let (anim_handle, anim_rx, anim_state) = EngineInitializer::ensure_animation_conductor();
        
        (conductor_arc, gen_rx, gen_state, anim_handle, anim_rx, anim_state)
    }
}


// -----------------------------------------------------------------------------
// 2. Trait Definition (The boilerplate reducer)
// -----------------------------------------------------------------------------

/// Trait implemented on SSXLEngine to provide access to API delegation methods
/// without cluttering the main SSXLEngine impl block.
pub trait EngineApiExtension {
    // This trait is empty but used to implement the methods below.
}

// -----------------------------------------------------------------------------
// 3. Trait Implementation (The bulk of the logic moved from ssxl_engine.rs)
// -----------------------------------------------------------------------------

/// Implements all public Godot API methods that are simple delegates.
/// This drastically reduces the LOC count in ssxl_engine.rs.
#[godot_api]
impl EngineApiExtension for SSXLEngine {
    
    // --- Generation API Delegation (REMOVED FROM ssxl_engine.rs) ---

    #[func]
    fn build_map(&mut self, width: i32, height: i32, seed: GString, generator_name: GString) {
        GenerationAPI::new(self.conductor.as_ref()).build_map(width, height, seed, generator_name, self.signals_node.as_ref());
    }

    #[func]
    fn set_generator(&mut self, id: GString) -> bool {
        GenerationAPI::new(self.conductor.as_ref()).set_generator(id)
    }

    #[func]
    fn get_active_generator_id(&self) -> GString {
        GenerationAPI::new(self.conductor.as_ref()).get_active_generator_id()
    }

    // --- Animation API Delegation (REMOVED FROM ssxl_engine.rs) ---

    #[func]
    fn start_loading_animation(&mut self, framerate: f32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).start_loading_animation(framerate, self.signals_node.as_ref());
    }

    #[func]
    fn register_chunk_for_animation(&mut self, chunk_x: i32, chunk_y: i32) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).register_chunk_for_animation(chunk_x, chunk_y);
    }

    #[func]
    fn stop_loading_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref()).stop_loading_animation(self.signals_node.as_ref());
    }

    #[func]
    fn send_animation_command(&mut self, command_name: GString) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .send_command_by_name(command_name.to_string());
    }

    #[func]
    fn start_test_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .start_test_animation(self.tilemap_node.as_ref());
    }

    #[func]
    fn stop_test_animation(&mut self) {
        AnimationAPI::new(self.animation_conductor.as_ref(), self.conductor.as_ref())
            .stop_test_animation(self.signals_node.as_ref());
    }
}
>>> FILE END: rust\ssxl_godot\src\engine_core_logic.rs <<<

======================================================
======================================================
// ssxl_godot/src/gde_api_defs.rs

//! # Godot Extension API Definitions (GDExtension Interface)
//!
//! This module defines the essential Rust-side bindings that connect the `SSXLEngine`
//! struct to the Godot engine's runtime environment. It implements the necessary
//! traits to register the class and hook into the standard Node lifecycle methods.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;

// --- Local Crate Imports ---
// Import the core SSXL engine implementation.
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// GDExtension Initialization Macro
// -----------------------------------------------------------------------------

/// The mandatory **GDExtension entry point**.
///
/// This function is called by Godot when the dynamic library is loaded.
/// The `#[gdextension]` attribute marks it as the entry function.
/// It is declared `unsafe` because it interacts with the C/C++ FFI of Godot.
#[gdextension]
unsafe fn ssxl_godot_init(builder: &mut InitHandle) {
    // 1. **Class Registration:** Registers the core `SSXLEngine` struct with Godot.
    // This makes the Rust struct available in the Godot scripting environment (GDScript/C#).
    builder.add_class::<SSXLEngine>();
}


// -----------------------------------------------------------------------------
// Godot Node Lifecycle Implementation
// -----------------------------------------------------------------------------

/// Implements the `ExtensionLibrary` trait for `SSXLEngine`.
/// This trait binds the Rust struct to a Godot class (in this case, `Node`)
/// and maps Godot's virtual methods (like `_init`, `_process`) to the Rust implementation.
impl ExtensionLibrary for SSXLEngine {
    /// **Godot's Constructor (`_init`)**:
    /// This runs when an instance of `SSXLEngine` is created in Godot.
    /// It delegates initialization to the custom `SSXLEngine::init` method.
    fn _init(base: Base<Node>) -> Self {
        // `base` is the underlying Godot Node that this struct wraps.
        SSXLEngine::init(base)
    }

    /// **Godot's Frame Update (`_process(delta)`)**:
    /// This is called every frame, **adapting** the engine's logic to the game's **tempo**.
    /// The `delta` is the time elapsed since the last frame.
    fn _process(&mut self, delta: f64) {
        // Call the internal game loop tick function, passing the delta time.
        // The delta is cast to `u64` (milliseconds or similar unit) as used internally
        // by the SSXL-ext game loop logic (which may need adjustment depending on the unit).
        self.tick(delta as u64);
    }

    /// **Godot's Initialization Hook (`_ready`)**:
    /// This runs once when the node and all its children have entered the scene tree.
    /// This is the ideal place to start the multi-threaded SSXL engine.
    fn _ready(&mut self) {
        self.on_ready();
    }
}
>>> FILE END: rust\ssxl_godot\src\gde_api_defs.rs <<<

======================================================
======================================================
// ssxl_godot/src/generation_api.rs (FIXED and CLEANED)

//! # GenerationAPI
//!
//! This module provides the high-level, exposed interface for the Godot runtime
//! (e.g., GDScript or C#) to control the **SSXL-ext Generation Conductor**.
//! It handles the necessary **synchronization (Arc/Mutex)** to safely pass commands
//! from the single-threaded Godot main loop to the background Conductor thread.

// --- Godot GDExtension Imports ---
use godot::classes::Node;
use godot::obj::Gd;
use godot::builtin::GString;

// --- Standard Library Imports (Synchronization & Logging) ---
use std::sync::{Arc, Mutex};
use tracing::{info, error, warn}; // Tracing/logging for debugging and tracking the tempo

// --- SSXL-ext Internal Crates Imports ---
use ssxl_generate::Conductor;
use ssxl_generate::GeneratorConfig;


// -----------------------------------------------------------------------------
// GenerationAPI Struct
// -----------------------------------------------------------------------------

/// # GenerationAPI
///
/// A wrapper that holds a reference to the **thread-safe Conductor**.
/// It is responsible for accepting Godot inputs, validating them, and forwarding
/// the commands to the core generation logic.
/// The lifetime parameter `'a` ensures the API wrapper doesn't outlive the engine context.
#[derive(Default)]
pub struct GenerationAPI<'a> {
    /// A potentially temporary, borrowed reference to the globally shared,
    /// mutex-protected `Conductor` instance.
    conductor: Option<&'a Arc<Mutex<Conductor>>>,
}

impl<'a> GenerationAPI<'a> {
    /// Constructs a new `GenerationAPI`, injecting the `Conductor` reference.
    pub fn new(conductor: Option<&'a Arc<Mutex<Conductor>>>) -> Self {
        GenerationAPI { conductor }
    }

    // -------------------------------------------------------------------------
    // Core Method: Map Generation Dispatch
    // -------------------------------------------------------------------------

    /// Initiates a new map generation task on the worker threads.
    /// This is the primary method called from the Godot environment.
    ///
    /// # Arguments
    /// * `width`, `height`: Dimensions of the map (in tiles or chunks).
    /// * `seed`: The generation seed string, converted from Godot's `GString`.
    /// * `generator_name`: The ID of the generator (e.g., "CellularAutomata").
    pub fn build_map(
        &self,
        width: i32,
        height: i32,
        seed: GString,
        generator_name: GString,
        _signals_node: Option<&Gd<Node>>, // Retained for future signal use, currently unused
    ) {
        // FIX: Abort early if the dimensions are invalid (e.g., 0 or negative).
        if width <= 0 || height <= 0 {
            error!("GenerationAPI: Map dimensions must be positive (received {}x{}). Aborting command.", width, height);
            return;
        }

        // 1. Check for the Conductor and acquire the Mutex lock.
        if let Some(arc) = self.conductor {
            // Use `map` to perform the action only if the lock succeeds.
            let result = arc.lock().map(|mut conductor| {
                info!("GenerationAPI: Attempting to build map with width={} height={}...", width, height);

                // 2. Build the thread-safe configuration object.
                let config = GeneratorConfig {
                    width: width as usize,
                    height: height as usize,
                    seed: seed.to_string(),
                    generator_name: generator_name.to_string(),
                };

                // 3. Dispatch the command to the Conductor.
                // The Conductor handles placing this task on the worker queue.
                conductor.start_generation(config)
            });

            // 4. Handle results and synchronization errors.
            match result {
                Ok(Ok(())) => info!("Generation command successfully dispatched to Conductor."),
                Ok(Err(e)) => error!("Failed to start map generation: {}", e), // Conductor reported logic error
                Err(e) => error!("Failed to lock Conductor mutex: {}", e),        // Mutex poisoned/lock error
            }

        } else {
            warn!("GenerationAPI: Conductor is not initialized. Cannot build map.");
        }
    }

    // -------------------------------------------------------------------------
    // Utility Method: Active Generator Management
    // -------------------------------------------------------------------------

    /// Sets the active generator to be used for future generation requests.
    ///
    /// # Returns
    /// `true` if the generator was successfully set, `false` otherwise.
    pub fn set_generator(&self, id: GString) -> bool {
        let generator_id: String = id.to_string();

        if let Some(arc) = self.conductor {
            // Use `map_or_else` to handle both the Mutex lock error (`Err`) and the
            // internal Conductor's result (`Ok(Result)`).
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for set_generator: {}", e);
                    false
                },
                |mut conductor| {
                    match conductor.set_active_generator(&generator_id) {
                        Ok(()) => {
                            info!("GenerationAPI: Active generator set to '{}'.", generator_id);
                            true
                        }
                        Err(e) => {
                            error!("GenerationAPI: Failed to set generator '{}': {}", generator_id, e);
                            false
                        }
                    }
                },
            );
        }
        warn!("GenerationAPI: Conductor is not initialized. Cannot set generator.");
        false
    }

    // -------------------------------------------------------------------------
    // Utility Method: Active Generator Query
    // -------------------------------------------------------------------------

    /// Retrieves the ID of the currently active generator.
    ///
    /// # Returns
    /// The generator ID as a Godot `GString`, or an error string if the lock fails.
    pub fn get_active_generator_id(&self) -> GString {
        if let Some(arc) = self.conductor {
            return arc.lock().map_or_else(
                |e| {
                    error!("Failed to lock Conductor mutex for get_active_generator_id: {}", e);
                    GString::from("Error: Mutex Lock Failed")
                },
                |conductor| {
                    let id_string = conductor.get_active_generator_id();
                    // Convert the internal Rust String back to Godot's GString type.
                    GString::from(&id_string)
                },
            );
        }
        GString::from("Error: Conductor Not Initialized")
    }
}
>>> FILE END: rust\ssxl_godot\src\generation_api.rs <<<

======================================================
======================================================
// ssxl_godot/src/lib.rs

//! # SSXL-ext GDExtension Core Library
//!
//! This file is the **root manifest** for the `ssxl_godot` crate. It defines the module
//! structure, imports necessary Godot framework components, and sets up the required
//! boilerplate for the Rust code to be loaded as a GDExtension dynamic library.

// -----------------------------------------------------------------------------
// Public Modules (Exposed to the GDExtension Interface)
// -----------------------------------------------------------------------------

/// The core class that wraps the GDExtension Node and orchestrates the SSXL engine.
pub mod ssxl_engine;
/// Defines custom signals for communication between the Rust core and Godot scripts.
pub mod ssxl_signals;
/// A potential future module for querying engine state or procedural data (the "Oracle").
pub mod ssxl_oracle;

// -----------------------------------------------------------------------------
// Private Modules (Internal Implementation Details)
// -----------------------------------------------------------------------------

/// Handles non-blocking, asynchronous polling of message channels from worker threads.
mod async_poll;
/// Delegates the final rendering of generated chunk data onto the Godot TileMap.
mod chunk_presenter;
/// Processes messages drained by the `AsyncPoller` and delegates to the `ChunkPresenter`.
mod channel_handler;
/// Contains utility structs and functions for initial configuration of the APIs.
mod api_initializers;
/// The exposed API for starting and configuring map generation from Godot.
mod generation_api;
/// The exposed API for controlling real-time tile animation and simulation.
mod animation_api;
/// ⭐ **NEW:** Contains the asynchronous worker for control panel UI flair animation.

// -----------------------------------------------------------------------------
// GDExtension Boilerplate
// -----------------------------------------------------------------------------

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::init::{ExtensionLibrary, InitLevel};


/// Placeholder struct required by the `godot-rust` library to implement
/// the `ExtensionLibrary` trait, which defines the dynamic library's behavior.
struct SSXLExtension;

/// Implements the required trait for the GDExtension to be loaded.
/// This acts as the **primary entry point** for the Godot runtime.
///
/// NOTE: The `gde_api_defs.rs` file handles the class registration (like `SSXLEngine`),
/// while this block handles the low-level library initialization hooks.
#[gdextension]
unsafe impl ExtensionLibrary for SSXLExtension {
    /// Called by Godot when a new initialization level is reached.
    /// This hook is used for potential setup that needs to occur before/after
    /// the game engine, editor, or scene is initialized.
    fn on_level_init(_level: InitLevel) {
        // Currently, no actions are required at this low-level init stage,
        // as setup is handled in `SSXLEngine::_init` and `_ready`.
    }

    // `on_level_deinit` is implicitly handled or omitted if no cleanup is needed.
}
>>> FILE END: rust\ssxl_godot\src\lib.rs <<<

======================================================
======================================================
//! # SSXLEngine (The Core Orchestrator)
//!
//! This minimal module defines the `SSXLEngine` Godot class. Its sole focus is **orchestration**
//! and **lifecycle management**. All complex logic for thread initialization, API access,
//! and scene manipulation is strictly delegated to specialized components, resulting in
//! a clean, fast main-thread component.

// --- Godot GDExtension Imports (Minimized) ---
use godot::prelude::*;
use godot::classes::{Node, TileMap};
use godot::obj::Base;
use godot::builtin::GString;

// --- Standard Library Imports (Synchronization) ---
use std::sync::{Arc, Mutex};

// --- Core Handles & State ---
use ssxl_generate::Conductor;
use ssxl_generate::conductor_state::ConductorState;
use ssxl_sync::AnimationConductorHandle;
use ssxl_sync::AnimationState;

// --- Local Crate Imports (Components & Delegates) ---
use crate::async_poll::AsyncPoller;
use crate::chunk_presenter::ChunkPresenter;
use crate::channel_handler::ChannelHandler;
use crate::api_initializers::EngineInitializer;
use crate::status_reporter::StatusReporter;
use crate::engine_api_extension::EngineApiExtension; // Trait providing delegated API methods


// -----------------------------------------------------------------------------
// SSXLEngine Struct Definition
// -----------------------------------------------------------------------------

/// The central Godot Node that holds the state and handles the orchestration.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLEngine {
    // --- Threaded Core Handles ---
    conductor: Option<Arc<Mutex<Conductor>>>,
    animation_conductor: Option<AnimationConductorHandle>,

    // --- State Accessors ---
    conductor_state: Option<ConductorState>,
    animation_state: Option<AnimationState>,

    // --- Godot Node References ---
    signals_node: Option<Gd<Node>>,
    tilemap_node: Option<Gd<TileMap>>,

    // --- Main-Thread System Components ---
    initializer: EngineInitializer,
    poller: AsyncPoller,
    presenter: ChunkPresenter,
    handler: ChannelHandler,

    #[base]
    base: Base<Node>,
}


// -----------------------------------------------------------------------------
// Internal Logic (Minimal Lifecycle Hooks)
// -----------------------------------------------------------------------------

impl SSXLEngine {
    pub fn init(base: Base<Node>) -> Self {
        // Initializes all internal components to their default/empty state.
        Self {
            conductor: None, animation_conductor: None,
            conductor_state: None, animation_state: None,
            signals_node: None, tilemap_node: None,
            initializer: EngineInitializer::new(),
            poller: AsyncPoller::new(),
            presenter: ChunkPresenter::new(),
            handler: ChannelHandler::new(),
            base,
        }
    }

    /// Centralized Core Initialization Logic (Delegates complexity to EngineInitializer)
    fn initialize_core(&mut self) -> bool {
        // Single call to retrieve all handles and states from a dedicated module.
        let (c, grx, gs, ah, arx, as_) = self.initializer.execute_core_setup(); 

        if c.is_none() || ah.is_none() { 
            godot_print!("CRITICAL ERROR: Failed to spawn Rust conductors.");
            return false;
        }

        // Store handles and configure main-thread pipeline.
        self.conductor = c; self.conductor_state = gs;
        self.animation_conductor = ah; self.animation_state = as_;
        self.poller.set_generation_receiver(grx);
        self.poller.set_animation_receiver(arx);
        self.handler.set_presenter_handle(self.presenter.clone());
        self.handler.set_signals_node(self.signals_node.clone());
        true
    }

    /// Drains the generation channel and updates the scene if new data is available.
    fn poll_generation(&mut self) {
        let gen_messages = self.poller.poll_generation_messages();

        if let Some(status_update) = self.handler.process_generation_messages_deferred(
            gen_messages,
            self.conductor.as_ref().map(|arc| arc.clone()),
        ) {
            // Inlined helper: Emit status signal on self.
            self.base_mut().emit_signal("status_updated", &[status_update.to_variant()]);
        }
    }
}


// -----------------------------------------------------------------------------
// Exposed Godot API (Minimal)
// -----------------------------------------------------------------------------

#[godot_api]
impl SSXLEngine {
    /// Godot `_ready` Hook: Called when the node enters the scene tree.
    #[func]
    pub fn _ready(&mut self) { self.initialize_core(); }

    // --- State and Status (Delegated) ---
    #[func]
    pub fn get_current_tile_count(&self) -> u64 {
        StatusReporter::get_current_tile_count_value(self.conductor_state.as_ref())
    }

    #[func]
    pub fn get_status(&self) -> GString {
        StatusReporter::get_status_report(
            self.conductor_state.as_ref(),
            self.animation_state.as_ref(),
        )
    }

    // --- Signals (Events exposed to Godot) (Unchanged) ---
    #[signal]
    fn status_updated(status_message: godot::prelude::GString);

    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);


    // --- Core Game Loop (CLEANED) ---
    /// Godot `_process` mapped function: Called every frame for updating.
    #[func]
    pub fn tick(&mut self, _current_tick: u64) {
        if self.conductor.is_none() && !self.initialize_core() {
            return;
        }
        
        // 1. Check for and render newly generated chunks.
        self.poll_generation();
        
        // 2. Check for, drain, and process real-time animation updates.
        // The Poller only drains messages; the Handler emits the signal to prevent main-thread lag.
        let anim_messages = self.poller.poll_animations();
        self.handler.process_animation_messages(anim_messages);
    }

    // --- API Delegation (Provided by EngineApiExtension trait implementation below) ---
    
    // --- Engine Configuration (Minimal Delegation) ---

    /// Sets the signals node. Delegation is to ChannelHandler.
    #[func]
    pub fn set_signals_node(&mut self, signals_node: Gd<Node>) {
        self.signals_node = Some(signals_node.clone());
        self.handler.set_signals_node(Some(signals_node));
    }

    /// Sets the target TileMap node. Delegation is to ChunkPresenter.
    #[func]
    pub fn set_tilemap(&mut self, tilemap_node: Gd<TileMap>) {
        self.tilemap_node = Some(tilemap_node.clone());
        self.presenter.set_tilemap_node(tilemap_node.clone());
    }

    /// Safely shuts down the multi-threaded conductors and clears resources.
    #[func]
    pub fn shutdown_engine(&mut self) {
        self.initializer.shutdown(self.animation_conductor.take(), self.conductor.take());
        self.poller.clear_receivers();
    }
}

// -----------------------------------------------------------------------------
// Trait Implementation: Brings back the public API functionality without the bulk.
// -----------------------------------------------------------------------------
impl EngineApiExtension for SSXLEngine {}
>>> FILE END: rust\ssxl_godot\src\ssxl_engine.rs <<<

======================================================
======================================================
// ssxl_godot/src/SSXL_oracle.rs

//! # SSXLOracle
//!
//! This module defines the `SSXLOracle` Godot class, an optional, **decoupled manager**
//! responsible for driving the main `SSXLEngine` update loop. It provides an explicit
//! clock (`tick` method) for precise control, which is essential for deterministic
//! simulation or fixed-timestep game loops. It serves as a query endpoint for engine state.

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;
use godot::obj::{Base, Gd};

// --- Local Crate Imports ---
use crate::ssxl_engine::SSXLEngine;


// -----------------------------------------------------------------------------
// SSXLOracle Struct Definition
// -----------------------------------------------------------------------------

/// # SSXLOracle
///
/// A Godot class that acts as the external driver and observer of the SSXL system.
#[derive(GodotClass)]
#[class(tool, base = Node, init)]
pub struct SSXLOracle {
    /// The base field required for the Godot GDExtension class implementation.
    #[base]
    base: Base<Node>,

    /// A reference to the core `SSXLEngine` instance it controls.
    /// This connection allows the Oracle to explicitly call the engine's `tick` function.
    engine: Option<Gd<SSXLEngine>>,

    /// Internal counter for the number of times the engine has been updated.
    tick_count: u64,
}

impl SSXLOracle {
    /// Custom constructor logic called when the Godot node is created.
    pub fn init(base: Base<Node>) -> Self {
        Self {
            base,
            engine: None,
            tick_count: 0
        }
    }
}


// -----------------------------------------------------------------------------
// Exposed Godot API (Methods callable from GDScript/C#)
// -----------------------------------------------------------------------------

#[godot_api]
impl SSXLOracle {

    /// **Godot `_ready` Hook:** Initializes the Oracle upon entering the scene tree.
    #[func]
    fn _ready(&mut self) {
        godot_print!("🔮 SSXLOracle (v8.2) is online. I await the ignition.");
        self.base_mut().set_process(true);
    }

    /// Establishes the link between the Oracle and the `SSXLEngine` instance.
    /// This is mandatory before calling `tick`.
    #[func]
    pub fn set_engine(&mut self, engine: Gd<SSXLEngine>) {
        self.engine = Some(engine);
        godot_print!("🔗 Oracle: Engine link established.");
    }

    /// Drives the core game loop for the `SSXLEngine`, sending the current
    /// tick count as the time delta/update indicator. This dictates the system's **tempo**.
    #[func]
    pub fn tick(&mut self) {
        match self.engine.as_mut() {
            Some(engine) => {
                // CLEANUP: Use direct method call for type-safety and performance.
                engine.bind_mut().tick(self.tick_count);

                godot_print!("🔮 Oracle: Tick {} → Engine", self.tick_count);
                self.tick_count += 1;
            }
            None => {
                godot_warn!("⚠️ Oracle: No engine linked. Tick aborted.");
            }
        }
    }

    /// ⭐ **FIX FOR ANIMATION:** Retrieves the total number of tiles placed by the engine.
    /// This is called by the GDScript animation timer to poll generation progress.
    #[func]
    pub fn get_total_tiles_placed(&self) -> i64 {
        match self.engine.as_ref() {
            Some(engine) => {
                // CRITICAL: Call the SSXLEngine FFI method to safely read the atomic/shared progress state.
                // NOTE: SSXLEngine MUST implement `get_current_tile_count` to fetch this data.
                engine.bind().get_current_tile_count() as i64
            }
            None => {
                0
            }
        }
    }
    
    /// Simple diagnostics function for checking if the Oracle is reachable.
    #[func]
    pub fn ping(&self) {
        godot_print!("🔮 Oracle: Ping received. I am awake.");
    }

    /// Resets the internal tick counter.
    #[func]
    pub fn reset(&mut self) {
        self.tick_count = 0;
        godot_print!("🔄 Oracle: Tick counter reset.");
    }

    /// Retrieves the current tick count.
    #[func]
    pub fn get_tick(&self) -> u64 {
        self.tick_count
    }
}
>>> FILE END: rust\ssxl_godot\src\ssxl_oracle.rs <<<

======================================================
======================================================
// ssxl_godot/src/ssxl_signals.rs

//! # SSXLSignals (Communications Hub)
//!
//! Defines a simple, stateless Godot class (`SSXLSignals`) used exclusively
//! to house and expose engine signals to Godot's scripting environment (GDScript/C#).

// --- Godot GDExtension Imports ---
use godot::prelude::*;
use godot::classes::Node;
use godot::obj::Base;

// -----------------------------------------------------------------------------
// SSXLSignals Struct Definition
// -----------------------------------------------------------------------------

/// SSXLSignals: A simple, stateless Node class for defining and emitting custom engine signals.
#[derive(GodotClass)]
#[class(tool, base=Node, init)]
pub struct SSXLSignals {
    /// Base field required for the GDExtension class implementation.
    #[base]
    base: Base<Node>,
}

// -----------------------------------------------------------------------------
// Godot API (Signal Definitions)
// -----------------------------------------------------------------------------

#[godot_api]
impl SSXLSignals {
    /// Constructor logic.
    pub fn init(base: Base<Node>) -> Self {
        SSXLSignals { base }
    }

    // --- Generation Lifecycle Signals ---

    /// Emitted when the engine receives a `build_map` command and starts processing.
    #[signal]
    fn build_map_start();

    /// Emitted when a single **chunk** has finished generation on a worker thread.
    /// Args: x (i32), y (i32)
    #[signal]
    fn chunk_generated(x: i32, y: i32);

    /// Emitted when the entire map generation task has finished.
    #[signal]
    fn build_map_complete();

    /// Emitted when a critical, non-recoverable error occurs during generation.
    /// Args: error_message (GString)
    #[signal]
    fn generation_error(error_message: godot::prelude::GString);

    // --- Animation & Utility Signals ---

    /// CRITICAL: Emitted when a single tile's state flips (e.g., collapsed).
    /// Used to queue animation frames without blocking the engine's generation speed.
    /// Args: tile_id (i32), flip_frame (i32)
    #[signal]
    fn tile_flip_updated(tile_id: i32, flip_frame: i32);

    /// Emitted for high-level animation or loading updates.
    /// Args: percent_done (f32), new_atlas_coords (Vector2i)
    #[signal]
    fn animation_update(percent_done: f32, new_atlas_coords: godot::builtin::Vector2i);

    /// **FIXED:** Emitted periodically to update the Godot client on the engine's internal status (e.g., worker queue size).
    /// Args: status_message (GString)
    #[signal]
    fn engine_status_updated(status_message: godot::prelude::GString);
}
>>> FILE END: rust\ssxl_godot\src\ssxl_signals.rs <<<

======================================================
======================================================
use godot::prelude::GString;
// Assuming these internal state structures are publically accessible or have accessor traits.
use ssxl_generate::conductor_state::ConductorState;
use ssxl_sync::AnimationState;

/// # StatusReporter
/// 
/// A stateless utility struct responsible for querying the various core states
/// (Generation, Animation) and compiling human-readable status reports
/// for the Godot scripting layer.
pub struct StatusReporter;

impl StatusReporter {
    /// Constructs a new, human-readable status string combining the state of
    /// the Generation and Animation cores.
    /// 
    /// This removes complex string formatting logic from SSXLEngine.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    /// * `anim_state` - Read-only reference to the Animation process state.
    /// 
    /// # Returns
    /// A Godot `GString` containing the formatted status message.
    pub fn get_status_report(
        gen_state: Option<&ConductorState>,
        anim_state: Option<&AnimationState>,
    ) -> GString {
        let gen_status = gen_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let anim_status = anim_state
            .map(|state| format!("{:?}", state.get_status()))
            .unwrap_or_else(|| String::from("Uninitialized"));

        let status = format!(
            "STATUS: Generation: {} | Animation: {}", 
            gen_status, 
            anim_status
        );

        GString::from(status.as_str())
    }

    /// Retrieves the total number of tiles placed by the engine during generation.
    /// 
    /// # Arguments
    /// * `gen_state` - Read-only reference to the Generation process state.
    pub fn get_current_tile_count_value(gen_state: Option<&ConductorState>) -> u64 {
        gen_state
            .map(|state| state.get_tiles_placed())
            // Fails gracefully to 0 if the core is not yet initialized.
            .unwrap_or(0)
    }
}
>>> FILE END: rust\ssxl_godot\src\status_reporter.rs <<<

======================================================
======================================================
[package]
name = "ssxl_math"
version = "0.1.0"
edition.workspace = true

[dependencies]
# Internal dependencies (Local Crates)

# External dependencies (Workspace-Inherited)
# FIX: Explicitly re-enable the 'serde' feature for glam.
# This ensures IVec3 implements Serialize/Deserialize, resolving the E0277 errors.
glam = { workspace = true, features = ["serde"] }
serde = { workspace = true }
thiserror = { workspace = true } # Added for defining local crate Result type
tracing = { workspace = true }
sha2 = { workspace = true }
rand = { workspace = true }
rand_pcg = { workspace = true }
>>> FILE END: rust\ssxl_math\Cargo.toml <<<

======================================================
======================================================
// ssxl_math/src/coordinate_system.rs

//! # Coordinate System
//!
//! Defines the core coordinate types for the SSXL-ext engine, using 64-bit integers (`I64Vec3`)
//! to support extremely large, virtually infinite world dimensions.
//!
//! This module implements the crucial logic for converting a global `WorldPos` into its
//! localized `(ChunkKey, TileOffset)` components, ensuring mathematical correctness
//! even for large **negative coordinates** through the use of Euclidean division.

use serde::{Serialize, Deserialize};
use crate::primitives::CHUNK_SIZE_I64;
use glam::I64Vec3;


// -----------------------------------------------------------------------------
// Core Coordinate Types
// -----------------------------------------------------------------------------

/// Represents a specific point in the vast 3D world space.
/// The underlying `I64Vec3` ensures the system can handle coordinates well beyond i32 limits.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WorldPos(pub I64Vec3);

/// The unique identifier for a 3D chunk.
/// This acts as the *base coordinate* for a 32x32x32 (or `CHUNK_SIZE`) cubic volume of the world.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkKey(pub I64Vec3);

/// The local position of a tile *within* its parent chunk.
/// Coordinates are always non-negative and range from `[0, CHUNK_SIZE - 1]`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TileOffset(pub I64Vec3);


// -----------------------------------------------------------------------------
// WorldPos Implementation
// -----------------------------------------------------------------------------

impl WorldPos {
    /// Converts a global `WorldPos` into its discrete `ChunkKey` and local `TileOffset` components.
    ///
    /// This conversion is robust against **negative world coordinates** by using
    /// `rem_euclid`, which guarantees the `TileOffset` is always positive (or zero).
    pub fn to_chunk_coords(&self) -> (ChunkKey, TileOffset) {

        let chunk_size = CHUNK_SIZE_I64;

        // 1. Calculate the Tile Offset (Local Position)
        // `rem_euclid` ensures the remainder is always non-negative, correctly wrapping
        // negative world coordinates (e.g., -1 rem_euclid 32 = 31).
        let tile_x = self.0.x.rem_euclid(chunk_size);
        let tile_y = self.0.y.rem_euclid(chunk_size);
        let tile_z = self.0.z.rem_euclid(chunk_size);

        // 2. Calculate the Chunk Key (Chunk Index)
        // The chunk index is calculated by subtracting the tile offset (remainder)
        // and then performing simple integer division. This is the correct Euclidean
        // division for finding the quotient (chunk index).
        let chunk_x = (self.0.x - tile_x) / chunk_size;
        let chunk_y = (self.0.y - tile_y) / chunk_size;
        let chunk_z = (self.0.z - tile_z) / chunk_size;

        let chunk_key = ChunkKey(I64Vec3::new(chunk_x, chunk_y, chunk_z));
        let tile_offset = TileOffset(I64Vec3::new(tile_x, tile_y, tile_z));

        (chunk_key, tile_offset)
    }
}

// -----------------------------------------------------------------------------
// ChunkKey Implementation
// -----------------------------------------------------------------------------

impl ChunkKey {
    /// Reconstructs the original `WorldPos` from the `ChunkKey` and `TileOffset`.
    ///
    /// This is the inverse operation, verifying the idempotence of the coordinate system.
    pub fn to_world_pos(&self, offset: TileOffset) -> WorldPos {
        let chunk_size = CHUNK_SIZE_I64;

        // Formula: World = (Chunk Index * Chunk Size) + Tile Offset
        let world_x = self.0.x * chunk_size + offset.0.x;
        let world_y = self.0.y * chunk_size + offset.0.y;
        let world_z = self.0.z * chunk_size + offset.0.z;

        WorldPos(I64Vec3::new(world_x, world_y, world_z))
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use glam::I64Vec3;

    // NOTE: CHUNK_SIZE_I64 is assumed to be 32 for these tests.

    #[test]
    /// Tests conversion for a very large positive coordinate, confirming I64 robustness.
    fn test_world_to_chunk_positive() {
        let huge_coord = 5_000_000_000i64; // Well over i32::MAX
        let expected_chunk_key = huge_coord / CHUNK_SIZE_I64; // 156,250,000
        let expected_offset = huge_coord % CHUNK_SIZE_I64; // 0

        let pos = WorldPos(I64Vec3::new(huge_coord, 10, 64));
        let (key, offset) = pos.to_chunk_coords();

        // 64 / 32 = 2 (chunk key), 64 rem_euclid 32 = 0 (offset)
        assert_eq!(key.0, I64Vec3::new(expected_chunk_key, 0, 2), "ChunkKey failed for i64 coord");
        assert_eq!(offset.0, I64Vec3::new(expected_offset, 10, 0), "TileOffset failed for i64 coord");
    }

    #[test]
    /// CRUCIAL test for negative coordinates, verifying the Euclidean division logic.
    fn test_world_to_chunk_negative_crucial() {
        // Test case 1: (-1, -1, -1)
        // Expected: Chunk index should be -1. Offset should be 31 (32 - 1).
        let pos = WorldPos(I64Vec3::new(-1, -1, -1));
        let (key, offset) = pos.to_chunk_coords();

        assert_eq!(key.0, I64Vec3::new(-1, -1, -1), "ChunkKey for -1 failed to be -1");
        assert_eq!(offset.0, I64Vec3::new(31, 31, 31), "TileOffset for -1 failed to be 31");

        // Test case 2: (-33, -64, -100)
        // X: -33 rem 32 = 31, (-33 - 31)/32 = -2.
        // Y: -64 rem 32 = 0, (-64 - 0)/32 = -2.
        // Z: -100 rem 32 = 28, (-100 - 28)/32 = -4.
        let pos_deep = WorldPos(I64Vec3::new(-33, -64, -100));
        let (key_deep, offset_deep) = pos_deep.to_chunk_coords();

        assert_eq!(key_deep.0, I64Vec3::new(-2, -2, -4), "Deep negative ChunkKey failed");
        assert_eq!(offset_deep.0, I64Vec3::new(31, 0, 28), "Deep negative TileOffset failed");
    }

    #[test]
    /// Tests that converting a WorldPos to (ChunkKey, TileOffset) and back results in the original WorldPos.
    fn test_round_trip() {
        let original_pos = WorldPos(I64Vec3::new(-9_876_543_210, 456, -789));

        let (key, offset) = original_pos.to_chunk_coords();

        let final_pos = key.to_world_pos(offset);

        assert_eq!(original_pos, final_pos, "WorldPos to ChunkKey and back must be idempotent with i64");
    }
}
>>> FILE END: rust\ssxl_math\src\coordinate_system.rs <<<

======================================================
======================================================
// ssxl_math/src/generation_utils.rs

//! # Generation Utilities
//!
//! Provides common mathematical and random-sampling utilities used throughout the
//! procedural generation pipeline (e.g., `ssxl_generate` crate).
//!
//! Functions here are designed for rapid, stateless generation logic, such as
//! calculating percentage chance rolls and generating unique identifiers for data structures.

use crate::primitives::SSXLData;
use rand::Rng;

// -----------------------------------------------------------------------------
// Randomness and Chance Utilities
// -----------------------------------------------------------------------------

/// Rolls a chance check against a given percentage.
///
/// This function is vital for injecting controlled **randomness** and **balance**
/// into the generation process (e.g., probability of a resource spawning, or a
/// cellular automata rule firing).
///
/// # Arguments
/// * `target_percent` - The probability of success, expressed as a whole percentage (0-100).
///
/// # Returns
/// * `0`: Success (The random number was less than `target_percent`).
/// * `1`: Failure (The random number was greater than or equal to `target_percent`).
///
/// # Example
/// A 25% chance of spawning:
/// ```ignore
/// if generate_percent_roll(25) == 0 {
///     // spawn item
/// }
/// ```
pub fn generate_percent_roll(target_percent: u8) -> u32 {
    // Generate a random value in the inclusive range [0, 99], which is a 0-100 scale.
    let rand_val = rand::thread_rng().gen_range(0..100) as u8;

    // Success occurs if the random value falls within the target range.
    if rand_val < target_percent {
        0 // Success / Hit
    } else {
        1 // Failure / Miss
    }
}

// -----------------------------------------------------------------------------
// Data Processing Utilities
// -----------------------------------------------------------------------------

/// Processes an object implementing the `SSXLData` trait to derive a simple aggregate identifier.
///
/// This is a basic utility that combines the object's unique ID with its data payload size.
/// It is often used for creating quick, unique signatures or simple hashing/checksums
/// for data chunks across worker threads.
///
/// # Arguments
/// * `data` - A reference to any structure that implements the `SSXLData` trait.
///
/// # Returns
/// * `u64` - The sum of the data's ID and the length of its associated value.
pub fn process_data(data: &impl SSXLData) -> u64 {
    // Combine the inherent ID (u64) with the value length (u64 after casting).
    let processed_value = data.get_id() + data.get_value_len() as u64;
    processed_value
}
>>> FILE END: rust\ssxl_math\src\generation_utils.rs <<<

======================================================
======================================================

// ssxl_math/src/hashing.rs

/// # Hashing Utilities for SSXL-ext
///
/// This module provides **deterministic, collision-resistant** hashing functions
/// essential for identifying and retrieving procedural data.
///
/// Hashing is crucial for:
/// 1.  Generating unique, stable IDs for **world chunks** based on their coordinates.
/// 2.  Creating cache keys for **generated content** to ensure persistence and integrity.
use crate::primitives::SSXLResult;
use glam::I64Vec3;
use sha2::{Digest, Sha256};

/// Generates a **deterministic SHA-256 hash** for a given 3D chunk coordinate.
///
/// This hash is used as a unique identifier (a key) for world chunks, ensuring that
/// the same coordinate always yields the identical hash string, which is crucial
/// for cache lookups and procedural generation stability.
///
/// # Arguments
///
/// * `coords` - The 3D world coordinate of the chunk, using 64-bit integers (`I64Vec3`)
///              to support extremely large, dimension-agnostic worlds.
///
/// # Returns
///
/// A `SSXLResult<String>` containing the 64-character hexadecimal SHA-256 hash.
pub fn hash_chunk_coords(coords: I64Vec3) -> SSXLResult<String> {
    // 1. Serialize the coordinates into a canonical string format (e.g., "100:5:25").
    // This fixed format ensures deterministic input for the hash function.
    let coord_string = format!("{}:{}:{}", coords.x, coords.y, coords.z);

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(coord_string.as_bytes());
    let result = hasher.finalize();

    // 3. Convert the hash bytes into a lowercase 64-character hexadecimal string.
    Ok(format!("{:x}", result))
}

/// Generates a **deterministic SHA-256 hash** for a generic 64-bit data key.
///
/// This is typically used to create unique cache keys for generated content or
/// assets, prefixed with `"content_"` for easy identification in the cache system
/// (`ssxl_cache`).
///
/// # Arguments
///
/// * `data_key` - A generic `u64` identifier for the content (e.g., a seed,
///                a configuration ID, or a tile type index).
///
/// # Returns
///
/// A `SSXLResult<String>` containing the hash prefixed with `"content_"`.
pub fn hash_content_data(data_key: u64) -> SSXLResult<String> {
    // 1. Convert the u64 key into a string.
    let key_string = data_key.to_string();

    // 2. Compute the SHA-256 hash.
    let mut hasher = Sha256::new();
    hasher.update(key_string.as_bytes());
    let result = hasher.finalize();

    // 3. Format the result with the required "content_" prefix.
    Ok(format!("content_{:x}", result))
}


/// Unit tests to ensure the hashing functions are **deterministic** and produce
/// the expected **format** and **uniqueness** required for stable world generation.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// Tests that the same coordinates always produce the identical hash (determinism).
    fn test_chunk_coords_determinism() {
        let coords = I64Vec3::new(3_000_000_000, -5, 100);
        let hash1 = hash_chunk_coords(coords).unwrap();
        let hash2 = hash_chunk_coords(coords).unwrap();

        assert_eq!(hash1, hash2, "Deterministic hashing failed: hashes must be identical for same input.");
    }

    #[test]
    /// Tests the expected hash length (64 chars) and confirms that a small coordinate change
    /// results in a completely different hash (uniqueness/avalanche effect).
    fn test_chunk_coords_uniqueness_and_format() {
        let coords1 = I64Vec3::new(1, 1, 1);
        let coords2 = I64Vec3::new(1, 1, 2); // Only Z differs
        let hash1 = hash_chunk_coords(coords1).unwrap();
        let hash2 = hash_chunk_coords(coords2).unwrap();

        assert_eq!(hash1.len(), 64, "Chunk hash is not the expected SHA-256 hex length (64).");
        assert_ne!(hash1, hash2, "Uniqueness failed: adjacent coordinates produced same hash.");
    }

    #[test]
    /// Tests determinism, the 'content_' prefix, and the total expected length (72 chars).
    fn test_content_data_determinism_and_format() {
        let key: u64 = 987654321;

        let hash1 = hash_content_data(key).unwrap();
        let hash2 = hash_content_data(key).unwrap();

        assert_eq!(hash1, hash2, "Content hash determinism failed.");

        assert!(hash1.starts_with("content_"), "Content hash is missing the 'content_' prefix.");
        // 'content_' (8 chars) + SHA-256 hex (64 chars) = 72
        assert_eq!(hash1.len(), 8 + 64, "Content hash is not the expected total length (72).");
    }
}
>>> FILE END: rust\ssxl_math\src\hashing.rs <<<

======================================================
======================================================
// ssxl_math/src/lib.rs

//! # SSXL Math Crate (`ssxl_math`)
//!
//! This crate contains the core mathematical utilities, data structures, and coordinate
//! system logic required by the SSXL-ext procedural generation engine.
//!
//! Key functionalities include:
//! - **Coordinate System:** Defining world and chunk positions (`ChunkKey`, `WorldPos`).
//! - **Hashing:** Deterministic generation of unique chunk and content identifiers.
//! - **Primitives:** Shared types and result wrappers (`SSXLResult`, `Vec2i`).

// --- Module Declarations ---

/// Defines the global and local coordinate system structures (`ChunkKey`, `WorldPos`).
pub mod coordinate_system;

/// Houses various utility functions for procedural generation algorithms.
pub mod generation_utils;

/// Provides deterministic hashing functions (e.g., `hash_chunk_coords`).
pub mod hashing;

/// Core mathematical primitives, custom types, and error handling results.
pub mod primitives;

// --- Public Re-exports (The Main Crate API) ---

// Re-export key coordinate types for direct use by other SSXL-ext crates.
pub use coordinate_system::{ChunkKey, TileOffset, WorldPos};

// Re-export core functions and utilities.
pub use crate::generation_utils::process_data;

// Re-export essential primitives and type aliases.
pub use crate::primitives::Vec2i;
pub use crate::primitives::SSXLData;
pub use crate::primitives::SSXLResult;
pub use crate::primitives::TileCoord; // ⭐ FIXED: Changed 'crate primitives' to 'crate::primitives'

// --- Prelude for Internal Engine Use ---

/// A convenience module that re-exports all essential types and traits
/// from the `ssxl_math` crate.
///
/// Crates in the SSXL-ext project are encouraged to use `use ssxl_math::prelude::*`
/// to easily import the most commonly needed math components. This adheres to the
/// common Rust practice for making libraries ergonomic.
pub mod prelude {
    pub use super::coordinate_system::*;
    pub use super::generation_utils::*;
    pub use super::hashing::*;
    pub use super::primitives::*;
}

// --- Initialization Function ---

/// Initializes the SSXL Math system.
///
/// Currently, this only logs an informational message. It acts as a potential
/// future hook for any necessary global math configuration or setup checks.
pub fn initialize_math_system() {
    tracing::info!("SSXL Math system initialized and ready.");
}
>>> FILE END: rust\ssxl_math\src\lib.rs <<<

======================================================
======================================================
//! # Primitives Module (`ssxl_math::primitives`)
//!
//! Defines the essential, low-level data types, type aliases, traits, and global
//! constants used throughout the SSXL-ext procedural generation engine.

use serde::{Deserialize, Serialize};

// --- Data Structures ---

/// A 2D vector for integer coordinates, typically used for tile offsets or local
/// coordinate mapping within a chunk.
///
/// Uses `i64` to maintain compatibility with the large coordinate space of `I64Vec3`
/// from the `glam` crate, preventing silent overflow issues.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Vec2i {
    /// The X component of the 2D vector.
    pub x: i64,
    /// The Y component of the 2D vector.
    pub y: i64,
}

impl Vec2i {
    /// Creates a new `Vec2i` instance.
    pub fn new(x: i64, y: i64) -> Self {
        Vec2i { x, y }
    }
}

// --- Type Aliases ---

/// A specialized `Result` type for the SSXL-ext project.
///
/// The error type is fixed as `String`, providing a simple, high-level way to
/// convey error messages across the engine's various crates (e.g., from
/// generation logic to the Godot FFI layer).
pub type SSXLResult<T> = Result<T, String>;

/// ⭐ **FIX**: The standard 2D coordinate type for referencing a tile in the world
/// or within a chunk. Aliased to `Vec2i`.
pub type TileCoord = Vec2i; 

// --- Traits for Engine Data Management ---

/// A trait defining the requirements for any data structure that will be managed
/// or processed by the SSXL engine (e.g., in the task queue or cache).
///
/// The bounds `Send + Sync` are mandatory, ensuring that all implementors can be
/// safely sent between worker threads and shared across thread boundaries—a necessity
/// for the engine's high-performance multithreaded design.
pub trait SSXLData: Send + Sync {
    /// Retrieves a unique 64-bit ID for the data. Used primarily for cache keys
    /// and tracking within the `task_queue`.
    fn get_id(&self) -> u64;

    /// Returns the length or size of the data's core value in bytes or elements.
    /// Used for diagnostics, memory management, or processing limits.
    fn get_value_len(&self) -> usize;
}

// --- Global Constants ---

/// The canonical side length of a procedural chunk in the world.
///
/// This value is cast to `i64` to match the coordinate system of the engine,
/// ensuring consistent type usage for chunk-related calculations.
pub const CHUNK_SIZE_I64: i64 = 32;

/// A small constant used for floating-point comparisons to account for
/// precision errors (e.g., in perlin noise interpolation or physics-related math).
pub const F32_EPSILON: f32 = 1.0e-6;
>>> FILE END: rust\ssxl_math\src\primitives.rs <<<

======================================================
======================================================
[package]
name = "ssxl_shared"
version = "0.6.0" # Standardized version number
edition = "2021"

[dependencies]
ssxl_math = { path = "../ssxl_math" }
# Internal dependencies (Local Crates)
serde       = { workspace = true }
serde-big-array  = { workspace = true }
bincode     = { workspace = true }
thiserror   = { workspace = true }
anyhow      = { workspace = true }

# External dependency (Workspace-Inherited)
tracing     = { workspace = true }

>>> FILE END: rust\ssxl_shared\cargo.toml <<<

======================================================
======================================================
// ssxl_shared\src\chunk_data.rs 

//! # Chunk Data Structures (`ssxl_shared::chunk_data`)
//!
//! This module defines the `ChunkData` structure, which represents a single,
//! fixed-size block of the procedural world. It includes coordinates, bounds,
//! the array of tiles, and metadata about its generation. This is the atomic
//! unit of data shared between generation workers and the cache/Godot runtime,
//! forming the basis of the engine's "crypto coded memory."

use serde::{Deserialize, Serialize};
use std::time::SystemTime;

use crate::grid_bounds::GridBounds;
use crate::tile_data::TileData;
// Imports the custom Serde helper for deterministic SystemTime serialization.
use crate::math_primitives;

// Re-exports a core math primitive for chunk coordinates.
use ssxl_math::Vec2i;

// Used to enable serialization/deserialization of arrays larger than 32 elements
// by the serde framework (necessary for the 1024-tile array).
use serde_big_array::BigArray;

// --- Constants ---

/// The canonical side length of a chunk (e.g., 32x32 tiles), defined as a public constant.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles in a single chunk (32 * 32 = 1024).
const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;


// --- Coordinate Structure ---

/// Defines the **chunk-space** coordinates (e.g., Chunk [1, 5] on the world grid).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ChunkCoords {
    pub x: i64,
    pub y: i64,
}


// --- Core Data Structure ---

/// The central data structure for a world chunk. This is the primary payload
/// for procedural generation tasks and caching.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChunkData {
    /// A unique, deterministic identifier for this chunk.
    pub id: u64,
    /// The world-space bounding box of the chunk, using the half-open range convention.
    pub bounds: GridBounds,
    /// The fixed-size array containing all tiles within the chunk.
    #[serde(with = "BigArray")]
    pub tiles: [TileData; TILE_ARRAY_SIZE],
    /// A string tag identifying the dimension or layer this chunk belongs to.
    pub dimension_tag: String,
    /// Timestamp indicating when the chunk was generated (serialized deterministically).
    #[serde(with = "math_primitives::system_time_serde")]
    pub generated_at: SystemTime,
}


impl ChunkData {
    /// Re-export of the canonical chunk size as an associated constant for use in methods.
    pub const SIZE: u32 = CHUNK_SIZE;

    /// Creates a new `ChunkData` instance using explicit, pre-calculated parameters.
    pub fn new(id: u64, bounds: GridBounds, dimension_tag: String) -> Self {
        // Initialize the tile array with default (empty) TileData.
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];
        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag,
            generated_at: SystemTime::now(),
        }
    }
    
    /// Creates a new `ChunkData` instance by calculating its bounds and generating
    /// an initial ID based solely on its chunk coordinates.
    pub fn new_at_coords(chunk_coords: Vec2i) -> Self {
        let chunk_size_i64 = Self::SIZE as i64;
        
        // 1. Calculate the world-space minimum coordinates (inclusive).
        let min_x = chunk_coords.x * chunk_size_i64;
        let min_y = chunk_coords.y * chunk_size_i64;
        
        // 2. Calculate the world-space maximum coordinates (exclusive, half-open range).
        // Max is Min + Size (e.g., Min 0, Size 32 -> Max 32).
        let max_x = min_x + chunk_size_i64;
        let max_y = min_y + chunk_size_i64;

        let bounds = GridBounds::new(min_x, min_y, max_x, max_y);
        
        // 3. Generate a reasonably unique ID by bit-shifting/ORing the two 64-bit coordinates.
        // NOTE: This improved formula is still inferior to a proper SHA-256 hash
        // from ssxl_math::hashing::hash_chunk_coords, but is better than a simple XOR.
        let id = (chunk_coords.x as u64) | ((chunk_coords.y as u64) << 32);
        let tiles = [TileData::default(); TILE_ARRAY_SIZE];

        ChunkData {
            id,
            bounds,
            tiles,
            dimension_tag: "Default".to_string(),
            generated_at: SystemTime::now(),
        }
    }

    /// Internal helper to convert local tile coordinates (x, y) within the chunk
    /// into a flat array index.
    ///
    /// This is marked `#[inline(always)]` for **performance optimization**
    /// as it's called repeatedly during generation loops.
    ///
    /// Returns `None` if the coordinates are out of the [0, CHUNK_SIZE - 1] range.
    #[inline(always)]
    fn coord_to_index(x: u32, y: u32) -> Option<usize> {
        if x < Self::SIZE && y < Self::SIZE {
            // Index = Y * Width + X (standard row-major order)
            Some((y * Self::SIZE + x) as usize)
        } else {
            None
        }
    }

    /// Safely retrieves an immutable reference to a tile at the given local coordinates.
    pub fn get_tile(&self, x: u32, y: u32) -> Option<&TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &self.tiles[index]
        })
    }
    
    /// Inserts a fully generated vector of tiles into the chunk's internal array.
    ///
    /// # Panics
    /// Panics if the input vector's length does not exactly match the expected
    /// `TILE_ARRAY_SIZE`, which is a critical **data integrity** check.
    pub fn insert_tiles(&mut self, tiles_vec: Vec<TileData>) {
        if tiles_vec.len() == TILE_ARRAY_SIZE {
            // Efficiently copy the data from the vector into the fixed-size array.
            self.tiles.clone_from_slice(&tiles_vec);
        } else {
            // Critical error: A generator produced an incomplete or oversized chunk.
            panic!(
                "Tile vector size mismatch for chunk {:?}. Generator returned {} tiles, but expected {}.",
                self.bounds,
                tiles_vec.len(),
                TILE_ARRAY_SIZE
            );
        }
    }
    
    /// Safely retrieves a mutable reference to a tile at the given local coordinates.
    pub fn get_tile_mut(&mut self, x: u32, y: u32) -> Option<&mut TileData> {
        Self::coord_to_index(x, y).map(|index| {
            &mut self.tiles[index]
        })
    }
}

// --- Unit Tests ---

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// Tests the critical coordinate-to-index logic for boundaries and center.
    fn test_coord_to_index() {
        // Top-left corner
        assert_eq!(ChunkData::coord_to_index(0, 0), Some(0));

        // Center (16, 16) -> 16 * 32 + 16 = 528
        assert_eq!(ChunkData::coord_to_index(16, 16), Some(528));

        // Bottom-right corner (31, 31) -> 31 * 32 + 31 = 1023 (TILE_ARRAY_SIZE - 1)
        assert_eq!(ChunkData::coord_to_index(31, 31), Some(1023));

        // Out of bounds checks (32 is the exclusive size limit)
        assert_eq!(ChunkData::coord_to_index(32, 0), None);
        assert_eq!(ChunkData::coord_to_index(0, 32), None);
        assert_eq!(ChunkData::coord_to_index(33, 33), None);
    }
}

>>> FILE END: rust\ssxl_shared\src\chunk_data.rs <<<

======================================================
======================================================
// ssxl_shared/src/config.rs

//! # Global Configuration Constants (`ssxl_shared::config`)
//!
//! This module defines fundamental, immutable constants that govern the structure
//! and scale of the SSXL procedural world. These values must be consistent
//! across all SSXL-ext crates (math, generate, cache, godot) to ensure data
//! integrity and system entropy is controlled.

// --- World Geometry Constants ---

/// The canonical side length of a procedural chunk in tiles.
///
/// **Value:** 32 (meaning chunks are 32x32 tiles).
///
/// This constant defines the resolution and granularity of the generated world
/// and is critical for both memory allocation and generation performance.
pub const CHUNK_SIZE: u32 = 32;

/// The total number of tiles contained within a single `ChunkData` structure.
///
/// **Calculation:** CHUNK_SIZE * CHUNK_SIZE (32 * 32 = 1024).
///
/// This value is used to define the fixed-size array in `ChunkData` and for
/// ensuring generators return the correct payload size.
pub const TILE_ARRAY_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize;
>>> FILE END: rust\ssxl_shared\src\config.rs <<<

======================================================
======================================================
// ssxl_shared/src/errors.rs

//! # SSXL Error Definitions (`ssxl_shared::errors`)
//!
//! This module defines the global, canonical error type for the entire SSXL-ext
//! procedural generation engine. Centralizing error handling ensures that failures
//! across different crates (math, generate, cache, godot) can be consistently
//! reported, managed, and debugged, particularly across FFI boundaries.

use thiserror::Error;

/// A specialized `Result` type for the SSXL-ext project.
///
/// All function calls that can fail within the SSXL ecosystem should return this
/// type, wrapping the concrete `SSXLError` enum.
pub type SSXLResult<T> = Result<T, SSXLError>;

/// The comprehensive enumeration of all possible errors within the SSXL-ext engine.
#[derive(Error, Debug)]
pub enum SSXLError {
    /// Wrapper for standard I/O errors (e.g., file system access, network issues).
    /// This variant automatically handles conversion from `std::io::Error`.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors encountered during data serialization (e.g., using Bincode or Serde).
    /// Indicates problems with converting data to or from a byte stream.
    #[error("Serialization/Data Error: {0}")]
    Serialization(String),

    /// Errors related to unexpected or invalid data states, such as a generator
    /// returning a tile array of the wrong size or an invalid chunk key.
    #[error("Data Consistency Error: {0}")]
    DataConsistency(String),

    /// Errors specific to the procedural generation pipeline (e.g., a generator
    /// failing to find a valid output after too many iterations).
    #[error("Generation Failure: {0}")]
    GenerationPipeline(String),

    /// Errors occurring in the Godot GDExtension bridge or FFI layer.
    /// Crucial for debugging communication issues between Rust and the Godot runtime.
    #[error("Interface Bridge Error: {0}")]
    InterfaceBridge(String),

    /// A critical, unexpected error indicating a bug in the core logic that
    /// should never occur under normal execution (a **"BUG!"**).
    #[error("Mythic Core Logic Failure (BUG!): {0}")]
    CoreLogicBug(String),

    /// Generic wrapper for errors originating from third-party libraries or crates
    /// that are not covered by other specific variants.
    #[error("External Crate Error: {0}")]
    External(String),
}


// --- Error Conversion Implementations ---

/// Implements conversion from the `bincode::Error` type into the SSXL `Serialization` error.
impl From<bincode::Error> for SSXLError {
    fn from(err: bincode::Error) -> Self {
        SSXLError::Serialization(format!("Bincode failure: {}", err))
    }
}

/// Implements conversion from the generic `anyhow::Error` type into the SSXL `External` error.
/// This provides a convenient way to integrate external library errors into the SSXL system.
impl From<anyhow::Error> for SSXLError {
    fn from(err: anyhow::Error) -> Self {
        // Use the debug message of the anyhow error to retain the source chain.
        SSXLError::External(format!("General anyhow error: {:?}", err))
    }
}
>>> FILE END: rust\ssxl_shared\src\errors.rs <<<

======================================================
======================================================
// ssxl_shared/src/generation_message.rs

//! # Generation Messaging (`ssxl_shared::generation_message`)
//!
//! This module defines the structures and enumerations used for communication
//! between the main **Conductor** thread and the asynchronous **Worker Threads**
//! (managed by the `RuntimeManager` in the `ssxl_generate` crate).
//!
//! These structures manage the flow of work requests (`GenerationTask`) and
//! completed results (`GenerationMessage`).

use crate::chunk_data::ChunkData;
use ssxl_math::Vec2i;
use std::sync::Arc;


// --- Work Request Structure ---

/// Defines a single unit of work (a task) to be processed by a worker thread.
///
/// This structure is put into the engine's `TaskQueue` by the `Conductor`.
#[derive(Debug, Clone)]
pub struct GenerationTask {
    /// The chunk-space coordinates of the chunk that needs to be generated.
    pub chunk_coords: Vec2i,
    /// The unique identifier of the generator to be used for this task (e.g., "cellular_automata").
    pub generator_id: String,
}


// --- Communication Message Enumeration ---

/// An enumeration of messages sent from the worker threads back to the
/// main thread or the Conductor to signal task completion or pipeline status.
#[derive(Debug)]
pub enum GenerationMessage {
    /// Signals that a chunk has been successfully generated.
    ///
    /// Uses `Arc<ChunkData>` (Atomic Reference Counted) to allow multiple parts
    /// of the engine (e.g., the cache and the Godot presenter) to hold a reference
    /// to the generated data simultaneously without deep copying, which is critical
    /// for high-performance data sharing.
    ChunkGenerated(Vec2i, Arc<ChunkData>),

    /// Signals that all current tasks related to a specific generation batch
    /// or request have been finalized. Used by the `Conductor` to update
    /// the generation state.
    GenerationComplete,
}
>>> FILE END: rust\ssxl_shared\src\generation_message.rs <<<

======================================================
======================================================
// ssxl_shared/src/grid_bounds.rs

//! # Grid Bounds Structures (`ssxl_shared::grid_bounds`)
//!
//! This module defines the core structures for representing 2D world-space points
//! and rectangular bounding boxes (bounds) used throughout the SSXL-ext engine.

use serde::{Deserialize, Serialize};

// --- Coordinate Structure ---

/// Represents a single 2D world-space coordinate point.
///
/// Uses `i64` to support the massive scale of the SSXL world coordinates.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coord2D {
    /// The X component of the coordinate.
    pub x: i64,
    /// The Y component of the coordinate.
    pub y: i64,
}

// --- Bounding Box Structure ---

/// Defines a rectangular region in the world by its minimum and maximum coordinate points.
///
/// **Convention:** `GridBounds` uses a **half-open range** (`[min, max)`), meaning
/// the minimum coordinates are **inclusive** and the maximum coordinates are **exclusive**.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct GridBounds {
    /// The inclusive minimum coordinate (e.g., the bottom-left point of the region).
    pub min: Coord2D,
    /// The exclusive maximum coordinate (one unit past the top-right point of the region).
    pub max: Coord2D,
}

impl GridBounds {
    /// Creates a new `GridBounds` instance from four explicit coordinate components.
    pub fn new(min_x: i64, min_y: i64, max_x: i64, max_y: i64) -> Self {
        GridBounds {
            min: Coord2D { x: min_x, y: min_y },
            max: Coord2D { x: max_x, y: max_y },
        }
    }

    /// Calculates the size (width and height) of the bounds.
    ///
    /// For a half-open range, the size is simply `max - min`, which correctly
    /// yields the number of unique integer coordinates contained within the bounds.
    pub fn size(&self) -> Coord2D {
        Coord2D {
            x: self.max.x - self.min.x,
            y: self.max.y - self.min.y,
        }
    }

    /// Checks if a given coordinate is contained within the bounds.
    ///
    /// Follows the half-open range convention: `[min.x, max.x)` and `[min.y, max.y)`.
    pub fn contains(&self, coord: Coord2D) -> bool {
        coord.x >= self.min.x && coord.x < self.max.x &&
        coord.y >= self.min.y && coord.y < self.max.y
    }
}

impl Default for GridBounds {
    /// Returns a default, zero-sized bounds at the origin (0, 0) to (0, 0).
    fn default() -> Self {
        GridBounds {
            min: Coord2D { x: 0, y: 0 },
            max: Coord2D { x: 0, y: 0 },
        }
    }
}
>>> FILE END: rust\ssxl_shared\src\grid_bounds.rs <<<

======================================================
======================================================
// ssxl_shared/src/lib.rs

//! # SSXL Shared Data Crate (`ssxl_shared`)
//!
//! This crate contains fundamental data structures, configuration constants, and
//! error handling definitions that are utilized across all modules of the
//! SSXL-ext procedural generation engine. Its purpose is to ensure data integrity
//! and consistency (crypto coded memory) between the high-speed worker threads
//! and the main Godot runtime.

use serde::{Deserialize, Serialize};
use tracing;

// --- Module Declarations ---

/// Defines the core atomic unit of the world: the `ChunkData` structure.
pub mod chunk_data;
/// Defines the local tile data structure, including properties like material type.
pub mod tile_data;
/// Defines structures for spatial awareness and bounding boxes (`GridBounds`).
pub mod grid_bounds;
/// Defines the enumeration of available tile material types (`TileType`).
pub mod tile_type;
/// Defines the canonical error type (`SSXLError`) for the entire SSXL engine.
pub mod errors;
/// General messaging utilities (potential placeholder or used for generic events).
pub mod messages;
/// Global configuration constants, such as `CHUNK_SIZE`.
pub mod config;
/// Defines the work request and result messages for thread communication (`GenerationTask`).
pub mod generation_message;

/// A module used for custom Serde helpers, particularly for types like `SystemTime`.
pub mod math_primitives;

// --- Public Re-exports (The Main Crate API) ---

// Re-export core data structures for convenient access.
pub use chunk_data::ChunkData;
pub use chunk_data::CHUNK_SIZE; // Re-exporting from chunk_data for common use
pub use tile_data::TileData;
pub use grid_bounds::GridBounds;
pub use tile_type::TileType;

// Re-export the canonical error types.
pub use errors::{SSXLError, SSXLResult};

// Re-export of the widely used `anyhow` crate for flexible external error handling.
pub use anyhow;

// --- Generic Data Structure ---

/// A generic struct used to represent serializable, time-stamped data payloads.
///
/// This may be used within the caching system (`ssxl_cache`) or the FFI layer
/// to wrap basic return values.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SSXLData {
    pub id: u64,
    pub timestamp: u64,
    pub value: String,
}

// --- Initialization Function ---

/// Initializes the shared data module.
///
/// Used as a global entry point for any necessary setup (e.g., logging configuration
/// specific to shared data types).
pub fn initialize_shared_data() {
    tracing::info!("SSXL Shared Data Primitives initialized (Priority 1 complete).");
}

// --- Prelude for Ergonomics ---

/// A convenience module that re-exports all essential types for ergonomic use.
///
/// Other SSXL-ext crates are encouraged to use `use ssxl_shared::prelude::*`
/// to easily import the most commonly needed data components, adhering to the
/// Rust community best practice for large libraries.
pub mod prelude {
    pub use super::chunk_data::ChunkData;
    pub use super::tile_data::TileData;
    pub use super::grid_bounds::GridBounds;
    pub use super::tile_type::TileType;

    pub use super::errors::{SSXLError, SSXLResult};
}
>>> FILE END: rust\ssxl_shared\src\lib.rs <<<

======================================================
======================================================
// ssxl_shared/src/math_primitives.rs

//! # Math Primitives & Serde Helpers (`ssxl_shared::math_primitives`)
//!
//! This module contains custom logic, primarily Serde serialization/deserialization
//! functions, for mathematical or standard library types that require specific,
//! deterministic formatting (e.g., `SystemTime`) for cross-platform compatibility
//! and persistent caching.

use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serializer, Deserializer, Deserialize};


/// Serde serialization/deserialization helper for `std::time::SystemTime`.
///
/// This custom serializer converts `SystemTime` to and from a `u64` representing
/// the time in milliseconds since the Unix epoch (1970-01-01). This guarantees
/// a **deterministic, platform-independent** representation for caching and networking.
pub mod system_time_serde {
    use super::*;

    /// Serializes a `SystemTime` into a `u64` representing milliseconds since epoch.
    /// This is used by Serde when writing data (e.g., saving a `ChunkData` to cache).
    pub fn serialize<S>(time: &SystemTime, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Calculate the duration from the UNIX_EPOCH to the current time.
        let duration = time.duration_since(UNIX_EPOCH).map_err(serde::ser::Error::custom)?;
        // Convert the duration to milliseconds (u64) to ensure a stable format.
        let ms = duration.as_millis() as u64;
        // Serialize the u64 millisecond count.
        serializer.serialize_u64(ms)
    }

    /// Deserializes a `u64` (milliseconds since epoch) back into a `SystemTime`.
    /// This is used by Serde when reading data (e.g., loading a `ChunkData` from cache).
    pub fn deserialize<'de, D>(deserializer: D) -> Result<SystemTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize the u64 millisecond count.
        let ms = u64::deserialize(deserializer)?;
        // Convert the millisecond count into a Duration, then add it to UNIX_EPOCH.
        Ok(UNIX_EPOCH + std::time::Duration::from_millis(ms))
    }
}
>>> FILE END: rust\ssxl_shared\src\math_primitives.rs <<<

======================================================
======================================================
// ssxl_shared/src/messages.rs

//! # Generic Data Messages (`ssxl_shared::messages`)
//!
//! This module defines a basic, serializable message envelope used to communicate
//! the outcome of a chunk-related request. This structure is typically used for
//! simpler, potentially synchronous, interactions like direct cache lookups or
//! FFI (Foreign Function Interface) calls that return a complete chunk, its absence,
//! or a specific error state.

use serde::{Deserialize, Serialize};
use crate::chunk_data::ChunkData;


/// A generic, serializable message wrapper for communicating the status of a
/// single chunk data request.
///
/// Unlike the high-performance `GenerationMessage` (which uses `Arc`), this
/// structure typically involves cloning the `ChunkData` on serialization/deserialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChunkMessage {
    /// The request was successful, and the complete `ChunkData` is attached.
    Generated(ChunkData),

    /// The request was processed, but the data does not exist (e.g., a cache miss).
    NoData,

    /// An operational error occurred during the request (e.g., I/O failure).
    /// The attached `String` contains the human-readable error description.
    Error(String),
}
>>> FILE END: rust\ssxl_shared\src\messages.rs <<<

======================================================
======================================================
// ssxl_shared/src/tile_data.rs

//! # Tile Data Structures (`ssxl_shared::tile_data`)
//!
//! This module defines the `TileData` structure, which holds the minimal necessary
//! information for a single tile in the procedural world. It also includes utility
//! structures and bitmask constants (`tile_flags`) for efficient property management.
//! The use of `Copy` and `u8` flags is key to maintaining the high-speed "Tempo"
//! of the multi-threaded engine.

use super::tile_type::TileType;
use serde::{Deserialize, Serialize};

// Re-exports a core math primitive for use in related structures (e.g., AnimationUpdate).
use ssxl_math::Vec2i;


// --- Core Data Structure ---

/// Represents the data payload for a single tile in a chunk.
///
/// Marked `Copy` for high performance, as tiles are frequently cloned/copied
/// within generation and rendering loops.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TileData {
    /// The material or type of tile (e.g., grass, rock, empty).
    pub tile_type: TileType,
    
    /// The raw noise value (e.g., Perlin, Simplex) used to determine this tile's type.
    /// This is crucial for seamless neighbor checks and debugging the procedural generation.
    pub noise_value: f32,
    
    /// A compact bitfield storing up to 8 boolean properties about the tile.
    pub flags: u8,
}

impl Default for TileData {
    /// Returns the default state for a tile: `TileType::Void` with zero noise and no flags set.
    fn default() -> Self {
        TileData {
            tile_type: TileType::default(),
            noise_value: 0.0,
            flags: 0,
        }
    }
}


// --- Godot FFI Message Structure ---

/// Data structure used specifically for communication between the Rust engine
/// and the Godot runtime regarding tile animations.
///
/// This message is typically used by a dedicated rendering or animation system.
#[derive(Debug, Clone, Serialize, Deserialize)] // FIX: Added Serialize and Deserialize
pub struct AnimationUpdate {
    /// The layer or dimension the tile belongs to.
    pub layer: i32,
    /// The source ID of the tile map or animation source.
    pub source_id: i32,
    /// The world coordinates of the tile to update.
    pub tile_coords: Vec2i,
    /// The new coordinates within the texture atlas for the tile's animation frame.
    pub new_atlas_coords: Vec2i,
}


// --- Bitwise Flag Constants ---

/// Bitmasks used to set, check, or clear properties in the `TileData::flags` field.
/// This maximizes data density by storing 8 booleans in a single byte (`u8`).
pub mod tile_flags {
    /// Bit 0: Is the tile physically passable by entities? (e.g., air, water surface)
    pub const IS_TRAVERSABLE: u8 = 0b0000_0001;
    /// Bit 1: Is the tile currently visible/rendered by the client?
    pub const IS_RENDERED:    u8 = 0b0000_0010;
    /// Bit 2: Has this tile been manually changed post-generation by a player/editor?
    pub const IS_MODIFIED:    u8 = 0b0000_0100;
    /// Bit 3: Does this tile contain a gatherable resource or item?
    pub const HAS_RESOURCE:    u8 = 0b0000_1000;
    // Bits 4-7 are reserved for future properties.
}


impl TileData {
    /// Creates a new `TileData` instance with specified type and noise value.
    pub fn new(tile_type: TileType, noise_value: f32) -> Self {
        TileData {
            tile_type,
            noise_value,
            flags: 0, // Flags are initialized to zero (all false)
        }
    }

    /// Checks if the tile is considered a "solid" block, typically used for collision.
    pub const fn is_solid(&self) -> bool {
        // Relies on a method in TileType to define "solidity."
        !self.tile_type.is_empty()
    }

    /// Sets a flag based on its **bit index** (0-7).
    pub fn set_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise OR assignment: sets the bit at the given index to 1.
            self.flags |= 1 << flag_index;
        }
    }

    /// Clears (sets to 0) a flag based on its **bit index** (0-7).
    pub fn clear_flag_by_index(&mut self, flag_index: u8) {
        if flag_index < 8 {
            // Bitwise AND assignment with the inverted mask: sets the bit to 0.
            self.flags &= !(1 << flag_index);
        }
    }

    /// Checks the status of a flag based on its **bit index** (0-7).
    pub fn check_flag_by_index(&self, flag_index: u8) -> bool {
        if flag_index < 8 {
            // Bitwise AND with the mask: returns true if the bit is set.
            (self.flags & (1 << flag_index)) != 0
        } else {
            false
        }
    }
    
    /// Sets or clears a property using a predefined **flag mask** (e.g., `tile_flags::IS_TRAVERSABLE`).
    pub fn set_flag(&mut self, flag_mask: u8, value: bool) {
        if value {
            // Set the bit(s) (|= is bitwise OR assignment).
            self.flags |= flag_mask;
        } else {
            // Clear the bit(s) (&! is bitwise AND with the inverted mask).
            self.flags &= !flag_mask;
        }
    }

    /// Checks the status of a property using a predefined **flag mask**.
    pub const fn has_flag(&self, flag_mask: u8) -> bool {
        // Returns true if any of the bits in the mask are set in self.flags.
        (self.flags & flag_mask) != 0
    }
}
>>> FILE END: rust\ssxl_shared\src\tile_data.rs <<<

======================================================
======================================================
// ssxl_shared/src/tile_type.rs

//! # Tile Type Enumeration (`ssxl_shared::tile_type`)
//!
//! This module defines the canonical `TileType` enum, which identifies the material
//! or nature of a single tile. It is a fundamental data structure shared across
//! the entire SSXL-ext engine.
//!
//! **Critical Feature:** The use of `#[repr(u8)]` is a **memory optimization**
//! that guarantees the enum is stored as a single byte, drastically reducing the
//! memory footprint of the massive `ChunkData` tile arrays.

use serde::{Deserialize, Serialize};

/// Enumeration of all primary tile materials available in the procedural world.
///
/// Ensures strict memory layout as a single byte for efficiency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)] 
pub enum TileType {
    /// The default, empty state (e.g., air or background).
    Void = 0,
    /// A fluid, typically used for rivers, oceans, or lower areas.
    Water = 1,
    /// Base terrain, usually flat and traversable.
    Grass = 2,
    /// Elevated terrain, potentially difficult to traverse.
    Mountain = 3,
    /// An artificial boundary used to cap chunk edges or isolate generation regions.
    Boundary = 4,
    /// An engineered or placed structure (e.g., a ruin, road, or wall).
    Structure = 5,
    /// A solid, rocky, non-soil terrain type.
    Rock = 6,
    /// Reserved for generator-specific customization or future expansion.
    Custom1 = 7,
    /// Reserved for generator-specific customization or future expansion.
    Custom2 = 8,
}


impl Default for TileType {
    /// The default state of a tile is always `TileType::Void` (empty).
    fn default() -> Self {
        TileType::Void
    }
}

impl TileType {
    /// Converts the `TileType` instance into its underlying `u8` representation.
    #[inline] 
    pub const fn to_u8(self) -> u8 {
        self as u8
    }

    /// Attempts to convert a raw `u8` value back into a `TileType`.
    ///
    /// Returns `None` if the input value does not correspond to a defined variant,
    /// ensuring safe deserialization.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TileType::Void),
            1 => Some(TileType::Water),
            2 => Some(TileType::Grass),
            3 => Some(TileType::Mountain),
            4 => Some(TileType::Boundary),
            5 => Some(TileType::Structure),
            6 => Some(TileType::Rock),
            7 => Some(TileType::Custom1),
            8 => Some(TileType::Custom2),
            _ => None,
        }
    }
    
    /// Provides a simple, default unique ID for this tile type (equal to its u8 value).
    pub const fn get_default_tile_id(self) -> u16 {
        self.to_u8() as u16
    }

    /// Provides default atlas coordinates (X, Y) for initial rendering/visual representation.
    ///
    /// This is a common lookup function used by the rendering component (`ssxl_godot`).
    pub const fn get_default_atlas_coords(self) -> (u16, u16) {
        match self {
            // All default tiles are expected to be on the first row (Y=0) of the atlas.
            TileType::Water    => (1, 0),
            TileType::Grass    => (2, 0),
            TileType::Mountain => (3, 0),
            TileType::Boundary => (4, 0),
            TileType::Structure=> (5, 0),
            TileType::Rock     => (6, 0),
            // Void and unspecified types default to the origin (0, 0).
            _ => (0, 0), 
        }
    }
}


impl TileType {
    /// Checks if the tile type is one that a character can typically traverse (walk on).
    pub const fn is_walkable(self) -> bool {
        matches!(self, 
            TileType::Grass 
            | TileType::Mountain 
            | TileType::Structure 
            | TileType::Rock
        )
    }

    /// Checks if the tile type is considered a fluid (e.g., for flow/buoyancy simulation).
    pub const fn is_fluid(self) -> bool {
        matches!(self, TileType::Water)
    }

    /// Checks if the tile is empty (the default/void state).
    pub const fn is_empty(self) -> bool {
        matches!(self, TileType::Void)
    }
}
>>> FILE END: rust\ssxl_shared\src\tile_type.rs <<<

======================================================
======================================================
[package]
name = "ssxl_sync"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
# Required for shared data types and the canonical error type
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_animate = { path = "../ssxl_animate" }

# --- EXTERNAL CONCURRENCY & DIAGNOSTICS ---
# Primary async runtime
tokio               = { workspace = true, features = ["full"] }
# High-performance channel types
crossbeam           = { workspace = true }
crossbeam-channel   = { workspace = true }
# High-performance sync primitives (like RwLock, often preferred over std::sync)
parking_lot         = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing             = { workspace = true }
godot               = { workspace = true, optional = true }

[features]
# Add a feature flag for Godot-specific dependencies
godot-bindings = ["godot"]
>>> FILE END: rust\ssxl_sync\Cargo.toml <<<

======================================================
======================================================
use godot::prelude::*;
use godot::builtin::Array;
use ssxl_animate::{
    initialize_animation_conductor, 
    AnimationUpdate, 
    AnimationConductor, 
    AnimationConductorHandle,
};
use tokio::sync::mpsc::UnboundedReceiver; // Used for the Update Poller

// Type alias for the receiver that brings updates back from the worker threads.
pub type AnimationUpdateReceiver = UnboundedReceiver<AnimationUpdate>;

// NOTE: We assume 'AnimationCommand' is defined elsewhere in ssxl_sync.

/// The FFI Conductor: This struct is exposed to Godot as a Singleton or Node.
/// Its sole purpose is to bridge Godot's main thread with the Rust async workers.
#[derive(GodotClass)]
#[class(tool, init, base=Node)] // Base Node for easy Godot integration
pub struct FfiAnimationConductor {
    // 1. The FFI Handle: Used by Godot to send commands to the Rust async loop.
    command_tx: Option<AnimationConductorHandle>,
    // 2. The FFI Poller: Used by Godot's main thread to receive updates from workers.
    update_rx: Option<AnimationUpdateReceiver>,
    // 3. The Arc<Mutex<Conductor>>: The core async component (needs to be run by the Tokio runtime).
    _core_conductor: Option<std::sync::Arc<std::sync::Mutex<AnimationConductor>>>,
    // Godot-safe handle to the TileMap resource for applying updates.
    tilemap_node: Option<Gd<Node2D>>,
}

#[godot_api]
impl FfiAnimationConductor {
    // FFI Lifecycle: Called once when the Node enters the tree.
    #[base]
    fn ready(&mut self) {
        // Initialization logic for the async core lives here.
        // NOTE: A real implementation requires a Tokio runtime already started.
        let (tx_handle, core_conductor) = initialize_animation_conductor(
            // NOTE: We create the Update Channel here and pass the sender to the workers.
            // The receiver (poller) is kept in the FFI Conductor.
            // (You will need to pass the real UpdateSender to initialize_animation_conductor)
            todo!(), // Placeholder for the real UpdateSender from the update_rx's creation
            todo!(), // Placeholder for initial state
        );

        self.command_tx = Some(tx_handle);
        self._core_conductor = Some(core_conductor); // Keep a handle to prevent drop/cleanup

        godot_print!("SSXL Animation System FFI initialized.");
    }

    /// FFI Method: Used by Godot/GDScript to queue a new animation job.
    /// This is where GDScript calls your Rust logic.
    #[func]
    pub fn queue_job(&self, job_data: GArray) {
        if let Some(tx) = &self.command_tx {
            // CRITICAL LOGIC: Convert Godot data (GArray) into Rust's AnimationCommand
            // We assume AnimationCommand::from_godot() exists for type safety.
            // This is the only place type conversion should happen.
            // let command = AnimationCommand::from_godot(job_data);
            
            // Simple send; the FFI function MUST return quickly.
            // The async Conductor takes over from here.
            // let _ = tx.send(command).ok();
            godot_print!("Command sent to animation conductor.");
        }
    }
    
    /// FFI Method: Called every frame (e.g., via _process(delta)) by GDScript.
    /// This is the most performance-critical function in the FFI layer.
    #[func]
    pub fn poll_updates(&mut self) -> i32 {
        let mut updates_processed = 0;
        
        if let Some(rx) = self.update_rx.as_mut() {
            // CRITICAL LOGIC: Non-blocking receive loop.
            // We read as many updates as possible without ever yielding/blocking.
            while let Ok(update) = rx.try_recv() {
                // Restore the logic of applying the update to Godot's world.
                self.apply_update_to_tilemap(&update); 
                updates_processed += 1;
            }
        }
        updates_processed
    }
    
    // Internal function for Godot interaction details (TileMap logic lives here).
    fn apply_update_to_tilemap(&mut self, update: &AnimationUpdate) {
        if let Some(tilemap) = &mut self.tilemap_node {
            // TODO: Restore original 246-LOC logic for applying the change.
            // This will involve checking TileSet IDs and proper resource ownership.
            
            // Example:
            // let tile_pos = Vector2::new(update.coord.x as f32, update.coord.y as f32);
            // tilemap.call("set_cell_animation", &[tile_pos.to_variant(), update.payload.to_variant()]);
        }
    }
}
>>> FILE END: rust\ssxl_sync\src\animation_conductor.rs <<<

======================================================
======================================================
// ssxl_sync/src/lib.rs

//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//!
//! This crate provides the core primitives and manager structs necessary for
//! thread synchronization, communication, and high-performance worker management
//! within the SSXL-ext engine. This includes:
//! 1. **Data Safety:** Atomic wrappers for thread-safe shared resources.
//! 2. **Worker Management:** Thread pools and specialized, dedicated worker threads (Conductors).
//! 3. **Communication:** Channel definitions for command and result passing.

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import tokio for the channel types used in the aliases below.
use tokio::sync::mpsc; 
// CRITICAL: Import types used in the type aliases from ssxl_shared.
use ssxl_shared::{SSXLError, tile_data::AnimationUpdate};

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

/// Defines core thread-safe types, enums, and channel aliases used for concurrency and communication.
pub mod primitives;

/// Manages the generic, fixed-size thread pool used for synchronous, CPU-intensive tasks.
pub mod pool_manager;

/// Manages the dedicated worker thread and state for calculating visual animation frames.
pub mod animation_conductor;


// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

// --- 1. Generic Primitives and Utility Functions (from primitives) ---

/// Re-exports of generic thread-safe resource wrappers, synchronous channels, and worker placeholders.
pub use primitives::{
    AtomicResource, 
    create_sync_channel, 
    start_sync_worker
};

// --- 2. Animation Conductor Types (from animation_conductor) ---

/// Re-exports of all public types related to the dedicated animation worker thread.
pub use animation_conductor::{
    AnimationConductor, 
    AnimationCommand, 
    // AnimationConductorHandle was removed here to clear the E0255 error.
    AnimationReceiver, 
    AnimationState, 
    AnimationStatus,
};

// --- 3. Thread Pool Manager Types (from pool_manager) ---

/// Re-exports of all public types related to the generic CPU worker thread pool.
pub use pool_manager::{
    WorkerPool, 
    GenerationTask, 
    ConductorResult, 
    Task, 
    TaskResult
};

// --------------------------------------------------------------------------------
// --- Final Type Aliases (CRATE ROOT API - FIX E0255, E0412, and E0432) ---
// --------------------------------------------------------------------------------

// The UnboundedSender type is used to send commands to the Conductor's thread.
pub type AnimationConductorHandle = mpsc::UnboundedSender<AnimationCommand>;

// ⭐ NEW ALIAS: The Receiver half of the command channel for the AnimationConductor.
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;

// The UnboundedSender type is used to send updates (e.g., animation frames) back to the main thread.
pub type UpdateSender = mpsc::UnboundedSender<AnimationUpdate>; 

// ⭐ FIXED: The standard result wrapper, using SSXLError and removing the generic parameter.
pub type CommandResult = Result<(), SSXLError>;
>>> FILE END: rust\ssxl_sync\src\lib.rs <<<

======================================================
======================================================
// ssxl_sync/src/pool_manager.rs

//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::Vec2i;

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    CompletedChunk(Arc<ssxl_shared::chunk_data::ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // ssxl_shared::chunk_data is assumed to be available to this crate.
                        Arc::new(ssxl_shared::chunk_data::ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
>>> FILE END: rust\ssxl_sync\src\pool_manager.rs <<<

======================================================
======================================================
// ssxl_sync/src/primitives.rs

//! # Synchronization Primitives (`ssxl_sync::primitives`)
//!
//! This module defines the core thread-safe data structures and communication channels.

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
use tracing::info; // Required for the start_sync_worker function

// --- 1. Thread-Safe Resource Wrapper ---

/// A generic, thread-safe wrapper for data shared between multiple threads.
/// It uses `parking_lot::RwLock` for fast, efficient concurrent read access.
#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    /// The actual data protected by an Arc (shared ownership) and RwLock (read/write access control).
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    /// Creates a new `AtomicResource` containing the provided data.
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    /// Acquires a read lock on the data. Allows multiple concurrent readers.
    #[inline]
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    /// Acquires an exclusive write lock on the data. Blocks all other readers/writers.
    #[inline]
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}


// --- 2. Generic Synchronous Channel (Crossbeam) ---

/// Creates an unbounded, multi-producer, single-consumer channel for synchronous (blocking) communication.
/// This is used primarily for simple signalling or utility messaging.
pub fn create_sync_channel() -> (Sender<String>, Receiver<String>) {
    unbounded()
}

/// A placeholder function demonstrating where a synchronous worker thread might be started.
pub fn start_sync_worker() {
    info!("SSXL Synchronization Worker placeholder started.");
}
>>> FILE END: rust\ssxl_sync\src\primitives.rs <<<

======================================================
======================================================
[package]
name = "ssxl_tools"
edition = "2021" 

[dependencies]
# Internal dependencies (Local Crates)
ssxl_shared = { path = "../ssxl_shared" }

# External dependency (Workspace-Inherited)
regex = { workspace = true }
once_cell = { workspace = true }
tracing = { workspace = true }
>>> FILE END: rust\ssxl_tools\Cargo.toml <<<

======================================================
======================================================
// ssxl_tools/src/lib.rs

//! # SSXL Engine Tools (`ssxl_tools`)
//!
//! Provides utility functions for **configuration management**, **data validation**,
//! and other engine-wide tooling not specific to generation or synchronization.

use once_cell::sync::Lazy;
use regex::Regex;
use tracing::{info, warn};
use std::io::{self, Read};
use std::fs::File;

use ssxl_shared::SSXLData;

// --------------------------------------------------------------------------------
// --- Configuration Constants ---
// --------------------------------------------------------------------------------

/// The default file path to check for engine configuration.
const DEFAULT_CONFIG_PATH: &str = "./config/engine.toml";
/// The ID of the generator used when configuration loading fails or is not specified.
const DEFAULT_GENERATOR: &str = "cellular_automata_basic";
/// The default Cellular Automata ruleset ID to use.
const DEFAULT_CA_RULESET: u8 = 0;

// --------------------------------------------------------------------------------
// --- SSXL Configuration Management ---
// --------------------------------------------------------------------------------

/// Configuration structure holding key engine settings, primarily for generation defaults.
pub struct SSXLConfig {
    /// The ID of the world generator to use when no specific one is requested.
    default_generator_id: String,
    /// The default ruleset ID for the Cellular Automata generator.
    ca_default_ruleset: u8,
}

impl SSXLConfig {
    /// Creates a new `SSXLConfig` instance populated with hardcoded default values.
    fn new_with_defaults() -> Self {
        SSXLConfig {
            default_generator_id: DEFAULT_GENERATOR.to_string(),
            ca_default_ruleset: DEFAULT_CA_RULESET,
        }
    }

    /// Attempts to read and simulate loading engine configuration from a file path.
    ///
    /// The actual configuration parsing logic is currently simulated:
    /// it reads the file and then unconditionally returns hardcoded override values.
    fn load_from_path(path: &str) -> Result<Self, io::Error> {
        info!("SSXLConfig: Attempting to load configuration from: {}", path);

        match File::open(path) {
            Ok(mut file) => {
                let mut contents = String::new();
                // Read the entire file content into a string.
                file.read_to_string(&mut contents)?;

                info!("SSXLConfig: File read successfully. Simulating config override.");
                // Placeholder: In a real implementation, 'contents' would be parsed (e.g., via TOML).
                Ok(SSXLConfig {
                    default_generator_id: "perlin_basic_2d".to_string(), // Simulated override
                    ca_default_ruleset: 1,                               // Simulated override
                })
            },
            // If file opening fails, propagate the standard I/O error.
            Err(e) => Err(e),
        }
    }

    /// Returns the configured default generator ID string.
    pub fn get_default_generator_id(&self) -> &str {
        &self.default_generator_id
    }

    /// Returns the configured default Cellular Automata ruleset ID.
    pub fn get_ca_default_ruleset(&self) -> u8 {
        self.ca_default_ruleset
    }
}

/// Attempts to load the configuration from the specified path.
///
/// If `path` is `None`, it defaults to `DEFAULT_CONFIG_PATH`.
/// If the file loading fails for any reason, it logs a warning and **returns
/// a new `SSXLConfig` instance populated with hardcoded defaults** (safe fallback).
pub fn get_config_from_path(path: Option<&str>) -> Result<SSXLConfig, io::Error> {
    let path_to_load = path.unwrap_or(DEFAULT_CONFIG_PATH);

    match SSXLConfig::load_from_path(path_to_load) {
        Ok(config) => {
            info!("SSXLConfig loaded from path: {}", path_to_load);
            Ok(config)
        },
        Err(e) => {
            // Log the failure but ensure the engine has a runnable configuration.
            warn!("Config load FAILED from path '{}'. Error: {:?}. Returning defaults to ensure engine initialization.", path_to_load, e);
            // Return the defaults wrapped in an Ok() to ensure initialization succeeds.
            Ok(SSXLConfig::new_with_defaults())
        }
    }
}

// --------------------------------------------------------------------------------
// --- Static Configuration (DEPRECATED) ---
// --------------------------------------------------------------------------------

/// Lazy-initialized static instance of the default configuration.
///
/// Used by the deprecated `get_config()` function.
static CONFIG: Lazy<SSXLConfig> = Lazy::new(SSXLConfig::new_with_defaults);

/// Retrieves the global static configuration instance.
///
/// **WARNING:** This function is **DEPRECATED**. It does not allow for specifying
/// a configuration path and relies on a hardcoded static default.
/// Use [`get_config_from_path`] instead.
pub fn get_config() -> &'static SSXLConfig {
    warn!("DEPRECATED: Called `get_config()`. Use `get_config_from_path()` for correct FFI CWD handling and dynamic loading.");
    &CONFIG
}

// --------------------------------------------------------------------------------
// --- Utility Functions ---
// --------------------------------------------------------------------------------

/// Lazy-initialized regular expression for validating SSXL data IDs (must be composed only of digits).
static ID_REGEX: Lazy<Regex> = Lazy::new(|| {
    // Pattern matches one or more digits from start to end of the string.
    Regex::new(r"^\d+$").expect("Failed to compile ID validation regex")
});

/// Validates that an `SSXLData` ID is composed solely of digits.
pub fn validate_data_id(data: &SSXLData) -> bool {
    // Checks if the string representation of the data ID matches the digit-only regex.
    ID_REGEX.is_match(&data.id.to_string())
}

/// Initializes engine tool utilities.
///
/// This function triggers the lazy initialization of necessary static resources,
/// such as the ID validation regex, ensuring they are ready before first use.
pub fn initialize() {
    // Force initialization of the static regex.
    let _ = &*ID_REGEX;
    info!("SSXL Tools: Configuration and data validation utilities initialized.");
}
>>> FILE END: rust\ssxl_tools\src\lib.rs <<<

======================================================
======================================================
extends Node

func enter_idle():
    print("🌙 Aetherion in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ Aetherion activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 Aetherion teardown.")
    # Optional: stop ticker, release ligatures

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\Aetherion.gd <<<

======================================================
======================================================
@tool
extends EditorPlugin

var ssxl_instance: Node = null

func _enter_tree() -> void:
    print("🌀 SSXL plugin booting...")
    ProjectSettings.set_setting("ssxl/plugin_enabled", true)

    var script_path := "res://addons/S2O_godot_plugin/ssxl.gd"
    if ResourceLoader.exists(script_path):
        var script_res := load(script_path)
        if script_res and script_res is Script:
            ssxl_instance = script_res.new()
            if ssxl_instance:
                get_tree().root.add_child(ssxl_instance)
                print("✨ SSXL instance added to scene tree.")
                if ssxl_instance.has_method("enter_idle"):
                    ssxl_instance.call_deferred("enter_idle")
                else:
                    print("⚠️ SSXL instance missing 'enter_idle' method.")
            else:
                push_error("❌ Failed to instantiate SSXL script.")
        else:
            push_error("❌ Invalid script resource at: %s" % script_path)
    else:
        push_error("❌ SSXL script not found at: %s" % script_path)

func _exit_tree() -> void:
    print("🧹 SSXL plugin dismissed.")
    ProjectSettings.set_setting("ssxl/plugin_enabled", false)

    if is_instance_valid(ssxl_instance):
        ssxl_instance.queue_free()
        print("🧺 SSXL instance freed.")
    ssxl_instance = null

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\S2O_plugin.gd <<<

======================================================
======================================================
extends Node

func enter_idle():
    print("🌙 SSXL in idle mode.")
    call_deferred("_bind_idle")

func _bind_idle():
    if Engine.is_editor_hint():
        print("🧿 Editor context detected. Idle phase skipped.")
        return

    if has_method("start_idle"):
        start_idle()
    else:
        print("⚠️ No idle method found. Skipping ticker.")

func start_idle():
    print("🪶 Idle ticker started.")
    # Optional: set up heartbeat, overlay, or runtime polling

func activate():
    print("⚡ SSXL activated.")
    # Optional: call_deferred("_bind_active")

func teardown():
    print("🧺 SSXL teardown.")
    # Optional: stop ticker, release ligatures

>>> FILE END: SSXL_engine_tester\addons\S2O_godot_plugin\SSXL.gd <<<

======================================================
======================================================
extends Node

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robust access)
# ----------------------------------------------------------------------

@onready var camera1: Camera2D = $camera1
@onready var camera2: Camera2D = $camera2

# ----------------------------------------------------------------------
## CONSTANTS & STATE
# ----------------------------------------------------------------------

# Zoom constants
const ZOOM_SPEED: float = 0.1 
const MIN_ZOOM: float = 0.05 
const MAX_ZOOM: float = 10.0 

# Panning State
var is_panning: bool = false
var last_mouse_position: Vector2 = Vector2.ZERO

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Ensure camera nodes exist before attempting to use them
	if camera1 == null or camera2 == null:
		push_error("❌ Critical: Camera nodes (camera1 or camera2) not found as children.")
		return
		
	# Start by making camera1 current
	camera1.make_current()

# ----------------------------------------------------------------------
## INPUT HANDLING (Toggle, Zoom, & Pan)
# ----------------------------------------------------------------------

func _unhandled_input(event: InputEvent) -> void:
	# --- 1. Camera Toggle Logic (Space/Tab) ---
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.is_action("ui_accept") or event.is_action("ui_focus_next"):
			get_viewport().set_input_as_handled()
			_toggle_camera()
			return

	# Only proceed with Mouse/Map controls if camera2 is the current active camera
	if camera2 and camera2.is_current():
		
		# --- 2. Combined Mouse Input Handling (Zoom & Pan State) ---
		if event is InputEventMouseButton:
			
			var current_zoom: Vector2 = camera2.zoom
			var new_zoom: Vector2 = current_zoom
			
			# --- A. ZOOM LOGIC (Scroll Wheel) ---
			# We only check for the press event to prevent double-processing.
			if event.is_pressed():
				if event.button_index == MOUSE_BUTTON_WHEEL_UP:
					# Zoom IN
					new_zoom -= Vector2(ZOOM_SPEED, ZOOM_SPEED)
				elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
					# Zoom OUT
					new_zoom += Vector2(ZOOM_SPEED, ZOOM_SPEED)
			
			if new_zoom != current_zoom:
				# Apply and clamp zoom
				new_zoom = new_zoom.clamp(Vector2(MIN_ZOOM, MIN_ZOOM), Vector2(MAX_ZOOM, MAX_ZOOM))
				camera2.zoom = new_zoom
				get_viewport().set_input_as_handled()
				return 
			
			# --- B. PANNING STATE LOGIC (Middle Click) ---
			if event.button_index == MOUSE_BUTTON_MIDDLE:
				is_panning = event.is_pressed()
				
				if is_panning:
					last_mouse_position = event.position
				
				get_viewport().set_input_as_handled()
				return 

		# --- 3. Camera Pan Logic (Mouse Motion) ---
		elif event is InputEventMouseMotion and is_panning:
			
			var delta: Vector2 = event.position - last_mouse_position
			
			# Correct Pan: Moves the camera by the screen delta adjusted for current zoom level.
			camera2.position -= delta / camera2.zoom
			
			last_mouse_position = event.position
			get_viewport().set_input_as_handled()
			return

# ----------------------------------------------------------------------
## PUBLIC API (No functional change, uses @onready variables)
# ----------------------------------------------------------------------

func switch_to_camera(index: int) -> void:
	if camera1 == null or camera2 == null:
		print("⚠️ Camera nodes not found.")
		return

	if index == 1:
		camera1.make_current()
		print("➡️ Switched to Camera 1 (Control Panel View).")
	elif index == 2:
		camera2.make_current()
		print("➡️ Switched to Camera 2 (Map View).")
	else:
		print("⚠️ Invalid camera index passed.")

func _toggle_camera() -> void:
	if camera1 == null or camera2 == null:
		return

	# Determine which camera is currently active and switch
	if camera1.is_current():
		switch_to_camera(2) # Use public API for consistency
	elif camera2.is_current():
		switch_to_camera(1) # Use public API for consistency
	else:
		# Fallback: if neither is current, default to camera1
		switch_to_camera(1)

>>> FILE END: SSXL_engine_tester\root_scripts\cameras.gd <<<

======================================================
======================================================
extends Camera2D

>>> FILE END: SSXL_engine_tester\root_scripts\camera_2.gd <<<

======================================================
======================================================
class_name control_panel_animation_logic extends RefCounted

## 🎯 Properties
var controller: Control
# Queue to hold incoming tile updates (flips) from the engine
var tile_flip_queue: Array = []
# Maximum number of tile updates to process per animation tick
const MAX_FLIPS_PER_TICK: int = 1000

## 🛠️ Internal Command Names (Must match Rust FFI API)
const CMD_ANIMATION_ENABLE: String = "ANIMATION_ENABLE"
const CMD_ANIMATION_DISABLE: String = "ANIMATION_DISABLE"


func _init(p_controller: Control) -> void:
	# Store a reference to the main controller node
	controller = p_controller



##  ANIMATION STATE CONTROL

func on_animate_checkbox_toggled(button_pressed: bool) -> void:
	"""
	Updates the controller's local animation state and sends the new mode 
	to the Rust engine via FFI to update its status.
	"""
	controller.is_animated = button_pressed
	print("⚙️ Animation Toggled: %s" % controller.is_animated)
	
	# FFI: Send the correct command string to the engine.
	if is_instance_valid(controller.ssxl_engine):
		var command_to_send: String = CMD_ANIMATION_ENABLE if button_pressed else CMD_ANIMATION_DISABLE
		controller.ssxl_engine.send_animation_command(command_to_send)
	
	# Automatically switch the polling mechanism based on the animation mode
	setup_animation_worker(button_pressed)


func setup_animation_worker(should_animate: bool) -> void:
	"""
	Starts the correct timer (throttled animation or fast engine poll)
	based on the user's animation choice.
	"""
	if should_animate:
		if is_instance_valid(controller.animation_timer):
			# Slower tick for visual updates
			controller.animation_timer.start()
		if is_instance_valid(controller.engine_timer):
			# Stop the fast poll
			controller.engine_timer.stop()
	else:
		if is_instance_valid(controller.engine_timer):
			# Fast tick for engine polling
			controller.engine_timer.start()
		if is_instance_valid(controller.animation_timer):
			# Stop the animation loop
			controller.animation_timer.stop()



## ⏱️ TIMER HANDLERS (Polling & Animation Loop)

func _on_engine_timer_timeout() -> void:
	"""
	Called by the fast (e.g., 0.01s) engine_timer when NOT animating.
	Its primary job is to poll the Rust engine for updates.
	"""
	if not controller.is_generating or not is_instance_valid(controller.ssxl_engine):
		return
	
	controller.engine_tick_count += 1
	# Manually poll the engine status
	controller.ssxl_engine.get_status()


func _on_animation_timer_timeout() -> void:
	"""
	Called by the throttled animation_timer when ANIMATING.
	Processes a batch of tile flips and updates the screen once.
	"""
	if not controller.is_generating:
		return
	
	# 1. Determine how many flips to process
	var flips_to_process: int = min(tile_flip_queue.size(), MAX_FLIPS_PER_TICK)
	
	if flips_to_process > 0:
		# Process the first batch of flips directly from the queue
		for i in range(flips_to_process):
			var flip_data: Array = tile_flip_queue[i]
			var tile_id: int = flip_data[0]
			var flip_frame: int = flip_data[1]
			
			process_tile_flip(tile_id, flip_frame)
			
		# FIX: Remove the processed elements from the queue using pop_front()
		# This is the correct way to handle FIFO batch removal in Godot 4.x.
		for i in range(flips_to_process):
			tile_flip_queue.pop_front()


	# 2. Update Map and Poll Engine Status
	if is_instance_valid(controller.expansive_tilemap):
		# Force the TileMap to refresh with the batch of new tiles
		controller.expansive_tilemap.force_update()
	
	# Poll Engine Status (Less frequently in animation mode)
	if is_instance_valid(controller.ssxl_engine):
		controller.ssxl_engine.get_status()



## 💡 TILE FLIP PROCESSING

func process_tile_flip(tile_id: int, flip_frame: int) -> void:
	"""Converts linear tile ID to grid coords and applies the visual flip/frame."""
	if not is_instance_valid(controller.expansive_tilemap) or not is_instance_valid(controller.grid_width):
		return

	# Use the current grid width value (which is likely a SpinBox or similar)
	var map_width: int = int(controller.grid_width.value)
	if map_width <= 0:
		return

	# Convert linear tile_id back to grid coordinates (x, y)
	var x: int = tile_id % map_width
	var y: int = tile_id / map_width
	var coords: Vector2i = Vector2i(x, y)
	
	# Apply the tile flip/alternative tile index
	controller.expansive_tilemap.set_cell_alt(0, coords, flip_frame)


func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
	Signal handler connected to SSXLSignals.
	Queues the incoming tile flip data for processing on the next animation tick.
	"""
	# Only queue updates if the system is running and animation is enabled
	if not controller.is_animated or not controller.is_generating:
		return

	# Store the data in the queue immediately
	tile_flip_queue.append([tile_id, flip_frame])

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelanimation.gd <<<

======================================================
======================================================
class_name control_panel_gen_logic extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
# ⏯️ TOGGLE (UI ENTRY POINT)
# ------------------------------------------------------------------------------
func toggle_generation() -> void:
	"""
	Toggles map generation between start and stop based on the current state.
	This is the function connected directly to the 'Generate' button.
	"""
	if controller.is_generating:
		stop_generation()
	else:
		start_generation()

# ------------------------------------------------------------------------------
# 🛑 STOP GENERATION LOGIC
# ------------------------------------------------------------------------------
func stop_generation() -> void:
	print("🛑 ControlPanel: Stop button pressed. Halting generation.")
	
	# Attempt to send a stop command to the FFI/Rust engine
	if is_instance_valid(controller.ssxl_engine) and controller.ssxl_engine.has_method("send_stop_command"): # Refactored method name for clarity
		controller.ssxl_engine.send_stop_command()
		print("🛑 ControlPanel: Sent explicit stop command to SSXL Engine.")
		
	# Reset state and update UI
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🛑 Generation halted by user."
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"
	
	# Switch back to the Control Panel camera
	controller.utility.switch_to_camera_view(1) # Delegated to utility script
	print("➡️ Switched to Camera 1 (Control Panel View).")


# ------------------------------------------------------------------------------
# 🟢 START GENERATION LOGIC
# ------------------------------------------------------------------------------
func start_generation() -> void:
	# Critical node checks
	if not controller.utility.check_critical_nodes():
		return # Error message handled in utility

	# Input gathering: Grid size
	var width: int = int(controller.grid_width.value) if is_instance_valid(controller.grid_width) else 0
	var height: int = int(controller.grid_height.value) if is_instance_valid(controller.grid_height) else 0
	
	# Input validation
	if width <= 0 or height <= 0:
		if is_instance_valid(controller.status_label):
			controller.status_label.text = "⚠️ Invalid grid size."
		return

	# Retrieve inputs using safer, single-purpose functions
	var generator_name: String = get_selector_item_text(controller.placement_mode_selector, "perlin_basic_2d", "Generator list empty. Using default: %s")
	var tile_type_name: String = get_selector_item_text(controller.tile_type_selector, "tile_type_grass")
	var seed: int = get_and_set_seed()
		
	# State Setup
	if controller.ssxl_engine.has_method("set_generator"):
		controller.ssxl_engine.set_generator(tile_type_name)
		print("⚙️ ControlPanel: set_generator called with tile_type %s" % tile_type_name)

	controller.utility.clear_generation_state()
	controller.is_generating = true
	controller.is_animated = controller.animate_checkbox.button_pressed
	
	controller.animation_logic.setup_animation_worker(controller.is_animated)

	controller.generation_start_time_ms = Time.get_ticks_msec()
	
	# Progress Bar Setup
	var total_chunks_x: float = ceil(float(width) / controller.CHUNK_SIZE_X)
	var total_chunks_y: float = ceil(float(height) / controller.CHUNK_SIZE_Y)
	
	if is_instance_valid(controller.progress_bar):
		var total_tiles: float = total_chunks_x * total_chunks_y * controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
		controller.progress_bar.max_value = total_tiles
		controller.progress_bar.value = 0.0
		controller.progress_bar.visible = true
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🧬 Generating map with mode: %s..." % [generator_name]
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		controller.generate_button.text = "STOP"
	
	prepopulate_map(width, height)
	controller.get_tree().process_frame

	# Camera switch to map view
	controller.utility.switch_to_camera_view(2)
	print("➡️ Switched to Camera 2 (Map View).")

	# FFI CALL 2: Queues the task in the Rust engine
	controller.ssxl_engine.build_map(width, height, str(seed), generator_name)
	print("🧪 ControlPanel: build_map called with seed %d and generator %s (Task Queued)" % [seed, generator_name])

	# Start the appropriate timer based on animation state
	if controller.is_animated and is_instance_valid(controller.animation_timer):
		controller.animation_timer.start()
	elif is_instance_valid(controller.engine_timer):
		controller.engine_timer.start()

# ------------------------------------------------------------------------------
# ⚙️ UTILITY FUNCTIONS
# ------------------------------------------------------------------------------

func get_selector_item_text(selector: OptionButton, default_value: String, warning_message: String = "") -> String:
	"""Safely retrieves the selected item text from an OptionButton, or returns a default."""
	if not is_instance_valid(selector) or selector.get_item_count() == 0:
		if not warning_message.is_empty() and is_instance_valid(controller.status_label):
			controller.status_label.text = warning_message % default_value
		return default_value
		
	var selected_idx: int = max(0, selector.selected)
	if selected_idx < selector.get_item_count():
		return selector.get_item_text(selected_idx)
		
	return default_value # Should not happen if item_count > 0, but safe fallback

func get_and_set_seed() -> int:
	"""Retrieves the seed from input or generates a new random one, updating the UI."""
	if is_instance_valid(controller.seed_input) and controller.seed_input.text.is_valid_int():
		return int(controller.seed_input.text)
	
	var new_seed: int = randi() % 1_000_000
	if is_instance_valid(controller.seed_input):
		controller.seed_input.text = str(new_seed)
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "⚠️ Invalid seed. Using random seed: %d" % new_seed
	
	return new_seed

func prepopulate_map(width: int, height: int) -> void:
	"""Pre-fills the entire map with a base tile to reserve space and show bounds."""
	if not is_instance_valid(controller.expansive_tilemap):
		push_error("Cannot prepopulate: TileMap invalid.")
		return

	controller.expansive_tilemap.clear_layer(0)
	for x in range(width):
		for y in range(height):
			controller.expansive_tilemap.set_cell(0, Vector2i(x, y), controller.BASE_SOURCE_ID, controller.BASE_ATLAS_COORDS, controller.BASE_ALT_ID)
	
	# Note: force_update() is called after build_map_complete for final drawing.
	print("🎨 ControlPanel: Map prepopulated with base tile (%d x %d)." % [width, height])


# ------------------------------------------------------------------------------
# ✅ COMPLETION HANDLER
# ------------------------------------------------------------------------------
func _on_build_map_complete_received() -> void:
	# This function is connected directly to the ssxl_signals build_map_complete signal
	on_build_map_complete()
	
func on_build_map_complete() -> void:
	print("✅ Finalizing map generation.")
	
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	var elapsed_placement_time_ms: int = Time.get_ticks_msec() - controller.generation_start_time_ms
	var elapsed_placement_time_sec: float = float(elapsed_placement_time_ms) / 1000.0
	
	var final_tile_count: int = controller.total_tiles_placed
	
	# Update labels
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % final_tile_count
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "⏱️ Tile Placement Time: %.2fs" % elapsed_placement_time_sec
		
	if is_instance_valid(controller.engine_timer_label):
		controller.engine_timer_label.text = "⏱️ Final Runtime: %.2fs | Ticks: %d" % [elapsed_placement_time_sec, controller.engine_tick_count]

	# Final camera positioning and zoom (Delegate this logic to Utility)
	controller.utility.set_map_zoom_and_position()
	
	if is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	
	controller.get_tree().process_frame

	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "✅ Generation Complete. Map built. (%d tiles)" % final_tile_count
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelgenlogic.gd <<<

======================================================
======================================================
class_name control_panel_signal_handler extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

## 🔄 ENGINE STATUS/ERROR SIGNALS
# 
func _on_engine_status_updated(status_message: String) -> void:
	"""Updates the status label with a general message from the engine."""
	if is_instance_valid(controller.status_label):
		# Only update the status if it's a critical or final state, 
		# allowing chunk_generated to handle progress status.
		if status_message.begins_with("ERROR:") or status_message.begins_with("IDLE:"):
			controller.status_label.text = status_message

func _on_generation_error(error_message: String) -> void:
	"""Handles a critical error signal from the generation process."""
	print("❌ ERROR: Generation failed: %s" % error_message)
	
	controller.utility.reset_temporary_state()
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "❌ ERROR: Generation failed. Check console."
	if is_instance_valid(controller.generate_button):
		controller.generate_button.text = "IGNITION"


## 🏗️ GENERATION PROGRESS SIGNALS
func _on_build_map_start() -> void:
	"""Fired when the FFI build_map call is successfully received by the Rust engine."""
	print("📡 Signal: build_map_start received.")
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "🏗️ Engine task started..."

func _on_chunk_generated(chunk_x: int, chunk_y: int) -> void:
	"""Updates progress bar and tile count when a chunk is processed by the engine."""
	var tiles_in_chunk: int = controller.CHUNK_SIZE_X * controller.CHUNK_SIZE_Y
	
	# Update Progress Bar and Tile Count
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.value += float(tiles_in_chunk)
	
	controller.total_tiles_placed += tiles_in_chunk
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: %d" % controller.total_tiles_placed
	
	# Request the utility module to schedule a visual TileMap redraw (throttled)
	# This is the key to fixing the map refresh rate.
	controller.utility.request_redraw()

	# Update the status label with percentage progress
	var percent: int = 0
	if is_instance_valid(controller.progress_bar) and controller.progress_bar.max_value > 0:
		percent = int(controller.progress_bar.value / controller.progress_bar.max_value * 100.0)

	if is_instance_valid(controller.status_label):
		# Only update status if the percentage value has changed significantly (e.g., 5%)
		if percent != controller.last_percent and (percent % 5 == 0 or percent == 100):
			controller.status_label.text = "🏗️ Chunk (%d, %d) applied... %d%%" % [chunk_x, chunk_y, percent]
		
	controller.last_percent = percent


## 💡 ANIMATION/TILE FLIP SIGNAL
# 
func _on_tile_flip_updated(tile_id: int, flip_frame: int) -> void:
	"""
	Handles an individual tile flip update signal, delegating the data to the
	Animation Logic module for queueing and processing.
	"""
	if not is_instance_valid(controller.animation_logic):
		return
	
	# FIX: Delegate the flip data to the animation logic module for queueing.
	controller.animation_logic._on_tile_flip_updated(tile_id, flip_frame)

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelsignalhandler.gd <<<

======================================================
======================================================
class_name control_panel_ui_setup extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller


# ------------------------------------------------------------------------------
## 🛠️ CORE LIFECYCLE
# ------------------------------------------------------------------------------
func setup_all() -> void:
	"""Combines all setup functions for the main controller's _ready()."""
	setup_timers()
	setup_engine_links()
	setup_ui()
	connect_signals()
	print("⚙️ ControlPanel UI Setup complete.")


# ------------------------------------------------------------------------------
## ⏱️ TIMER CONFIGURATION
# ------------------------------------------------------------------------------
func setup_timers() -> void:
	"""Sets up timer properties and connects timeouts to the appropriate handler."""
	
	# Engine Timer (Fast poll for non-animated generation)
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.wait_time = 0.01
		controller.engine_timer.one_shot = false
		controller.engine_timer.autostart = false
	
	# Animation Timer (Throttled tick for animated generation)
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.wait_time = 0.5
		controller.animation_timer.one_shot = false
		controller.animation_timer.autostart = false
	
	# Clock Timer
	if is_instance_valid(controller.clock_timer):
		# Connect to the Utility module for clock updates
		controller.clock_timer.timeout.connect(controller.utility.on_clock_timer_timeout)
		
	# Redraw Throttle Timer (Map Gen batch redraw)
	if is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.one_shot = true
		controller.redraw_throttle_timer.wait_time = 0.1


# ------------------------------------------------------------------------------
## 🔗 EXTERNAL NODE LINKING
# ------------------------------------------------------------------------------
func setup_engine_links() -> void:
	"""Passes necessary Godot node references to the SSXL engine components."""
	if is_instance_valid(controller.ssxl_engine):
		if is_instance_valid(controller.ssxl_signals) and controller.ssxl_engine.has_method("set_signals_node"):
			controller.ssxl_engine.set_signals_node(controller.ssxl_signals)
		if is_instance_valid(controller.expansive_tilemap) and controller.ssxl_engine.has_method("set_tilemap"):
			controller.ssxl_engine.set_tilemap(controller.expansive_tilemap)
	else:
		push_error("❌ SSXLEngine node not found.")

# ------------------------------------------------------------------------------
## 📐 UI INITIALIZATION (Populate OptionButtons)
# ------------------------------------------------------------------------------
func setup_ui() -> void:
	"""Sets initial values and properties for core UI elements and populates selectors."""
	
	# 1. Grid Size SpinBoxes
	if is_instance_valid(controller.grid_width) and is_instance_valid(controller.grid_height):
		# Set sensible bounds and default values based on CHUNK_SIZE
		controller.grid_width.max_value = 1_000_000_000.0
		controller.grid_width.step = float(controller.CHUNK_SIZE_X)
		controller.grid_width.value = float(controller.CHUNK_SIZE_X * controller.DEFAULT_CHUNKS)
		
		controller.grid_height.max_value = 1_000_000_000.0
		controller.grid_height.step = float(controller.CHUNK_SIZE_Y)
		controller.grid_height.value = float(controller.CHUNK_SIZE_Y * controller.DEFAULT_CHUNKS)

	# 2. Tile Type Selector
	if is_instance_valid(controller.tile_type_selector):
		controller.tile_type_selector.clear()
		controller.tile_type_selector.add_item("tile_type_grass")
		controller.tile_type_selector.add_item("tile_type_water")
		controller.tile_type_selector.add_item("tile_type_mountain")
		controller.tile_type_selector.select(0)
	
	# 3. Placement Mode Selector
	if is_instance_valid(controller.placement_mode_selector):
		controller.placement_mode_selector.clear()
		controller.placement_mode_selector.add_item("perlin_basic_2d")
		controller.placement_mode_selector.add_item("cellular_automata_checkerboard")
		controller.placement_mode_selector.add_item("drunkards_walk")
		controller.placement_mode_selector.add_item("maze_recursive_division")
		controller.placement_mode_selector.select(0)
		
	# 4. Status and Progress Bar
	if is_instance_valid(controller.progress_bar):
		controller.progress_bar.visible = false
	
	if is_instance_valid(controller.status_label):
		controller.status_label.text = "IDLE: Ready for Ignition."


# ------------------------------------------------------------------------------
## 🔌 SIGNAL CONNECTIONS
# ------------------------------------------------------------------------------
func connect_signals() -> void:
	"""Connects all UI and external engine signals to the appropriate handler functions."""
	
	# --- UI Connections (Delegated to helper scripts) ---
	if is_instance_valid(controller.generate_button):
		controller.generate_button.pressed.connect(controller.gen_logic.toggle_generation)
	
	if is_instance_valid(controller.animate_ui_button):
		controller.animate_ui_button.pressed.connect(controller.utility.toggle_camera_view)
		
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.pressed.connect(controller.utility.on_toggle_terminal_button_pressed)
		
	if is_instance_valid(controller.animate_checkbox):
		controller.animate_checkbox.toggled.connect(controller.animation_logic.on_animate_checkbox_toggled)
	
	# --- External Engine Connections (SSXLSignals Hub) ---

	if is_instance_valid(controller.ssxl_signals):
		# Signals related to map start/chunk/error go to the dedicated Signal Handler
		controller.ssxl_signals.build_map_start.connect(controller.signal_handler._on_build_map_start)
		controller.ssxl_signals.chunk_generated.connect(controller.signal_handler._on_chunk_generated)
		controller.ssxl_signals.generation_error.connect(controller.signal_handler._on_generation_error)
		
		# Completion signal connects directly to the Generation Logic to finalize the process
		controller.ssxl_signals.build_map_complete.connect(controller.gen_logic._on_build_map_complete_received)

>>> FILE END: SSXL_engine_tester\root_scripts\controlpaneluisetup.gd <<<

======================================================
======================================================
class_name control_panel_utility extends RefCounted

var controller: Control

func _init(p_controller: Control) -> void:
	# Store the reference to the main ControlPanel node
	controller = p_controller

# ------------------------------------------------------------------------------
# ⚠️ CRITICAL NODE CHECKING
# ------------------------------------------------------------------------------
func check_critical_nodes() -> bool:
	"""Checks if all core FFI and rendering nodes are present and valid."""
	var valid: bool = true
	var missing_nodes: Array[String] = []

	if not is_instance_valid(controller.ssxl_engine):
		missing_nodes.append("SSXLEngine")
		valid = false
	if not is_instance_valid(controller.ssxl_signals):
		missing_nodes.append("SSXLSignals")
		valid = false
	if not is_instance_valid(controller.expansive_tilemap):
		missing_nodes.append("expansive_tilemap")
		valid = false
	if not is_instance_valid(controller.ssxl_oracle):
		missing_nodes.append("SSXLOracle")
		valid = false

	if not valid:
		var error_msg: String = "❌ CRITICAL NODES MISSING: " + ", ".join(missing_nodes)
		push_error(error_msg)
		if is_instance_valid(controller.status_label):
			controller.status_label.text = error_msg
	
	return valid

# ------------------------------------------------------------------------------
# ⌨️ INPUT HANDLING
# ------------------------------------------------------------------------------
func handle_input_event(event: InputEvent) -> void:
	"""Handles global input events delegated from _input()."""
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		if event.keycode == KEY_SPACE:
			# Check if any input field is focused (prevent spacebar from activating buttons)
			var is_input_focused: bool = (is_instance_valid(controller.seed_input) and controller.seed_input.has_focus()) or \
										 (is_instance_valid(controller.grid_width) and controller.grid_width.has_focus()) or \
										 (is_instance_valid(controller.grid_height) and controller.grid_height.has_focus())
			
			if not is_input_focused:
				# Spacebar toggles the camera view between UI and Map
				toggle_camera_view()
				controller.get_viewport().set_input_as_handled()
				

# ------------------------------------------------------------------------------
# 🔄 REDRAW THROTTLING
# ------------------------------------------------------------------------------
func request_redraw() -> void:
	"""
	Starts the redraw throttle timer if not already running.
	Limits TileMap updates to the timer's wait_time (e.g., 10 FPS).
	"""
	if not controller.redraw_pending and is_instance_valid(controller.redraw_throttle_timer):
		controller.redraw_throttle_timer.start()
		controller.redraw_pending = true

func _on_redraw_throttle_timeout() -> void:
	"""Forces a TileMap update when the throttle timer times out."""
	if controller.is_generating and is_instance_valid(controller.expansive_tilemap):
		controller.expansive_tilemap.force_update()
	controller.redraw_pending = false


# ------------------------------------------------------------------------------
# 📷 CAMERA / UI TOGGLES (Delegated Logic)
# ------------------------------------------------------------------------------

func toggle_camera_view() -> void:
	"""The handler connected to the 'Animate/Toggle View' button and SPACEBAR."""
	# Toggle the current ID: 1 becomes 2, 2 becomes 1
	var new_camera_id: int = 2 if controller.current_camera_id == 1 else 1
	switch_to_camera_view(new_camera_id)

func switch_to_camera_view(target_id: int) -> void:
	"""
	Sets the camera to the target_id (1=UI, 2=Map View) and updates the controller state.
	This is called by both toggle_camera_view and gen_logic.
	"""
	if not is_instance_valid(controller.cameras) or not controller.cameras.has_method("switch_to_camera"):
		return
		
	controller.current_camera_id = target_id
	controller.cameras.switch_to_camera(controller.current_camera_id)
	print("Camera switched to: %d" % controller.current_camera_id)

func set_map_zoom_and_position() -> void:
	"""Positions the map camera (camera2) to center the generated map and calculates appropriate zoom."""
	if not is_instance_valid(controller.camera2) or not is_instance_valid(controller.grid_width) or not is_instance_valid(controller.grid_height):
		return
		
	var map_width_tiles: int = int(controller.grid_width.value)
	var map_height_tiles: int = int(controller.grid_height.value)
	
	var full_map_width: float = float(map_width_tiles) * controller.tile_size.x
	var full_map_height: float = float(map_height_tiles) * controller.tile_size.y

	# Center the camera on the map
	controller.camera2.global_position = Vector2(full_map_width / 2.0, full_map_height / 2.0)
	
	# Calculate zoom
	var viewport_size: Vector2 = controller.get_viewport_rect().size
	var zoom_factor: float = min(viewport_size.x / full_map_width, viewport_size.y / full_map_height) * 0.9
	
	controller.camera2.zoom = Vector2(clampf(zoom_factor, 0.05, 1.0), clampf(zoom_factor, 0.05, 1.0))
	controller.initial_zoom_set = true
	print("Camera 2 positioned and zoomed after generation.")


func on_toggle_terminal_button_pressed() -> void:
	"""Toggles the visibility and size of the control panel."""
	controller.panel_collapsed = !controller.panel_collapsed
	
	var target_y: float = 32.0 if controller.panel_collapsed else 300.0
	var button_text: String = "EXPAND 🔽" if controller.panel_collapsed else "COLLAPSE 🔼"
	
	# Apply changes
	controller.custom_minimum_size.y = target_y
	if is_instance_valid(controller.toggle_terminal_button):
		controller.toggle_terminal_button.text = button_text
	
	# Hide/Show all main controls when collapsed
	for child in controller.get_children():
		if child != controller.toggle_terminal_button and child is Control:
			child.visible = not controller.panel_collapsed


# ------------------------------------------------------------------------------
# 🧹 STATE MANAGEMENT & MISC UTILITIES
# ------------------------------------------------------------------------------

func on_clock_timer_timeout() -> void:
	"""Updates the clock label."""
	if is_instance_valid(controller.clock_label):
		controller.clock_label.text = "🕒 " + Time.get_datetime_string_from_system()

func reset_temporary_state() -> void:
	"""Resets generation-specific state flags and stops timers."""
	controller.is_generating = false
	controller.redraw_pending = false
	
	if is_instance_valid(controller.generate_button):
		controller.generate_button.disabled = false
		
	if is_instance_valid(controller.engine_timer):
		controller.engine_timer.stop()
		
	if is_instance_valid(controller.animation_timer):
		controller.animation_timer.stop()
		
	controller.engine_tick_count = 0
	
func clear_generation_state() -> void:
	"""Resets all generation-related counters and labels to zero/default."""
	reset_temporary_state() # Calls the basic reset
	
	controller.total_tiles_placed = 0
	controller.generation_start_time_ms = 0
	controller.initial_zoom_set = false
	
	if is_instance_valid(controller.tiles_placed_label):
		controller.tiles_placed_label.text = "Tiles Placed: 0"
		
	if is_instance_valid(controller.tile_placement_time_label):
		controller.tile_placement_time_label.text = "⏱️ Tile Placement Time: N/A"

>>> FILE END: SSXL_engine_tester\root_scripts\controlpanelutility.gd <<<

======================================================
======================================================
# control_panel.gd
extends Control

# ------------------------------------------------------------------------------
# --- CHUNK & RENDER CONSTANTS ⚙️ ---
# ------------------------------------------------------------------------------
# These constants define the dimensions used by the Rust generation logic.
const CHUNK_SIZE_X: int = 32
const CHUNK_SIZE_Y: int = 32
const DEFAULT_CHUNKS: int = 12
const BASE_SOURCE_ID: int = 0
const BASE_ATLAS_COORDS: Vector2i = Vector2i(0, 0)
const BASE_ALT_ID: int = 0

# ------------------------------------------------------------------------------
# 🧭 UI Node & External References (DATA HUB)
# ------------------------------------------------------------------------------
# All @onready references use explicit type hints for performance and clarity.
# UI Elements
@onready var grid_width: SpinBox = $gridwidthspinbox
@onready var grid_height: SpinBox = $gridheightspinbox
@onready var seed_input: LineEdit = $seedlineedit
@onready var placement_mode_selector: OptionButton = $placementoptionbutton
@onready var tile_type_selector: OptionButton = $tiletypeoptionbutton
@onready var animate_checkbox: CheckBox = $animatecheckbox
@onready var status_label: Label = $billboard
@onready var generate_button: Button = $map_gen_button
@onready var animate_ui_button: Button = $animate_button
@onready var progress_bar: ProgressBar = $progressbar
@onready var toggle_terminal_button: Button = $toggleterminalbutton

# Timers
@onready var engine_timer: Timer = $enginetimer             # Fast poll when NOT animating
@onready var animation_timer: Timer = $AnimationTimer       # Animation loop when animating
@onready var redraw_throttle_timer: Timer = $redrawthrottle # Map Gen batch redraw

# Timer Labels
@onready var engine_timer_label: Label = $enginetimerlabel
@onready var tiles_placed_label: Label = $tilesplacedlabel
@onready var tile_placement_time_label: Label = $tiletimeofplacement

# Scene Tree Nodes (Critical Engine References)
@onready var main: Node2D = get_parent() as Node2D
# Use NodePath strings directly in @onready where possible for robust reference initialization
@onready var ssxl_engine: Node = main.get_node("SSXLEngine")
@onready var ssxl_oracle: Node = main.get_node("SSXLOracle")
@onready var ssxl_signals: Node = main.get_node("SSXLSignals") # <-- CRITICAL FIX: Named correctly!
@onready var expansive_tilemap: TileMap = main.get_node("expansive_tilemap") as TileMap
@onready var clock_label: Label = main.get_node("tilemap/clocklabel") as Label
@onready var clock_timer: Timer = main.get_node("tilemap/clocktimer") as Timer
@onready var tilemap_node: Node2D = main.get_node("tilemap") as Node2D
@onready var cameras: Node = main.get_node("cameras")
@onready var camera1: Camera2D = main.get_node("cameras/camera1") as Camera2D
@onready var camera2: Camera2D = main.get_node("cameras/camera2") as Camera2D

# 📊 State Variables (Shared data)
var last_percent: int = -1
var tile_size: Vector2 = Vector2(16, 16)
var panel_collapsed: bool = false
var engine_tick_count: int = 0
var total_tiles_placed: int = 0
var is_generating: bool = false
var initial_zoom_set: bool = false
var current_camera_id: int = 1
var generation_start_time_ms: int = 0
var redraw_pending: bool = false
var is_animated: bool = false
var animation_tilemap_handle: TileMap = null # Initialize to null with explicit type

# 🔗 Composed Helper Scripts (Typed instantiation)
# Note: Type hints use the script resource's type for better safety
var ui_setup: control_panel_ui_setup
var gen_logic: control_panel_gen_logic
var signal_handler: control_panel_signal_handler
var animation_logic: control_panel_animation_logic
var utility: control_panel_utility


# ------------------------------------------------------------------------------
# 🧭 CORE LIFECYCLE (COORDINATION)
# ------------------------------------------------------------------------------

func _ready() -> void:
	# Use preload() for optimal, faster resource loading and type safety
	const SCRIPT_PATH = "res://root_scripts/"
	
	# 1. Instantiate Helper Scripts
	# Using preload().new() is generally faster than load().new()
	ui_setup = preload(SCRIPT_PATH + "controlpaneluisetup.gd").new(self) as control_panel_ui_setup
	gen_logic = preload(SCRIPT_PATH + "controlpanelgenlogic.gd").new(self) as control_panel_gen_logic
	signal_handler = preload(SCRIPT_PATH + "controlpanelsignalhandler.gd").new(self) as control_panel_signal_handler
	animation_logic = preload(SCRIPT_PATH + "controlpanelanimation.gd").new(self) as control_panel_animation_logic
	utility = preload(SCRIPT_PATH + "controlpanelutility.gd").new(self) as control_panel_utility

	# 2. Critical Node Validation (Ensure engine and map are present)
	if not is_instance_valid(expansive_tilemap):
		push_error("❌ FATAL: Initialization Error: TileMap missing.")
		if is_instance_valid(status_label):
			status_label.text = "❌ FATAL: TileMap missing."
		return

	# Validate Engine references (Crucial for GDExtension FFI)
	if not is_instance_valid(ssxl_engine) or not is_instance_valid(ssxl_signals):
		push_error("❌ FATAL: SSXLEngine or SSXLSignals GDExtension nodes missing.")
		return

	# --- 3. Delegate Initialization Tasks ---
	ui_setup.setup_all()
	
	# Final ready steps
	if is_instance_valid(cameras) and cameras.has_method("switch_to_camera"):
		cameras.switch_to_camera(current_camera_id)

	var tileset: TileSet = expansive_tilemap.get_tileset()
	if tileset:
		tile_size = tileset.get_tile_size()

	# Initialize animation state
	if is_instance_valid(animate_checkbox):
		animation_logic.on_animate_checkbox_toggled(animate_checkbox.button_pressed)

	# --- 4. Connect Engine Signals to Handlers ---
	
	# High-Frequency Signals (Animation)
	# This signal is only connected here and in ui_setup.gd (for animation checkbox)
	# The animation logic relies on the GDExtension's ability to emit high-frequency data.
	ssxl_signals.tile_flip_updated.connect(animation_logic._on_tile_flip_updated) 
	
	# Status signal: check existence before connecting (Good practice preserved)
	if ssxl_signals.has_signal("engine_status_updated"):
		ssxl_signals.engine_status_updated.connect(signal_handler._on_engine_status_updated)
	else:
		push_error("❌ FATAL: Engine status signal not found. Check Rust GDExtension.")


	# --- 5. Connect Timers to Logic (Separating concerns) ---
	
	# Map Generation Redraw Throttling (Map Gen Draw)
	redraw_throttle_timer.timeout.connect(utility._on_redraw_throttle_timeout)

	# Animation/Polling Timers (Animation Draw & Status Polling)
	animation_timer.timeout.connect(animation_logic._on_animation_timer_timeout)
	engine_timer.timeout.connect(animation_logic._on_engine_timer_timeout)
	
	# Ensure one polling mechanism is active
	animation_logic.setup_animation_worker(is_animated)


func _input(event: InputEvent) -> void:
	utility.handle_input_event(event)


func _process(_delta: float) -> void:
	# Process polling is handled by timers. This remains empty, prioritizing
	# asynchronous Rust conduction over synchronous _process() polling.
	pass

>>> FILE END: SSXL_engine_tester\root_scripts\control_panel.gd <<<

======================================================
======================================================
extends Node

# Use the more specific Node type hint for GDExtension nodes
var engine_ref: Node = null
var status: String = "Unknown"

# Links this monitor to the SSXLEngine node and establishes signal communication.
func set_engine(engine: Node) -> void:
	# 1. Disconnect safely if a previous engine was linked
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Check if the signal is ALREADY connected before trying to disconnect
		if engine_ref.status_updated.is_connected(Callable(self, "_on_status_updated")):
			engine_ref.status_updated.disconnect(Callable(self, "_on_status_updated"))

	# 2. Set the new engine reference
	engine_ref = engine
	print("✅ EngineMonitor: Engine linked.")

	# 3. Connect the signal (now guaranteed to connect only once)
	if is_instance_valid(engine_ref) and engine_ref.has_signal("status_updated"):
		# Use the modern signal syntax for cleaner code
		engine_ref.status_updated.connect(_on_status_updated)
		print("📶 EngineMonitor: Connected to 'status_updated' signal.")
	else:
		push_warning("⚠️ EngineMonitor: Engine missing 'status_updated' signal.")


# Polls the engine for its current status (used by the engine_timer).
func update_status() -> void:
	if not is_instance_valid(engine_ref):
		push_error("🚨 EngineMonitor: Engine not linked.")
		return

	# Check for the existence of the method (essential for FFI/GDExtension calls)
	if not engine_ref.has_method("get_status"):
		push_error("🚨 EngineMonitor: Engine missing 'get_status' method.")
		return

	# Use call() for safety when interacting with GDExtension
	status = engine_ref.call("get_status") as String
	print("📡 EngineMonitor: Polled status → %s" % status)


# Handler for the status_updated signal (Asynchronous update from Rust).
func _on_status_updated(status_msg: String) -> void:
	status = status_msg
	print("📡 EngineMonitor: Received status → %s" % status)

>>> FILE END: SSXL_engine_tester\root_scripts\engine_monitor.gd <<<

======================================================
======================================================
extends Node

var initialized_nodes: Array = []

func initialize():
	print("\n🎶 Init: Commencing recursive scene scan...")
	initialized_nodes.clear()

	var root_node := get_tree().get_root()
	if root_node == null:
		push_error("❌ Init: Could not access scene root. Ritual aborted.")
		return

	_recursive_initialize(root_node)

	var tester := root_node.get_node("ssxltester")
	if tester == null:
		push_error("❌ Init: AetherionTester node not found. No one to receive the scroll.")
		return

	print("\n📜 Init: Scroll prepared. Delivering to AetherionTester...")
	tester.call("report_initialized", initialized_nodes)

func _recursive_initialize(node: Node) -> void:
	print("✨ Init: Blessing node → %s" % node.name)
	initialized_nodes.append(node)

	for child in node.get_children():
		if child is Node:
			_recursive_initialize(child)

>>> FILE END: SSXL_engine_tester\root_scripts\init.gd <<<

======================================================
======================================================
extends Node

>>> FILE END: SSXL_engine_tester\root_scripts\logger.gd <<<

======================================================
======================================================
extends Node2D

# ----------------------------------------------------------------------
## DEPENDENCIES (using @onready for robustness)
# ----------------------------------------------------------------------

# System Nodes (Children of this Main node, must match GDExtension names)
@onready var ssxl_oracle: Node = $SSXLOracle
@onready var ssxl_engine: Node = $SSXLEngine
@onready var ssxl_signals: Node = $SSXLSignals

# Global Utility Nodes (Explicitly typed for performance)
@onready var clock_timer: Timer = $/root/ssxltester/main/tilemap/clocktimer
@onready var engine_monitor: Node = $/root/ssxltester/main/EngineMonitor

# ----------------------------------------------------------------------
## LIFECYCLE
# ----------------------------------------------------------------------

func _ready() -> void:
	# Check for critical timer node before connecting
	if is_instance_valid(clock_timer):
		# Start the primary orchestration loop
		clock_timer.timeout.connect(_on_clock_tick)
		clock_timer.start()
	else:
		push_error("❌ Clock timer not found. Main orchestration failed to start.")
	
	# We call this here to ensure all engine links are established immediately
	# after the clock timer is configured.
	enter_idle_state()


# Initializes the links between the Godot-side controllers and the Rust GDExtension engine.
func enter_idle_state() -> void:
	print("\n🎬 Main: Entering idle state. Systems standing by...")

	# Validate all core systems before proceeding
	if is_instance_valid(ssxl_oracle) and is_instance_valid(ssxl_engine) and is_instance_valid(engine_monitor):
		
		# --- 1. Oracle Link (Tells the Oracle which Engine to command) ---
		print("🔗 Linking Oracle to Engine...")
		ssxl_oracle.set_engine(ssxl_engine) 
		print("🔗 Oracle: Engine link established.")

		# --- 2. Monitor Link (Tells the Monitor which Engine to observe) ---
		print("📡 Linking EngineMonitor to Engine...")
		engine_monitor.set_engine(ssxl_engine)
		print("✅ EngineMonitor: Engine linked.")

		# --- 3. Signals Link (Tells the Engine which Godot Node to use for signal emission) ---
		if is_instance_valid(ssxl_signals):
			# 💡 FIX APPLIED: Changed AetherionSignals to SSXLSignals
			print("📶 Connecting Engine to SSXLSignals...")
			ssxl_engine.set_signals_node(ssxl_signals) 
			
			# The Monitor-Signal connection is trusted to happen within set_engine()
			print("✅ EngineMonitor connected to status signal.")
		else:
			push_warning("⚠️ SSXLSignals node not found. Signal emission connection skipped.")

		# --- 4. First Pulse ---
		# The Oracle's initial tick primes the Rust system's state machine.
		print("🔮 Oracle linked. Delivering first pulse...")
		ssxl_oracle.tick() 

		print("⚙️ Engine confirmed idle.")
	else:
		# Use push_error to make this visible in the debugger
		push_error("❌ Failed to link Core Systems (Oracle/Engine/Monitor). Invocation aborted.")


# ----------------------------------------------------------------------
## RUNTIME (Clock Tick)
# ----------------------------------------------------------------------

# Drives the core update loop for the engine and monitor systems.
func _on_clock_tick() -> void:
	print("🕰️ Clock tick.")

	if is_instance_valid(ssxl_oracle):
		# Tick the Oracle, which in turn commands the Rust engine
		ssxl_oracle.tick() 

	if is_instance_valid(engine_monitor):
		# Polls the engine for its current status (should be throttled or non-blocking)
		engine_monitor.update_status()

>>> FILE END: SSXL_engine_tester\root_scripts\main.gd <<<

======================================================
======================================================
extends Node2D

# 🧭 Node references
@onready var control_panel: Control = get_node("/root/main/ControlPanel")
@onready var aetherion_engine: Node = get_node("/root/main/AetherionEngine")
@onready var aetherion_signals: Node = get_node("/root/main/AetherionSignals")
@onready var expansive_tilemap: TileMap = get_node("/root/main/Expansive_TileMap")
@onready var camera1: Camera2D = get_node("/root/main/Cameras/Camera1")
@onready var camera2: Camera2D = get_node("/root/main/Cameras/Camera2")
@onready var terminal_output: RichTextLabel = get_node_or_null("/root/main/ControlPanel/TerminalOutput")


# 📊 State
var dragging: bool = false
var active_camera: int = 1
var last_mouse_position: Vector2 = Vector2.ZERO
var tile_size: Vector2 = Vector2(16, 16)

func _ready() -> void:
	if not aetherion_signals.generation_complete.is_connected(_on_generation_complete):
		aetherion_signals.generation_complete.connect(_on_generation_complete)

	# 🛡️ Prevent duplicate Main nodes
	var main_nodes := get_tree().get_nodes_in_group("Main")
	if main_nodes.size() > 1:
		GlobalLogger.log("⚠️ Multiple Main nodes detected: %s" % main_nodes, "WARN")
		queue_free()
		return

	
	GlobalLogger.log("🟢 Main.gd is ready. AetherionEngine is idle.")
	GlobalLogger.log("⚠️ Multiple Main nodes detected: %s" % [main_nodes], "WARN")


	# 🎥 Camera configuration
	camera1.enabled = true
	camera1.make_current()
	camera2.enabled = false
	camera2.zoom = Vector2(1.0, 1.0)

	# 🔧 Initialize AetherionEngine
	aetherion_engine.set_signals_node(aetherion_signals)
	aetherion_engine.set_tilemap(expansive_tilemap)

	# 🧪 Debug: TileMap state
	GlobalLogger.log("TileMap position: %s" % expansive_tilemap.global_position)
	GlobalLogger.log("TileMap scale: %s" % expansive_tilemap.scale)
	GlobalLogger.log("TileMap layer enabled: %s" % expansive_tilemap.is_layer_enabled(0))
	GlobalLogger.log("TileMap tileset: %s" % expansive_tilemap.get_tileset())
	GlobalLogger.log("TileMap used rect: %s" % expansive_tilemap.get_used_rect())

	# 🧪 Debug: Camera states
	GlobalLogger.log("Camera1 position: %s" % camera1.global_position)
	GlobalLogger.log("Camera1 enabled: %s" % camera1.enabled)
	GlobalLogger.log("Camera1 is current: %s" % camera1.is_current())
	GlobalLogger.log("Camera2 position: %s" % camera2.global_position)
	GlobalLogger.log("Camera2 zoom: %s" % camera2.zoom)
	GlobalLogger.log("Camera2 enabled: %s" % camera2.enabled)
	GlobalLogger.log("Camera2 is current: %s" % camera2.is_current())

	# 🧠 TileSet analysis
	var tileset := expansive_tilemap.get_tileset()
	if tileset:
		tile_size = tileset.get_tile_size()
		GlobalLogger.log("TileSet tile size: %s" % tile_size)

		if tileset.get_source_count() > 0:
			var source := tileset.get_source(0)
			if source and source.is_class("TileSetAtlasSource"):
				var atlas_source := source as TileSetAtlasSource
				GlobalLogger.log("TileSet atlas grid size: %s" % atlas_source.get_atlas_grid_size())
				GlobalLogger.log("Tile (0, 0) exists: %s" % atlas_source.has_tile(Vector2i(0, 0)))
				GlobalLogger.log("Tile (1, 0) exists: %s" % atlas_source.has_tile(Vector2i(1, 0)))

func _toggle_camera() -> void:
	var status_label: Label = get_node("/root/main/ControlPanel/StatusLabel")

	if active_camera == 1:
		if camera2.is_inside_tree() and camera2.enabled:
			camera2.make_current()
			active_camera = 2
			status_label.text = "🧭 Switched to Map View"
			GlobalLogger.log("🎥 Camera2 is now active.")
		else:
			GlobalLogger.log("⚠️ Camera2 is not ready.", "WARN")
	else:
		if camera1.is_inside_tree() and camera1.enabled:
			camera1.make_current()
			active_camera = 1
			status_label.text = "🎛️ Returned to Control Panel"
			GlobalLogger.log("🎥 Camera1 is now active.")
		else:
			GlobalLogger.log("⚠️ Camera1 is not ready.", "WARN")

func _unhandled_input(event: InputEvent) -> void:
	#GlobalLogger.log("Active camera: %d | Zoom: %s" % [active_camera, camera2.zoom])

	if event is InputEventKey and event.pressed and event.keycode == KEY_SPACE:
		_toggle_camera()

	if active_camera == 2:
		if event is InputEventMouseButton:
			if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				camera2.zoom *= 0.9
			elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
				camera2.zoom *= 1.1

			camera2.zoom.x = clamp(camera2.zoom.x, 0.5, 5.0)
			camera2.zoom.y = clamp(camera2.zoom.y, 0.5, 5.0)

			if event.button_index == MOUSE_BUTTON_LEFT:
				dragging = event.pressed
				last_mouse_position = event.position

		if event is InputEventMouseMotion and dragging:
			var delta: Vector2 = event.position - last_mouse_position
			camera2.position -= delta / camera2.zoom
			last_mouse_position = event.position

func _on_generation_complete(results: Dictionary) -> void:
	GlobalLogger.log("🧭 Generation complete signal received.")
	_toggle_camera()

>>> FILE END: SSXL_engine_tester\root_scripts\main1.gd <<<

======================================================
======================================================
extends Node2D

var init_node: Node
var main_node: Node2D
var initialized_nodes: Array = []

func _ready():
	get_tree().get_root().print_tree()

	print("🚀 AetherionTester: Summoning subsystems...")

	init_node = get_node("init")
	main_node = get_node("main")

	if init_node == null:
		push_error("❌ AetherionTester: Init node not found.")
		return

	if main_node == null:
		push_error("❌ AetherionTester: Main node not found.")
		return

	print("🧭 AetherionTester: Launching initialization sequence...")
	init_node.call("initialize")

func report_initialized(nodes: Array) -> void:
	initialized_nodes = nodes
	print("✅ AetherionTester: Initialization complete. All nodes accounted for.")
	print("🎙️ AetherionTester: Delegating control to Main...")
	main_node.call("enter_idle_state")

>>> FILE END: SSXL_engine_tester\root_scripts\root.gd <<<

======================================================
======================================================
extends Node

signal tree_ready(map)

func scan_tree():
	var map = {}
	_recursive_scan(get_tree().root, map)
	emit_signal("tree_ready", map)

func _recursive_scan(node: Node, map: Dictionary):
	map[node.name.to_lower()] = node.get_path()
	for child in node.get_children():
		_recursive_scan(child, map)

>>> FILE END: SSXL_engine_tester\root_scripts\scenescanner.gd <<<

======================================================
======================================================
extends Node2D


func _ready():
	#var rust_node = AetherionRoot.new()
	#add_child(rust_node)
	pass

>>> FILE END: SSXL_engine_tester\root_scripts\tester.gd <<<

======================================================
======================================================
extends Node

func _ready():
	# Wire up dependencies
	$AetherionEngine.signals_node = $AetherionSignals

	$AetherionEngine.set_tilemap($TileMap)

	# Connect signals
	$AetherionSignals.connect("generation_progress", Callable(self, "_on_progress"))
	$AetherionSignals.connect("generation_complete", Callable(self, "_on_complete"))
	$AetherionSignals.connect("map_building_status", Callable(self, "_on_status"))


	# Trigger map generation
	var seed = randi()
	$AetherionEngine.build_map(
		32, 32, seed, "basic", true,
		Vector2i(0, 0), Vector2i(1, 0)
	)

func _on_progress(percent):
	print("Progress:", percent)

func _on_complete(results):
	print("Map generation complete:")
	for key in results.keys():
		print("  %s: %s" % [key, results[key]])

func _on_status(msg):
	print("Status:", msg)

>>> FILE END: SSXL_engine_tester\test_scripts\control_panel.gd <<<

======================================================
======================================================
# test_ffi_data.gd
# Attached to the root Node in test_ffi_data.tscn
# Goal: Validate FFI Bridge Data Integrity (Phase 7 Finalization)

extends Node

# The GDExtension class exposed by the Rust side
const ENGINE_CLASS_NAME = "SSXLEngine"

func _ready():
	print("--- STARTING FFI DATA INTEGRITY TEST ---")
	
	# 1. Instantiate the GDExtension Class
	var engine = load_engine()
	if engine == null:
		print("ERROR: Godot failed to instantiate GDExtension class.")
		# Exit with a non-zero code to signal failure to the CLI
		get_tree().quit(1) 
		return

	# 2. Call the FFI-bound method and measure the data returned
	# We test key (1, 2, 3) to ensure arguments pass correctly.
	var chunk_data = engine.generate_chunk(1, 2, 3)
	
	# 3. Validation Checks
	var success = check_data_integrity(chunk_data)
	
	# 4. Final Quit
	if success:
		print("✅ FFI Data Integrity Test: PASSED.")
		get_tree().quit(0) # Signal success to the Rust CLI
	else:
		print("❌ FFI Data Integrity Test: FAILED.")
		get_tree().quit(1) # Signal failure to the Rust CLI

# Helper function to safely instantiate AetherionEngine
func load_engine():
	if not ClassDB.can_instantiate(ENGINE_CLASS_NAME):
		printerr("ERROR: GDExtension class '%s' not found. Ensure GDExtension is compiled and registered." % ENGINE_CLASS_NAME)
		return null
	return ClassDB.instantiate(ENGINE_CLASS_NAME)

# Core validation logic
func check_data_integrity(data):
	# A. Basic Structure Check
	if not data is Dictionary:
		printerr("FAIL: FFI return is not a Dictionary.")
		return false
	if not data.has("tiles") or not data.has("tile_count"):
		printerr("FAIL: FFI Dictionary is missing 'tiles' array or 'tile_count'.")
		return false
	
	var tiles = data.tiles
	var tile_count = data.tile_count
	
	print("INFO: Received chunk at key_x: %d with count: %d" % [data.get("key_x", -1), tile_count])
	
	# B. Non-empty Check (Assumes generation logic returns at least one tile)
	if tile_count == 0 or tiles.is_empty():
		printerr("FAIL: Chunk generation returned zero tiles. Check Rust core logic.")
		return false
		
	# C. Data Type and Value Check (Crucial for FFI integrity)
	var first_tile = tiles[0]
	
	# Validate types translated correctly across the FFI boundary
	if typeof(first_tile.id) != TYPE_INT:
		printerr("FAIL: Tile ID type mismatch. Expected TYPE_INT, got %s." % typeof(first_tile.id))
		return false
		
	if typeof(first_tile.level) != TYPE_FLOAT:
		printerr("FAIL: Tile Level type mismatch. Expected TYPE_FLOAT, got %s." % typeof(first_tile.level))
		return false
		
	print("INFO: First tile data verified (ID: %d, Level: %f)." % [first_tile.id, first_tile.level])
	
	# If all checks pass
	return true

>>> FILE END: SSXL_engine_tester\test_scripts\test_ffi_data.gd <<<

