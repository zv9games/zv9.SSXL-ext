>>> FILE START: rust\ssxl_sync\Cargo.toml (24 LOC) <<<
[package]
name = "ssxl_sync"
version = "0.6.0"
edition = "2021"

[dependencies]
# --- INTERNAL DEPENDENCIES ---
# Required for shared data types and the canonical error type
ssxl_shared = { path = "../ssxl_shared" }
ssxl_math = { path = "../ssxl_math" }
ssxl_animate = { path = "../ssxl_animate" }

# --- EXTERNAL CONCURRENCY & DIAGNOSTICS ---
# Primary async runtime
tokio               = { workspace = true, features = ["full"] }
# High-performance channel types
crossbeam           = { workspace = true }
crossbeam-channel   = { workspace = true }
# High-performance sync primitives (like RwLock, often preferred over std::sync)
parking_lot         = { workspace = true }
# Ensure we use the workspace's standard logging framework
tracing             = { workspace = true }
godot               = { workspace = true, optional = true }

[features]
# Add a feature flag for Godot-specific dependencies
godot-bindings = ["godot"]
<<< FILE END: rust\ssxl_sync\Cargo.toml >>>

>>> FILE START: rust\ssxl_sync\src\animation_conductor.rs (89 LOC) <<<
// ssxl_sync/src/animation_conductor.rs (Type Resolution Fix)

use ssxl_shared::{
    AnimationConductorHandle,
    AnimationState,
    AnimationCommand, 
};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tracing::info;

// FIX: Import the exact nested type required by the CoreAnimationWorker's signature 
// and alias it as `AnimationUpdate`. This resolves the E0308 type mismatch.
use ssxl_shared::message::messages::AnimationUpdate as AnimationUpdate; 

// NOTE: We rely on the core worker being defined as `conductor::AnimationConductor` within ssxl_animate.
use ssxl_animate::conductor::AnimationConductor as CoreAnimationWorker;

// -----------------------------------------------------------------------------
// 1. Internal Setup Struct (for passing state between FFI stages)
// -----------------------------------------------------------------------------

/// Holds all the necessary internal channels and initial state required to spawn the
/// heavy, background Animation Conductor thread.
pub struct AnimationConductorInternalSetup {
    pub initial_state: AnimationState,
    /// The receiver for Godot commands, which the worker thread will consume.
    pub command_receiver: UnboundedReceiver<AnimationCommand>,
    
    /// The sender for updates, which the worker thread will use.
    // This field now holds the correctly nested type due to the aliased import above.
    pub update_sender: UnboundedSender<AnimationUpdate>,
}

// -----------------------------------------------------------------------------
// 2. The Public Conductor Struct (The FFI-facing worker wrapper)
// -----------------------------------------------------------------------------

/// The SSXL Animation Conductor. This struct is responsible for executing the
/// animation logic in a background thread.
pub struct AnimationConductor {}

impl AnimationConductor {
    // -------------------------------------------------------------------------
    // Stage 1: FAST Channel and State Setup (Non-blocking)
    // -------------------------------------------------------------------------
    
    /// Creates all the necessary MPSC channels and the initial `AnimationState`.
    /// 
    /// # Returns
    /// A tuple containing:
    /// 1. `AnimationConductorInternalSetup`: The struct holding internal handles for spawning.
    /// 2. `AnimationConductorHandle`: The public command sender handle exposed to Godot's FFI layer.
    /// 3. `UnboundedReceiver<AnimationUpdate>`: The public update receiver handle exposed to Godot's Poller.
    pub fn setup_channels_and_state() -> (AnimationConductorInternalSetup, AnimationConductorHandle, UnboundedReceiver<AnimationUpdate>) {
        info!("Animation Conductor: Starting FAST Channel and State Setup.");

        // Channels for commands from Godot to the worker.
        let (command_tx, command_rx) = mpsc::unbounded_channel::<AnimationCommand>();
        
        // Channels for updates from the worker to Godot (Poller).
        // This channel uses the correctly aliased type.
        let (update_tx, update_rx) = mpsc::unbounded_channel::<AnimationUpdate>();
        
        let initial_state = AnimationState::default();

        let internal_setup = AnimationConductorInternalSetup {
            initial_state,
            command_receiver: command_rx,
            update_sender: update_tx,
        };
        
        let public_command_handle = command_tx;

        (internal_setup, public_command_handle, update_rx)
    }

    // -------------------------------------------------------------------------
    // Stage 2: HEAVY Thread Spawn
    // -------------------------------------------------------------------------

    /// Consumes the setup handles and spawns the core animation worker thread.
    /// 
    /// # Arguments
    /// * `setup`: The internal channels and initial state from the setup stage.
    /// 
    /// # Returns
    /// A new `AnimationConductor` instance representing the running worker.
    pub fn new(setup: AnimationConductorInternalSetup) -> Self {
        info!("Animation Conductor: Spawning background worker thread.");

        // This call is now correct because `setup.update_sender` holds the 
        // type the `CoreAnimationWorker::new` function requires.
        let _core_worker = CoreAnimationWorker::new(
            setup.command_receiver,
            setup.update_sender,
            setup.initial_state,
        );
        
        info!("Animation Conductor: Worker thread started successfully.");

        // Return the opaque public handle struct
        AnimationConductor {} 
    }
}
<<< FILE END: rust\ssxl_sync\src\animation_conductor.rs >>>

>>> FILE START: rust\ssxl_sync\src\lib.rs (88 LOC) <<<
// FILE: ssxl_sync/src/lib.rs

//! # SSXL Synchronization and Concurrency (`ssxl_sync`)
//! 
//! This crate defines core thread-safe primitives, thread pool management, 
//! and high-level FFI channel handles for communication across the engine's asynchronous boundary.

use tokio::sync::mpsc;
use std::ops::{Deref, DerefMut}; // Required for implementing the FFI Handle wrapper

// --------------------------------------------------------------------------------
// --- CRITICAL EXTERNAL IMPORTS ---
// --------------------------------------------------------------------------------

// CRITICAL: Import all core contract types from ssxl_shared.
use ssxl_shared::{
    SSXLError,
    AnimationUpdate,
    AnimationCommand,
};
// FIX: Import and public re-export the core struct in one step to avoid E0252/E0365.
pub use ssxl_animate::AnimationConductor;

// --------------------------------------------------------------------------------
// --- Internal Modules ---
// --------------------------------------------------------------------------------

/// Defines core thread-safe types, enums, and channel aliases used for concurrency and communication.
pub mod primitives;

/// Manages the generic, fixed-size thread pool used for synchronous, CPU-intensive tasks.
pub mod pool;

/// Manages the dedicated worker thread and state for calculating visual animation frames.
pub mod animation_conductor;


// --------------------------------------------------------------------------------
// --- Public Re-exports (Crate Facade) ---
// --------------------------------------------------------------------------------

// --- 1. Generic Primitives and Utility Functions (from primitives) ---

/// Re-exports of generic thread-safe resource wrappers and synchronous channels.
pub use primitives::{
    AtomicResource,
    create_unbounded_channel,
};

// --- 2. Thread Pool Manager Types (from pool_manager) ---

/// Re-exports of all public types related to the generic CPU worker thread pool.
pub use pool::{
    WorkerPool,
    GenerationTask,
    ConductorResult,
    Task,
    TaskResult
};

// --------------------------------------------------------------------------------
// --- Final FFI Wrappers and Type Aliases (CRATE ROOT API) ---
// --------------------------------------------------------------------------------

// The Receiver half of the command channel for the AnimationConductor.
pub type CommandReceiver = mpsc::UnboundedReceiver<AnimationCommand>;

// The UnboundedSender type is used to send updates (e.g., animation frames) back to the main thread.
pub type UpdateSender = mpsc::UnboundedSender<AnimationUpdate>;

// The standard result wrapper, using SSXLError.
pub type CommandResult = Result<(), SSXLError>;


/// The **Animation Conductor Handle**. 
/// 
/// **FIX:** Changed from a type alias to a public struct wrapping the channel sender. 
/// This allows us to implement the `::new()` constructor required by the FFI layer (`ssxl_godot`), 
/// resolving `error[E0599]`.
pub struct AnimationConductorHandle {
    inner: mpsc::UnboundedSender<AnimationCommand>,
}

impl AnimationConductorHandle {
    /// Public constructor required by the FFI layer (`ssxl_godot/api_initializers.rs`).
    /// Allows the FFI layer to wrap the raw channel sender into this opaque handle.
    pub fn new(inner: mpsc::UnboundedSender<AnimationCommand>) -> Self {
        AnimationConductorHandle { inner }
    }
    
    // FIX (E0599): Adds the method to access the inner sender, allowing the FFI layer
    // to call `.inner().clone()` and re-wrap the result in ssxl_godot/src/engine/init.rs.
    pub fn inner(&self) -> &mpsc::UnboundedSender<AnimationCommand> {
        &self.inner
    }
}

// Allows the struct to be used as if it were the underlying `mpsc::UnboundedSender`.
impl Deref for AnimationConductorHandle {
    type Target = mpsc::UnboundedSender<AnimationCommand>;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

// Provides mutable access to the underlying sender.
impl DerefMut for AnimationConductorHandle {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
<<< FILE END: rust\ssxl_sync\src\lib.rs >>>

>>> FILE START: rust\ssxl_sync\src\pool.rs (151 LOC) <<<
//! # Thread Pool Manager (`ssxl_sync::pool_manager`)
//!
//! Defines the generic, fixed-size thread pool used for executing synchronous,
//! CPU-intensive generation tasks off the main thread and the main Tokio runtime.
//! This pattern ensures high-throughput batch processing of `ChunkData`.

use std::thread::{self, JoinHandle};
use crossbeam_channel::{Sender, Receiver, unbounded};
use tracing::{info, error, warn};
use std::sync::Arc;

// --- Imports from sibling crates/modules ---
// NOTE: Imports from ssxl_generate removed to avoid cyclical dependency.
use ssxl_math::prelude::Vec2i;
// FIX: Import ChunkData directly from the root of ssxl_shared to resolve both E0433 errors.
use ssxl_shared::ChunkData; 

// --- Configuration ---
/// Defines the size of the worker pool.
const POOL_SIZE: usize = 4;


// --- 1. Worker Definition ---

/// Represents a single worker thread's state and handle.
struct Worker {
    /// The ID of the worker thread.
    id: usize,
    /// The handle to join the thread on shutdown.
    handle: Option<JoinHandle<()>>,
}

// --- Local Definitions to Break Dependency Cycle ---
/// The unit of work sent to the thread pool.
#[derive(Debug)]
pub enum GenerationTask {
    /// A command to begin generating a new chunk of data.
    GenerateChunk,
    /// A command to signal the worker thread to shut down gracefully.
    Shutdown,
}

/// The result returned from the completed work.
#[derive(Debug)]
pub enum ConductorResult {
    /// A successfully completed chunk of generated data.
    // FIX 1 (Line 47): Use the directly imported ChunkData.
    CompletedChunk(Arc<ChunkData>),
    /// An error that occurred during generation.
    Error(String),
}

/// The unit of work sent to the thread pool (Alias for local definition).
pub type Task = GenerationTask;

/// The result returned from the completed work (Alias for local definition).
pub type TaskResult = ConductorResult;


// --- 2. Pool Manager Structure ---

/// Manages the pool of worker threads and the task queue.
pub struct WorkerPool {
    /// The channel used to send tasks from the `Conductor` to the workers.
    task_sender: Sender<Task>,
    // Redundant `result_receiver` field removed.
    /// Collection of worker structs, primarily used to hold join handles for shutdown.
    workers: Vec<Worker>,
}

impl WorkerPool {
    /// Creates a new worker pool and starts all worker threads.
    pub fn new() -> (Self, Receiver<TaskResult>) {
        let (task_tx, task_rx) = unbounded::<Task>();
        let (result_tx, result_rx) = unbounded::<TaskResult>();
        
        let mut workers = Vec::with_capacity(POOL_SIZE);
        
        // Wrap the task receiver in an Arc to be shared by all worker threads.
        let shared_task_rx = Arc::new(task_rx);

        for id in 0..POOL_SIZE {
            let worker_task_rx = Arc::clone(&shared_task_rx);
            let worker_result_tx = result_tx.clone();
            
            let handle = thread::Builder::new()
                .name(format!("ssxl-worker-{}", id))
                .spawn(move || {
                    WorkerPool::run_worker_loop(id, worker_task_rx, worker_result_tx);
                })
                .expect(&format!("Failed to spawn worker thread {}", id));
            
            workers.push(Worker { id, handle: Some(handle) });
        }

        info!("WorkerPool initialized with {} threads.", POOL_SIZE);

        (
            WorkerPool {
                task_sender: task_tx,
                // Removed the unused `result_receiver` from initialization.
                workers,
            },
            result_rx, // The primary receiver is correctly returned for the Conductor to use.
        )
    }

    /// Submits a new generation task to the pool.
    pub fn submit_task(&self, task: Task) -> Result<(), crossbeam_channel::SendError<Task>> {
        self.task_sender.send(task)
    }

    /// The main loop executed by each worker thread.
    fn run_worker_loop(
        id: usize,
        task_rx: Arc<Receiver<Task>>,
        result_tx: Sender<TaskResult>,
    ) {
        info!("Worker {} started, ready to receive tasks.", id);

        loop {
            // Blocks until a task is available or the sender is dropped (shutdown).
            match task_rx.recv() {
                Ok(task) => {
                    // --- Perform CPU-intensive generation work here ---
                    info!("Worker {} processing task {:?}", id, task);
                    
                    // TODO: Execute the actual generation/batch function
                    let result: TaskResult = TaskResult::CompletedChunk(
                        // FIX 2 (Line 130): Use the directly imported ChunkData.
                        Arc::new(ChunkData::new_at_coords(Vec2i::new(0, 0)))
                    );
                    
                    // Send the result back to the Conductor
                    if let Err(e) = result_tx.send(result) {
                        warn!("Worker {} failed to send result: {}", id, e);
                        // The Conductor's receiver must have dropped. Exit.
                        break;
                    }
                }
                Err(_) => {
                    // Sender was dropped, time to shut down.
                    info!("Worker {} task channel closed. Shutting down.", id);
                    break;
                }
            }
        }
    }
}

// --- 3. Graceful Shutdown ---

impl Drop for WorkerPool {
    /// Gracefully shuts down all worker threads.
    fn drop(&mut self) {
        info!("WorkerPool initiating graceful shutdown...");
        
        // Attempt to send a shutdown command to any worker currently blocked on `recv()`.
        let _ = self.task_sender.send(Task::Shutdown);
        
        // Wait for all workers to finish.
        for mut worker in self.workers.drain(..) {
            if let Some(handle) = worker.handle.take() {
                if let Err(e) = handle.join() {
                    error!("Worker {} thread failed to join: {:?}", worker.id, e);
                } else {
                    info!("Worker {} successfully joined.", worker.id);
                }
            }
        }
        info!("WorkerPool shutdown complete.");
    }
}
<<< FILE END: rust\ssxl_sync\src\pool.rs >>>

>>> FILE START: rust\ssxl_sync\src\primitives.rs (41 LOC) <<<
// ssxl_sync/src/primitives.rs

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::sync::Arc;
use crossbeam_channel::{unbounded, Receiver, Sender};
// DELETE: tracing::info removed (placeholder worker function removed)

// --------------------------------------------------------------------------------
// --- Thread-Safe Resource Management (AtomicResource) ---
// --------------------------------------------------------------------------------

#[derive(Debug, Clone)]
pub struct AtomicResource<T> {
    data: Arc<RwLock<T>>,
}

impl<T> AtomicResource<T> {
    pub fn new(data: T) -> Self {
        AtomicResource {
            data: Arc::new(RwLock::new(data)),
        }
    }

    #[inline(always)] // O(1) Accessor: Force inlining
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.data.read()
    }

    #[inline(always)] // O(1) Mutator: Force inlining
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.data.write()
    }
}

impl<T: Default> Default for AtomicResource<T> {
    fn default() -> Self {
        Self::new(T::default())
    }
}

// --------------------------------------------------------------------------------
// --- Synchronization Primitives (Channels) ---
// --------------------------------------------------------------------------------

/// Creates an unbounded, multi-producer, single-consumer channel.
/// Generic over message type `M` (Zero Entropy).
pub fn create_unbounded_channel<M>() -> (Sender<M>, Receiver<M>) {
    unbounded()
}
// DELETE: start_sync_worker placeholder removed (non-primitive code).
<<< FILE END: rust\ssxl_sync\src\primitives.rs >>>

